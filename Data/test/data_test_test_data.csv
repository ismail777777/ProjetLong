prompt,code
"('Prompt:. . You are testing a symbol stream generator with a delay calculation feature. The function `testbench_symstreamcf_delay` takes two parameters: `_k` and `_m`, used to create a symbol stream generator for QPSK modulation. The generator is created with a linear filter of type `LIQUID_FIRFILT_ARKAISER` and a beta value of 0.30. The function then determines the delay of the generator and writes samples to it until a certain condition is met. The delay is compared to the iteration count, and a tolerance of 2.0 added to `_k`. If the test is run in verbose mode, the expected delay, approximate delay, and tolerance are printed to the console. Finally, the delay is compared to the iteration count with a tolerance, and the generator is destroyed.. . To provide a test case for the function, you can call `autotest_symstreamcf_delay_13` which tests the functionality with `_k","//...\nvoid testbench_symstreamcf_delay(unsigned int _k,\n                                 unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamcf  gen    = symstreamcf_create_linear(ftype,_k,_m,beta,ms);\n    unsigned int delay  = symstreamcf_get_delay(gen);\n    float        tol    = 2.0f + _k; \n    unsigned int i;\n    for (i=0; i<1000 + delay; i++) {\n        float complex sample;\n        symstreamcf_write_samples(gen, &sample, 1);\n        if (cabsf(sample) > 0.9f)\n            break;\n    }\n    if (liquid_autotest_verbose)\n        printf(""expected delay: %u, approximate delay: %u, tol: %.0f\\n"", delay, i, tol);\n    CONTEND_DELTA((float)delay, (float)i, tol);\n    symstreamcf_destroy(gen);\n}\nvoid autotest_symstreamcf_delay_13() { testbench_symstreamcf_delay( 6,12); }\n//...')
"
"('Prompt: If you were asked to create a set of automated tests for a Hamming (128,12) forward error correction codec, including one for hard decoding and another for soft decoding, what would the code look like? The testing should involve encoding a randomly generated symbol, then corrupting it by flipping one bit at a time and comparing the decoded symbol to the original. In the soft decoding test, you should generate a symbol, encode it, introduce errors by flipping individual bits, and then decode using a soft decoding algorithm, ensuring that the decoded symbol matches the original.","//...\nvoid autotest_hamming128_codec()\n{\n    unsigned int n=8;   \n    unsigned int k=12;  \n    unsigned int i;     \n    for (i=0; i<k; i++) {\n        unsigned int sym_org = rand() % (1<<n);\n        unsigned int sym_enc = fec_hamming128_encode_symbol(sym_org);\n        unsigned int sym_rec = sym_enc ^ (1<<(k-i-1));\n        unsigned int sym_dec = fec_hamming128_decode_symbol(sym_rec);\n        if (liquid_autotest_verbose) {\n            printf(""error index : %u\\n"", i);\n            printf(""    sym org     :   ""); liquid_print_bitstring(sym_org, n); printf(""\\n"");\n            printf(""    sym enc     :   ""); liquid_print_bitstring(sym_enc, k); printf(""\\n"");\n            printf(""    sym rec     :   ""); liquid_print_bitstring(sym_rec, k); printf(""\\n"");\n            printf(""    sym dec     :   ""); liquid_print_bitstring(sym_dec, n); printf(""\\n"");\n            printf(""    bit errors  :   %u\\n"", count_bit_errors(sym_org, sym_dec));\n        }\n        CONTEND_EQUALITY(sym_org, sym_dec);\n    }\n}\nvoid autotest_hamming128_codec_soft()\n{\n    unsigned int s;             \n    unsigned int c;             \n    unsigned char c_soft[12];   \n    unsigned int s_hat;         \n    for (s=0; s<256; s++) {\n        c = fec_hamming128_encode_symbol(s);\n        c_soft[ 0] = (c & 0x0800) ? 255 : 0;\n        c_soft[ 1] = (c & 0x0400) ? 255 : 0;\n        c_soft[ 2] = (c & 0x0200) ? 255 : 0;\n        c_soft[ 3] = (c & 0x0100) ? 255 : 0;\n        c_soft[ 4] = (c & 0x0080) ? 255 : 0;\n        c_soft[ 5] = (c & 0x0040) ? 255 : 0;\n        c_soft[ 6] = (c & 0x0020) ? 255 : 0;\n        c_soft[ 7] = (c & 0x0010) ? 255 : 0;\n        c_soft[ 8] = (c & 0x0008) ? 255 : 0;\n        c_soft[ 9] = (c & 0x0004) ? 255 : 0;\n        c_soft[10] = (c & 0x0002) ? 255 : 0;\n        c_soft[11] = (c & 0x0001) ? 255 : 0;\n        s_hat = fecsoft_hamming128_decode(c_soft);\n        CONTEND_EQUALITY(s, s_hat);\n    }\n}\n//...')
"
"('Sure, here is a detailed technical scenario for the prompt that could have led to the code provided:. . Prompt: Write a function that calculates the Bessel function J of the first kind for a given order (_nu) and argument (_z). The Bessel function J is commonly used in various scientific and engineering applications to describe wave propagation, heat conduction, and other phenomena involving oscillatory behavior.. . The function should return the value of J given the input parameters. The calculation should account for edge cases, such as when _z is zero or when the argument is close to zero, where specific conditions must be implemented to ensure numerical stability and accuracy.. . Additionally, the function should utilize numerical approximation techniques, such as series expansion or iterative methods, to efficiently compute the Bessel function J. Make sure to handle intermediate calculations with care to avoid overflow or underflow issues.. . Consider optimizing the code for performance by implementing algorithmic optimizations or leveraging math library functions to simplify the computation where possible. It is crucial to ensure","//...\nfloat liquid_besseljf(float _nu,\n                      float _z)\n{\n    if (_z == 0) {\n        return _nu == 0.0f ? 1.0f : 0.0f;\n    }\n    if (_z < 1e-3f*sqrtf(_nu + 1.0f)) {\n        return powf(0.5f*_z,_nu) / liquid_gammaf(_nu + 1.0f);\n    }\n    float J = 0.0f;\n    float abs_nu = fabsf(_nu);\n    unsigned int k;\n    for (k=0; k<NUM_BESSELJ_ITERATIONS; k++) {\n        float t0 = (2.0f*k + abs_nu);\n        float t1 = t0 * logf(_z);\n        float t2 = t0 * logf(2.0f);\n        float t3 = liquid_lngammaf((float)k + 1.0f);\n        float t4 = liquid_lngammaf(abs_nu + (float)k + 1.0f);\n        if ( (k%2) == 0) J += expf(t1 - t2 - t3 - t4);\n        else             J -= expf(t1 - t2 - t3 - t4);\n    }\n    return J;\n}\n//...')
"
'Please provide a code snippet that creates a bar object with events and animations in LittlevGL when the LV_USE_BAR and LV_BUILD_EXAMPLES flags are enabled.,"#if LV_USE_BAR && LV_BUILD_EXAMPLES\nstatic void set_value(void * bar, int32_t v)\n{\n    lv_bar_set_value(bar, v, LV_ANIM_OFF);\n}\nstatic void event_cb(lv_event_t * e)\n{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    label_dsc.font = LV_FONT_DEFAULT;\n    char buf[8];\n    lv_snprintf(buf, sizeof(buf), ""%d"", (int)lv_bar_get_value(obj));\n    lv_point_t txt_size;\n    lv_text_get_size(&txt_size, buf, label_dsc.font, label_dsc.letter_space, label_dsc.line_space, LV_COORD_MAX,\n                     label_dsc.flag);\n    lv_area_t txt_area;\n    txt_area.x1 = 0;\n    txt_area.x2 = txt_size.x - 1;\n    txt_area.y1 = 0;\n    txt_area.y2 = txt_size.y - 1;\n    lv_bar_t * bar = (lv_bar_t *) obj;\n    const lv_area_t * indic_area = &bar->indic_area;\n    if(lv_area_get_width(indic_area) > txt_size.x + 20) {\n        lv_area_align(indic_area, &txt_area, LV_ALIGN_RIGHT_MID, -10, 0);\n        label_dsc.color = lv_color_white();\n    }\n    else {\n        lv_area_align(indic_area, &txt_area, LV_ALIGN_OUT_RIGHT_MID, 10, 0);\n        label_dsc.color = lv_color_black();\n    }\n    label_dsc.text = buf;\n    label_dsc.text_local = true;\n    lv_layer_t * layer = lv_event_get_layer(e);\n    lv_draw_label(layer, &label_dsc, &txt_area);\n}\nvoid lv_example_bar_6(void)\n{\n    lv_obj_t * bar = lv_bar_create(lv_screen_active());\n    lv_obj_set_size(bar, 200, 20);\n    lv_obj_center(bar);\n    lv_obj_add_event_cb(bar, event_cb, LV_EVENT_DRAW_MAIN_END, NULL);\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, bar);\n    lv_anim_set_values(&a, 0, 100);\n    lv_anim_set_exec_cb(&a, set_value);\n    lv_anim_set_duration(&a, 4000);\n    lv_anim_set_playback_duration(&a, 4000);\n    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n    lv_anim_start(&a);\n}\n#endif'"
"('Prompt: Please write a function that tests the copy functionality of a modem. The function should create a modem object with a specified modulation scheme, perform modulate and demodulate operations on random symbols, then create a copy of the modem object. The function should compare the modulation schemes of the original and copied modem objects. Finally, the function should modulate the same symbols with both modem objects and verify that the output signals are equal. The modulation scheme to be tested is DPSK16.","//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_dpsk16()    { modemcf_test_copy(LIQUID_MODEM_DPSK16);    }\n//...')
"
"('Prompt: Please provide a code snippet to test copying a Forward Error Correction (FEC) scheme using the `fec_test_copy` function. In this scenario, the function checks if the `LIBFEC_ENABLED` flag is set, and if not, it creates an FEC object, encodes a random message, copies the FEC object, encodes the same random message again, and then compares the encoded messages to ensure they are the same. Finally, it decodes the encoded messages using both FEC objects and verifies that the decoded messages match. The test specifically involves the `LIQUID_FEC_SECDED2216` code.","//...\nvoid fec_test_copy(fec_scheme _fs)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    unsigned int n_dec = 64;\n    void *       opts  = NULL;\n    fec q0 = fec_create(_fs,opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,n_dec);\n    unsigned char msg_org[n_dec];   \n    unsigned char msg_enc_0[n_enc]; \n    unsigned char msg_enc_1[n_enc]; \n    unsigned char msg_dec_0[n_dec]; \n    unsigned char msg_dec_1[n_dec]; \n    unsigned int i;\n    for (i=0; i<n_dec; i++)\n        msg_org[i] = rand() & 0xff;\n    fec_encode(q0,n_dec,msg_org,msg_enc_0);\n    fec q1 = fec_copy(q0);\n    fec_encode(q1,n_dec,msg_org,msg_enc_1);\n    CONTEND_SAME_DATA(msg_enc_0,msg_enc_1,n_enc);\n    for (i=0; i<n_enc; i++) {\n        msg_enc_0[i] = rand() & 0xff;\n        msg_enc_1[i] = msg_enc_0[i];\n    }\n    fec_decode(q0,n_dec,msg_enc_0,msg_dec_0);\n    fec_decode(q1,n_dec,msg_enc_1,msg_dec_1);\n    CONTEND_SAME_DATA(msg_dec_0,msg_dec_1,n_dec);\n    fec_destroy(q0);\n    fec_destroy(q1);\n}\nvoid autotest_fec_copy_secded2216() { fec_test_copy(LIQUID_FEC_SECDED2216 ); }\n//...')
"
"('Prompt: You are developing a C program that utilizes error handling functions. The program should output error messages to stderr, including the error code, error information, file name, and line number. Additionally, the program should optionally exit with the error code in case of severe errors. Can you provide me with C code that includes functions for handling errors named `liquid_error_config_fl` and `liquid_error_fl` to accomplish this? The code should utilize variable argument lists for flexible error message formatting and should include conditional compilation flags to suppress error output and enable strict exit behavior.","//...\nvoid * liquid_error_config_fl(const char * _file,\n                              int          _line,\n                              const char * _format,\n                              ...)\n{\n    int code = LIQUID_EICONFIG;\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    va_list argptr;\n    va_start(argptr, _format);\n    fprintf(stderr,""error [%d]: %s\\n"", code, liquid_error_info(code));\n    fprintf(stderr,""  %s:%u: "", _file, _line);\n    vfprintf(stderr, _format, argptr);\n    fprintf(stderr,""\\n"");\n    va_end(argptr);\n#endif\n#if LIQUID_STRICT_EXIT\n    exit(code);\n#endif\n    return NULL;\n}\nint liquid_error_fl(int          _code,\n                    const char * _file,\n                    int          _line,\n                    const char * _format,\n                    ...)\n{\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    va_list argptr;\n    va_start(argptr, _format);\n    fprintf(stderr,""error [%d]: %s\\n"", _code, liquid_error_info(_code));\n    fprintf(stderr,""  %s:%u: "", _file, _line);\n    vfprintf(stderr, _format, argptr);\n    fprintf(stderr,""\\n"");\n    va_end(argptr);\n#endif\n#if LIQUID_STRICT_EXIT\n    exit(_code);\n#endif\n    return _code;\n}\n//...')
"
"'Sure! The technical scenario is that you are working on a project involving real-time streaming protocol (RTSP) and need to implement functionality related to handling H.264 video streams. You want to access the code that deals specifically with this aspect, located in the `rtp_h264.c` file within the `gear-lib` library folder. Please provide me with the code relevant to handling H.264 video streams within the `rtp_h264.c` file.",../gear-lib/librtsp/rtp_h264.c'
"('You could have prompted me with the following scenario: . . ""Write a set of functions that implement the encoding and decoding schemes for the SECDED (Single Error Correction, Double Error Detection) code with a constraint length of 22 and a code rate of 1/2. The encoder should take an input message and compute the corresponding SECDED codeword. The decoder should be able to correct single errors and detect multiple errors in the received codeword. Ensure that the appropriate error correction and detection mechanisms are implemented within the functions. Additionally, provide a function to create an instance of the SECDED code and initialize the necessary parameters for encoding and decoding.""","//...\nint fec_secded2216_encode(fec             _q,\n                          unsigned int    _dec_msg_len,\n                          unsigned char * _msg_dec,\n                          unsigned char * _msg_enc)\n{\n    unsigned int i=0;       \n    unsigned int j=0;       \n    unsigned int r = _dec_msg_len % 2;\n    for (i=0; i<_dec_msg_len-r; i+=2) {\n        _msg_enc[j+0] = fec_secded2216_compute_parity(&_msg_dec[i]);\n        _msg_enc[j+1] = _msg_dec[i+0];\n        _msg_enc[j+2] = _msg_dec[i+1];\n        j += 3;\n    }\n    if (r) {\n        unsigned char m[2] = {_msg_dec[i], 0x00};\n        unsigned char v[3];\n        fec_secded2216_encode_symbol(m, v);\n        _msg_enc[j+0] = v[0];\n        _msg_enc[j+1] = v[1];\n        i += r;\n        j += r+1;\n    }\n    assert( j == fec_get_enc_msg_length(LIQUID_FEC_SECDED2216,_dec_msg_len) );\n    assert( i == _dec_msg_len);\n    return LIQUID_OK;\n}\nint fec_secded2216_decode_symbol(unsigned char * _sym_enc,\n                                 unsigned char * _sym_dec)\n{\n#if 0\n    if (_sym_enc[0] >= (1<<6)) {\n        fprintf(stderr,""warning, fec_secded2216_decode_symbol(), input symbol too large\\n"");\n    }\n#endif\n    unsigned char e_hat[3] = {0,0,0};\n    int syndrome_flag = fec_secded2216_estimate_ehat(_sym_enc, e_hat);\n    _sym_dec[0] = _sym_enc[1] ^ e_hat[1];\n    _sym_dec[1] = _sym_enc[2] ^ e_hat[2];\n#if DEBUG_FEC_SECDED2216\n    if (syndrome_flag == 1) {\n        printf(""secded2216_decode_symbol(): single error detected!\\n"");\n    } else if (syndrome_flag == 2) {\n        printf(""secded2216_decode_symbol(): no match found (multiple errors detected)\\n"");\n    }\n#endif\n    return syndrome_flag;\n}\nint fec_secded2216_estimate_ehat(unsigned char * _sym_enc,\n                                 unsigned char * _e_hat)\n{\n    _e_hat[0] = 0x00;\n    _e_hat[1] = 0x00;\n    _e_hat[2] = 0x00;\n    unsigned char s = fec_secded2216_compute_syndrome(_sym_enc);\n    unsigned int ws = liquid_c_ones[s];\n    if (ws == 0) {\n        return 0;\n    } else {\n        unsigned int n;\n        for (n=0; n<22; n++) {\n            if (s == secded2216_syndrome_w1[n]) {\n                div_t d = div(n,8);\n                _e_hat[3-d.quot-1] = 1 << d.rem;\n                return 1;\n            }\n        }\n    }\n    return 2;\n}\nint fec_secded2216_encode_symbol(unsigned char * _sym_dec,\n                                 unsigned char * _sym_enc)\n{\n    _sym_enc[0] = fec_secded2216_compute_parity(_sym_dec);\n    _sym_enc[1] = _sym_dec[0];\n    _sym_enc[2] = _sym_dec[1];\n    return LIQUID_OK;\n}\nunsigned char fec_secded2216_compute_parity(unsigned char * _m)\n{\n    unsigned char parity = 0x00;\n    unsigned int i;\n    for (i=0; i<6; i++) {\n        parity <<= 1;\n        unsigned int p = liquid_c_ones[ secded2216_P[2*i+0] & _m[0] ] +\n                         liquid_c_ones[ secded2216_P[2*i+1] & _m[1] ];\n        parity |= p & 0x01;\n    }\n    return parity;\n}\nunsigned char fec_secded2216_compute_syndrome(unsigned char * _v)\n{\n    unsigned int i;\n    unsigned char syndrome = 0x00;\n    for (i=0; i<6; i++) {\n        syndrome <<= 1;\n        unsigned int p =\n            ( (_v[0] & (1<<(6-i-1))) ? 1 : 0 )+\n            liquid_c_ones[ secded2216_P[2*i+0] & _v[1] ] +\n            liquid_c_ones[ secded2216_P[2*i+1] & _v[2] ];\n        syndrome |= p & 0x01;\n    }\n    return syndrome;\n}\nint fec_secded2216_decode(fec             _q,\n                          unsigned int    _dec_msg_len,\n                          unsigned char * _msg_enc,\n                          unsigned char * _msg_dec)\n{\n    unsigned int i=0;       \n    unsigned int j=0;       \n    unsigned int r = _dec_msg_len % 2;\n    for (i=0; i<_dec_msg_len-r; i+=2) {\n        fec_secded2216_decode_symbol(&_msg_enc[j], &_msg_dec[i]);\n        j += 3;\n    }\n    if (r) {\n        unsigned char v[3] = {_msg_enc[j+0], _msg_enc[j+1], 0x00};\n        unsigned char m_hat[2];\n        fec_secded2216_decode_symbol(v, m_hat);\n        _msg_dec[i] = m_hat[0];\n        i += r;\n        j += r+1;\n    }\n    assert( j == fec_get_enc_msg_length(LIQUID_FEC_SECDED2216,_dec_msg_len) );\n    assert( i == _dec_msg_len);\n    return LIQUID_OK;\n}\nfec fec_secded2216_create(void * _opts)\n{\n    fec q = (fec) malloc(sizeof(struct fec_s));\n    q->scheme = LIQUID_FEC_SECDED2216;\n    q->rate = fec_get_rate(q->scheme);\n    q->encode_func      = &fec_secded2216_encode;\n    q->decode_func      = &fec_secded2216_decode;\n    q->decode_soft_func = NULL;\n    return q;\n}\n//...')
"
"('Prompt: Can you provide a function that performs an automated test for a 5th order IIR filter using coefficients from specified data arrays with a length of 64? The test should use the function iirfilt_crcf_test and pass arrays iirfilt_crcf_data_h5x64_b, iirfilt_crcf_data_h5x64_a, iirfilt_crcf_data_h5x64_x, and iirfilt_crcf_data_h5x64_y with appropriate lengths.","//...\nvoid autotest_iirfilt_crcf_h5x64()\n{\n    iirfilt_crcf_test(iirfilt_crcf_data_h5x64_b,\n                      iirfilt_crcf_data_h5x64_a, 5,\n                      iirfilt_crcf_data_h5x64_x, 64,\n                      iirfilt_crcf_data_h5x64_y, 64);\n}\n//...')
"
"""You want to create a program that demonstrates the usage and performance of both spin locks and mutex locks in a multithreaded environment where threads increment and decrement a shared value. The prompt should ask for the type of lock to use (spin or mutex) and the number of iterations each thread should perform (between 2 and 10). The program should then create two threads with the specified lock type and iteration count, measure the time taken for the threads to complete their tasks, and output the final shared value along with the elapsed time in seconds and microseconds. The code provided will handle the creation of threads, locking mechanisms, value manipulation, timing, and output display based on the user's input.","#define __STDC_FORMAT_MACROS\nstatic spin_lock_t spin;\nstatic mutex_lock_t mutex;\nstatic int64_t value = 0;\nstruct thread_arg {\n    int flag;\n    uint64_t count;\n};\nvoid usage(int argc, char **argv)\n{\n    if (argc != 3) {\n        printf(""Usage: %s <type> <count>\\n"", argv[0]);\n        printf(""type: spin | mutex\\n"");\n        printf(""count: 2 ~ 10\\n"");\n        exit(0);\n    }\n}\nstatic void *print_mutex_lock(void *arg)\n{\n    struct thread_arg *argp = (struct thread_arg *)arg;\n    int c = argp->flag;\n    uint64_t n = argp->count;\n    uint64_t i;\n    pthread_t tid = pthread_self();\n    printf(""c = %d\\n"", c);\n    for (i = 0; i < n; ++ i) {\n        if (c) {\n            mutex_lock(&mutex);\n            ++ value;\n            if (!(i % 100) && 0) {\n                printf(""tid=%d, c=%d, value = %""PRId64""\\n"", (int)tid, c, value);\n            }\n            mutex_unlock(&mutex);\n        } else {\n            mutex_lock(&mutex);\n            -- value;\n            if (!(i % 100) && 0) {\n                printf(""tid=%d, c=%d, value = %""PRId64""\\n"", (int)tid, c, value);\n            }\n            mutex_unlock(&mutex);\n        }\n    }\n    return NULL;\n}\nstatic void *print_spin_lock(void *arg)\n{\n    struct thread_arg *argp = (struct thread_arg *)arg;\n    int c = argp->flag;\n    uint64_t n = argp->count;\n    uint64_t i;\n    pthread_t tid = pthread_self();\n    printf(""c = %d\\n"", c);\n    for (i = 0; i < n; ++ i) {\n        if (c) {\n            spin_lock(&spin);\n            ++ value;\n            if (!(i % 100) && 0) {\n                printf(""tid=%d, c=%d, value = %""PRId64""\\n"", (int)tid, c, value);\n            }\n            spin_unlock(&spin);\n        } else {\n            spin_lock(&spin);\n            -- value;\n            if (!(i % 100) && 0) {\n                printf(""tid=%d, c=%d, value = %""PRId64""\\n"", (int)tid, c, value);\n            }\n            spin_unlock(&spin);\n        }\n    }\n    return NULL;\n}\nint main(int argc, char **argv)\n{\n    usage(argc, argv);\n    pthread_t tid1, tid2;\n    struct timeval start;\n    struct timeval end;\n    uint64_t times = strtoul((const char*)argv[2], (char**)NULL, 10);\n    value = times;\n    struct thread_arg arg1, arg2;\n    arg1.flag = 0;\n    arg1.count = times;\n    arg2.flag = 1;\n    arg2.count = times;\n    if (!strcmp(argv[1], ""spin"")) {\n        gettimeofday(&start, NULL);\n        pthread_create(&tid1, NULL, print_spin_lock, (void *)&arg1);\n        pthread_create(&tid2, NULL, print_spin_lock, (void *)&arg2);\n    } else if (!strcmp(argv[1], ""mutex"")) {\n        gettimeofday(&start, NULL);\n        mutex_lock_init(&mutex);\n        pthread_create(&tid1, NULL, print_mutex_lock, (void *)&arg1);\n        pthread_create(&tid2, NULL, print_mutex_lock, (void *)&arg2);\n    }\n    printf(""tid1=%d, tid2=%d\\n"", (int)tid1, (int)tid2);\n    if (tid1 && tid2) {\n        uint64_t startUs = 0;\n        uint64_t endUs = 0;\n        pthread_join(tid1, NULL);\n        pthread_join(tid2, NULL);\n        gettimeofday(&end, NULL);\n        startUs = start.tv_sec * 1000000 + start.tv_usec;\n        endUs = end.tv_sec * 1000000 + end.tv_usec;\n        fprintf(stdout, ""Value is %"" PRIu64 "", Used %"" PRIu64 ""us:%"" PRIu64 ""\\n"",\n                value, (endUs - startUs) / 1000000, (endUs - startUs) % 1000000);\n    }\n    mutex_lock_deinit(&mutex);\n    return 0;\n}'"
"('Prompt: Can you provide a code snippet for testing the `msresamp2_crcf` function with 2 stages, a center frequency of 0.25 Hz, and stopband attenuation of 60 dB?. . Technical scenario: You are working on validating the performance of a multistage resampler function (`msresamp2_crcf`) in a signal processing library. To ensure the resampler is functioning correctly, you need to test it with specific parameters like the number of stages, center frequency, and stopband attenuation. In this case, you are interested in testing the function with 2 stages, a center frequency of 0.25 Hz, and a stopband attenuation of 60 dB. By running this test, you aim to confirm that the resampler produces the expected output signal with the specified parameters.","//...\nvoid testbench_msresamp2_crcf_interp(unsigned int _num_stages,\n                                     float        _fc,\n                                     float        _as)\n{\n    msresamp2_crcf resamp = msresamp2_crcf_create(\n        LIQUID_RESAMP_INTERP, _num_stages, _fc, 0.0f, _as);\n    float delay = msresamp2_crcf_get_delay(resamp);\n    unsigned int  M = 1 << _num_stages; \n    unsigned int  buf_len = 0;\n    unsigned int  num_blocks = 0;\n    while ((float)buf_len < 2*M*delay) {\n        buf_len += M;\n        num_blocks++;\n    }\n    float complex buf[buf_len]; \n    unsigned int i;\n    for (i=0; i<num_blocks; i++) {\n        float complex x = (i==0) ? 1.0f : 0.0f;\n        msresamp2_crcf_execute(resamp, &x, buf+ i*M);\n    }\n    liquid_vectorcf_mulscalar(buf, buf_len, 1.0f/(float)M, buf);\n#if 0\n    for (i=0; i<buf_len; i++)\n        printf(""%3u : %12.8f %12.8f\\n"", i, crealf(buf[i]), cimagf(buf[i]));\n#endif\n    float f0 = _fc / (float)M;\n    float f1 = 1.0f / (float)M - f0;\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f, .fmax=-f1,   .pmin=   0, .pmax=-_as, .test_lo=0, .test_hi=1},\n        {.fmin=  -f0, .fmax= f0,   .pmin=-0.1, .pmax= 0.1, .test_lo=1, .test_hi=1},\n        {.fmin=   f1, .fmax= 0.5f, .pmin=   0, .pmax=-_as, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/msresamp2_crcf_interp_M%u_f%.3u_a%u.m"",\n        M, (int)(_fc*1000), (int)_as);\n    liquid_autotest_validate_psd_signal(buf, buf_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    msresamp2_crcf_destroy(resamp);\n}\nvoid autotest_msresamp2_crcf_interp_02() { testbench_msresamp2_crcf_interp(2, 0.25f, 60.0f); }\n//...')
"
"('Prompt: You are working on testing a function that quantizes a floating point value using an 8-bit ADC and DAC. The function takes in a float value `x` initialized to -1.0, a number of steps `num_steps` set to 30, a number of bits `num_bits` set to 8, and a tolerance `tol` calculated based on the number of bits. It iterates through the steps, quantizes the input value using the ADC function `quantize_adc` which returns an unsigned int `q`, and then quantizes the result using the DAC function `quantize_dac` which returns a float value `x_hat`. After each quantization, it checks if the most significant bits of `q` are zero, prints the quantized values if in verbose mode, and verifies if the difference between original `x` and quantized `x_hat` is within tolerance. The input `x` increments by `dx` until it reaches ","void autotest_quantize_float_n8() {\n    float x = -1.0f;\n    unsigned int num_steps=30;\n    unsigned int num_bits=8;\n    float dx = 2/(float)(num_steps);\n    unsigned int q;\n    float x_hat;\n    float tol = 1.0f / (float)(1<<num_bits);\n    unsigned int i;\n    for (i=0; i<num_steps; i++) {\n        q = quantize_adc(x,num_bits);\n        CONTEND_EQUALITY(q>>num_bits, 0);\n        x_hat = quantize_dac(q,num_bits);\n        if (liquid_autotest_verbose)\n            printf(""%8.4f > 0x%2.2x > %8.4f\\n"", x, q, x_hat);\n        CONTEND_DELTA(x,x_hat,tol);\n        x += dx;\n        x = (x > 1.0f) ? 1.0f : x;\n    }\n}')
"
"('Prompt: Can you provide a function that prints out the usage information for an infinite impulse response filter example? The function should display various options including filter type, filter transformation, filter order, passband ripple, stopband attenuation, passband cut-off, center frequency, and format. Default values should be provided in square brackets.","//...\nvoid usage()\n{\n    printf(""iirfilt_cccf_example -- infinite impulse response filter example\\n"");\n    printf(""options (default values in []):\\n"");\n    printf(""  h     : print help\\n"");\n    printf(""  t     : filter type: [butter], cheby1, cheby2, ellip, bessel\\n"");\n    printf(""  b     : filter transformation: [LP], HP, BP, BS\\n"");\n    printf(""  n     : filter order, n > 0 [5]\\n"");\n    printf(""  r     : passband ripple in dB (cheby1, ellip), r > 0 [1.0]\\n"");\n    printf(""  s     : stopband attenuation in dB (cheby2, ellip), s > 0 [40.0]\\n"");\n    printf(""  f     : passband cut-off, 0 < f < 0.5 [0.2]\\n"");\n    printf(""  c     : center frequency (BP, BS cases), 0 < c < 0.5 [0.25]\\n"");\n    printf(""  o     : format [sos], tf\\n"");\n    printf(""          sos   : second-order sections form\\n"");\n    printf(""          tf    : regular transfer function form (potentially\\n"");\n    printf(""                  unstable for large orders\\n"");\n}\n//...')
"
"('You are conducting a simulation to compare the accuracy of the `cacosf` function from the C Standard Library with a custom implementation `sandbox_cacosf`. To proceed with the simulation, please provide me with the prompt: ""Please generate and test `n` random complex numbers using both `cacosf` and `sandbox_cacosf`, and output the results along with the maximum error. Also, format the random complex numbers and results arrays in groups of `d` for better readability.""","#define sandbox_randf() ((float) rand() / (float) RAND_MAX)\nfloat complex sandbox_cacosf(float complex _z)\n{\n    int sign_i = crealf(_z) > 0;\n    int sign_q = cimagf(_z) > 0;\n    if (sign_i == sign_q) {\n        return - _Complex_I*clogf(_z + csqrtf(_z*_z - 1.0f));\n    } else {\n        return - _Complex_I*clogf(_z - csqrtf(_z*_z - 1.0f));\n    }\n    return 0.0f;\n}\nint main() {\n    unsigned int n=32;  \n    unsigned int d=2;   \n    float complex z[n];\n    float complex test[n];\n    float complex err_max = 0.0f;\n    unsigned int i;\n    for (i=0; i<n; i++) {\n        z[i] = 2.0f*(2.0f*sandbox_randf() - 1.0f) +\n               2.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;\n        test[i] = cacosf(z[i]);\n        float complex acosz_hat = sandbox_cacosf(z[i]);\n        float complex err = test[i] - acosz_hat;\n        printf(""%3u: z=%6.2f+j%6.2f, acos(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\\n"",\n                i,\n                crealf(z[i]),       cimagf(z[i]),\n                crealf(test[i]),    cimagf(test[i]),\n                crealf(acosz_hat),  cimagf(acosz_hat),\n                cabsf(err));\n        if ( cabsf(err) > cabsf(err_max) )\n            err_max = err;\n    }\n    printf(""maximum error: %12.4e;\\n"", cabsf(err_max));\n    printf(""\\n"");\n    printf(""    float complex z[%u] = {\\n      "", n);\n    for (i=0; i<n; i++) {\n        printf(""%12.4e+_Complex_I*%12.4e"", crealf(z[i]), cimagf(z[i]));\n        if ( i == n-1)\n            printf("" "");\n        else if ( ((i+1)%d)==0 )\n            printf("",\\n      "");\n        else\n            printf("", "");\n    }\n    printf(""};\\n"");\n    printf(""\\n"");\n    printf(""    float complex test[%u] = {\\n      "", n);\n    for (i=0; i<n; i++) {\n        printf(""%12.4e+_Complex_I*%12.4e"", crealf(test[i]), cimagf(test[i]));\n        if ( i == n-1)\n            printf("" "");\n        else if ( ((i+1)%d)==0 )\n            printf("",\\n      "");\n        else\n            printf("", "");\n    }\n    printf(""};\\n"");\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Can you provide a function that encodes a header for a GMSK frame generator (_q) based on the input header received (_header)? The header should contain information such as GMSKFRAME_VERSION, dec_msg_len, check bits, fec0, and fec1. The encoded header should be stored in _q->header_enc, and the function should also scramble the data in the encoded header using `scramble_data()`.","//...\n    unsigned int k;             \n    unsigned int m;             \n    unsigned int header_user_len;\n    unsigned int header_enc_len;\n    unsigned char * header_dec; \n    unsigned char * header_enc; \n    packetizer p_header;        \n    crc_scheme check;           \n    fec_scheme fec0;            \n    fec_scheme fec1;            \n    unsigned int dec_msg_len;   \nint gmskframegen_encode_header(gmskframegen          _q,\n                               const unsigned char * _header)\n{\n    if (_header == NULL)\n        memset(_q->header_dec, 0, _q->header_user_len);\n    else\n        memmove(_q->header_dec, _header, _q->header_user_len);\n    unsigned int n = _q->header_user_len;\n    _q->header_dec[n+0] = GMSKFRAME_VERSION;\n    _q->header_dec[n+1] = (_q->dec_msg_len >> 8) & 0xff;\n    _q->header_dec[n+2] = (_q->dec_msg_len     ) & 0xff;\n    _q->header_dec[n+3]  = (_q->check & 0x07) << 5;\n    _q->header_dec[n+3] |= (_q->fec0) & 0x1f;\n    _q->header_dec[n+4]  = (_q->fec1) & 0x1f;\n    packetizer_encode(_q->p_header, _q->header_dec, _q->header_enc);\n    scramble_data(_q->header_enc, _q->header_enc_len);\n#if 0\n    printf(""    header_enc      :"");\n    unsigned int i;\n    for (i=0; i<GMSKFRAME_H_ENC; i++)\n        printf("" %.2X"", _q->header_enc[i]);\n    printf(""\\n"");\n#endif\n    return LIQUID_OK;\n}\n//...')
"
"('Create a prompt around a scenario where you need assistance with encoding header information for a FSK frame generator in a communication system. . . Request: ""I am working on implementing a FSK frame generator in a communication system and I am having trouble encoding the header information. Can you help me write code that encodes the header using FSK modulation techniques? I need to properly format the header with specific payload information and check the resulting symbols. Thank you!""","//...\n    unsigned int    m;                  \n    unsigned int    k;                  \n    fskmod          mod;                \n#define DEBUG_FSKFRAMEGEN    0\n    qpacketmodem    header_encoder;     \n    unsigned char * header_dec;         \n    unsigned char * header_enc;         \n    unsigned int    header_sym_len;     \n    unsigned char * header_sym;         \n#define DEBUG_FSKFRAMEGEN    0\n    crc_scheme      payload_crc;        \n    fec_scheme      payload_fec0;       \n    fec_scheme      payload_fec1;       \nint fskframegen_encode_header(fskframegen     _q,\n                               unsigned char * _header)\n{\n    memmove(_q->header_dec, _header, 8);\n    unsigned int n = 8;\n#if 0\n    _q->header_dec[n+0] = 0;    \n    _q->header_dec[n+1] = (_q->payload_dec_len >> 8) & 0xff;\n    _q->header_dec[n+2] = (_q->payload_dec_len     ) & 0xff;\n    _q->header_dec[n+3]  = (_q->payload_crc & 0x07) << 5;\n    _q->header_dec[n+3] |= (_q->payload_fec0      ) & 0x1f;\n    _q->header_dec[n+4]  = (_q->payload_fec1      ) & 0x1f;\n#else\n    while (n < _q->header_dec_len)\n        _q->header_dec[n++] = 0xff;\n#endif\n    qpacketmodem_encode_syms(_q->header_encoder, _q->header_dec, _q->header_sym);\n#if 0\n    printf(""tx header symbols (%u):\\n"", _q->header_sym_len);\n    unsigned int i;\n    for (i=0; i<_q->header_sym_len; i++)\n        printf(""%1x"", _q->header_sym[i]);\n    printf(""\\n"");\n    printf(""tx header decoded (%u):\\n"", _q->header_dec_len);\n    for (i=0; i<_q->header_dec_len; i++)\n        printf("" %2x"", _q->header_dec[i]);\n    printf(""\\n"");\n#endif\n    return LIQUID_OK;\n}\n//...')
"
'Please provide a technical scenario where you need help implementing alignment pattern positions and initializing function modules in a QR code generator.,"//...\ntestable int getAlignmentPatternPositions(int version, uint8_t result[7])\n{\n    if(version == 1)\n        return 0;\n    int numAlign = version / 7 + 2;\n    int step = (version == 32) ? 26 :\n               (version * 4 + numAlign * 2 + 1) / (numAlign * 2 - 2) * 2;\n    for(int i = numAlign - 1, pos = version * 4 + 10; i >= 1; i--, pos -= step)\n        result[i] = pos;\n    result[0] = 6;\n    return numAlign;\n}\nstatic void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[])\n{\n    for(int dy = 0; dy < height; dy++) {\n        for(int dx = 0; dx < width; dx++)\n            setModule(qrcode, left + dx, top + dy, true);\n    }\n}\ntestable void setModule(uint8_t qrcode[], int x, int y, bool isBlack)\n{\n    int qrsize = qrcode[0];\n    LV_ASSERT(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n    int index = y * qrsize + x;\n    int bitIndex = index & 7;\n    int byteIndex = (index >> 3) + 1;\n    if(isBlack)\n        qrcode[byteIndex] |= 1 << bitIndex;\n    else\n        qrcode[byteIndex] &= (1 << bitIndex) ^ 0xFF;\n}\ntestable void initializeFunctionModules(int version, uint8_t qrcode[])\n{\n    int qrsize = version * 4 + 17;\n    memset(qrcode, 0, ((qrsize * qrsize + 7) / 8 + 1) * sizeof(qrcode[0]));\n    qrcode[0] = (uint8_t)qrsize;\n    fillRectangle(6, 0, 1, qrsize, qrcode);\n    fillRectangle(0, 6, qrsize, 1, qrcode);\n    fillRectangle(0, 0, 9, 9, qrcode);\n    fillRectangle(qrsize - 8, 0, 8, 9, qrcode);\n    fillRectangle(0, qrsize - 8, 9, 8, qrcode);\n    uint8_t alignPatPos[7];\n    int numAlign = getAlignmentPatternPositions(version, alignPatPos);\n    for(int i = 0; i < numAlign; i++) {\n        for(int j = 0; j < numAlign; j++) {\n            if(!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))\n                fillRectangle(alignPatPos[i] - 2, alignPatPos[j] - 2, 5, 5, qrcode);\n        }\n    }\n    if(version >= 7) {\n        fillRectangle(qrsize - 11, 0, 3, 6, qrcode);\n        fillRectangle(0, qrsize - 11, 6, 3, qrcode);\n    }\n}\n//...'"
'Prompt: You are working on a project that involves converting RGB color values to HSL color values. You need to write a function that takes an RGB color value as input and returns the corresponding HSL color value. Write the code for a function called `rgb888_to_hsl` that takes a pointer to an `rgb_t` struct as an argument and performs the conversion. Make sure to handle the edge cases and correctly calculate the HSL values based on the RGB input.,"//...\nhsl_t\nrgb888_to_hsl(rgb_t *rgb)\n{\n    hsl_t hsl;\n    float r, g, b, h, s, l;\n    r = rgb->r / 256.0;\n    g = rgb->g / 256.0;\n    b = rgb->b / 256.0;\n    float maxColor = max(r, max(g, b));\n    float minColor = min(r, min(g, b));\n    if (minColor == maxColor) {\n        h = 0.0;\n        s = 0.0;\n        l = r;\n    } else {\n        l = (minColor + maxColor) / 2;\n        if (l < 0.5) {\n            s = (maxColor - minColor) / (maxColor + minColor);\n        } else {\n            s = (maxColor - minColor) / (2.0 - maxColor - minColor);\n        }\n        if (r == maxColor) {\n            h = (g - b) / (maxColor - minColor);\n        } else if (g == maxColor) {\n            h = 2.0 + (b - r) / (maxColor - minColor);\n        } else {\n            h = 4.0 + (r - g) / (maxColor - minColor);\n        }\n        h /= 6; \n        if (h < 0) {\n            h++;\n        }\n    }\n    hsl.h = (uint8_t)(h * 255.0);\n    hsl.s = (uint8_t)(s * 255.0);\n    hsl.l = (uint8_t)(l * 255.0);\n    return hsl;\n}\n//...'"
"('Please provide a prompt for a function that creates a waterfall plot structure for spectral analysis using a specific window type, window length, delay, and time duration. The code should include functions to create, copy, destroy, clear, and export the waterfall plot data in binary and GNU plot formats. It should also include functions to set parameters such as frequency, sample rate, dimensions, commands, and push data points to update the plot.","struct SPWATERFALL(_s) {\n    unsigned int    nfft;           \n    unsigned int    time;           \n    SPGRAM()        periodogram;    \n    T *             psd;            \n    unsigned int    index_time;     \n    unsigned int    rollover;       \n    float           frequency;      \n    float           sample_rate;    \n    unsigned int    width;          \n    unsigned int    height;         \n    char *          commands;       \n};\nint SPWATERFALL(_step)(SPWATERFALL() _q);\nint SPWATERFALL(_consolidate_buffer)(SPWATERFALL() _q);\nint SPWATERFALL(_export_bin)(SPWATERFALL() _q, const char * _base);\nint SPWATERFALL(_export_gnu)(SPWATERFALL() _q, const char * _base);\nSPWATERFALL() SPWATERFALL(_create)(unsigned int _nfft,\n                                   int          _wtype,\n                                   unsigned int _window_len,\n                                   unsigned int _delay,\n                                   unsigned int _time)\n{\n    if (_nfft < 2)\n        return liquid_error_config(""spwaterfall%s_create(), fft size must be at least 2"", EXTENSION);\n    if (_window_len > _nfft)\n        return liquid_error_config(""spwaterfall%s_create(), window size cannot exceed fft size"", EXTENSION);\n    if (_window_len == 0)\n        return liquid_error_config(""spwaterfall%s_create(), window size must be greater than zero"", EXTENSION);\n    if (_wtype == LIQUID_WINDOW_KBD && _window_len % 2)\n        return liquid_error_config(""spwaterfall%s_create(), KBD window length must be even"", EXTENSION);\n    if (_delay == 0)\n        return liquid_error_config(""spwaterfall%s_create(), delay must be greater than 0"", EXTENSION);\n    if (_time == 0)\n        return liquid_error_config(""spwaterfall%s_create(), time must be greater than 0"", EXTENSION);\n    SPWATERFALL() q = (SPWATERFALL()) malloc(sizeof(struct SPWATERFALL(_s)));\n    q->nfft         = _nfft;\n    q->time         = _time;\n    q->frequency    =  0;\n    q->sample_rate  = -1;\n    q->width        = 800;\n    q->height       = 800;\n    q->commands     = NULL;\n    q->psd = (T*) malloc( 2 * q->nfft * q->time * sizeof(T));\n    q->periodogram = SPGRAM(_create)(_nfft, _wtype, _window_len, _delay);\n    SPWATERFALL(_reset)(q);\n    return q;\n}\nSPWATERFALL() SPWATERFALL(_create_default)(unsigned int _nfft,\n                                           unsigned int _time)\n{\n    if (_nfft < 2)\n        return liquid_error_config(""spwaterfall%s_create_default(), fft size must be at least 2"", EXTENSION);\n    if (_time < 2)\n        return liquid_error_config(""spwaterfall%s_create_default(), fft size must be at least 2"", EXTENSION);\n    return SPWATERFALL(_create)(_nfft, LIQUID_WINDOW_KAISER, _nfft/2, _nfft/4, _time);\n}\nSPWATERFALL() SPWATERFALL(_copy)(SPWATERFALL() q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""spwaterfall%s_copy(), object cannot be NULL"", EXTENSION);\n    SPWATERFALL() q_copy = (SPWATERFALL()) malloc(sizeof(struct SPWATERFALL(_s)));\n    memmove(q_copy, q_orig, sizeof(struct SPWATERFALL(_s)));\n    q_copy->periodogram = SPGRAM(_copy)(q_orig->periodogram);\n    q_copy->psd = (T*) malloc( 2 * q_copy->nfft * q_copy->time * sizeof(T));\n    memmove(q_copy->psd, q_orig->psd, 2 * q_copy->nfft * q_copy->time * sizeof(T));\n    q_copy->commands = NULL;\n    SPWATERFALL(_set_commands)(q_copy, q_orig->commands);\n    return q_copy;\n}\nint SPWATERFALL(_destroy)(SPWATERFALL() _q)\n{\n    free(_q->psd);\n    free(_q->commands);\n    SPGRAM(_destroy)(_q->periodogram);\n    free(_q);\n    return LIQUID_OK;\n}\nint SPWATERFALL(_clear)(SPWATERFALL() _q)\n{\n    SPGRAM(_clear)(_q->periodogram);\n    memset(_q->psd, 0x00, 2*_q->nfft*_q->time*sizeof(T));\n    _q->index_time = 0;\n    return LIQUID_OK;\n}\nint SPWATERFALL(_reset)(SPWATERFALL() _q)\n{\n    SPWATERFALL(_clear)(_q);\n    SPGRAM(_reset)(_q->periodogram);\n    _q->rollover = 1;\n    return LIQUID_OK;\n}\nint SPWATERFALL(_print)(SPWATERFALL() _q)\n{\n    printf(""spwaterfall%s: nfft=%u, time=%u\\n"", EXTENSION, _q->nfft, _q->time);\n    return LIQUID_OK;\n}\nuint64_t SPWATERFALL(_get_num_samples_total)(SPWATERFALL() _q)\n{\n    return SPGRAM(_get_num_samples_total)(_q->periodogram);\n}\nunsigned int SPWATERFALL(_get_num_freq)(SPWATERFALL() _q)\n{\n    return _q->nfft;\n}\nunsigned int SPWATERFALL(_get_num_time)(SPWATERFALL() _q)\n{\n    return _q->index_time;\n}\nunsigned int SPWATERFALL(_get_window_len)(SPWATERFALL() _q)\n{\n    return SPGRAM(_get_window_len)(_q->periodogram);\n}\nunsigned int SPWATERFALL(_get_delay)(SPWATERFALL() _q)\n{\n    return SPGRAM(_get_delay)(_q->periodogram);\n}\nint SPWATERFALL(_get_wtype)(SPWATERFALL() _q)\n{\n    return SPGRAM(_get_wtype)(_q->periodogram);\n}\nconst float * SPWATERFALL(_get_psd)(SPWATERFALL() _q)\n{\n    return (const T *) _q->psd;\n}\nint SPWATERFALL(_set_freq)(SPWATERFALL() _q,\n                           float         _freq)\n{\n    _q->frequency = _freq;\n    return LIQUID_OK;\n}\nint SPWATERFALL(_set_rate)(SPWATERFALL() _q,\n                           float         _rate)\n{\n    if (_rate <= 0.0f)\n        return liquid_error(LIQUID_EICONFIG,""spwaterfall%s_set_rate(), sample rate must be greater than zero"", EXTENSION);\n    _q->sample_rate = _rate;\n    return LIQUID_OK;\n}\nint SPWATERFALL(_set_dims)(SPWATERFALL() _q,\n                           unsigned int  _width,\n                           unsigned int  _height)\n{\n    _q->width  = _width;\n    _q->height = _height;\n    return LIQUID_OK;\n}\nint SPWATERFALL(_set_commands)(SPWATERFALL() _q,\n                               const char *  _commands)\n{\n    if (_commands == NULL) {\n        free(_q->commands);\n        _q->commands = NULL;\n        return LIQUID_OK;\n    }\n    unsigned int n = strlen(_commands);\n    if (n > 1<<14) {\n        SPWATERFALL(_set_commands)(_q, ""# error: input string size limit exceeded"");\n        return liquid_error(LIQUID_EICONFIG,""spwaterfall%s_set_commands(), input string size exceeds reasonable limits"",EXTENSION);\n    }\n    _q->commands = (char*) realloc(_q->commands, n+1);\n    memmove(_q->commands, _commands, n);\n    _q->commands[n] = \'\\0\';\n    return LIQUID_OK;\n}\nint SPWATERFALL(_push)(SPWATERFALL() _q,\n                       TI            _x)\n{\n    if (SPGRAM(_push)(_q->periodogram, _x))\n        return liquid_error(LIQUID_EINT,""spwaterfall%s_push(), could not push to internal spgram object"",EXTENSION);\n    if (SPWATERFALL(_step)(_q))\n        return liquid_error(LIQUID_EINT,""spwaterfall%s_push(), could not step internal state"",EXTENSION);\n    return LIQUID_OK;\n}\nint SPWATERFALL(_write)(SPWATERFALL() _q,\n                        TI *          _x,\n                        unsigned int  _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        SPWATERFALL(_push)(_q, _x[i]);\n    return LIQUID_OK;\n}\nint SPWATERFALL(_export)(SPWATERFALL() _q,\n                         const char *  _base)\n{\n    if (SPWATERFALL(_export_bin)(_q, _base))\n        return liquid_error(LIQUID_EIO,""spwaterfall%s_export(), could not export binary file to \'%s.bin\'"",EXTENSION,_base);\n    if (SPWATERFALL(_export_gnu)(_q, _base))\n        return liquid_error(LIQUID_EIO,""spwaterfall%s_export(), could not export gnuplot file to \'%s.gnu\'"",EXTENSION,_base);\n    return LIQUID_OK;\n}\nint SPWATERFALL(_step)(SPWATERFALL() _q)\n{\n    if (SPGRAM(_get_num_transforms)(_q->periodogram) >= _q->rollover) {\n        SPGRAM(_get_psd)(_q->periodogram, _q->psd + _q->nfft*_q->index_time);\n        SPGRAM(_clear)(_q->periodogram);\n        _q->index_time++;\n        if (_q->index_time == 2*_q->time)\n            SPWATERFALL(_consolidate_buffer)(_q);\n    }\n    return LIQUID_OK;\n}\nint SPWATERFALL(_consolidate_buffer)(SPWATERFALL() _q)\n{\n    unsigned int i; \n    unsigned int k; \n    for (i=0; i<_q->time; i++) {\n        for (k=0; k<_q->nfft; k++) {\n            T v0 = powf(10.0f, _q->psd[ (2*i + 0)*_q->nfft + k ]*0.1f);\n            T v1 = powf(10.0f, _q->psd[ (2*i + 1)*_q->nfft + k ]*0.1f);\n            _q->psd[ i*_q->nfft + k ] = 10.0f*log10f(0.5f*(v0+v1));\n        }\n    }\n    _q->index_time = _q->time;\n    _q->rollover *= 2;\n    return LIQUID_OK;\n}\nint SPWATERFALL(_export_bin)(SPWATERFALL() _q,\n                             const char *  _base)\n{\n    int n = strlen(_base);\n    char filename[n+5];\n    sprintf(filename,""%s.bin"", _base);\n    FILE * fid = fopen(filename,""w"");\n    if (fid == NULL) {\n        liquid_error(LIQUID_EICONFIG,""spwaterfall%s_export_bin(), could not open \'%s\' for writing"",\n                EXTENSION, filename);\n        return -1;\n    }\n    unsigned int i;\n    float nfftf = (float)(_q->nfft);\n    fwrite(&nfftf, sizeof(float), 1, fid);\n    for (i=0; i<_q->nfft; i++) {\n        float f = (float)i/nfftf - 0.5f;\n        fwrite(&f, sizeof(float), 1, fid);\n    }\n    uint64_t total_samples = SPGRAM(_get_num_samples_total)(_q->periodogram);\n    for (i=0; i<_q->index_time; i++) {\n        float n = (float)i / (float)(_q->index_time) * (float)total_samples;\n        fwrite(&n, sizeof(float), 1, fid);\n        fwrite(&_q->psd[i*_q->nfft], sizeof(float), _q->nfft, fid);\n    }\n    fclose(fid);\n    return LIQUID_OK;\n}\nint SPWATERFALL(_export_gnu)(SPWATERFALL() _q,\n                             const char *  _base)\n{\n    int n = strlen(_base);\n    char filename[n+5];\n    sprintf(filename,""%s.gnu"", _base);\n    FILE * fid = fopen(filename,""w"");\n    if (fid == NULL)\n        return liquid_error(LIQUID_EICONFIG,""spwaterfall%s_export_gnu(), could not open \'%s\' for writing"",EXTENSION,filename);\n    uint64_t total_samples = SPGRAM(_get_num_samples_total)(_q->periodogram);\n    char units  = \' \';\n    float scale = 1.0f;\n    liquid_get_scale((float)total_samples/4, &units, &scale);\n    fprintf(fid,""#!/usr/bin/gnuplot\\n"");\n    fprintf(fid,""reset\\n"");\n    fprintf(fid,""set terminal png size %u,%u enhanced font \'Verdana,10\'\\n"", _q->width, _q->height);\n    fprintf(fid,""set output \'%s.png\'\\n"", _base);\n    fprintf(fid,""unset key\\n"");\n    fprintf(fid,""set style line 11 lc rgb \'#808080\' lt 1\\n"");\n    fprintf(fid,""set border 3 front ls 11\\n"");\n    fprintf(fid,""set style line 12 lc rgb \'#888888\' lt 0 lw 1\\n"");\n    fprintf(fid,""set grid front ls 12\\n"");\n    fprintf(fid,""set tics nomirror out scale 0.75\\n"");\n    fprintf(fid,""set yrange [0:%f]\\n"", (float)(total_samples-1)*scale);\n    fprintf(fid,""set ylabel \'Sample Index\'\\n"");\n    fprintf(fid,""set format y \'%%.0f %c\'\\n"", units);\n    fprintf(fid,""# disable colorbar tics\\n"");\n    fprintf(fid,""set cbtics scale 0\\n"");\n    fprintf(fid,""set palette negative defined ( \\\\\\n"");\n    fprintf(fid,""    0 \'#D53E4F\',\\\\\\n"");\n    fprintf(fid,""    1 \'#F46D43\',\\\\\\n"");\n    fprintf(fid,""    2 \'#FDAE61\',\\\\\\n"");\n    fprintf(fid,""    3 \'#FEE08B\',\\\\\\n"");\n    fprintf(fid,""    4 \'#E6F598\',\\\\\\n"");\n    fprintf(fid,""    5 \'#ABDDA4\',\\\\\\n"");\n    fprintf(fid,""    6 \'#66C2A5\',\\\\\\n"");\n    fprintf(fid,""    7 \'#3288BD\' )\\n"");\n    fprintf(fid,""\\n"");\n    if (_q->sample_rate < 0) {\n        fprintf(fid,""set xrange [-0.5:0.5]\\n"");\n        float xtics = 0.1f;\n        fprintf(fid,""set xtics %f\\n"", xtics);\n        fprintf(fid,""set xlabel \'Normalized Frequency [f/F_s]\'\\n"");\n        if (_q->commands != NULL)\n            fprintf(fid,""%s\\n"", _q->commands);\n        fprintf(fid,""plot \'%s.bin\' u 1:($2*%e):3 binary matrix with image\\n"", _base, scale);\n    } else {\n        char unit;\n        float g = 1.0f;\n        float f_hi = _q->frequency + 0.5f*_q->sample_rate; \n        liquid_get_scale(f_hi/2, &unit, &g);\n        fprintf(fid,""set xlabel \'Frequency [%cHz]\'\\n"", unit);\n        float xn = ((float) _q->width * 0.8f) / 70.0f;  \n        float xt = 1.0f;                                \n        float spacing[] = {0.01,0.02,0.05,0.1,0.2,0.5,1.0,2.0,5.0,10.0,20.0,50.0,100.0,200.0,500.0,-1.0f};\n        unsigned int i=0;\n        while (spacing[i] > 0) {\n            if (_q->sample_rate*g/spacing[i] < 1.2f*xn) {\n                xt = spacing[i];\n                break;\n            }\n            i++;\n        }\n        fprintf(fid,""set xrange [%f:%f]\\n"", g*(_q->frequency-0.5*_q->sample_rate), g*(_q->frequency+0.5*_q->sample_rate));\n        fprintf(fid,""set xtics %f\\n"", xt);\n        if (_q->commands != NULL)\n            fprintf(fid,""%s\\n"", _q->commands);\n        fprintf(fid,""plot \'%s.bin\' u ($1*%f+%f):($2*%e):3 binary matrix with image\\n"",\n                _base,\n                g*(_q->sample_rate < 0 ? 1 : _q->sample_rate),\n                g*_q->frequency,\n                scale);\n    }\n    fclose(fid);\n#if 0\n    printf(""results written to %s\\n"", filename);\n    printf(""index time       : %u\\n"", _q->index_time);\n    printf(""rollover         : %u\\n"", _q->rollover);\n    printf(""total transforms : %llu\\n"", SPGRAM(_get_num_transforms_total)(_q->periodogram));\n#endif\n    return LIQUID_OK;\n}')
"
"'Please provide the technical scenario in which you would like to implement UART interrupt handling and how you would like to enable, clear, and disable specific UART interrupts in the system.","static uint32_t versal_uart_intr_all(void)\n{\n  return VERSAL_UARTI_OEI |\n    VERSAL_UARTI_BEI |\n    VERSAL_UARTI_PEI |\n    VERSAL_UARTI_FEI |\n    VERSAL_UARTI_RTI |\n    VERSAL_UARTI_TXI |\n    VERSAL_UARTI_RXI |\n    VERSAL_UARTI_DSRMI |\n    VERSAL_UARTI_DCDMI |\n    VERSAL_UARTI_CTSMI |\n    VERSAL_UARTI_RIMI;\n}\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\nstatic void versal_uart_intr_clear(volatile versal_uart *regs, uint32_t ints)\n{\n  regs->uarticr = ints;\n}\nstatic void versal_uart_intr_clearall(volatile versal_uart *regs)\n{\n  versal_uart_intr_clear(regs, versal_uart_intr_all());\n}\nstatic void versal_uart_intr_enable(volatile versal_uart *regs, uint32_t ints)\n{\n  regs->uartimsc |= ints;\n}\n#endif\nstatic void versal_uart_intr_disable(volatile versal_uart *regs, uint32_t ints)\n{\n  regs->uartimsc &= ~ints;\n}\nstatic void versal_uart_intr_disableall(volatile versal_uart *regs)\n{\n  versal_uart_intr_disable(regs, versal_uart_intr_all());\n}\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\nstatic bool versal_uart_flags_clear(volatile versal_uart *regs, uint32_t flags)\n{\n  return (regs->uartfr & flags) == 0;\n}\nstatic void versal_uart_interrupt(void *arg)\n{\n  rtems_termios_tty *tty = arg;\n  versal_uart_context *ctx = rtems_termios_get_device_context(tty);\n  volatile versal_uart *regs = ctx->regs;\n  uint32_t uartmis = regs->uartmis;\n  versal_uart_intr_clear(regs, uartmis);\n  if ((uartmis & (VERSAL_UARTI_RTI | VERSAL_UARTI_RXI)) != 0) {\n    char buf[32];\n    int c = 0;\n    while (c < sizeof(buf) &&\n           versal_uart_flags_clear(regs, VERSAL_UARTFR_RXFE)) {\n      buf[c++] = (char) VERSAL_UARTDR_DATA_GET(regs->uartdr);\n    }\n    rtems_termios_enqueue_raw_characters(tty, buf, c);\n  }\n  if (ctx->transmitting) {\n    int sent = ctx->tx_queued;\n    ctx->transmitting = false;\n    ctx->tx_queued = 0;\n    versal_uart_intr_disable(regs, VERSAL_UARTI_TXI);\n    rtems_termios_dequeue_characters(tty, sent);\n  }\n}\n#endif\nstatic bool versal_uart_first_open(\n  rtems_termios_tty *tty,\n  rtems_termios_device_context *base,\n  struct termios *term,\n  rtems_libio_open_close_args_t *args\n)\n{\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\n  versal_uart_context *ctx = (versal_uart_context *) base;\n  volatile versal_uart *regs = ctx->regs;\n  rtems_status_code sc;\n  ctx->transmitting = false;\n  ctx->tx_queued = 0;\n  ctx->first_send = true;\n#endif\n  rtems_termios_set_initial_baud(tty, VERSAL_UART_DEFAULT_BAUD);\n  versal_uart_initialize(base);\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\n  regs->uartifls = VERSAL_UARTIFLS_RXIFLSEL(2) | VERSAL_UARTIFLS_TXIFLSEL(2);\n  regs->uartlcr_h |= VERSAL_UARTLCR_H_FEN;\n  versal_uart_intr_disableall(regs);\n  sc = rtems_interrupt_handler_install(\n    ctx->irq,\n    ""UART"",\n    RTEMS_INTERRUPT_SHARED,\n    versal_uart_interrupt,\n    tty\n  );\n  if (sc != RTEMS_SUCCESSFUL) {\n    return false;\n  }\n  versal_uart_intr_clearall(regs);\n  versal_uart_intr_enable(regs, VERSAL_UARTI_RTI | VERSAL_UARTI_RXI);\n#endif\n  return true;\n}\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\nstatic void versal_uart_last_close(\n  rtems_termios_tty *tty,\n  rtems_termios_device_context *base,\n  rtems_libio_open_close_args_t *args\n)\n{\n  versal_uart_context *ctx = (versal_uart_context *) base;\n  rtems_interrupt_handler_remove(ctx->irq, versal_uart_interrupt, tty);\n}\n#endif\nstatic void versal_uart_write_support(\n  rtems_termios_device_context *base,\n  const char *buf,\n  size_t len\n)\n{\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\n  versal_uart_context *ctx = (versal_uart_context *) base;\n  volatile versal_uart *regs = ctx->regs;\n  if (len > 0) {\n    size_t len_remaining = len;\n    const char *p = &buf[0];\n    versal_uart_intr_enable(regs, VERSAL_UARTI_TXI);\n    if (ctx->first_send) {\n      ctx->first_send = false;\n      for (int i = 0; i < 17; ++i) {\n        regs->uartdr = VERSAL_UARTDR_DATA(\'\\r\');\n      }\n    }\n    while (versal_uart_flags_clear(regs, VERSAL_UARTFR_TXFF) &&\n           len_remaining > 0) {\n      regs->uartdr = VERSAL_UARTDR_DATA(*p++);\n      --len_remaining;\n    }\n    ctx->tx_queued = len - len_remaining;\n    ctx->transmitting = true;\n  }\n#else\n  ssize_t i;\n  for (i = 0; i < len; ++i) {\n    versal_uart_write_polled(base, buf[i]);\n  }\n#endif\n}\nstatic bool versal_uart_set_attributes(\n  rtems_termios_device_context *context,\n  const struct termios *term\n)\n{\n  versal_uart_context *ctx = (versal_uart_context *) context;\n  volatile versal_uart *regs = ctx->regs;\n  int32_t baud;\n  uint32_t ibauddiv = 0;\n  uint32_t fbauddiv = 0;\n  uint32_t mode = 0;\n  int rc;\n  baud = rtems_termios_baud_to_number(term->c_ospeed);\n  if (baud > 0) {\n    uint32_t maxerr = 3;\n    rc = versal_cal_baud_rate(\n        VERSAL_UART_DEFAULT_BAUD,\n        maxerr,\n        &ibauddiv,\n        &fbauddiv\n    );\n    if (rc != 0) {\n      return rc;\n    }\n  }\n  mode = regs->uartlcr_h & VERSAL_UARTLCR_H_FEN;\n  if ((term->c_cflag & PARENB) != 0) {\n    mode |= VERSAL_UARTLCR_H_PEN;\n    if ((term->c_cflag & PARODD) == 0) {\n      mode |= VERSAL_UARTLCR_H_EPS;\n    }\n  }\n  switch (term->c_cflag & CSIZE)\n  {\n  case CS5:\n    mode = VERSAL_UARTLCR_H_WLEN_SET(mode, VERSAL_UARTLCR_H_WLEN_5);\n    break;\n  case CS6:\n    mode = VERSAL_UARTLCR_H_WLEN_SET(mode, VERSAL_UARTLCR_H_WLEN_6);\n    break;\n  case CS7:\n    mode = VERSAL_UARTLCR_H_WLEN_SET(mode, VERSAL_UARTLCR_H_WLEN_7);\n    break;\n  case CS8:\n  default:\n    mode = VERSAL_UARTLCR_H_WLEN_SET(mode, VERSAL_UARTLCR_H_WLEN_8);\n    break;\n  }\n  if (term->c_cflag & CSTOPB) {\n    mode |= VERSAL_UARTLCR_H_STP2;\n  }\n  versal_uart_intr_disableall(regs);\n  while ((regs->uartfr & VERSAL_UARTFR_TXFE) == 0 ||\n         (regs->uartfr & VERSAL_UARTFR_BUSY) != 0) {\n  }\n  regs->uartcr = VERSAL_UARTCR_UARTEN;\n  if (baud > 0) {\n    regs->uartibrd = VERSAL_UARTIBRD_BAUD_DIVINT(ibauddiv);\n    regs->uartfbrd = VERSAL_UARTFBRD_BAUD_DIVFRAC(fbauddiv);\n  }\n  regs->uartlcr_h = mode;\n  regs->uartcr = VERSAL_UARTCR_RXE\n    | VERSAL_UARTCR_TXE\n    | VERSAL_UARTCR_UARTEN;\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\n  versal_uart_intr_clearall(regs);\n  versal_uart_intr_enable(regs, VERSAL_UARTI_RTI | VERSAL_UARTI_RXI);\n#endif\n  return true;\n}\nconst rtems_termios_device_handler versal_uart_handler = {\n  .first_open = versal_uart_first_open,\n  .set_attributes = versal_uart_set_attributes,\n  .write = versal_uart_write_support,\n#ifdef VERSAL_CONSOLE_USE_INTERRUPTS\n  .last_close = versal_uart_last_close,\n  .mode = TERMIOS_IRQ_DRIVEN\n#else\n  .poll_read = versal_uart_read_polled,\n  .mode = TERMIOS_POLLED\n#endif\n};'"
"'To provide the code snippet for handling image emojis with an image font in the LVGL library, you could have prompted me with the following scenario:. . ""Imagine you are working on a project with LVGL (LittlevGL) and want to display emojis using an image font. You need a function that determines the path to the image file of each emoji based on its Unicode value. If the emoji is supported by a specific image resource in your project, return the resource address; otherwise, return NULL. Additionally, create an example function that demonstrates how to use this image font to display text with emojis. However, account for the case where image font support is disabled in LVGL."". . Based on this technical scenario, you provided, I responded with the code snippet that includes the function `get_imgfont_path` to determine the path to image files of emojis based on their Unicode values, as well as the example function `lv_example_imgfont_1` to showcase the usage of the image font for displaying","#if LV_BUILD_EXAMPLES\n#if LV_USE_IMGFONT\nstatic const void * get_imgfont_path(const lv_font_t * font, uint32_t unicode, uint32_t unicode_next,\n                                     int32_t * offset_y, void * user_data)\n{\n    LV_UNUSED(font);\n    LV_UNUSED(unicode_next);\n    LV_UNUSED(offset_y);\n    LV_UNUSED(user_data);\n    LV_IMAGE_DECLARE(emoji_F617);\n    if(unicode < 0xF000) return NULL;\n    if(unicode == 0xF617) {\n        return &emoji_F617;\n    }\n    else if(unicode == 0xF600) {\n#if LV_USE_FFMPEG\n        return ""lvgl/examples/assets/emoji/F600.png"";\n#else\n        return ""A:lvgl/examples/assets/emoji/F600.png"";\n#endif\n    }\n    return NULL;\n}\nvoid lv_example_imgfont_1(void)\n{\n    lv_font_t * imgfont = lv_imgfont_create(80, get_imgfont_path, NULL);\n    if(imgfont == NULL) {\n        LV_LOG_ERROR(""imgfont init error"");\n        return;\n    }\n    imgfont->fallback = LV_FONT_DEFAULT;\n    lv_obj_t * label1 = lv_label_create(lv_screen_active());\n    lv_label_set_text(label1, ""12\\uF600\\uF617AB"");\n    lv_obj_set_style_text_font(label1, imgfont, LV_PART_MAIN);\n    lv_obj_center(label1);\n}\n#else\nvoid lv_example_imgfont_1(void)\n{\n    lv_obj_t * label = lv_label_create(lv_screen_active());\n    lv_label_set_text(label, ""imgfont is not installed"");\n    lv_obj_center(label);\n}\n#endif\n#endif'"
"'Prompt: You are working on a program that needs to handle an event whenever data is received on a file descriptor. Write a function that can be used as a callback whenever the event occurs. The function should read 2 bytes of data from the file descriptor, print the file descriptor and the first character read, and should be named ""on_time"".","//...\nstatic void on_time(int fd, void *arg)\n{\n    char ch[2];\n    read(fd, &ch, 2);\n    printf(""on_time fd = %d, ch=%c\\n"", fd, ch[0]);\n}\n//...'"
"('Please provide a prompt where you need a C program that performs decimation using a finite impulse response (FIR) filter and plots the original and decimated signals along with their frequency spectra. The program should have command-line options to specify the decimation factor, filter delay, stop-band attenuation, and number of samples. The decimation should be performed on a complex input signal composed of two tones with a Hamming window applied. The program should generate an output file in MATLAB format with the results.","#define OUTPUT_FILENAME ""firdecim_crcf_example.m""\nvoid usage()\n{\n    printf(""firdecim_crcf_example:\\n"");\n    printf(""  -h         : print usage/help\\n"");\n    printf(""  -M <decim> : decimation factor, M > 1           default: 2\\n"");\n    printf(""  -m <delay> : filter delay (symbols), m > 0,     default: 2\\n"");\n    printf(""  -s <atten> : filter stop-band attenuation [dB], default: 60\\n"");\n    printf(""  -n <num>   : number of samples (after decim),   default: 8\\n"");\n}\nint main(int argc, char*argv[]) {\n    unsigned int M           = 6;       \n    unsigned int m           = 8;       \n    float        As          = 60.0f;   \n    unsigned int num_samples = 120;     \n    int dopt;\n    while ((dopt = getopt(argc,argv,""hM:m:s:n:"")) != EOF) {\n        switch (dopt) {\n        case \'h\': usage();                    return 0;\n        case \'M\': M           = atoi(optarg); break;\n        case \'m\': m           = atoi(optarg); break;\n        case \'s\': As          = atof(optarg); break;\n        case \'n\': num_samples = atoi(optarg); break;\n        default:\n            usage();\n            return 1;\n        }\n    }\n    if (M < 2) {\n        fprintf(stderr,""error: %s, decim factor must be greater than 1\\n"", argv[0]);\n        return 1;\n    } else if (m < 1) {\n        fprintf(stderr,""error: %s, filter delay must be greater than 0\\n"", argv[0]);\n        return 1;\n    } else if (As <= 0.0) {\n        fprintf(stderr,""error: %s, stop-band attenuation must be greater than zero\\n"", argv[0]);\n        return 1;\n    } else if (num_samples < 1) {\n        fprintf(stderr,""error: %s, must have at least one sample\\n"", argv[0]);\n        return 1;\n    }\n    float complex x[M*num_samples]; \n    float complex y[  num_samples]; \n    unsigned int i;\n    unsigned int w_len = (unsigned int)(0.9*M*num_samples);\n    float f0 = 0.017f;\n    float f1 = 0.021f;\n    for (i=0; i<M*num_samples; i++) {\n        x[i]  = 0.6f*cexpf(_Complex_I*2*M_PI*f0*i);\n        x[i] += 0.4f*cexpf(_Complex_I*2*M_PI*f1*i);\n        x[i] *= (i < w_len) ? liquid_hamming(i,w_len) : 0;\n    }\n    firdecim_crcf decim = firdecim_crcf_create_kaiser(M, m, As);\n    firdecim_crcf_set_scale(decim, 1.0f/(float)M);\n    firdecim_crcf_execute_block(decim, x, num_samples, y);\n    firdecim_crcf_destroy(decim);\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""M  = %u;\\n"", M);\n    fprintf(fid,""m  = %u;\\n"", m);\n    fprintf(fid,""num_samples=%u;\\n"", num_samples);\n    for (i=0; i<M*num_samples; i++)\n        fprintf(fid,""x(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(x[i]), cimagf(x[i]));\n    for (i=0; i<num_samples; i++)\n        fprintf(fid,""y(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(y[i]), cimagf(y[i]));\n    fprintf(fid,""figure(\'position\',[100 100 600 800]);\\n"");\n    fprintf(fid,""tx = [0:(M*num_samples-1)];\\n"");\n    fprintf(fid,""ty = [0:(  num_samples-1)]*M - M*m;\\n"");\n    fprintf(fid,""nfft=3*2^nextpow2(M*num_samples);\\n"");\n    fprintf(fid,""fx = [0:(nfft-1)]/nfft-0.5;\\n"");\n    fprintf(fid,""fy = fx/M;\\n"");\n    fprintf(fid,""X=20*log10(abs(fftshift(fft(  x,nfft))));\\n"");\n    fprintf(fid,""Y=20*log10(abs(fftshift(fft(M*y,nfft))));\\n"");\n    fprintf(fid,""subplot(3,1,1);\\n"");\n    fprintf(fid,""  plot(tx,real(x),\'-\',ty,real(y),\'s\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  axis([-M*m M*num_samples -1.2 1.2]);\\n"");\n    fprintf(fid,""  xlabel(\'Input sample index\');\\n"");\n    fprintf(fid,""  ylabel(\'Real\');\\n"");\n    fprintf(fid,""  legend(\'original\',\'decimated\',\'location\',\'northeast\');"");\n    fprintf(fid,""subplot(3,1,2);\\n"");\n    fprintf(fid,""  plot(tx,imag(x),\'-\',ty,imag(y),\'s\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  axis([-M*m M*num_samples -1.2 1.2]);\\n"");\n    fprintf(fid,""  xlabel(\'Input sample index\');\\n"");\n    fprintf(fid,""  ylabel(\'Imag\');\\n"");\n    fprintf(fid,""  legend(\'original\',\'decimated\',\'location\',\'northeast\');"");\n    fprintf(fid,""subplot(3,1,3);\\n"");\n    fprintf(fid,""  plot(fx,X,\'Color\',[0.5 0.5 0.5],fy,Y,\'LineWidth\',2);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -40 60]);\\n"");\n    fprintf(fid,""  xlabel(\'normalized frequency\');\\n"");\n    fprintf(fid,""  ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""  legend(\'original/real\',\'transformed/decimated\',\'location\',\'northeast\');"");\n    fclose(fid);\n    printf(""results written to %s\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: You are working on a project that involves testing forward error correction schemes. You want to create a function that tests copying of FEC schemes and checks if the copied scheme encodes and decodes data correctly. Can you write a code snippet that includes a function to test copying of a specific FEC scheme (LIQUID_FEC_CONV_V27) and another function to test copying of a different FEC scheme (LIQUID_FEC_CONV_V27P67)? The code should generate random data, encode it, copy the scheme, re-encode the data, compare the encoded data for equality, modify the encoded data, decode it using both the original and copied scheme, and finally destroy the schemes.","//...\nvoid fec_test_copy(fec_scheme _fs)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    unsigned int n_dec = 64;\n    void *       opts  = NULL;\n    fec q0 = fec_create(_fs,opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,n_dec);\n    unsigned char msg_org[n_dec];   \n    unsigned char msg_enc_0[n_enc]; \n    unsigned char msg_enc_1[n_enc]; \n    unsigned char msg_dec_0[n_dec]; \n    unsigned char msg_dec_1[n_dec]; \n    unsigned int i;\n    for (i=0; i<n_dec; i++)\n        msg_org[i] = rand() & 0xff;\n    fec_encode(q0,n_dec,msg_org,msg_enc_0);\n    fec q1 = fec_copy(q0);\n    fec_encode(q1,n_dec,msg_org,msg_enc_1);\n    CONTEND_SAME_DATA(msg_enc_0,msg_enc_1,n_enc);\n    for (i=0; i<n_enc; i++) {\n        msg_enc_0[i] = rand() & 0xff;\n        msg_enc_1[i] = msg_enc_0[i];\n    }\n    fec_decode(q0,n_dec,msg_enc_0,msg_dec_0);\n    fec_decode(q1,n_dec,msg_enc_1,msg_dec_1);\n    CONTEND_SAME_DATA(msg_dec_0,msg_dec_1,n_dec);\n    fec_destroy(q0);\n    fec_destroy(q1);\n}\nvoid autotest_fec_copy_v27()     { fec_test_copy(LIQUID_FEC_CONV_V27      ); }\nvoid autotest_fec_copy_v27p67()  { fec_test_copy(LIQUID_FEC_CONV_V27P67   ); }\n//...')
"
"('Please provide me with the necessary functions and variables required for an automatic test of a function called `sumsqf` that calculates the sum of squares of elements in an array. The test should include an input array `_x` of length 3 called `sumsqf_test_x3`, a target sum of squares `_y` called `sumsqf_test_y3`, and a test case function `autotest_sumsqf_3`. The `sumsqf_runtest` function should compare the result of `liquid_sumsqf` function applied to the input array `_x` with the target sum `_y` with a given tolerance of `1e-6`.","//...\nfloat sumsqf_test_x3[3];    float sumsqf_test_y3;\nfloat sumsqf_test_y3 = 0.405030854218017;\nvoid sumsqf_runtest(float *      _x,\n                    unsigned int _n,\n                    float        _y)\n{\n    float tol = 1e-6;   \n    float y = liquid_sumsqf(_x, _n);\n    CONTEND_DELTA( y, _y, tol );\n}\nvoid autotest_sumsqf_3()    {   sumsqf_runtest( sumsqf_test_x3,  3,  sumsqf_test_y3  ); }\n//...')
"
'Please provide a technical scenario in which you need to initialize and configure clock sources and frequencies for a microcontroller using the HAL library.,"#ifdef HAL_RCC_MODULE_ENABLED\n#define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()\n#define MCO1_GPIO_PORT        GPIOA\n#define MCO1_PIN              GPIO_PIN_8\n#define MCO2_CLK_ENABLE()      __HAL_RCC_GPIOC_CLK_ENABLE()\n#define MCO2_GPIO_PORT         GPIOC\n#define MCO2_PIN               GPIO_PIN_9\n#ifndef __rtems__\nHAL_StatusTypeDef HAL_RCC_DeInit(void)\n{\n  uint32_t tickstart;\n  if (FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())\n  {\n    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);\n    if (__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)\n    {\n      return HAL_ERROR;\n    }\n  }\n  tickstart = HAL_GetTick();\n  SET_BIT(RCC->CR, RCC_CR_HSION);\n  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);\n  CLEAR_REG(RCC->CFGR);\n  SystemCoreClock = HSI_VALUE;\n  SystemD2Clock = HSI_VALUE;\n  if (HAL_InitTick(uwTickPrio) != HAL_OK)\n  {\n    return HAL_ERROR;\n  }\n  tickstart = HAL_GetTick();\n  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  tickstart = HAL_GetTick();\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON | RCC_CR_HSIDIV | RCC_CR_HSIDIVF | RCC_CR_CSION | RCC_CR_CSIKERON  \\\n            | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);\n  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  tickstart = HAL_GetTick();\n  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);\n  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  tickstart = HAL_GetTick();\n  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);\n  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  tickstart = HAL_GetTick();\n  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);\n  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n#if defined(RCC_D1CFGR_HPRE)\n  CLEAR_REG(RCC->D1CFGR);\n  CLEAR_REG(RCC->D2CFGR);\n  CLEAR_REG(RCC->D3CFGR);\n#else\n  CLEAR_REG(RCC->CDCFGR1);\n  CLEAR_REG(RCC->CDCFGR2);\n  CLEAR_REG(RCC->SRDCFGR);\n#endif\n  RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM1_5 | RCC_PLLCKSELR_DIVM2_5 | RCC_PLLCKSELR_DIVM3_5;\n  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);\n  WRITE_REG(RCC->PLL1DIVR, 0x01010280U);\n  CLEAR_REG(RCC->PLL1FRACR);\n  WRITE_REG(RCC->PLL2DIVR, 0x01010280U);\n  CLEAR_REG(RCC->PLL2FRACR);\n  WRITE_REG(RCC->PLL3DIVR, 0x01010280U);\n  CLEAR_REG(RCC->PLL3FRACR);\n#if defined(RCC_CR_HSEEXT)\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);\n#endif \n  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);\n  CLEAR_REG(RCC->CIER);\n  WRITE_REG(RCC->CICR, 0xFFFFFFFFU);\n  SET_BIT(RCC->RSR, RCC_RSR_RMVF);\n  if (FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())\n  {\n    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);\n    if (__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)\n    {\n      return HAL_ERROR;\n    }\n  }\n  return HAL_OK;\n}\n#endif \n__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\n{\n  uint32_t tickstart;\n  uint32_t temp1_pllckcfg, temp2_pllckcfg;\n  if (RCC_OscInitStruct == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)\n  {\n    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));\n    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();\n    const uint32_t temp_pllckselr = RCC->PLLCKSELR;\n    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))\n    {\n      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))\n      {\n        return HAL_ERROR;\n      }\n    }\n    else\n    {\n      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);\n      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)\n      {\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)\n        {\n          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else\n      {\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)\n        {\n          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)\n  {\n    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));\n    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));\n    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();\n    const uint32_t temp_pllckselr = RCC->PLLCKSELR;\n    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))\n    {\n      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))\n      {\n        return HAL_ERROR;\n      }\n      else\n      {\n        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\n        {\n          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\n      }\n    }\n    else\n    {\n      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)\n      {\n        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\n      }\n      else\n      {\n        __HAL_RCC_HSI_DISABLE();\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)\n  {\n    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));\n    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));\n    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();\n    const uint32_t temp_pllckselr = RCC->PLLCKSELR;\n    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))\n    {\n      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))\n      {\n        return HAL_ERROR;\n      }\n      else\n      {\n        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);\n      }\n    }\n    else\n    {\n      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)\n      {\n        __HAL_RCC_CSI_ENABLE();\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);\n      }\n      else\n      {\n        __HAL_RCC_CSI_DISABLE();\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)\n  {\n    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));\n    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)\n    {\n      __HAL_RCC_LSI_ENABLE();\n      tickstart = HAL_GetTick();\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)\n      {\n        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else\n    {\n      __HAL_RCC_LSI_DISABLE();\n      tickstart = HAL_GetTick();\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)\n      {\n        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)\n  {\n    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));\n    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)\n    {\n      __HAL_RCC_HSI48_ENABLE();\n      tickstart = HAL_GetTick();\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)\n      {\n        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else\n    {\n      __HAL_RCC_HSI48_DISABLE();\n      tickstart = HAL_GetTick();\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)\n      {\n        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)\n  {\n    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));\n    PWR->CR1 |= PWR_CR1_DBP;\n    tickstart = HAL_GetTick();\n    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)\n    {\n      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);\n    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)\n    {\n      tickstart = HAL_GetTick();\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)\n      {\n        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else\n    {\n      tickstart = HAL_GetTick();\n      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)\n      {\n        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));\n  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)\n  {\n    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)\n    {\n      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)\n      {\n        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));\n        assert_param(IS_RCC_PLLRGE_VALUE(RCC_OscInitStruct->PLL.PLLRGE));\n        assert_param(IS_RCC_PLLVCO_VALUE(RCC_OscInitStruct->PLL.PLLVCOSEL));\n        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));\n        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));\n        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));\n        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));\n        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));\n        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));\n        __HAL_RCC_PLL_DISABLE();\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,\n                             RCC_OscInitStruct->PLL.PLLM,\n                             RCC_OscInitStruct->PLL.PLLN,\n                             RCC_OscInitStruct->PLL.PLLP,\n                             RCC_OscInitStruct->PLL.PLLQ,\n                             RCC_OscInitStruct->PLL.PLLR);\n        __HAL_RCC_PLLFRACN_DISABLE();\n        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);\n        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;\n        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;\n        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);\n        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\n        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);\n        __HAL_RCC_PLLFRACN_ENABLE();\n        __HAL_RCC_PLL_ENABLE();\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else\n      {\n        __HAL_RCC_PLL_DISABLE();\n        tickstart = HAL_GetTick();\n        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)\n        {\n          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    else\n    {\n      temp1_pllckcfg = RCC->PLLCKSELR;\n      temp2_pllckcfg = RCC->PLL1DIVR;\n      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\n          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\n          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||\n          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||\n          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||\n          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||\n          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))\n      {\n        return HAL_ERROR;\n      }\n      else\n      {\n        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);\n        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)\n        {\n          assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));\n          __HAL_RCC_PLLFRACN_DISABLE();\n          tickstart = HAL_GetTick();\n          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)\n          {\n          }\n          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);\n          __HAL_RCC_PLLFRACN_ENABLE();\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)\n{\n  HAL_StatusTypeDef halstatus;\n  uint32_t tickstart;\n  uint32_t common_system_clock;\n  if (RCC_ClkInitStruct == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));\n  assert_param(IS_FLASH_LATENCY(FLatency));\n  if (FLatency > __HAL_FLASH_GET_LATENCY())\n  {\n    __HAL_FLASH_SET_LATENCY(FLatency);\n    if (__HAL_FLASH_GET_LATENCY() != FLatency)\n    {\n      return HAL_ERROR;\n    }\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)\n  {\n#if defined (RCC_D1CFGR_D1PPRE)\n    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))\n    {\n      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);\n    }\n#else\n    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))\n    {\n      assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\n  {\n#if defined (RCC_D2CFGR_D2PPRE1)\n    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))\n    {\n      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\n      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\n    }\n#else\n    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))\n    {\n      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\n      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\n  {\n#if defined(RCC_D2CFGR_D2PPRE2)\n    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))\n    {\n      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\n      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\n    }\n#else\n    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))\n    {\n      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\n      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)\n  {\n#if defined(RCC_D3CFGR_D3PPRE)\n    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))\n    {\n      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));\n      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));\n    }\n#else\n    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))\n    {\n      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));\n      MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider));\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\n  {\n#if defined (RCC_D1CFGR_HPRE)\n    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))\n    {\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\n    }\n#else\n    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))\n    {\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)\n  {\n    assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));\n    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));\n#if defined(RCC_D1CFGR_D1CPRE)\n    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);\n#else\n    MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);\n#endif\n    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)\n    {\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)\n      {\n        return HAL_ERROR;\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)\n    {\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)\n      {\n        return HAL_ERROR;\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)\n    {\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)\n      {\n        return HAL_ERROR;\n      }\n    }\n    else\n    {\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\n      {\n        return HAL_ERROR;\n      }\n    }\n    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);\n    tickstart = HAL_GetTick();\n    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))\n    {\n      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\n  {\n#if defined(RCC_D1CFGR_HPRE)\n    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))\n    {\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\n    }\n#else\n    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))\n    {\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\n    }\n#endif\n  }\n  if (FLatency < __HAL_FLASH_GET_LATENCY())\n  {\n    __HAL_FLASH_SET_LATENCY(FLatency);\n    if (__HAL_FLASH_GET_LATENCY() != FLatency)\n    {\n      return HAL_ERROR;\n    }\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)\n  {\n#if defined(RCC_D1CFGR_D1PPRE)\n    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))\n    {\n      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);\n    }\n#else\n    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))\n    {\n      assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\n  {\n#if defined(RCC_D2CFGR_D2PPRE1)\n    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))\n    {\n      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\n      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\n    }\n#else\n    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))\n    {\n      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\n      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\n  {\n#if defined (RCC_D2CFGR_D2PPRE2)\n    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))\n    {\n      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\n      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\n    }\n#else\n    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))\n    {\n      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\n      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\n    }\n#endif\n  }\n  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)\n  {\n#if defined(RCC_D3CFGR_D3PPRE)\n    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))\n    {\n      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));\n      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));\n    }\n#else\n    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))\n    {\n      assert_param(IS_RCC_SRDPCLK1(RCC_ClkInitStruct->APB4CLKDivider));\n      MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider));\n    }\n#endif\n  }\n#if defined(RCC_D1CFGR_D1CPRE)\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);\n#else\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);\n#endif\n#if defined(RCC_D1CFGR_HPRE)\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\n#else\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\n#endif\n#if defined(DUAL_CORE) && defined(CORE_CM4)\n  SystemCoreClock = SystemD2Clock;\n#else\n  SystemCoreClock = common_system_clock;\n#endif \n#ifndef __rtems__\n  halstatus = HAL_InitTick(uwTickPrio);\n#else \n  halstatus = HAL_OK;\n#endif \n  return halstatus;\n}\nvoid HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)\n{\n  GPIO_InitTypeDef GPIO_InitStruct;\n  assert_param(IS_RCC_MCO(RCC_MCOx));\n  assert_param(IS_RCC_MCODIV(RCC_MCODiv));\n  if (RCC_MCOx == RCC_MCO1)\n  {\n    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));\n    MCO1_CLK_ENABLE();\n    GPIO_InitStruct.Pin = MCO1_PIN;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\n    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));\n  }\n  else\n  {\n    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));\n    MCO2_CLK_ENABLE();\n    GPIO_InitStruct.Pin = MCO2_PIN;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\n    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));\n  }\n}\nvoid HAL_RCC_EnableCSS(void)\n{\n  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;\n}\nvoid HAL_RCC_DisableCSS(void)\n{\n  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);\n}\nuint32_t HAL_RCC_GetSysClockFreq(void)\n{\n  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue;\n  float_t fracn1, pllvco;\n  uint32_t sysclockfreq;\n  switch (RCC->CFGR & RCC_CFGR_SWS)\n  {\n    case RCC_CFGR_SWS_HSI:  \n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\n      {\n        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));\n      }\n      else\n      {\n        sysclockfreq = (uint32_t) HSI_VALUE;\n      }\n      break;\n    case RCC_CFGR_SWS_CSI:  \n      sysclockfreq = CSI_VALUE;\n      break;\n    case RCC_CFGR_SWS_HSE:  \n      sysclockfreq = HSE_VALUE;\n      break;\n    case RCC_CFGR_SWS_PLL1:  \n      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\n      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;\n      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);\n      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));\n      if (pllm != 0U)\n      {\n        switch (pllsource)\n        {\n          case RCC_PLLSOURCE_HSI:  \n            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\n            {\n              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));\n              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);\n            }\n            else\n            {\n              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);\n            }\n            break;\n          case RCC_PLLSOURCE_CSI:  \n            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);\n            break;\n          case RCC_PLLSOURCE_HSE:  \n            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);\n            break;\n          default:\n            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);\n            break;\n        }\n        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;\n        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);\n      }\n      else\n      {\n        sysclockfreq = 0U;\n      }\n      break;\n    default:\n      sysclockfreq = CSI_VALUE;\n      break;\n  }\n  return sysclockfreq;\n}\nuint32_t HAL_RCC_GetHCLKFreq(void)\n{\n  uint32_t common_system_clock;\n#if defined(RCC_D1CFGR_D1CPRE)\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);\n#else\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);\n#endif\n#if defined(RCC_D1CFGR_HPRE)\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\n#else\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\n#endif\n#if defined(DUAL_CORE) && defined(CORE_CM4)\n  SystemCoreClock = SystemD2Clock;\n#else\n  SystemCoreClock = common_system_clock;\n#endif \n  return SystemD2Clock;\n}\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n{\n#if defined (RCC_D2CFGR_D2PPRE1)\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));\n#else\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));\n#endif\n}\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n{\n#if defined(RCC_D2CFGR_D2PPRE2)\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));\n#else\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));\n#endif\n}\nvoid HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\n{\n  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \\\n                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSI48;\n#if defined(RCC_CR_HSEEXT)\n  if ((RCC->CR & (RCC_CR_HSEBYP | RCC_CR_HSEEXT)) == RCC_CR_HSEBYP)\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\n  }\n  else if ((RCC->CR & (RCC_CR_HSEBYP | RCC_CR_HSEEXT)) == (RCC_CR_HSEBYP | RCC_CR_HSEEXT))\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS_DIGITAL;\n  }\n  else if ((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\n  }\n#else\n  if ((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\n  }\n  else if ((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\n  }\n#endif \n  if ((RCC->CR & RCC_CR_CSION) == RCC_CR_CSION)\n  {\n    RCC_OscInitStruct->CSIState = RCC_CSI_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;\n  }\n#if defined(RCC_VER_X)\n  if (HAL_GetREVID() <= REV_ID_Y)\n  {\n    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);\n  }\n  else\n  {\n    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);\n  }\n#else\n  RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);\n#endif \n  if ((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)\n  {\n    RCC_OscInitStruct->HSIState = RCC_HSI_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\n  }\n#if defined(RCC_VER_X)\n  if (HAL_GetREVID() <= REV_ID_Y)\n  {\n    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);\n  }\n  else\n  {\n    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);\n  }\n#else\n  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);\n#endif \n#if defined(RCC_BDCR_LSEEXT)\n  if ((RCC->BDCR & (RCC_BDCR_LSEBYP | RCC_BDCR_LSEEXT)) == RCC_BDCR_LSEBYP)\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\n  }\n  else if ((RCC->BDCR & (RCC_BDCR_LSEBYP | RCC_BDCR_LSEEXT)) == (RCC_BDCR_LSEBYP | RCC_BDCR_LSEEXT))\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_DIGITAL;\n  }\n  else if ((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\n  }\n#else\n  if ((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\n  }\n  else if ((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\n  }\n#endif \n  if ((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)\n  {\n    RCC_OscInitStruct->LSIState = RCC_LSI_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\n  }\n  if ((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)\n  {\n    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;\n  }\n  if ((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)\n  {\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\n  }\n  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\n  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos);\n  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos) + 1U;\n  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) + 1U;\n  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) + 1U;\n  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) + 1U;\n  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));\n  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);\n  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));\n}\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)\n{\n  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |\n                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;\n  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);\n#if defined(RCC_D1CFGR_D1CPRE)\n  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);\n  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);\n  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);\n  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);\n  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);\n  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);\n#else\n  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE);\n  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE);\n  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE);\n  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1);\n  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2);\n  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);\n#endif\n  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);\n}\nvoid HAL_RCC_NMI_IRQHandler(void)\n{\n  if (__HAL_RCC_GET_IT(RCC_IT_CSS))\n  {\n    HAL_RCC_CSSCallback();\n    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);\n  }\n}\n__weak void HAL_RCC_CSSCallback(void)\n{\n}\n#endif '"
"'Prompt: You are tasked with writing a function in C that destroys a pthread condition attribute object. The function should take a pointer to a pthread_condattr_t object as an argument and should return an integer value indicating the success or failure of the operation. In the case of success, the function should free the memory allocated to the attribute object and set the pointer to NULL. If the pointer is null or points to a null object, the function should return an error code indicating an invalid argument.",//...\nint\npthread_condattr_destroy (pthread_condattr_t * attr)\n{\n  int result = 0;\n  if (attr == NULL || *attr == NULL)\n    {\n      result = EINVAL;\n    }\n  else\n    {\n      (void) free (*attr);\n      *attr = NULL;\n      result = 0;\n    }\n  return result;\n}\n//...'
"'""Can you provide a code snippet for a C function that retrieves the value of the `pshared` attribute from a given pthread condition attribute object? The function should return 0 if successful and set the `pshared` value accordingly, otherwise return the error code EINVAL.""","//...\nint\npthread_condattr_getpshared (const pthread_condattr_t * attr, int *pshared)\n{\n  int result;\n  if ((attr != NULL && *attr != NULL) && (pshared != NULL))\n    {\n      *pshared = (*attr)->pshared;\n      result = 0;\n    }\n  else\n    {\n      result = EINVAL;\n    }\n  return result;\n}\n//...'"
('Prompt: Can you provide me with a sample function that can be used to perform an automated test to check for null input validation? Assume that this function should trigger a pass if the input is null.,"//...\nvoid autotest_null()\n{\n    AUTOTEST_PASS();\n}\n//...')
"
"('Prompt: You are testing a digital signal processing library that implements Butterworth lowpass filter design. The library has a function `testbench_iirdes_butter_lowpass` that takes in three parameters: number of filter coefficients `_n`, cutoff frequency `_fc`, and sampling frequency `_fs`. The function creates an IIR filter prototype using the specified parameters and checks the filter response. Write a test case function `autotest_iirdes_butter_lowpass_4` that calls `testbench_iirdes_butter_lowpass` with `_n=15`, `_fc=0.35f`, and `_fs=0.41f` for validation. The test should check the filter response within specified tolerance ranges and log the results if verbose mode is enabled.","//...\nvoid testbench_iirdes_butter_lowpass(unsigned int _n,  \n                                     float        _fc, \n                                     float        _fs) \n{\n    float        tol  = 1e-3f;  \n    unsigned int nfft = 800;    \n    iirfilt_crcf q = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_BUTTER, LIQUID_IIRDES_LOWPASS, LIQUID_IIRDES_SOS,\n        _n,_fc,0.0f,1,60);\n    if (liquid_autotest_verbose)\n        iirfilt_crcf_print(q);\n    float H0 = 0.0f, H1 = -3, H2 = -60.0f;\n    unsigned int i;\n    float H[nfft]; \n    for (i=0; i<nfft; i++)\n        H[i] = iirfilt_crcf_get_psd(q, (float)i/(float)nfft-0.5f);\n    autotest_psd_s regions[] = {\n      {.fmin=0.0f, .fmax=0.98*_fc, .pmin=H1-tol, .pmax=H0+tol, .test_lo=1, .test_hi=1},\n      {.fmin=_fs,  .fmax=+0.5f,    .pmin=0,      .pmax=H2+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(H, nfft, regions, 2,\n        liquid_autotest_verbose ? ""autotest/logs/iirdes_butter_lowpass.m"" : NULL);\n    iirfilt_crcf_destroy(q);\n}\nvoid autotest_iirdes_butter_lowpass_4(){ testbench_iirdes_butter_lowpass(15,0.35f,0.41f); }\n//...')
"
"('Prompt: Implement a test bench function that performs equalization using the least mean squares (LMS) algorithm in a communication system. The function should take parameters for filter lengths, interpolation factor, beta value, initial equalizer type, number of symbols, update type, and modulation scheme. The function should perform equalization on a received symbol stream and calculate the root mean square error (RMSE) of the equalized symbols compared to the original symbols. Use appropriate filter coefficients and modulation settings.","//...\nvoid testbench_eqlms(unsigned int k, unsigned int m, float beta, int init,\n                     unsigned int p, float mu, unsigned int num_symbols,\n                     int update, int ms)\n{\n    unsigned int   i;\n    modemcf        mod    = modemcf_create(ms);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,k,m,beta,0);\n    float complex h[5] = {\n         1.00f +  0.00f*_Complex_I,\n         0.00f + -0.01f*_Complex_I,\n        -0.11f +  0.02f*_Complex_I,\n         0.02f +  0.01f*_Complex_I,\n        -0.09f + -0.04f*_Complex_I };\n    firfilt_cccf fchannel = firfilt_cccf_create(h,5);\n    float complex hp[2*k*p+1];\n    for (i=0; i<2*k*p+1; i++)\n        hp[i] = sincf( (float)i/(float)k - p) * liquid_hamming(i,2*k*p+1) / k;\n    eqlms_cccf eq;\n    switch (init) {\n    case 0: eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER,k,p,beta,0); break;\n    case 1: eq = eqlms_cccf_create_lowpass (2*k*p+1, 0.5f/(float)k); break;\n    case 2: eq = eqlms_cccf_create         (hp, 2*k*p+1); break; \n    default:eq = eqlms_cccf_create         (NULL, 2*k*p+1); break; \n    }\n    eqlms_cccf_set_bw(eq, mu);\n    float complex buf[k];                   \n    float complex sym_in, sym_out;          \n    wdelaycf buf_sym = wdelaycf_create(m+p);\n    float rmse = 0.0f; \n    for (i=0; i<2*num_symbols; i++) {\n        unsigned int sym = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod, sym, &sym_in);\n        wdelaycf_push(buf_sym, sym_in);\n        firinterp_crcf_execute(interp, sym_in, buf);\n        firfilt_cccf_execute_block(fchannel, buf, k, buf);\n        eqlms_cccf_decim_execute(eq, buf, &sym_out, k);\n        if (i < m + p) continue;\n        wdelaycf_read(buf_sym, &sym_in);\n        if (i < num_symbols) {\n            float complex d_hat;\n            unsigned int  index;\n            switch (update) {\n            case 0: eqlms_cccf_step(eq, sym_in, sym_out); break; \n            case 1: eqlms_cccf_step_blind(eq, sym_out);   break; \n            case 2:\n                modemcf_demodulate(mod, sym_out, &index);\n                modemcf_get_demodulator_sample(mod, &d_hat);\n                eqlms_cccf_step(eq, d_hat, sym_out);\n                break;\n            default:;\n            }\n            continue;\n        }\n        float error = cabsf(sym_in-sym_out);\n        rmse += error * error;\n#if 0\n        if (liquid_autotest_verbose) {\n            printf(""%3u : x = {%12.8f,%12.8f}, y = {%12.8f,%12.8f}, error=%12.8f %s\\n"",\n                    i, crealf(sym_in ), cimagf(sym_in ), crealf(sym_out), cimagf(sym_out),\n                    error, error > tol ? ""*"" : """");\n        }\n#endif\n    }\n    rmse = 10*log10f( rmse/num_symbols );\n    printf(""rmse : %.3f dB\\n"", rmse);\n    CONTEND_LESS_THAN(rmse, -20.0f);\n    wdelaycf_destroy(buf_sym);\n    firfilt_cccf_destroy(fchannel);\n    firinterp_crcf_destroy(interp);\n    eqlms_cccf_destroy(eq);\n    modemcf_destroy(mod);\n}\nvoid autotest_eqlms_03() { testbench_eqlms(2,7, 0.3,   0,7,0.3,800,     0,LIQUID_MODEM_QAM16); }\n//...')
"
"('Please provide a detailed technical scenario in which you need to implement a function that computes interpolation using a Lagrange barycentric algorithm for a specific FIR filter design. Additionally, explain that you expect the function to perform the necessary calculations for interpolation and error handling as specified in the given code snippet.","//...\n#define LIQUID_FIRDESPM_DEBUG       0\n    for (i=0; i<_q->grid_size; i++) {\n        fprintf(fid,""F(%4u) = %16.8e;\\n"", i+1, _q->F[i]);\n    for (i=0; i<_q->r+1; i++) {\n        fprintf(fid,""iext(%4u) = %u;\\n"", i+1, _q->iext[i]+1);\n    fprintf(fid,""grid on;\\n"");\n        double f = (double) i / (double)(2*(n-1));\n        double x = cos(2*M_PI*f);\n        double c = poly_val_lagrange_barycentric(_q->x,_q->c,_q->alpha,x,_q->r+1);\n    fprintf(fid,""rho = %20.12e;\\n"", _q->rho);\n    float des[2]     = {1.0f, 0.0f};\n    for (i=0; i<_q->grid_size; i++) {\nint firdespm_compute_interp(firdespm _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->r+1; i++) {\n        _q->x[i] = cos(2*M_PI*_q->F[_q->iext[i]]);\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n        printf(""x[%3u] = %12.8f\\n"", i, _q->x[i]);\n#endif\n    }\n    poly_fit_lagrange_barycentric(_q->x,_q->r+1,_q->alpha);\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n    for (i=0; i<_q->r+1; i++)\n        printf(""a[%3u] = %12.8f\\n"", i, _q->alpha[i]);\n#endif\n    double t0 = 0.0;    \n    double t1 = 0.0;    \n    for (i=0; i<_q->r+1; i++) {\n        t0 += _q->alpha[i] * _q->D[_q->iext[i]];\n        t1 += _q->alpha[i] / _q->W[_q->iext[i]] * (i % 2 ? -1.0 : 1.0);\n    }\n    _q->rho = t0/t1;\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n    printf(""  rho   :   %12.4e\\n"", _q->rho);\n    printf(""\\n"");\n#endif\n    for (i=0; i<_q->r+1; i++) {\n        _q->c[i] = _q->D[_q->iext[i]] - (i % 2 ? -1 : 1) * _q->rho / _q->W[_q->iext[i]];\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n        printf(""c[%3u] = %16.8e\\n"", i, _q->c[i]);\n#endif\n    }\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: Can you provide a code example for creating a custom style in LittlevGL with a gradient background?. . In this scenario, you are looking to create a custom style with a gradient background in LittlevGL. The code should initialize a static style object, set its radius and background opacity properties, define a gradient description structure with vertical direction and two color stops, set the colors and opacities for each stop, specify the positions of the stops, apply the gradient to the background of the style, create a new object on the active screen, assign the custom style to the new object, and center the object on the screen.","#if LV_BUILD_EXAMPLES\nvoid lv_example_style_2(void)\n{\n    static lv_style_t style;\n    lv_style_init(&style);\n    lv_style_set_radius(&style, 5);\n    lv_style_set_bg_opa(&style, LV_OPA_COVER);\n    static lv_grad_dsc_t grad;\n    grad.dir = LV_GRAD_DIR_VER;\n    grad.stops_count = 2;\n    grad.stops[0].color = lv_palette_lighten(LV_PALETTE_GREY, 1);\n    grad.stops[0].opa = LV_OPA_COVER;\n    grad.stops[1].color = lv_palette_main(LV_PALETTE_BLUE);\n    grad.stops[1].opa = LV_OPA_COVER;\n    grad.stops[0].frac  = 128;\n    grad.stops[1].frac  = 192;\n    lv_style_set_bg_grad(&style, &grad);\n    lv_obj_t * obj = lv_obj_create(lv_screen_active());\n    lv_obj_add_style(obj, &style, 0);\n    lv_obj_center(obj);\n}\n#endif'"
"('Prompt: You are working on a digital communication system and need a function to calculate the number of pilots needed based on the payload length and pilot spacing. The function should take two parameters: `_payload_len` which represents the length of the payload in bits, and `_pilot_spacing` which represents the spacing between pilots in bits. If the payload length is 0 or the pilot spacing is less than 2, no pilots are needed. Define a function in C that calculates the number of pilots required and returns it as an unsigned integer. Use the `div` function to perform the required division and handle any remainder appropriately.","//...\nunsigned int qpilot_num_pilots(unsigned int _payload_len,\n                               unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0 || _pilot_spacing < 2)\n        return 0;\n    div_t d = div(_payload_len,(_pilot_spacing - 1));\n    return d.quot + (d.rem ? 1 : 0);\n}\n//...')
"
"('Create a C program that generates a scatterplot for an interleaver example. The program should allow options to specify the number of bytes and interleaver depth. The program will generate data points and plot them in a scatterplot using MATLAB format. . . The program should output the results to a file named ""interleaver_scatterplot_example.m"". The usage of the program should be as follows:. ```. interleaver_scatterplot_example [options].   u/h   : print usage.   n     : number of bytes, default: 8.   d     : interleaver depth, default: 4. ```","#define OUTPUT_FILENAME ""interleaver_scatterplot_example.m""\nvoid usage()\n{\n    printf(""interleaver_scatterplot_example [options]\\n"");\n    printf(""  u/h   : print usage\\n"");\n    printf(""  n     : number of bytes, default: 8\\n"");\n    printf(""  d     : interleaver depth, default: 4\\n"");\n}\nunsigned int interleaver_find_bit(unsigned char * _x,\n                                  unsigned int _n);\nint main(int argc, char*argv[]) {\n    unsigned int n=8; \n    unsigned int depth = 4;\n    int dopt;\n    while ((dopt = getopt(argc,argv,""uhn:d:"")) != EOF) {\n        switch (dopt) {\n        case \'u\':\n        case \'h\': usage();              return 0;\n        case \'n\': n = atoi(optarg);     break;\n        case \'d\': depth = atoi(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    interleaver q = interleaver_create(n);\n    interleaver_set_depth(q, depth);\n    unsigned char x[n]; \n    unsigned char y[n]; \n    unsigned int index[8*n];\n    unsigned int i;\n    unsigned int j;\n    unsigned int k=0;\n    memset(x, 0, n*sizeof(unsigned char));\n    for (i=0; i<n; i++) {\n        for (j=0; j<8; j++) {\n            x[i] = 1 << (8-j-1);\n            interleaver_encode(q,x,y);\n            index[k] = interleaver_find_bit(y,n);\n            k++;\n        }\n        x[i] = 0;\n    }\n    assert(k==8*n);\n    interleaver_destroy(q);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    if (fid == NULL) {\n        fprintf(stderr,""error: %s, could not open file \'%s\' for writing.\\n"", argv[0],OUTPUT_FILENAME);\n        exit(1);\n    }\n    fprintf(fid,""%% %s : auto-generated file (do not edit)\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""%% invoked as :"");\n    for (i=0; i<argc; i++)\n        fprintf(fid,"" %s"",argv[i]);\n    fprintf(fid,""\\n"");\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""n = %u;\\n"", 8*n);\n    for (i=0; i<8*n; i++)\n        fprintf(fid,""index(%6u) = %6u;\\n"", i+1, index[i]);\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""i = [0:(n-1)];\\n"");\n    fprintf(fid,""plot(i/n,index/n,\'x\');\\n"");\n    fprintf(fid,""axis square\\n"");\n    fprintf(fid,""axis([0 1 0 1]);\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}\nunsigned int interleaver_find_bit(unsigned char * _x,\n                                  unsigned int _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        if (_x[i] != 0)\n            break;\n    }\n    unsigned char byte = _x[i];\n    switch (byte) {\n    case (1<<7):    return 8*i + 0;     \n    case (1<<6):    return 8*i + 1;     \n    case (1<<5):    return 8*i + 2;     \n    case (1<<4):    return 8*i + 3;     \n    case (1<<3):    return 8*i + 4;     \n    case (1<<2):    return 8*i + 5;     \n    case (1<<1):    return 8*i + 6;     \n    case (1<<0):    return 8*i + 7;     \n    default:\n        fprintf(stderr,""error: interleaver_find_bid(), invalid array\\n"");\n        exit(1);\n    }\n}')
"
"('Prompt: . . You are working on a digital communication system and need to create a function that copies the parameters of a Gaussian Minimum Shift Keying (GMSK) modulation object. The GMSK modulation object consists of various parameters such as k, m, BT, h_len, h, interp_tx, theta, and k_inv. Write a C function `gmskmod_copy` that takes a GMSK modulation object as input, checks if the object is not null, creates a deep copy of the object including its dynamically allocated memory for `h`, and returns the copied GMSK modulation object. Ensure to handle the memory allocations properly to avoid memory leaks in the copied object.","//...\nstruct gmskmod_s {\n    unsigned int k;         \n    unsigned int m;         \n    float        BT;        \n    unsigned int h_len;     \n    float *      h;         \n    firinterp_rrrf interp_tx;\n    float theta;            \n    float k_inv;            \n};\ngmskmod gmskmod_copy(gmskmod q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""gmskmod_copy(), object cannot be NULL"");\n    gmskmod q_copy = (gmskmod) malloc(sizeof(struct gmskmod_s));\n    memmove(q_copy, q_orig, sizeof(struct gmskmod_s));\n    q_copy->h = (float *) liquid_malloc_copy(q_orig->h, q_orig->h_len, sizeof(float));\n    q_copy->interp_tx = firinterp_rrrf_copy(q_orig->interp_tx);\n    return q_copy;\n}\n//...')
"
"(""Prompt: Suppose you are working on a software project that involves signal processing and modulation schemes. You need to create a function that displays usage instructions for a specific module called 'modem_demodulate_arb_gentab'. The function should print out the options available for the user, including the default settings for modulation schemes. The prompt requires you to include an option to print out the available modulation schemes using a function called 'liquid_print_modulation_schemes'. . Create a function in C that fulfills these requirements and prints out the usage instructions as shown in the given code snippet.","//...\nvoid usage()\n{\n    printf(""sandbox/modem_demodulate_arb_gentab [options]\\n"");\n    printf(""  u/h   : print usage\\n"");\n    printf(""  m     : input modulation scheme (arb64vt default)\\n"");\n    printf(""  r     : reference modulation scheme (qam16 default)\\n"");\n    liquid_print_modulation_schemes();\n    printf(""  a     : alpha (reference scheme gain), default: 1.0\\n"");\n}\n//...')
"
"('You are working on optimizing a code for calculating the dot product between two vectors of complex floating-point values using SIMD instructions. You need to implement functions for creating, destroying, and recreating instances of the dot product object. . . Prompt: ""I need a set of functions for creating, destroying, and recreating instances of a dot product object that calculates the dot product between two vectors of complex floating-point values. Can you write the code for the creation, destruction, and recreation of the dot product object based on the given structure and operations?""","//...\ndotprod_cccf dotprod_cccf_create(float complex * _h,\n                                 unsigned int    _n)\n{\n    return dotprod_cccf_create_opt(_h, _n, 0);\n}\ndotprod_cccf dotprod_cccf_create_opt(float complex * _h,\n                                     unsigned int    _n,\n                                     int             _rev)\n{\n    dotprod_cccf q = (dotprod_cccf)malloc(sizeof(struct dotprod_cccf_s));\n    q->n = _n;\n    q->hi = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );\n    q->hq = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );\n    unsigned int i;\n    for (i=0; i<q->n; i++) {\n        unsigned int k = _rev ? q->n-i-1 : i;\n        q->hi[2*i+0] = crealf(_h[k]);\n        q->hi[2*i+1] = crealf(_h[k]);\n        q->hq[2*i+0] = cimagf(_h[k]);\n        q->hq[2*i+1] = cimagf(_h[k]);\n    }\n    return q;\n}\nint dotprod_cccf_destroy(dotprod_cccf _q)\n{\n    _mm_free(_q->hi);\n    _mm_free(_q->hq);\n    free(_q);\n    return LIQUID_OK;\n}\ndotprod_cccf dotprod_cccf_recreate(dotprod_cccf    _q,\n                                   float complex * _h,\n                                   unsigned int    _n)\n{\n    dotprod_cccf_destroy(_q);\n    return dotprod_cccf_create(_h,_n);\n}\n//...')
"
"'Please provide code for initializing and using the encoder driver for a microcontroller system with features such as home trigger mode, reverse direction, watchdog, position compare, and interrupt enable/disable. Include functions for initializing, deinitializing, enabling watchdog, setting initial position value, getting position values, and clearing status flags.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.enc""\n#endif\n#define ENC_CTRL_W1C_FLAGS (ENC_CTRL_HIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_CMPIRQ_MASK)\n#if (defined(FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT) && FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT)\n#define ENC_CTRL2_W1C_FLAGS (ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_RUIRQ_MASK)\n#else\n#define ENC_CTRL2_W1C_FLAGS (ENC_CTRL2_SABIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_RUIRQ_MASK)\n#endif\nstatic uint32_t ENC_GetInstance(ENC_Type *base);\nstatic ENC_Type *const s_encBases[] = ENC_BASE_PTRS;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_encClocks[] = ENC_CLOCKS;\n#endif \nstatic uint32_t ENC_GetInstance(ENC_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_encBases); instance++)\n    {\n        if (s_encBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_encBases));\n    return instance;\n}\nvoid ENC_Init(ENC_Type *base, const enc_config_t *config)\n{\n    assert(NULL != config);\n    uint16_t tmp16;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(s_encClocks[ENC_GetInstance(base)]);\n#endif \n    tmp16 = base->CTRL & (uint16_t)(~(ENC_CTRL_W1C_FLAGS | ENC_CTRL_HIP_MASK | ENC_CTRL_HNE_MASK | ENC_CTRL_REV_MASK |\n                                      ENC_CTRL_PH1_MASK | ENC_CTRL_XIP_MASK | ENC_CTRL_XNE_MASK | ENC_CTRL_WDE_MASK));\n    if (kENC_HOMETriggerDisabled != config->HOMETriggerMode)\n    {\n        tmp16 |= ENC_CTRL_HIP_MASK;\n        if (kENC_HOMETriggerOnFallingEdge == config->HOMETriggerMode)\n        {\n            tmp16 |= ENC_CTRL_HNE_MASK;\n        }\n    }\n    if (config->enableReverseDirection)\n    {\n        tmp16 |= ENC_CTRL_REV_MASK;\n    }\n    if (kENC_DecoderWorkAsSignalPhaseCountMode == config->decoderWorkMode)\n    {\n        tmp16 |= ENC_CTRL_PH1_MASK;\n    }\n    if (kENC_INDEXTriggerDisabled != config->INDEXTriggerMode)\n    {\n        tmp16 |= ENC_CTRL_XIP_MASK;\n        if (kENC_INDEXTriggerOnFallingEdge == config->INDEXTriggerMode)\n        {\n            tmp16 |= ENC_CTRL_XNE_MASK;\n        }\n    }\n    if (config->enableWatchdog)\n    {\n        tmp16 |= ENC_CTRL_WDE_MASK;\n        base->WTR = config->watchdogTimeoutValue; \n    }\n    base->CTRL = tmp16;\n    base->FILT = ENC_FILT_FILT_CNT(config->filterCount) | ENC_FILT_FILT_PER(config->filterSamplePeriod);\n    tmp16 = base->CTRL2 & (uint16_t)(~(ENC_CTRL2_W1C_FLAGS | ENC_CTRL2_OUTCTL_MASK | ENC_CTRL2_REVMOD_MASK |\n                                       ENC_CTRL2_MOD_MASK | ENC_CTRL2_UPDPOS_MASK | ENC_CTRL2_UPDHLD_MASK));\n    if (kENC_POSMATCHOnReadingAnyPositionCounter == config->positionMatchMode)\n    {\n        tmp16 |= ENC_CTRL2_OUTCTL_MASK;\n    }\n    if (kENC_RevolutionCountOnRollOverModulus == config->revolutionCountCondition)\n    {\n        tmp16 |= ENC_CTRL2_REVMOD_MASK;\n    }\n    if (config->enableModuloCountMode)\n    {\n        tmp16 |= ENC_CTRL2_MOD_MASK;\n        base->UMOD = (uint16_t)(config->positionModulusValue >> 16U); \n        base->LMOD = (uint16_t)(config->positionModulusValue);        \n    }\n    if (config->enableTRIGGERClearPositionCounter)\n    {\n        tmp16 |= ENC_CTRL2_UPDPOS_MASK;\n    }\n    if (config->enableTRIGGERClearHoldPositionCounter)\n    {\n        tmp16 |= ENC_CTRL2_UPDHLD_MASK;\n    }\n    base->CTRL2 = tmp16;\n#if (defined(FSL_FEATURE_ENC_HAS_CTRL3) && FSL_FEATURE_ENC_HAS_CTRL3)\n    tmp16 = base->CTRL3 & (uint16_t)(~(ENC_CTRL3_PMEN_MASK | ENC_CTRL3_PRSC_MASK));\n    if (config->enablePeriodMeasurementFunction)\n    {\n        tmp16 |= ENC_CTRL3_PMEN_MASK;\n        tmp16 |= ((uint16_t)config->prescalerValue << ENC_CTRL3_PRSC_SHIFT);\n    }\n    base->CTRL3 = tmp16;\n#endif\n    base->UCOMP = (uint16_t)(config->positionCompareValue >> 16U); \n    base->LCOMP = (uint16_t)(config->positionCompareValue);        \n    base->UINIT = (uint16_t)(config->positionInitialValue >> 16U); \n    base->LINIT = (uint16_t)(config->positionInitialValue);        \n}\nvoid ENC_Deinit(ENC_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_DisableClock(s_encClocks[ENC_GetInstance(base)]);\n#endif \n}\nvoid ENC_GetDefaultConfig(enc_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n    config->enableReverseDirection                = false;\n    config->decoderWorkMode                       = kENC_DecoderWorkAsNormalMode;\n    config->HOMETriggerMode                       = kENC_HOMETriggerDisabled;\n    config->INDEXTriggerMode                      = kENC_INDEXTriggerDisabled;\n    config->enableTRIGGERClearPositionCounter     = false;\n    config->enableTRIGGERClearHoldPositionCounter = false;\n    config->enableWatchdog                        = false;\n    config->watchdogTimeoutValue                  = 0U;\n    config->filterCount                           = 0U;\n    config->filterSamplePeriod                    = 0U;\n    config->positionMatchMode                     = kENC_POSMATCHOnPositionCounterEqualToComapreValue;\n    config->positionCompareValue                  = 0xFFFFFFFFU;\n    config->revolutionCountCondition              = kENC_RevolutionCountOnINDEXPulse;\n    config->enableModuloCountMode                 = false;\n    config->positionModulusValue                  = 0U;\n    config->positionInitialValue                  = 0U;\n#if (defined(FSL_FEATURE_ENC_HAS_CTRL3) && FSL_FEATURE_ENC_HAS_CTRL3)\n    config->prescalerValue                  = kENC_ClockDiv1;\n    config->enablePeriodMeasurementFunction = true;\n#endif\n}\nvoid ENC_DoSoftwareLoadInitialPositionValue(ENC_Type *base)\n{\n    uint16_t tmp16 = base->CTRL & (uint16_t)(~ENC_CTRL_W1C_FLAGS);\n    tmp16 |= ENC_CTRL_SWIP_MASK; \n    base->CTRL = tmp16;\n}\nvoid ENC_SetSelfTestConfig(ENC_Type *base, const enc_self_test_config_t *config)\n{\n    uint16_t tmp16 = 0U;\n    if (NULL == config) \n    {\n        tmp16 = 0U;\n    }\n    else\n    {\n        tmp16 = ENC_TST_TEN_MASK | ENC_TST_TCE_MASK | ENC_TST_TEST_PERIOD(config->signalPeriod) |\n                ENC_TST_TEST_COUNT(config->signalCount);\n        if (kENC_SelfTestDirectionNegative == config->signalDirection)\n        {\n            tmp16 |= ENC_TST_QDN_MASK;\n        }\n    }\n    base->TST = tmp16;\n}\nvoid ENC_EnableWatchdog(ENC_Type *base, bool enable)\n{\n    uint16_t tmp16 = base->CTRL & (uint16_t)(~(ENC_CTRL_W1C_FLAGS | ENC_CTRL_WDE_MASK));\n    if (enable)\n    {\n        tmp16 |= ENC_CTRL_WDE_MASK;\n    }\n    base->CTRL = tmp16;\n}\nuint32_t ENC_GetStatusFlags(ENC_Type *base)\n{\n    uint32_t ret32 = 0U;\n    if (0U != (ENC_CTRL_HIRQ_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_HOMETransitionFlag;\n    }\n    if (0U != (ENC_CTRL_XIRQ_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_INDEXPulseFlag;\n    }\n    if (0U != (ENC_CTRL_DIRQ_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_WatchdogTimeoutFlag;\n    }\n    if (0U != (ENC_CTRL_CMPIRQ_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_PositionCompareFlag;\n    }\n#if !(defined(FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT) && FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT)\n    if (0U != (ENC_CTRL2_SABIRQ_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_SimultBothPhaseChangeFlag;\n    }\n#endif\n    if (0U != (ENC_CTRL2_ROIRQ_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_PositionRollOverFlag;\n    }\n    if (0U != (ENC_CTRL2_RUIRQ_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_PositionRollUnderFlag;\n    }\n    if (0U != (ENC_CTRL2_DIR_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_LastCountDirectionFlag;\n    }\n    return ret32;\n}\nvoid ENC_ClearStatusFlags(ENC_Type *base, uint32_t mask)\n{\n    uint32_t tmp16 = 0U;\n    if (0U != ((uint32_t)kENC_HOMETransitionFlag & mask))\n    {\n        tmp16 |= ENC_CTRL_HIRQ_MASK;\n    }\n    if (0U != ((uint32_t)kENC_INDEXPulseFlag & mask))\n    {\n        tmp16 |= ENC_CTRL_XIRQ_MASK;\n    }\n    if (0U != ((uint32_t)kENC_WatchdogTimeoutFlag & mask))\n    {\n        tmp16 |= ENC_CTRL_DIRQ_MASK;\n    }\n    if (0U != ((uint32_t)kENC_PositionCompareFlag & mask))\n    {\n        tmp16 |= ENC_CTRL_CMPIRQ_MASK;\n    }\n    if (0U != tmp16)\n    {\n        base->CTRL = (uint16_t)(((uint32_t)base->CTRL & (~ENC_CTRL_W1C_FLAGS)) | tmp16);\n    }\n    tmp16 = 0U;\n#if !(defined(FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT) && FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT)\n    if (0U != ((uint32_t)kENC_SimultBothPhaseChangeFlag & mask))\n    {\n        tmp16 |= ENC_CTRL2_SABIRQ_MASK;\n    }\n#endif\n    if (0U != ((uint32_t)kENC_PositionRollOverFlag & mask))\n    {\n        tmp16 |= ENC_CTRL2_ROIRQ_MASK;\n    }\n    if (0U != ((uint32_t)kENC_PositionRollUnderFlag & mask))\n    {\n        tmp16 |= ENC_CTRL2_RUIRQ_MASK;\n    }\n    if (0U != tmp16)\n    {\n        base->CTRL2 = (uint16_t)(((uint32_t)base->CTRL2 & (~ENC_CTRL2_W1C_FLAGS)) | tmp16);\n    }\n}\nvoid ENC_EnableInterrupts(ENC_Type *base, uint32_t mask)\n{\n    uint32_t tmp16 = 0U;\n    if (0U != ((uint32_t)kENC_HOMETransitionInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_HIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_INDEXPulseInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_XIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_WatchdogTimeoutInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_DIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_PositionCompareInerruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_CMPIE_MASK;\n    }\n    if (tmp16 != 0U)\n    {\n        base->CTRL = (uint16_t)(((uint32_t)base->CTRL & (~ENC_CTRL_W1C_FLAGS)) | tmp16);\n    }\n    tmp16 = 0U;\n#if !(defined(FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT) && FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT)\n    if (0U != ((uint32_t)kENC_SimultBothPhaseChangeInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL2_SABIE_MASK;\n    }\n#endif\n    if (0U != ((uint32_t)kENC_PositionRollOverInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL2_ROIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_PositionRollUnderInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL2_RUIE_MASK;\n    }\n    if (tmp16 != 0U)\n    {\n        base->CTRL2 = (uint16_t)(((uint32_t)base->CTRL2 & (~ENC_CTRL2_W1C_FLAGS)) | tmp16);\n    }\n}\nvoid ENC_DisableInterrupts(ENC_Type *base, uint32_t mask)\n{\n    uint16_t tmp16 = 0U;\n    if (0U != ((uint32_t)kENC_HOMETransitionInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_HIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_INDEXPulseInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_XIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_WatchdogTimeoutInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_DIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_PositionCompareInerruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL_CMPIE_MASK;\n    }\n    if (0U != tmp16)\n    {\n        base->CTRL = (uint16_t)(base->CTRL & (uint16_t)(~ENC_CTRL_W1C_FLAGS)) & (uint16_t)(~tmp16);\n    }\n    tmp16 = 0U;\n#if !(defined(FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT) && FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT)\n    if (0U != ((uint32_t)kENC_SimultBothPhaseChangeInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL2_SABIE_MASK;\n    }\n#endif\n    if (0U != ((uint32_t)kENC_PositionRollOverInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL2_ROIE_MASK;\n    }\n    if (0U != ((uint32_t)kENC_PositionRollUnderInterruptEnable & mask))\n    {\n        tmp16 |= ENC_CTRL2_RUIE_MASK;\n    }\n    if (tmp16 != 0U)\n    {\n        base->CTRL2 = (uint16_t)(base->CTRL2 & (uint16_t)(~ENC_CTRL2_W1C_FLAGS)) & (uint16_t)(~tmp16);\n    }\n}\nuint32_t ENC_GetEnabledInterrupts(ENC_Type *base)\n{\n    uint32_t ret32 = 0U;\n    if (0U != (ENC_CTRL_HIE_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_HOMETransitionInterruptEnable;\n    }\n    if (0U != (ENC_CTRL_XIE_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_INDEXPulseInterruptEnable;\n    }\n    if (0U != (ENC_CTRL_DIE_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_WatchdogTimeoutInterruptEnable;\n    }\n    if (0U != (ENC_CTRL_CMPIE_MASK & base->CTRL))\n    {\n        ret32 |= (uint32_t)kENC_PositionCompareInerruptEnable;\n    }\n#if !(defined(FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT) && FSL_FEATURE_ENC_HAS_NO_CTRL2_SAB_INT)\n    if (0U != (ENC_CTRL2_SABIE_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_SimultBothPhaseChangeInterruptEnable;\n    }\n#endif\n    if (0U != (ENC_CTRL2_ROIE_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_PositionRollOverInterruptEnable;\n    }\n    if (0U != (ENC_CTRL2_RUIE_MASK & base->CTRL2))\n    {\n        ret32 |= (uint32_t)kENC_PositionRollUnderInterruptEnable;\n    }\n    return ret32;\n}\nvoid ENC_SetInitialPositionValue(ENC_Type *base, uint32_t value)\n{\n    base->UINIT = (uint16_t)(value >> 16U); \n    base->LINIT = (uint16_t)(value);        \n}\nuint32_t ENC_GetPositionValue(ENC_Type *base)\n{\n    uint32_t ret32;\n    ret32 = base->UPOS; \n    ret32 <<= 16U;\n    ret32 |= base->LPOSH; \n    return ret32;\n}\nuint32_t ENC_GetHoldPositionValue(ENC_Type *base)\n{\n    uint32_t ret32;\n    ret32 = base->UPOSH; \n    ret32 <<= 16U;\n    ret32 |= base->LPOSH; \n    return ret32;\n}'"
"(""Prompt: You are working on a project that involves testing a linear predictive coding (LPC) algorithm. You need to create a test harness function that will evaluate the performance of the LPC algorithm under different parameter settings. Your test harness function should take in the number of samples (_n), the order of the LPC model (_p), the cutoff frequency of a lowpass filter (_fc), and a tolerance value (_tol). The function should generate test signals using a pseudo-random sequence generator, pass these signals through a lowpass filter and then through the LPC algorithm, calculate the root mean square error (RMSE) between the filtered signals, and check if the RMSE is within the specified tolerance. Finally, the function should print the results if the 'liquid_autotest_verbose' flag is set. Additionally, you need to create several auto-test functions that invoke the test harness function with different parameter settings to evaluate the LPC algorithm's performance for various scenarios.","void lpc_test_harness(unsigned int _n,\n                      unsigned int _p,\n                      float        _fc,\n                      float        _tol)\n{\n    iirfilt_rrrf lowpass = iirfilt_rrrf_create_lowpass(7,_fc);\n    float y[_n];         \n    float a_hat[_p+1];   \n    float g_hat[_p+1];   \n    unsigned int i;\n    msequence ms = msequence_create_default(15);\n    for (i=0; i<_n; i++) {\n        float v = (float)msequence_generate_symbol(ms,10)/1023.0f - 0.5f;\n        iirfilt_rrrf_execute(lowpass, v, &y[i]);\n    }\n    liquid_lpc(y,_n,_p,a_hat,g_hat);\n    float a_lpc[_p+1];\n    float b_lpc[_p+1];\n    for (i=0; i<_p+1; i++) {\n        a_lpc[i] = (i==0) ? 1.0f : 0.0f;\n        b_lpc[i] = (i==0) ? 0.0f : -a_hat[i];\n    }\n    iirfilt_rrrf lpc = iirfilt_rrrf_create(b_lpc,_p+1, a_lpc,_p+1);\n    float rmse = 0.0f;\n    unsigned int n_error = 5000;\n    for (i=0; i<n_error; i++) {\n        float v = (float)msequence_generate_symbol(ms,10)/1023.0f - 0.5f;\n        float s0, s1;\n        iirfilt_rrrf_execute(lowpass, v,  &s0); \n        iirfilt_rrrf_execute(lpc,     s0, &s1); \n        rmse += (s0-s1)*(s0-s1);\n    }\n    rmse = 10*log10f( rmse / (float)n_error );\n    if (liquid_autotest_verbose) {\n        printf(""original lowpass filter:\\n"");\n        iirfilt_rrrf_print(lowpass);\n        printf(""linear predictive filter:\\n"");\n        iirfilt_rrrf_print(lpc);\n        printf(""lpc(n=%u,p=%u,fc=%.3f), rmse: %.2f (tol: %.2f) dB\\n"", _n, _p, _fc, rmse, _tol);\n    }\n    CONTEND_LESS_THAN(rmse, _tol);\n    iirfilt_rrrf_destroy(lowpass);\n    iirfilt_rrrf_destroy(lpc);\n    msequence_destroy(ms);\n}\nvoid autotest_lpc_p4()  { lpc_test_harness( 200,  4, 0.020, -40.0f); }\nvoid autotest_lpc_p6()  { lpc_test_harness( 400,  6, 0.028, -40.0f); }\nvoid autotest_lpc_p8()  { lpc_test_harness( 600,  8, 0.035, -40.0f); }\nvoid autotest_lpc_p10() { lpc_test_harness( 800, 10, 0.050, -40.0f); }\nvoid autotest_lpc_p16() { lpc_test_harness(1600, 16, 0.055, -40.0f); }\nvoid autotest_lpc_p32() { lpc_test_harness(3200, 24, 0.065, -40.0f); }')
"
"('Please provide a prompt that describes a scenario where you need to create a Finite Impulse Response Polyphase Filterbank Channelizer (FIRPFBCH2) in a software-defined radio application. The FIRPFBCH2 needs to be capable of analyzing and synthesizing signals with a specified number of channels, filter semi-length, and type (analyzer or synthesizer). Additionally, there is a requirement to handle Kaiser windowing for filter design in certain cases.","struct FIRPFBCH2(_s) {\n    int          type;  \n    unsigned int M;     \n    unsigned int M2;    \n    unsigned int m;     \n    unsigned int h_len; \n    DOTPROD() * dp;     \n    FFT_PLAN ifft;      \n    TO * X;             \n    TO * x;             \n    WINDOW() * w0;      \n    WINDOW() * w1;      \n    int flag;           \n};\nFIRPFBCH2() FIRPFBCH2(_create)(int          _type,\n                               unsigned int _M,\n                               unsigned int _m,\n                               TC *         _h)\n{\n    if (_type != LIQUID_ANALYZER && _type != LIQUID_SYNTHESIZER)\n        return liquid_error_config(""firpfbch2_%s_create(), invalid type %d"", EXTENSION_FULL, _type);\n    if (_M < 2 || _M % 2)\n        return liquid_error_config(""firpfbch2_%s_create(), number of channels must be greater than 2 and even"", EXTENSION_FULL);\n    if (_m < 1)\n        return liquid_error_config(""firpfbch2_%s_create(), filter semi-length must be at least 1"", EXTENSION_FULL);\n    FIRPFBCH2() q = (FIRPFBCH2()) malloc(sizeof(struct FIRPFBCH2(_s)));\n    q->type     = _type;        \n    q->M        = _M;           \n    q->m        = _m;           \n    q->h_len    = 2*q->M*q->m;  \n    q->M2       = q->M / 2;     \n    q->dp = (DOTPROD()*) malloc((q->M)*sizeof(DOTPROD()));\n    unsigned int i;\n    unsigned int n;\n    unsigned int h_sub_len = 2 * q->m;\n    TC h_sub[h_sub_len];\n    for (i=0; i<q->M; i++) {\n        for (n=0; n<h_sub_len; n++)\n            h_sub[h_sub_len-n-1] = _h[i + n*(q->M)];\n        q->dp[i] = DOTPROD(_create)(h_sub,h_sub_len);\n    }\n    q->X = (T*) FFT_MALLOC((q->M)*sizeof(T));   \n    q->x = (T*) FFT_MALLOC((q->M)*sizeof(T));   \n    q->ifft = FFT_CREATE_PLAN(q->M, q->X, q->x, FFT_DIR_BACKWARD, FFT_METHOD);\n    q->w0 = (WINDOW()*) malloc((q->M)*sizeof(WINDOW()));\n    q->w1 = (WINDOW()*) malloc((q->M)*sizeof(WINDOW()));\n    for (i=0; i<q->M; i++) {\n        q->w0[i] = WINDOW(_create)(h_sub_len);\n        q->w1[i] = WINDOW(_create)(h_sub_len);\n    }\n    FIRPFBCH2(_reset)(q);\n    return q;\n}\nFIRPFBCH2() FIRPFBCH2(_create_kaiser)(int          _type,\n                                      unsigned int _M,\n                                      unsigned int _m,\n                                      float        _as)\n{\n    if (_type != LIQUID_ANALYZER && _type != LIQUID_SYNTHESIZER)\n        return liquid_error_config(""firpfbch2_%s_create_kaiser(), invalid type %d"", EXTENSION_FULL, _type);\n    if (_M < 2 || _M % 2)\n        return liquid_error_config(""firpfbch2_%s_create_kaiser(), number of channels must be greater than 2 and even"", EXTENSION_FULL);\n    if (_m < 1)\n        return liquid_error_config(""firpfbch2_%s_create_kaiser(), filter semi-length must be at least 1"", EXTENSION_FULL);\n    unsigned int h_len = 2*_M*_m+1;\n    float * hf = (float*)malloc(h_len*sizeof(float));\n    float fc = (_type == LIQUID_ANALYZER) ? 1.0f/(float)_M : 0.5f/(float)_M;\n    liquid_firdes_kaiser(h_len, fc, _as, 0.0f, hf);\n    float hf_sum = 0.0f;\n    unsigned int i;\n    for (i=0; i<h_len; i++) hf_sum += hf[i];\n    for (i=0; i<h_len; i++) hf[i] = hf[i] * (float)_M / hf_sum;\n    TC * h = (TC*) malloc(h_len * sizeof(TC));\n    for (i=0; i<h_len; i++)\n        h[i] = (TC) hf[i];\n    FIRPFBCH2() q = FIRPFBCH2(_create)(_type, _M, _m, h);\n    free(hf);\n    free(h);\n    return q;\n}\nFIRPFBCH2() FIRPFBCH2(_copy)(FIRPFBCH2() q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""firfilt_%s_copy(), object cannot be NULL"", EXTENSION_FULL);\n    FIRPFBCH2() q_copy = (FIRPFBCH2()) malloc(sizeof(struct FIRPFBCH2(_s)));\n    memmove(q_copy, q_orig, sizeof(struct FIRPFBCH2(_s)));\n    unsigned int i;\n    q_copy->dp = (DOTPROD()*) malloc((q_copy->M)*sizeof(DOTPROD()));\n    for (i=0; i<q_copy->M; i++)\n        q_copy->dp[i] = DOTPROD(_copy)(q_orig->dp[i]);\n    q_copy->X = (T*) FFT_MALLOC((q_copy->M)*sizeof(T));   \n    q_copy->x = (T*) FFT_MALLOC((q_copy->M)*sizeof(T));   \n    q_copy->ifft = FFT_CREATE_PLAN(q_copy->M, q_copy->X, q_copy->x, FFT_DIR_BACKWARD, FFT_METHOD);\n    q_copy->w0 = (WINDOW()*) malloc((q_copy->M)*sizeof(WINDOW()));\n    q_copy->w1 = (WINDOW()*) malloc((q_copy->M)*sizeof(WINDOW()));\n    for (i=0; i<q_copy->M; i++) {\n        q_copy->w0[i] = WINDOW(_copy)(q_orig->w0[i]);\n        q_copy->w1[i] = WINDOW(_copy)(q_orig->w1[i]);\n    }\n    return q_copy;\n}\nint FIRPFBCH2(_destroy)(FIRPFBCH2() _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        DOTPROD(_destroy)(_q->dp[i]);\n    free(_q->dp);\n    FFT_DESTROY_PLAN(_q->ifft);\n    FFT_FREE(_q->X);\n    FFT_FREE(_q->x);\n    for (i=0; i<_q->M; i++) {\n        WINDOW(_destroy)(_q->w0[i]);\n        WINDOW(_destroy)(_q->w1[i]);\n    }\n    free(_q->w0);\n    free(_q->w1);\n    free(_q);\n    return LIQUID_OK;\n}\nint FIRPFBCH2(_reset)(FIRPFBCH2() _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->M; i++) {\n        WINDOW(_reset)(_q->w0[i]);\n        WINDOW(_reset)(_q->w1[i]);\n    }\n    _q->flag = 0;\n    return LIQUID_OK;\n}\nint FIRPFBCH2(_print)(FIRPFBCH2() _q)\n{\n    printf(""firpfbch2_%s:\\n"", EXTENSION_FULL);\n    printf(""    type        :   %s\\n"", _q->type==LIQUID_ANALYZER ? ""analysis"" : ""synthesis"");\n    printf(""    channels    :   %u\\n"", _q->M);\n    printf(""    h_len       :   %u\\n"", _q->h_len);\n    printf(""    semi-length :   %u\\n"", _q->m);\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        DOTPROD(_print)(_q->dp[i]);\n    return LIQUID_OK;\n}\nint FIRPFBCH2(_get_type)(FIRPFBCH2() _q)\n{\n    return _q->type;\n}\nunsigned int FIRPFBCH2(_get_M)(FIRPFBCH2() _q)\n{\n    return _q->M;\n}\nunsigned int FIRPFBCH2(_get_m)(FIRPFBCH2() _q)\n{\n    return _q->m;\n}\nint FIRPFBCH2(_execute_analyzer)(FIRPFBCH2() _q,\n                                 TI *        _x,\n                                 TO *        _y)\n{\n    unsigned int i;\n    unsigned int base_index = _q->flag ? _q->M : _q->M2;\n    for (i=0; i<_q->M2; i++) {\n        WINDOW(_push)(_q->w0[base_index-i-1], _x[i]);\n    }\n    unsigned int offset = _q->flag ? _q->M2 : 0;\n    TI * r;      \n    for (i=0; i<_q->M; i++) {\n        WINDOW(_read)(_q->w0[i], &r);\n        DOTPROD(_execute)(_q->dp[(offset+i)%_q->M], r, &_q->X[i]);\n    }\n    FFT_EXECUTE(_q->ifft);\n    for (i=0; i<_q->M; i++)\n        _y[i] = _q->x[i] / (float)(_q->M);\n    _q->flag = 1 - _q->flag;\n    return LIQUID_OK;\n}\nint FIRPFBCH2(_execute_synthesizer)(FIRPFBCH2() _q,\n                                    TI *        _x,\n                                    TO *        _y)\n{\n    unsigned int i;\n    memmove(_q->X, _x, _q->M * sizeof(TI));\n    FFT_EXECUTE(_q->ifft);\n    for (i=0; i<_q->M; i++)\n        _q->x[i] *= 1.0f / (float)(_q->M);\n    for (i=0; i<_q->M; i++)\n        _q->x[i] *= (float)(_q->M2);\n    WINDOW() * buffer = (_q->flag == 0 ? _q->w1 : _q->w0);\n    for (i=0; i<_q->M; i++)\n        WINDOW(_push)(buffer[i], _q->x[i]);\n    TO * r0, * r1;  \n    TO   y0,   y1;  \n    for (i=0; i<_q->M2; i++) {\n        unsigned int b = (_q->flag == 0) ? i : i+_q->M2;\n        WINDOW(_read)(_q->w0[b], &r0);\n        WINDOW(_read)(_q->w1[b], &r1);\n        TO * p0 = _q->flag ? r0 : r1;\n        TO * p1 = _q->flag ? r1 : r0;\n        DOTPROD(_execute)(_q->dp[i],        p0, &y0);\n        DOTPROD(_execute)(_q->dp[i+_q->M2], p1, &y1);\n        _y[i] = y0 + y1;\n    }\n    _q->flag = 1 - _q->flag;\n    return LIQUID_OK;\n}\nint FIRPFBCH2(_execute)(FIRPFBCH2() _q,\n                        TI *        _x,\n                        TO *        _y)\n{\n    switch (_q->type) {\n    case LIQUID_ANALYZER:\n        return FIRPFBCH2(_execute_analyzer)(_q, _x, _y);\n    case LIQUID_SYNTHESIZER:\n        return FIRPFBCH2(_execute_synthesizer)(_q, _x, _y);\n    default:;\n    }\n    return liquid_error(LIQUID_EINT,""firpfbch2_%s_execute(), invalid internal type"", EXTENSION_FULL);\n}')
"
"('Prompt: You are working on optimizing a program that calculates the sum of squares of elements in an array. The array can be very large, and you want to speed up the calculation. Can you provide a function that takes a pointer to the array of floats and the number of elements in the array, and computes the sum of squares using a more efficient method to enhance performance?","//...\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    float r=0;\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        r += _v[i  ] * _v[i  ];\n        r += _v[i+1] * _v[i+1];\n        r += _v[i+2] * _v[i+2];\n        r += _v[i+3] * _v[i+3];\n    }\n    for ( ; i<_n; i++)\n        r += _v[i] * _v[i];\n    return r;\n}\n//...')
"
"('Create a Finite Impulse Response (FIR) filter using Parks-McClellan algorithm with the following specifications:. - Length of the filter: 4 times the filter order plus 1. - Number of bands: 2. - Band edges: [0.0, f0], [f1, 0.5], where f0 = 0.25 - 0.5 * transition bandwidth and f1 = 0.25 + 0.5 * transition bandwidth. - Desired response in each band: [1.0, 0.0]. - Weighting for each band: [1.0, 1.0]. - Type of FIR filter: Bandpass. . The code provided initializes and prints the filter parameters, initializes the filter grid, and creates the FIR filter using the Parks-McClellan algorithm.","//...\nstruct firdespm_s {\n    unsigned int h_len;         \n    unsigned int s;             \n    unsigned int n;             \n    unsigned int r;             \n    unsigned int num_bands;     \n    unsigned int grid_size;     \n    unsigned int grid_density;  \n    liquid_firdespm_btype btype;\n    double * bands;             \n    double * des;               \n    double * weights;           \n    liquid_firdespm_wtype * wtype;\n    double * F;                 \n    double * D;                 \n    double * W;                 \n    double * E;                 \n    double * x;                 \n    double * alpha;             \n    double * c;                 \n    double rho;                 \n    unsigned int * iext;        \n    unsigned int num_exchanges; \n    firdespm_callback callback; \n    void *            userdata; \n#if LIQUID_FIRDESPM_DEBUG\n    FILE * fid;\n#endif\n};\n    for (i=0; i<_q->grid_size; i++) {\n    for (i=0; i<_q->grid_size; i++) {\n    for (i=0; i<_q->r+1; i++) {\n        fprintf(fid,""iext(%4u) = %u;\\n"", i+1, _q->iext[i]+1);\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""grid on;\\n"");\n        double f = (double) i / (double)(2*(n-1));\n        double x = cos(2*M_PI*f);\n        double c = poly_val_lagrange_barycentric(_q->x,_q->c,_q->alpha,x,_q->r+1);\n    liquid_firdespm_btype btype = LIQUID_FIRDESPM_BANDPASS;\n    unsigned int h_len = 4*_m + 1;\n    unsigned int num_bands = 2;\n    float f0 = 0.25f - 0.5f*_ft;\n    float f1 = 0.25f + 0.5f*_ft;\n    float bands[4]   = {0.0f, f0, f1, 0.5f};\n    float des[2]     = {1.0f, 0.0f};\n    float weights[2] = {1.0f, 1.0f}; \n#define LIQUID_FIRDESPM_DEBUG       0\n    for (i=0; i<_q->grid_size; i++) {\nint firdespm_print(firdespm _q)\n{\n    unsigned int i;\n    printf(""firdespm:               "");\n    for (i=0; i<_q->num_bands; i++) printf(""      band %-5u"", i);\n    printf(""\\n"");\n    printf(""  lower band edge       "");\n    for (i=0; i<_q->num_bands; i++) printf(""%16.8f"", _q->bands[2*i+0]);\n    printf(""\\n"");\n    printf(""  upper band edge       "");\n    for (i=0; i<_q->num_bands; i++) printf(""%16.8f"", _q->bands[2*i+1]);\n    printf(""\\n"");\n    printf(""  desired value         "");\n    for (i=0; i<_q->num_bands; i++) printf(""%16.8f"", _q->des[i]);\n    printf(""\\n"");\n    printf(""  weighting             "");\n    for (i=0; i<_q->num_bands; i++) printf(""%16.8f"", _q->weights[i]);\n    printf(""\\n"");\n    return LIQUID_OK;\n}\nint firdespm_init_grid(firdespm _q)\n{\n    unsigned int i,j;\n    double df = 0.5/(_q->grid_density*_q->r);\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n    printf(""df : %12.8f\\n"", df);\n#endif\n#if 0\n    firdespm_print(_q);\n    double b=0.0;\n    for (i=0; i<_q->num_bands; i++)\n        b += _q->bands[2*i+1] - _q->bands[2*i+0];\n    printf(""b : %12.8f\\n"", b);\n    double g = b / (df * _q->r); \n    double gmin = 4.0;\n    if (g < gmin)\n        df *= g / gmin;\n    printf(""df : %12.8f\\n"", df);\n#endif\n    unsigned int n = 0;\n    double f0, f1;\n    double fw = 1.0f;   \n    for (i=0; i<_q->num_bands; i++) {\n        f0 = _q->bands[2*i+0];\n        f1 = _q->bands[2*i+1];\n        if (i==0 && _q->btype != LIQUID_FIRDESPM_BANDPASS)\n            f0 = f0 < df ? df : f0;\n        unsigned int num_points = (unsigned int)( (f1-f0)/df + 0.5 );\n        if (num_points < 1) num_points = 1;\n        for (j=0; j<num_points; j++) {\n            _q->F[n] = f0 + j*df;\n            if (_q->callback != NULL) {\n                _q->callback(_q->F[n], _q->userdata, &_q->D[n], &_q->W[n]);\n            } else {\n                _q->D[n] = _q->des[i];\n                switch (_q->wtype[i]) {\n                case LIQUID_FIRDESPM_FLATWEIGHT: fw = 1.0f;             break;\n                case LIQUID_FIRDESPM_EXPWEIGHT:  fw = expf(2.0f*j*df);  break;\n                case LIQUID_FIRDESPM_LINWEIGHT:  fw = 1.0f + 2.7f*j*df; break;\n                default:\n                    return liquid_error(LIQUID_EICONFIG,""firdespm_init_grid(), invalid weighting specifier: %d"", _q->wtype[i]);\n                }\n                _q->W[n] = _q->weights[i] * fw;\n            }\n            n++;\n        }\n        _q->F[n-1] = f1;   \n    }\n    _q->grid_size = n;\n    if (_q->btype == LIQUID_FIRDESPM_BANDPASS) {\n        if (_q->s == 0) {\n            for (i=0; i<_q->grid_size; i++) {\n                _q->D[i] /= cos(M_PI*_q->F[i]);\n                _q->W[i] *= cos(M_PI*_q->F[i]);\n            }\n        }\n    } else {\n        if (_q->s == 0) {\n            for (i=0; i<_q->grid_size; i++) {\n                _q->D[i] /= sin(M_PI*_q->F[i]);\n                _q->W[i] *= sin(M_PI*_q->F[i]);\n            }\n        } else {\n            for (i=0; i<_q->grid_size; i++) {\n                _q->D[i] /= sin(2*M_PI*_q->F[i]);\n                _q->W[i] *= sin(2*M_PI*_q->F[i]);\n            }\n        }\n    }\n    return LIQUID_OK;\n}\nfirdespm firdespm_create(unsigned int            _h_len,\n                         unsigned int            _num_bands,\n                         float *                 _bands,\n                         float *                 _des,\n                         float *                 _weights,\n                         liquid_firdespm_wtype * _wtype,\n                         liquid_firdespm_btype   _btype)\n{\n    if (_h_len==0)\n        return liquid_error_config(""firdespm_create(), filter length cannot be 0"");\n    if (_num_bands==0)\n        return liquid_error_config(""firdespm_create(), number of bands cannot be 0"");\n    unsigned int i;\n    int bands_valid = 1;\n    int weights_valid = 1;\n    for (i=0; i<2*_num_bands; i++)\n        bands_valid &= _bands[i] >= 0.0 && _bands[i] <= 0.5;\n    for (i=1; i<2*_num_bands; i++)\n        bands_valid &= _bands[i] >= _bands[i-1];\n    for (i=0; i<_num_bands; i++)\n        weights_valid &= _weights[i] > 0;\n    if (!bands_valid)\n        return liquid_error_config(""firdespm_create(), invalid bands"");\n    if (!weights_valid)\n        return liquid_error_config(""firdespm_create(), invalid weights (must be positive)"");\n    firdespm q = (firdespm) malloc(sizeof(struct firdespm_s));\n    q->h_len = _h_len;              \n    q->s     = q->h_len % 2;        \n    q->n     = (q->h_len - q->s)/2; \n    q->r     = q->n + q->s;         \n    q->btype = _btype;              \n    q->iext  = (unsigned int*) malloc((q->r+1)*sizeof(unsigned int));\n    q->x     = (double*) malloc((q->r+1)*sizeof(double));\n    q->alpha = (double*) malloc((q->r+1)*sizeof(double));\n    q->c     = (double*) malloc((q->r+1)*sizeof(double));\n    q->num_bands = _num_bands;\n    q->bands    = (double*) malloc(2*q->num_bands*sizeof(double));\n    q->des      = (double*) malloc(  q->num_bands*sizeof(double));\n    q->weights  = (double*) malloc(  q->num_bands*sizeof(double));\n    q->wtype = (liquid_firdespm_wtype*) malloc(q->num_bands*sizeof(liquid_firdespm_wtype));\n    if (_wtype == NULL) {\n        for (i=0; i<q->num_bands; i++)\n            q->wtype[i] = LIQUID_FIRDESPM_FLATWEIGHT;\n    } else {\n        for (i=0; i<q->num_bands; i++)\n            q->wtype[i] = _wtype[i];\n    }\n    for (i=0; i<q->num_bands; i++) {\n        q->bands[2*i+0] = _bands[2*i+0];\n        q->bands[2*i+1] = _bands[2*i+1];\n        q->des[i]       = _des[i];\n        q->weights[i]   = _weights == NULL ? 1.0f : _weights[i];\n    }\n    q->grid_density = 20;\n    q->grid_size = 0;\n    double df = 0.5/(q->grid_density*q->r); \n    for (i=0; i<q->num_bands; i++) {\n        double f0 = q->bands[2*i+0];         \n        double f1 = q->bands[2*i+1];         \n        q->grid_size += (unsigned int)( (f1-f0)/df + 1.0 );\n    }\n    q->F = (double*) malloc(q->grid_size*sizeof(double));\n    q->D = (double*) malloc(q->grid_size*sizeof(double));\n    q->W = (double*) malloc(q->grid_size*sizeof(double));\n    q->E = (double*) malloc(q->grid_size*sizeof(double));\n    q->callback = NULL;\n    q->userdata = NULL;\n    firdespm_init_grid(q);\n    return q;\n}\nfirdespm firdespm_create_callback(unsigned int          _h_len,\n                                  unsigned int          _num_bands,\n                                  float *               _bands,\n                                  liquid_firdespm_btype _btype,\n                                  firdespm_callback     _callback,\n                                  void *                _userdata)\n{\n    if (_h_len==0)\n        return liquid_error_config(""firdespm_create_callback(), filter length cannot be 0"");\n    if (_num_bands==0)\n        return liquid_error_config(""firdespm_create_callback(), number of bands cannot be 0"");\n    unsigned int i;\n    int bands_valid = 1;\n    for (i=0; i<2*_num_bands; i++)\n        bands_valid &= _bands[i] >= 0.0 && _bands[i] <= 0.5;\n    for (i=1; i<2*_num_bands; i++)\n        bands_valid &= _bands[i] >= _bands[i-1];\n    if (!bands_valid)\n        return liquid_error_config(""firdespm_create(), invalid bands"");\n    firdespm q = (firdespm) malloc(sizeof(struct firdespm_s));\n    q->h_len = _h_len;              \n    q->s     = q->h_len % 2;        \n    q->n     = (q->h_len - q->s)/2; \n    q->r     = q->n + q->s;         \n    q->btype = _btype;              \n    q->callback = _callback;\n    q->userdata = _userdata;\n    q->iext  = (unsigned int*) malloc((q->r+1)*sizeof(unsigned int));\n    q->x     = (double*) malloc((q->r+1)*sizeof(double));\n    q->alpha = (double*) malloc((q->r+1)*sizeof(double));\n    q->c     = (double*) malloc((q->r+1)*sizeof(double));\n    q->num_bands = _num_bands;\n    q->bands    = (double*) malloc(2*q->num_bands*sizeof(double));\n    q->des      = (double*) malloc(  q->num_bands*sizeof(double));\n    q->weights  = (double*) malloc(  q->num_bands*sizeof(double));\n    q->wtype = (liquid_firdespm_wtype*) malloc(q->num_bands*sizeof(liquid_firdespm_wtype));\n    for (i=0; i<q->num_bands; i++) {\n        q->bands[2*i+0] = _bands[2*i+0];\n        q->bands[2*i+1] = _bands[2*i+1];\n        q->des[i]       = 0.0f;\n        q->weights[i]   = 0.0f;\n    }\n    q->grid_density = 20;\n    q->grid_size = 0;\n    double df = 0.5/(q->grid_density*q->r); \n    for (i=0; i<q->num_bands; i++) {\n        double f0 = q->bands[2*i+0];         \n        double f1 = q->bands[2*i+1];         \n        q->grid_size += (unsigned int)( (f1-f0)/df + 1.0 );\n    }\n    q->F = (double*) malloc(q->grid_size*sizeof(double));\n    q->D = (double*) malloc(q->grid_size*sizeof(double));\n    q->W = (double*) malloc(q->grid_size*sizeof(double));\n    q->E = (double*) malloc(q->grid_size*sizeof(double));\n    firdespm_init_grid(q);\n    return q;\n}\n//...')
"
"(""Prompt: Can you provide a function that tests modulation and demodulation for different modulation schemes in a software-defined radio application? The function should create modulators and demodulators for the specified modulation scheme, modulate a signal, demodulate it, and verify the correctness of the demodulated signal. The function should handle various modulation schemes such as PSK, DPSK, ASK, QAM, APSK, BPSK, QPSK, OOK, and others. Furthermore, the function should assess the demodulator's phase error, error vector magnitude (EVM), and symbol matching accuracy.","void modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_psk2()      { modemcf_test_mod_demod(LIQUID_MODEM_PSK2);      }\nvoid autotest_mod_demod_psk4()      { modemcf_test_mod_demod(LIQUID_MODEM_PSK4);      }\nvoid autotest_mod_demod_psk8()      { modemcf_test_mod_demod(LIQUID_MODEM_PSK8);      }\nvoid autotest_mod_demod_psk16()     { modemcf_test_mod_demod(LIQUID_MODEM_PSK16);     }\nvoid autotest_mod_demod_psk32()     { modemcf_test_mod_demod(LIQUID_MODEM_PSK32);     }\nvoid autotest_mod_demod_psk64()     { modemcf_test_mod_demod(LIQUID_MODEM_PSK64);     }\nvoid autotest_mod_demod_psk128()    { modemcf_test_mod_demod(LIQUID_MODEM_PSK128);    }\nvoid autotest_mod_demod_psk256()    { modemcf_test_mod_demod(LIQUID_MODEM_PSK256);    }\nvoid autotest_mod_demod_dpsk2()     { modemcf_test_mod_demod(LIQUID_MODEM_DPSK2);     }\nvoid autotest_mod_demod_dpsk4()     { modemcf_test_mod_demod(LIQUID_MODEM_DPSK4);     }\nvoid autotest_mod_demod_dpsk8()     { modemcf_test_mod_demod(LIQUID_MODEM_DPSK8);     }\nvoid autotest_mod_demod_dpsk16()    { modemcf_test_mod_demod(LIQUID_MODEM_DPSK16);    }\nvoid autotest_mod_demod_dpsk32()    { modemcf_test_mod_demod(LIQUID_MODEM_DPSK32);    }\nvoid autotest_mod_demod_dpsk64()    { modemcf_test_mod_demod(LIQUID_MODEM_DPSK64);    }\nvoid autotest_mod_demod_dpsk128()   { modemcf_test_mod_demod(LIQUID_MODEM_DPSK128);   }\nvoid autotest_mod_demod_dpsk256()   { modemcf_test_mod_demod(LIQUID_MODEM_DPSK256);   }\nvoid autotest_mod_demod_ask2()      { modemcf_test_mod_demod(LIQUID_MODEM_ASK2);      }\nvoid autotest_mod_demod_ask4()      { modemcf_test_mod_demod(LIQUID_MODEM_ASK4);      }\nvoid autotest_mod_demod_ask8()      { modemcf_test_mod_demod(LIQUID_MODEM_ASK8);      }\nvoid autotest_mod_demod_ask16()     { modemcf_test_mod_demod(LIQUID_MODEM_ASK16);     }\nvoid autotest_mod_demod_ask32()     { modemcf_test_mod_demod(LIQUID_MODEM_ASK32);     }\nvoid autotest_mod_demod_ask64()     { modemcf_test_mod_demod(LIQUID_MODEM_ASK64);     }\nvoid autotest_mod_demod_ask128()    { modemcf_test_mod_demod(LIQUID_MODEM_ASK128);    }\nvoid autotest_mod_demod_ask256()    { modemcf_test_mod_demod(LIQUID_MODEM_ASK256);    }\nvoid autotest_mod_demod_qam4()      { modemcf_test_mod_demod(LIQUID_MODEM_QAM4);      }\nvoid autotest_mod_demod_qam8()      { modemcf_test_mod_demod(LIQUID_MODEM_QAM8);      }\nvoid autotest_mod_demod_qam16()     { modemcf_test_mod_demod(LIQUID_MODEM_QAM16);     }\nvoid autotest_mod_demod_qam32()     { modemcf_test_mod_demod(LIQUID_MODEM_QAM32);     }\nvoid autotest_mod_demod_qam64()     { modemcf_test_mod_demod(LIQUID_MODEM_QAM64);     }\nvoid autotest_mod_demod_qam128()    { modemcf_test_mod_demod(LIQUID_MODEM_QAM128);    }\nvoid autotest_mod_demod_qam256()    { modemcf_test_mod_demod(LIQUID_MODEM_QAM256);    }\nvoid autotest_mod_demod_apsk4()     { modemcf_test_mod_demod(LIQUID_MODEM_APSK4);     }\nvoid autotest_mod_demod_apsk8()     { modemcf_test_mod_demod(LIQUID_MODEM_APSK8);     }\nvoid autotest_mod_demod_apsk16()    { modemcf_test_mod_demod(LIQUID_MODEM_APSK16);    }\nvoid autotest_mod_demod_apsk32()    { modemcf_test_mod_demod(LIQUID_MODEM_APSK32);    }\nvoid autotest_mod_demod_apsk64()    { modemcf_test_mod_demod(LIQUID_MODEM_APSK64);    }\nvoid autotest_mod_demod_apsk128()   { modemcf_test_mod_demod(LIQUID_MODEM_APSK128);   }\nvoid autotest_mod_demod_apsk256()   { modemcf_test_mod_demod(LIQUID_MODEM_APSK256);   }\nvoid autotest_mod_demod_bpsk()      { modemcf_test_mod_demod(LIQUID_MODEM_BPSK);      }\nvoid autotest_mod_demod_qpsk()      { modemcf_test_mod_demod(LIQUID_MODEM_QPSK);      }\nvoid autotest_mod_demod_ook()       { modemcf_test_mod_demod(LIQUID_MODEM_OOK);       }\nvoid autotest_mod_demod_sqam32()    { modemcf_test_mod_demod(LIQUID_MODEM_SQAM32);    }\nvoid autotest_mod_demod_sqam128()   { modemcf_test_mod_demod(LIQUID_MODEM_SQAM128);   }\nvoid autotest_mod_demod_V29()       { modemcf_test_mod_demod(LIQUID_MODEM_V29);       }\nvoid autotest_mod_demod_arb16opt()  { modemcf_test_mod_demod(LIQUID_MODEM_ARB16OPT);  }\nvoid autotest_mod_demod_arb32opt()  { modemcf_test_mod_demod(LIQUID_MODEM_ARB32OPT);  }\nvoid autotest_mod_demod_arb64opt()  { modemcf_test_mod_demod(LIQUID_MODEM_ARB64OPT);  }\nvoid autotest_mod_demod_arb128opt() { modemcf_test_mod_demod(LIQUID_MODEM_ARB128OPT); }\nvoid autotest_mod_demod_arb256opt() { modemcf_test_mod_demod(LIQUID_MODEM_ARB256OPT); }\nvoid autotest_mod_demod_arb64vt()   { modemcf_test_mod_demod(LIQUID_MODEM_ARB64VT);   }\nvoid autotest_mod_demod_pi4dqpsk()  { modemcf_test_mod_demod(LIQUID_MODEM_PI4DQPSK);  }')
"
"('You are working on a project that involves calculating the sum of squares from a given array of float numbers. You are exploring ways to optimize this calculation using SIMD instructions on a processor that supports AVX512. You need to implement a function called `liquid_sumsqf` that takes in a pointer to the array of float numbers `_v` and the length of the array `_n`. This function should decide whether to use the AVX or AVX512 version of the sum of squares calculation based on the size of the input array. The AVX512 version of the function is split into two separate functions, `liquid_sumsqf_avx` for processing smaller arrays and `liquid_sumsqf_avxu` for larger arrays. Your task is to implement the `liquid_sumsqf` function that properly calls the AVX or AVX512 version based on the input array size. ","//...\nfloat liquid_sumsqf_avxu(float *      _v,\n                         unsigned int _n)\n{\n    __m512 v0, v1, v2, v3;   \n    __m512 s0, s1, s2, s3;   \n    __m512 sum = _mm512_setzero_ps(); \n    unsigned int t = (_n >> 6) << 4;\n    unsigned int i;\n    for (i=0; i<t; i+=16) {\n        v0 = _mm512_loadu_ps(&_v[4*i+ 0]);\n        v1 = _mm512_loadu_ps(&_v[4*i+16]);\n        v2 = _mm512_loadu_ps(&_v[4*i+32]);\n        v3 = _mm512_loadu_ps(&_v[4*i+48]);\n        s0 = _mm512_mul_ps(v0, v0);\n        s1 = _mm512_mul_ps(v1, v1);\n        s2 = _mm512_mul_ps(v2, v2);\n        s3 = _mm512_mul_ps(v3, v3);\n        sum = _mm512_add_ps( sum, s0 );\n        sum = _mm512_add_ps( sum, s1 );\n        sum = _mm512_add_ps( sum, s2 );\n        sum = _mm512_add_ps( sum, s3 );\n    }\n    float total = _mm512_reduce_add_ps(sum);\n    for (i=4*t; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf_avx(float *      _v,\n                        unsigned int _n)\n{\n    __m512 v;   \n    __m512 s;   \n    __m512 sum = _mm512_setzero_ps(); \n    unsigned int t = (_n >> 4) << 4;\n    unsigned int i;\n    for (i=0; i<t; i+=16) {\n        v = _mm512_loadu_ps(&_v[i]);\n        s = _mm512_mul_ps(v, v);\n        sum = _mm512_add_ps( sum, s );\n    }\n    float total = _mm512_reduce_add_ps(sum);\n    for (; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    if (_n < 64) {\n        return liquid_sumsqf_avx(_v, _n);\n    }\n    return liquid_sumsqf_avxu(_v, _n);\n}\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    if (_n < 64) {\n        return liquid_sumsqf_avx(_v, _n);\n    }\n    return liquid_sumsqf_avxu(_v, _n);\n}\n//...')
"
"('Please provide a prompt that includes the need to create a C program for a finite impulse response (FIR) interpolator. The program should allow the user to specify parameters such as the number of samples per symbol, filter delay, stop-band attenuation, and the number of data symbols. The program should generate random input data symbols, perform interpolation using a Kaiser window FIR filter, display the input and output data, and save the results to a MATLAB file.","#define OUTPUT_FILENAME ""firinterp_crcf_example.m""\nvoid usage()\n{\n    printf(""firinterp_crcf_example:\\n"");\n    printf(""  -h         : print usage/help\\n"");\n    printf(""  -k <s/sym> : samples/symbol (interp factor), k > 1, default: 4\\n"");\n    printf(""  -m <delay> : filter delay (symbols), m > 0,         default: 3\\n"");\n    printf(""  -s <atten> : filter stop-band attenuation [dB],     default: 60\\n"");\n    printf(""  -n <num>   : number of data symbols,                default: 16\\n"");\n}\nint main(int argc, char*argv[]) {\n    unsigned int    k        = 4;       \n    unsigned int    m        = 3;       \n    float           As       = 60.0f;   \n    unsigned int    num_syms = 16;      \n    int dopt;\n    while ((dopt = getopt(argc,argv,""uhk:m:s:n:"")) != EOF) {\n        switch (dopt) {\n        case \'u\':\n        case \'h\': usage();                          return 0;\n        case \'k\': k = atoi(optarg);                 break;\n        case \'m\': m = atoi(optarg);                 break;\n        case \'s\': As = atof(optarg);                break;\n        case \'n\': num_syms = atoi(optarg);  break;\n        default:\n            exit(1);\n        }\n    }\n    if (k < 2) {\n        fprintf(stderr,""error: %s, interp factor must be greater than 1\\n"", argv[0]);\n        exit(1);\n    } else if (m < 1) {\n        fprintf(stderr,""error: %s, filter delay must be greater than 0\\n"", argv[0]);\n        exit(1);\n    } else if (num_syms < 1) {\n        fprintf(stderr,""error: %s, must have at least one data symbol\\n"", argv[0]);\n        usage();\n        return 1;\n    }\n    unsigned int num_syms_total = num_syms + 2*m;   \n    unsigned int num_samples    = k*num_syms_total; \n    firinterp_crcf q = firinterp_crcf_create_kaiser(k,m,As);\n    float complex x[num_syms_total];   \n    float complex y[num_samples];   \n    unsigned int i;\n    for (i=0; i<num_syms; i++) {\n        x[i] = (rand() % 2 ? 1.0f : -1.0f) +\n               (rand() % 2 ? 1.0f : -1.0f) * _Complex_I;\n    }\n    for (i=num_syms; i<num_syms_total; i++)\n        x[i] = 0.0f;\n    for (i=0; i<num_syms_total; i++)\n        firinterp_crcf_execute(q, x[i], &y[k*i]);\n    firinterp_crcf_destroy(q);\n    printf(""x(t) :\\n"");\n    for (i=0; i<num_syms_total; i++)\n        printf(""  x(%4u) = %8.4f + j*%8.4f;\\n"", i, crealf(x[i]), cimagf(x[i]));\n    printf(""y(t) :\\n"");\n    for (i=0; i<num_samples; i++) {\n        printf(""  y(%4u) = %8.4f + j*%8.4f;"", i, crealf(y[i]), cimagf(y[i]));\n        if ( (i >= k*m) && ((i%k)==0))\n            printf("" **\\n"");\n        else\n            printf(""\\n"");\n    }\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s: auto-generated file\\n\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""k = %u;\\n"", k);\n    fprintf(fid,""m = %u;\\n"", m);\n    fprintf(fid,""num_syms_total = %u;\\n"", num_syms_total);\n    fprintf(fid,""num_samples = k*num_syms_total;\\n"");\n    fprintf(fid,""x = zeros(1,num_syms_total);\\n"");\n    fprintf(fid,""y = zeros(1,num_samples);\\n"");\n    for (i=0; i<num_syms_total; i++)\n        fprintf(fid,""x(%4u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(x[i]), cimagf(x[i]));\n    for (i=0; i<num_samples; i++)\n        fprintf(fid,""y(%4u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(y[i]), cimagf(y[i]));\n    fprintf(fid,""\\n\\n"");\n    fprintf(fid,""tx = [0:(num_syms_total-1)];\\n"");\n    fprintf(fid,""ty = [0:(num_samples-1)]/k - m;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(2,1,1);\\n"");\n    fprintf(fid,""    plot(ty,real(y),\'-\',tx,real(x),\'s\');\\n"");\n    fprintf(fid,""    xlabel(\'time\');\\n"");\n    fprintf(fid,""    ylabel(\'real\');\\n"");\n    fprintf(fid,""    grid on;\\n"");\n    fprintf(fid,""subplot(2,1,2);\\n"");\n    fprintf(fid,""    plot(ty,imag(y),\'-\',tx,imag(x),\'s\');\\n"");\n    fprintf(fid,""    xlabel(\'time\');\\n"");\n    fprintf(fid,""    ylabel(\'imag\');\\n"");\n    fprintf(fid,""    grid on;\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"",OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: ""You are implementing a function in C that calculates the dot product of two complex arrays using NEON SIMD instructions. The function should be able to handle arrays of different lengths efficiently. Can you provide the code for this scenario, including separate implementations for arrays of length less than 32 and arrays of length greater than or equal to 32?""","//...\nint dotprod_cccf_execute_neon(dotprod_cccf    _q,\n                              float complex * _x,\n                              float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    float32x4_t v;   \n    float32x4_t hi;  \n    float32x4_t hq;  \n    float32x4_t ci;  \n    float32x4_t cq;  \n    float zeros[4] = {0,0,0,0};\n    float32x4_t sumi = vld1q_f32(zeros);\n    float32x4_t sumq = vld1q_f32(zeros);\n    unsigned int t = (n >> 2) << 2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        v = vld1q_f32(&x[i]);\n        hi = vld1q_f32(&_q->hi[i]);\n        hq = vld1q_f32(&_q->hq[i]);\n        ci = vmulq_f32(v, hi);\n        cq = vmulq_f32(v, hq);\n        sumi = vaddq_f32(sumi, ci);\n        sumq = vaddq_f32(sumq, cq);\n    }\n    float wi[4];\n    float wq[4];\n    vst1q_f32(wi, sumi);\n    vst1q_f32(wq, sumq);\n    float complex total = \n        ((wi[0] - wq[1]) + (wi[2] - wq[3])) +\n        ((wi[1] + wq[0]) + (wi[3] + wq[2])) * _Complex_I;\n    for (i=t/2; i<_q->n; i++)\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    *_y = total;\n    return LIQUID_OK;\n}\nint dotprod_cccf_execute_neon4(dotprod_cccf    _q,\n                               float complex * _x,\n                               float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    float32x4_t v0,  v1,  v2,  v3;   \n    float32x4_t hi0, hi1, hi2, hi3;  \n    float32x4_t hq0, hq1, hq2, hq3;  \n    float32x4_t ci0, ci1, ci2, ci3;  \n    float32x4_t cq0, cq1, cq2, cq3;  \n    float zeros[4] = {0,0,0,0};\n    float32x4_t sumi = vld1q_f32(zeros);\n    float32x4_t sumq = vld1q_f32(zeros);\n    unsigned int r = (n >> 4) << 2;\n    unsigned int i;\n    for (i=0; i<r; i+=4) {\n        v0 = vld1q_f32(&x[4*i+0]);\n        v1 = vld1q_f32(&x[4*i+4]);\n        v2 = vld1q_f32(&x[4*i+8]);\n        v3 = vld1q_f32(&x[4*i+12]);\n        hi0 = vld1q_f32(&_q->hi[4*i+0]);\n        hi1 = vld1q_f32(&_q->hi[4*i+4]);\n        hi2 = vld1q_f32(&_q->hi[4*i+8]);\n        hi3 = vld1q_f32(&_q->hi[4*i+12]);\n        hq0 = vld1q_f32(&_q->hq[4*i+0]);\n        hq1 = vld1q_f32(&_q->hq[4*i+4]);\n        hq2 = vld1q_f32(&_q->hq[4*i+8]);\n        hq3 = vld1q_f32(&_q->hq[4*i+12]);\n        ci0 = vmulq_f32(v0, hi0);\n        ci1 = vmulq_f32(v1, hi1);\n        ci2 = vmulq_f32(v2, hi2);\n        ci3 = vmulq_f32(v3, hi3);\n        cq0 = vmulq_f32(v0, hq0);\n        cq1 = vmulq_f32(v1, hq1);\n        cq2 = vmulq_f32(v2, hq2);\n        cq3 = vmulq_f32(v3, hq3);\n        sumi = vaddq_f32(sumi, ci0);    sumq = vaddq_f32(sumq, cq0);\n        sumi = vaddq_f32(sumi, ci1);    sumq = vaddq_f32(sumq, cq1);\n        sumi = vaddq_f32(sumi, ci2);    sumq = vaddq_f32(sumq, cq2);\n        sumi = vaddq_f32(sumi, ci3);    sumq = vaddq_f32(sumq, cq3);\n    }\n    float wi[4];\n    float wq[4];\n    vst1q_f32(wi, sumi);\n    vst1q_f32(wq, sumq);\n    float complex total = \n        ((wi[0] - wq[1]) + (wi[2] - wq[3])) +\n        ((wi[1] + wq[0]) + (wi[3] + wq[2])) * _Complex_I;\n    for (i=2*r; i<_q->n; i++) {\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    }\n    *_y = total;\n    return LIQUID_OK;\n}\nint dotprod_cccf_execute(dotprod_cccf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 32) {\n        return dotprod_cccf_execute_neon(_q, _x, _y);\n    }\n    return dotprod_cccf_execute_neon4(_q, _x, _y);\n}\nint dotprod_cccf_execute_neon4(dotprod_cccf    _q,\n                               float complex * _x,\n                               float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    float32x4_t v0,  v1,  v2,  v3;   \n    float32x4_t hi0, hi1, hi2, hi3;  \n    float32x4_t hq0, hq1, hq2, hq3;  \n    float32x4_t ci0, ci1, ci2, ci3;  \n    float32x4_t cq0, cq1, cq2, cq3;  \n    float zeros[4] = {0,0,0,0};\n    float32x4_t sumi = vld1q_f32(zeros);\n    float32x4_t sumq = vld1q_f32(zeros);\n    unsigned int r = (n >> 4) << 2;\n    unsigned int i;\n    for (i=0; i<r; i+=4) {\n        v0 = vld1q_f32(&x[4*i+0]);\n        v1 = vld1q_f32(&x[4*i+4]);\n        v2 = vld1q_f32(&x[4*i+8]);\n        v3 = vld1q_f32(&x[4*i+12]);\n        hi0 = vld1q_f32(&_q->hi[4*i+0]);\n        hi1 = vld1q_f32(&_q->hi[4*i+4]);\n        hi2 = vld1q_f32(&_q->hi[4*i+8]);\n        hi3 = vld1q_f32(&_q->hi[4*i+12]);\n        hq0 = vld1q_f32(&_q->hq[4*i+0]);\n        hq1 = vld1q_f32(&_q->hq[4*i+4]);\n        hq2 = vld1q_f32(&_q->hq[4*i+8]);\n        hq3 = vld1q_f32(&_q->hq[4*i+12]);\n        ci0 = vmulq_f32(v0, hi0);\n        ci1 = vmulq_f32(v1, hi1);\n        ci2 = vmulq_f32(v2, hi2);\n        ci3 = vmulq_f32(v3, hi3);\n        cq0 = vmulq_f32(v0, hq0);\n        cq1 = vmulq_f32(v1, hq1);\n        cq2 = vmulq_f32(v2, hq2);\n        cq3 = vmulq_f32(v3, hq3);\n        sumi = vaddq_f32(sumi, ci0);    sumq = vaddq_f32(sumq, cq0);\n        sumi = vaddq_f32(sumi, ci1);    sumq = vaddq_f32(sumq, cq1);\n        sumi = vaddq_f32(sumi, ci2);    sumq = vaddq_f32(sumq, cq2);\n        sumi = vaddq_f32(sumi, ci3);    sumq = vaddq_f32(sumq, cq3);\n    }\n    float wi[4];\n    float wq[4];\n    vst1q_f32(wi, sumi);\n    vst1q_f32(wq, sumq);\n    float complex total = \n        ((wi[0] - wq[1]) + (wi[2] - wq[3])) +\n        ((wi[1] + wq[0]) + (wi[3] + wq[2])) * _Complex_I;\n    for (i=2*r; i<_q->n; i++) {\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    }\n    *_y = total;\n    return LIQUID_OK;\n}\n//...')
"
"('The prompt you could have given me for the code provided is:. . ""Please provide an implementation for a GMSK frame synchronization algorithm. The algorithm should include functions for updating symbol synchronization, executing the reception of header and payload data, pushing preamble data, updating frequency estimation, decoding headers, and resetting the frame synchronization. The algorithm should involve prefiltering, FIR filters, NCOs for mixing and frequency tracking, and window functions. Please ensure that the synchronization process follows a specific state machine with states for detecting frames, receiving preamble, header, and payload data. Implementing preambles, headers, payloads, and their decoding is integral. The synchronization process should involve updating sample synchronization using FIR filters and pushing preamble data. Additionally, please handle error cases like invalid states and invalid decoding configurations. Thank you."". . In response to this prompt, I have provided you with the detailed algorithm to meet the requirements specified.","//...\n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int m;                 \n    float fi_hat;                   \n    firpfb_rrrf mf;                 \n    firpfb_rrrf dmf;                \n    unsigned int npfb;              \n    float pfb_soft;                 \n    int pfb_index;                  \n    int pfb_timer;                  \n    float tau_hat;                  \n    float dphi_hat;                 \n    windowcf buffer;                \n    nco_crcf nco_coarse;            \n    unsigned int preamble_len;      \nint gmskframesync_syncpn(gmskframesync _q)\n{\n#if 0\n    unsigned int i;\n    for (i=0; i<_q->preamble_len; i++)\n        printf(""  %3u : %12.8f : %12.8f\\n"", i, _q->preamble_pn[i], _q->preamble_rx[i]);\n#endif\n    return LIQUID_OK;\n}\nint gmskframesync_execute_rxheader(gmskframesync _q,\n                                   float complex _x)\n{\n    float complex y;\n    nco_crcf_mix_down(_q->nco_coarse, _x, &y);\n    nco_crcf_step(_q->nco_coarse);\n    gmskframesync_update_fi(_q, y);\n    float mf_out = 0.0f;\n    int sample_available = gmskframesync_update_symsync(_q, _q->fi_hat, &mf_out);\n    if (sample_available) {\n        unsigned char s = mf_out > 0.0f ? 1 : 0;\n        _q->header_mod[_q->header_counter] = s;\n        _q->header_counter++;\n        if (_q->header_counter == _q->header_mod_len) {\n            gmskframesync_decode_header(_q);\n            _q->framedatastats.num_frames_detected++;\n            if (!_q->header_valid && _q->callback != NULL) {\n                _q->framesyncstats.rssi          = 20*log10f(_q->gamma_hat);\n                _q->framesyncstats.evm           = 0.0f;\n                _q->framesyncstats.framesyms     = NULL;\n                _q->framesyncstats.num_framesyms = 0;\n                _q->framesyncstats.mod_scheme    = LIQUID_MODEM_UNKNOWN;\n                _q->framesyncstats.mod_bps       = 1;\n                _q->framesyncstats.check         = LIQUID_CRC_UNKNOWN;\n                _q->framesyncstats.fec0          = LIQUID_FEC_UNKNOWN;\n                _q->framesyncstats.fec1          = LIQUID_FEC_UNKNOWN;\n                _q->callback(_q->header_dec,\n                             _q->header_valid,\n                             NULL,\n                             0,\n                             0,\n                             _q->framesyncstats,\n                             _q->userdata);\n                gmskframesync_reset(_q);\n            }\n            if (!_q->header_valid)\n                return gmskframesync_reset(_q);\n            _q->state = STATE_RXPAYLOAD;\n        }\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_execute(gmskframesync   _q,\n                          float complex * _x,\n                          unsigned int    _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        float complex xf;   \n#if GMSKFRAMESYNC_PREFILTER\n        iirfilt_crcf_execute(_q->prefilter, _x[i], &xf);\n#else\n        xf = _x[i];\n#endif\n        gmskframesync_execute_sample(_q, xf);\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_pushpn(gmskframesync _q)\n{\n    unsigned int i;\n    firpfb_rrrf_reset(_q->mf);\n    firpfb_rrrf_reset(_q->dmf);\n    float complex * rc;\n    windowcf_read(_q->buffer, &rc);\n    assert(_q->tau_hat < 0.5f && _q->tau_hat > -0.5f);\n    unsigned int delay = 2*_q->k*_q->m - 1; \n    _q->pfb_soft       = -_q->tau_hat*_q->npfb;\n    _q->pfb_index      = (int) roundf(_q->pfb_soft);\n    while (_q->pfb_index < 0) {\n        delay         -= 1;\n        _q->pfb_index += _q->npfb;\n        _q->pfb_soft  += _q->npfb;\n    }\n    _q->pfb_timer = 0;\n    nco_crcf_set_frequency(_q->nco_coarse, _q->dphi_hat);\n    unsigned int buffer_len = (_q->preamble_len + _q->m) * _q->k;\n    for (i=0; i<delay; i++) {\n        float complex y;\n        nco_crcf_mix_down(_q->nco_coarse, rc[i], &y);\n        nco_crcf_step(_q->nco_coarse);\n        gmskframesync_update_fi(_q, y);\n        firpfb_rrrf_push(_q->mf,  _q->fi_hat);\n        firpfb_rrrf_push(_q->dmf, _q->fi_hat);\n    }\n    _q->state = STATE_RXPREAMBLE;\n    for (i=delay; i<buffer_len; i++) {\n        gmskframesync_execute_sample(_q, rc[i]);\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_execute_rxpreamble(gmskframesync _q,\n                                     float complex _x)\n{\n    if (_q->preamble_counter == _q->preamble_len)\n        return liquid_error(LIQUID_EINT,""gmskframesync_execute_rxpn(), p/n buffer already full!\\n"");\n    float complex y;\n    nco_crcf_mix_down(_q->nco_coarse, _x, &y);\n    nco_crcf_step(_q->nco_coarse);\n    gmskframesync_update_fi(_q, y);\n    float mf_out = 0.0f;\n    int sample_available = gmskframesync_update_symsync(_q, _q->fi_hat, &mf_out);\n    if (sample_available) {\n        _q->preamble_rx[ _q->preamble_counter ] = mf_out / (float)(_q->k);\n        _q->preamble_counter++;\n        if (_q->preamble_counter == _q->preamble_len) {\n            gmskframesync_syncpn(_q);\n            _q->state = STATE_RXHEADER;\n        }\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_execute_rxpayload(gmskframesync _q,\n                                    float complex _x)\n{\n    float complex y;\n    nco_crcf_mix_down(_q->nco_coarse, _x, &y);\n    nco_crcf_step(_q->nco_coarse);\n    gmskframesync_update_fi(_q, y);\n    float mf_out = 0.0f;\n    int sample_available = gmskframesync_update_symsync(_q, _q->fi_hat, &mf_out);\n    if (sample_available) {\n        unsigned char s = mf_out > 0.0f ? 1 : 0;\n        _q->payload_byte <<= 1;\n        _q->payload_byte |= s ? 0x01 : 0x00;\n        _q->payload_enc[_q->payload_counter/8] = _q->payload_byte;\n        _q->payload_counter++;\n        if (_q->payload_counter == 8*_q->payload_enc_len) {\n            _q->payload_valid = packetizer_decode(_q->p_payload,\n                                                  _q->payload_enc,\n                                                  _q->payload_dec);\n            _q->framedatastats.num_headers_valid++;\n            _q->framedatastats.num_payloads_valid += _q->payload_valid;\n            _q->framedatastats.num_bytes_received += _q->payload_dec_len;\n            if (_q->callback != NULL) {\n                _q->framesyncstats.rssi          = 20*log10f(_q->gamma_hat);\n                _q->framesyncstats.evm           = 0.0f;\n                _q->framesyncstats.framesyms     = NULL;\n                _q->framesyncstats.num_framesyms = 0;\n                _q->framesyncstats.mod_scheme    = LIQUID_MODEM_UNKNOWN;\n                _q->framesyncstats.mod_bps       = 1;\n                _q->framesyncstats.check         = _q->check;\n                _q->framesyncstats.fec0          = _q->fec0;\n                _q->framesyncstats.fec1          = _q->fec1;\n                _q->callback(_q->header_dec,\n                             _q->header_valid,\n                             _q->payload_dec,\n                             _q->payload_dec_len,\n                             _q->payload_valid,\n                             _q->framesyncstats,\n                             _q->userdata);\n            }\n            gmskframesync_reset(_q);\n        }\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_update_symsync(gmskframesync _q,\n                                 float         _x,\n                                 float *       _y)\n{\n    firpfb_rrrf_push(_q->mf,  _x);\n    firpfb_rrrf_push(_q->dmf, _x);\n    float mf_out  = 0.0f;    \n    float dmf_out = 0.0f;    \n    int sample_available = 0;\n    if (_q->pfb_timer <= 0) {\n        sample_available = 1;\n        _q->pfb_timer = _q->k;  \n        firpfb_rrrf_execute(_q->mf,  _q->pfb_index, &mf_out);\n        firpfb_rrrf_execute(_q->dmf, _q->pfb_index, &dmf_out);\n        _q->pfb_q = 0.99f*_q->pfb_q + 0.05f*crealf( conjf(mf_out)*dmf_out );\n        _q->pfb_soft += _q->pfb_q;\n        _q->pfb_index = roundf(_q->pfb_soft);\n        while (_q->pfb_index < 0) {\n            _q->pfb_index += _q->npfb;\n            _q->pfb_soft  += _q->npfb;\n            _q->pfb_timer--;\n        }\n        while (_q->pfb_index > _q->npfb-1) {\n            _q->pfb_index -= _q->npfb;\n            _q->pfb_soft  -= _q->npfb;\n            _q->pfb_timer++;\n        }\n    }\n    _q->pfb_timer--;\n    *_y = mf_out / (float)(_q->k);\n    return sample_available;\n}\nint gmskframesync_reset(gmskframesync _q)\n{\n    _q->state = STATE_DETECTFRAME;\n    _q->preamble_counter = 0;\n    _q->header_counter   = 0;\n    _q->payload_counter  = 0;\n    windowcf_reset(_q->buffer);\n    detector_cccf_reset(_q->frame_detector);\n    nco_crcf_reset(_q->nco_coarse);\n    _q->x_prime = 0.0f;\n    _q->fi_hat  = 0.0f;\n    firpfb_rrrf_reset(_q->mf);\n    firpfb_rrrf_reset(_q->dmf);\n    _q->pfb_q = 0.0f;   \n    return LIQUID_OK;\n}\nint gmskframesync_execute_detectframe(gmskframesync _q,\n                                      float complex _x)\n{\n    windowcf_push(_q->buffer, _x);\n    int detected = detector_cccf_correlate(_q->frame_detector,\n                                           _x,\n                                           &_q->tau_hat,\n                                           &_q->dphi_hat,\n                                           &_q->gamma_hat);\n    if (detected) {\n        gmskframesync_pushpn(_q);\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_decode_header(gmskframesync _q)\n{\n    unsigned int num_written;\n    liquid_pack_bytes(_q->header_mod, _q->header_mod_len,\n                      _q->header_enc, _q->header_enc_len,\n                      &num_written);\n    assert(num_written==_q->header_enc_len);\n    unscramble_data(_q->header_enc, _q->header_enc_len);\n    _q->header_valid = packetizer_decode(_q->p_header, _q->header_enc, _q->header_dec);\n    if (!_q->header_valid)\n        return LIQUID_OK;\n    unsigned int n = _q->header_user_len;\n    if (_q->header_dec[n+0] != GMSKFRAME_VERSION) {\n        liquid_error(LIQUID_EICONFIG,""gmskframesync_decode_header(), invalid framing version (received %u, expected %u)"",\n            _q->header_dec[n+0], GMSKFRAME_VERSION);\n        _q->header_valid = 0;\n        return LIQUID_OK;\n    }\n    unsigned int payload_dec_len = (_q->header_dec[n+1] << 8) | (_q->header_dec[n+2]);\n    unsigned int check = (_q->header_dec[n+3] >> 5 ) & 0x07;\n    unsigned int fec0  = (_q->header_dec[n+3]      ) & 0x1f;\n    unsigned int fec1  = (_q->header_dec[n+4]      ) & 0x1f;\n    if (check == LIQUID_CRC_UNKNOWN || check >= LIQUID_CRC_NUM_SCHEMES) {\n        liquid_error(LIQUID_EICONFIG,""gmskframesync_decode_header(), invalid/unsupported crc: %u"", check);\n        check = LIQUID_CRC_UNKNOWN;\n        _q->header_valid = 0;\n    }\n    if (fec0 >= LIQUID_FEC_NUM_SCHEMES) {\n        liquid_error(LIQUID_EICONFIG,""gmskframesync_decode_header(), invalid/unsupported fec (inner): %u"", fec0);\n        fec0 = LIQUID_FEC_UNKNOWN;\n        _q->header_valid = 0;\n    }\n    if (fec1 >= LIQUID_FEC_NUM_SCHEMES) {\n        liquid_error(LIQUID_EICONFIG,""gmskframesync_decode_header(), invalid/unsupported fec (outer): %u"", fec1);\n        fec1 = LIQUID_FEC_UNKNOWN;\n        _q->header_valid = 0;\n    }\n    if (_q->header_valid) {\n        _q->payload_dec_len = payload_dec_len;\n        _q->check           = check;\n        _q->fec0            = fec0;\n        _q->fec1            = fec1;\n        _q->p_payload = packetizer_recreate(_q->p_payload,\n                                            _q->payload_dec_len,\n                                            _q->check,\n                                            _q->fec0,\n                                            _q->fec1);\n        _q->payload_enc_len = packetizer_get_enc_msg_len(_q->p_payload);\n        _q->payload_enc = (unsigned char*) realloc(_q->payload_enc, _q->payload_enc_len*sizeof(unsigned char));\n        _q->payload_dec = (unsigned char*) realloc(_q->payload_dec, _q->payload_dec_len*sizeof(unsigned char));\n    }\n    return LIQUID_OK;\n}\nint gmskframesync_execute_sample(gmskframesync _q,\n                                 float complex _x)\n{\n    switch (_q->state) {\n    case STATE_DETECTFRAME: return gmskframesync_execute_detectframe(_q, _x);\n    case STATE_RXPREAMBLE:  return gmskframesync_execute_rxpreamble (_q, _x);\n    case STATE_RXHEADER:    return gmskframesync_execute_rxheader   (_q, _x);\n    case STATE_RXPAYLOAD:   return gmskframesync_execute_rxpayload  (_q, _x);\n    default:;\n    }\n    return liquid_error(LIQUID_EINT,""gmskframesync_execute_sample(), invalid internal state"");\n}\nint gmskframesync_update_fi(gmskframesync _q,\n                            float complex _x)\n{\n    _q->fi_hat = cargf(conjf(_q->x_prime)*_x) * _q->k;\n    _q->x_prime = _x;\n    return LIQUID_OK;\n}\nint gmskframesync_pushpn(gmskframesync _q)\n{\n    unsigned int i;\n    firpfb_rrrf_reset(_q->mf);\n    firpfb_rrrf_reset(_q->dmf);\n    float complex * rc;\n    windowcf_read(_q->buffer, &rc);\n    assert(_q->tau_hat < 0.5f && _q->tau_hat > -0.5f);\n    unsigned int delay = 2*_q->k*_q->m - 1; \n    _q->pfb_soft       = -_q->tau_hat*_q->npfb;\n    _q->pfb_index      = (int) roundf(_q->pfb_soft);\n    while (_q->pfb_index < 0) {\n        delay         -= 1;\n        _q->pfb_index += _q->npfb;\n        _q->pfb_soft  += _q->npfb;\n    }\n    _q->pfb_timer = 0;\n    nco_crcf_set_frequency(_q->nco_coarse, _q->dphi_hat);\n    unsigned int buffer_len = (_q->preamble_len + _q->m) * _q->k;\n    for (i=0; i<delay; i++) {\n        float complex y;\n        nco_crcf_mix_down(_q->nco_coarse, rc[i], &y);\n        nco_crcf_step(_q->nco_coarse);\n        gmskframesync_update_fi(_q, y);\n        firpfb_rrrf_push(_q->mf,  _q->fi_hat);\n        firpfb_rrrf_push(_q->dmf, _q->fi_hat);\n    }\n    _q->state = STATE_RXPREAMBLE;\n    for (i=delay; i<buffer_len; i++) {\n        gmskframesync_execute_sample(_q, rc[i]);\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: Please provide a code snippet for a function that performs a test on a soft interleaver with a specified number of elements. The function should generate random data for input, create an interleaver object, encode the input data, decode the encoded data, and verify if the original input and decoded output are the same. Finally, the function should destroy the interleaver object. Additionally, include an automated test function for interleaver with 256 elements using this testing function.","//...\nvoid interleaver_test_soft(unsigned int _n)\n{\n    unsigned int i;\n    unsigned char x[8*_n];\n    unsigned char y[8*_n];\n    unsigned char z[8*_n];\n    for (i=0; i<8*_n; i++)\n        x[i] = rand() & 0xFF;\n    interleaver q = interleaver_create(_n);\n    interleaver_encode_soft(q,x,y);\n    interleaver_decode_soft(q,y,z);\n    CONTEND_SAME_DATA(x, z, 8*_n);\n    interleaver_destroy(q);\n}\nvoid autotest_interleaver_soft_256()    { interleaver_test_soft(256 ); }\n//...')
"
"'Prompt: ""I need a function that will return the current time in seconds with millisecond precision. Can you provide me with a C function that accomplishes this using the gettimeofday function from the sys/time.h library?""","//...\nstatic double epoch_double(void)\n{\n    struct timeval t;\n    gettimeofday(&t, NULL);\n    return t.tv_sec + (t.tv_usec * 1.0) / 1000000.0;\n}\n//...'"
"'Please provide a prompt where you are designing a client-server system using RPC (Remote Procedure Call) in C. The client and server will communicate over a network, and the RPC mechanism will handle various message types. Your task is to implement the RPC functions for handling different types of messages exchanged between the client and server.. . Given the prompt, please provide the implementation for handling RPC function callbacks in the form of C code, including functions like `on_get_connect_cnt`, `on_get_connect_list`, `on_test`, `on_test_resp`, `on_peer_post_msg`, `on_peer_post_msg_resp`, `on_shell_help`, and `on_shell_help_resp`. Additionally, include the definitions for the RPC maps, RPC structure initiation, and functions like `rpc_get_connect_list`, `rpc_get_connect_cnt`, `rpc_shell_help`, and `rpc_peer_post_msg`. Make sure the code includes error handling and printing relevant messages during various RPC interactions.","static struct thread *g_rpc_thread;\n#define MAX_UUID_LEN                (21)\nstatic int on_get_connect_cnt(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    struct rpcs *s = rpc_server_get_handle(r);\n    int cnt = hash_get_all_cnt(s->hash_session);\n    *olen = sizeof(int);\n    int *tmp = calloc(1, sizeof(int));\n    *tmp = cnt;\n    *obuf = tmp;\n    return 0;\n}\nstatic int on_get_connect_list(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    int expect = *(int*)ibuf;\n    struct rpcs *s = rpc_server_get_handle(r);\n    struct rpc_session *ss, *session;\n    int i = 0;\n    int num = 0;\n    int cnt = hash_get_all_cnt(s->hash_session);\n    char **key = calloc(cnt, sizeof(char **));\n    void **ptr = calloc(cnt, sizeof(void **));\n    printf(""connect cnt = %d, ibuf=%d\\n"", cnt, *(int*)ibuf);\n    hash_dump_all(s->hash_session, &num, key, ptr);\n    if (num != cnt) {\n        printf(""hash cnt %d does not match dump %d\\n"", num, cnt);\n    }\n    if (num != expect) {\n        printf(""hash cnt %d does not match expected  %d\\n"", num, expect);\n    }\n    ss = calloc(cnt, sizeof(struct rpc_session));\n    printf(""dump connect list:\\n"");\n    for (i = 0; i < cnt; i++) {\n        session = ptr[i];\n        print_session(session);\n        memcpy(&ss[i], session, sizeof(struct rpc_session));\n    }\n    *obuf = ss;\n    *olen = cnt*sizeof(struct rpc_session);\n#if 0\n    void *ptr;\n    int num = 0;\n    struct iovec *buf = CALLOC(1, struct iovec);\n    key_list *tmp, *uuids;\n    dict_get_key_list(r->dict_uuid2fd, &uuids);\n    for (num = 0, tmp = uuids; tmp; tmp = tmp->next, ++num) {\n    }\n    uuids = NULL;\n    buf->iov_len = num * MAX_UUID_LEN;\n    buf->iov_base = calloc(1, buf->iov_len);\n    for (ptr = buf->iov_base, tmp = uuids; tmp; tmp = tmp->next, ++num) {\n        logi(""uuid list: %s\\n"", (tmp->key));\n        len = MAX_UUID_LEN;\n        memcpy(ptr, tmp->key, len);\n        ptr += len;\n    }\n    r->send_pkt.header.msg_id = RPC_GET_CONNECT_LIST;\n    r->send_pkt.header.payload_len = buf->iov_len;\n    logi(""rpc_send len = %d, buf = %s\\n"", buf->iov_len, buf->iov_base);\n    rpc_send(r, buf->iov_base, buf->iov_len);\n#endif\n    printf(""%s:%d xxxx\\n"", __func__, __LINE__);\n    return 0;\n}\nstatic int on_test(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    printf(""%s:%d xxxx\\n"", __func__, __LINE__);\n    return 0;\n}\nstatic int on_test_resp(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    printf(""%s:%d xxxx\\n"", __func__, __LINE__);\n    return 0;\n}\nstatic int on_peer_post_msg(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    struct rpcs *s = rpc_server_get_handle(r);\n    printf(""post msg from %x to %x\\n"", r->uuid_src, r->uuid_dst);\n    struct rpc_session *dst_session = (struct rpc_session *)hash_get32(s->hash_session, r->uuid_dst);\n    if (!dst_session) {\n        printf(""hash_get failed: key=%08x\\n"", r->uuid_dst);\n        return -1;\n    }\n    struct rpc_packet send_pkt;\n    size_t pkt_len = pack_msg(&send_pkt, r->uuid_dst, r->uuid_src, r->msg_id, ibuf, ilen);\n    if (pkt_len == 0) {\n        printf(""pack_msg failed!\\n"");\n        return -1;\n    }\n    return rpc_send(&dst_session->base, &send_pkt);\n}\nstatic int on_peer_post_msg_resp(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    printf(""msg from %x :%s\\n"", r->uuid_dst, (char *)ibuf);\n    return 0;\n}\nstatic int on_shell_help(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    int ret;\n    char *cmd = (char *)ibuf;\n    *obuf = calloc(1, 1024);\n    *olen = 1024;\n    printf(""on_shell_help cmd = %s\\n"", cmd);\n    memset(*obuf, 0, 1024);\n    ret = system_with_result(cmd, *obuf, 1024);\n    if (ret > 0) {\n        *olen = ret;\n    }\n    return 0;\n}\nstatic int on_shell_help_resp(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    return 0;\n}\nBEGIN_RPC_MAP(RPC_CLIENT_API)\nRPC_MAP(RPC_TEST, on_test_resp)\nRPC_MAP(RPC_PEER_POST_MSG, on_peer_post_msg_resp)\nRPC_MAP(RPC_SHELL_HELP, on_shell_help_resp)\nEND_RPC_MAP()\nBEGIN_RPC_MAP(RPC_SERVER_API)\nRPC_MAP(RPC_TEST, on_test)\nRPC_MAP(RPC_GET_CONNECT_CNT, on_get_connect_cnt)\nRPC_MAP(RPC_GET_CONNECT_LIST, on_get_connect_list)\nRPC_MAP(RPC_PEER_POST_MSG, on_peer_post_msg)\nRPC_MAP(RPC_SHELL_HELP, on_shell_help)\nEND_RPC_MAP()\nstatic int rpc_get_connect_list(struct rpc *r, int cnt)\n{\n    int i;\n    struct rpc_session *ss;\n    ss = calloc(cnt, sizeof(struct rpc_session));\n    rpc_call(r, RPC_GET_CONNECT_LIST, &cnt, sizeof(int), ss, sizeof(ss));\n    printf(""get connect list:\\n"");\n    for (i = 0; i < cnt; i++) {\n        print_session(&ss[i]);\n    }\n    return 0;\n}\nstatic int rpc_get_connect_cnt(struct rpc *r, int *num)\n{\n    rpc_call(r, RPC_GET_CONNECT_CNT, NULL, 0, num, sizeof(int));\n    return 0;\n}\nstatic int rpc_shell_help(struct rpc *r, void *buf, size_t len)\n{\n    char res[1024] = {0};\n    rpc_call(r, RPC_SHELL_HELP, buf, len, res, sizeof(res));\n    printf(""return buffer\\n%s"", res);\n    return 0;\n}\nstatic int rpc_peer_post_msg(struct rpc *r, uint32_t uuid, void *buf, size_t len)\n{\n    rpc_client_set_dest(r, uuid);\n    rpc_call(r, RPC_PEER_POST_MSG, buf, len, NULL, 0);\n    return 0;\n}\nstatic void usage(void)\n{\n    fprintf(stderr, ""./test_libskt -s <port>\\n"");\n    fprintf(stderr, ""./test_libskt -c <ip> <port>\\n"");\n    fprintf(stderr, ""e.g. ./test_libskt -s 127.0.0.1 12345\\n"");\n}\nstatic void cmd_usage(void)\n{\n    printf(""====rpc cmd====\\n""\n            ""a: get all connect list\\n""\n            ""p: post message to peer\\n""\n            ""s: remote shell help\\n""\n            ""q: quit\\n""\n            ""\\n"");\n}\nstatic void *rpc_client_thread(struct thread *t, void *arg)\n{\n    struct rpc *r = (struct rpc *)arg;\n    uint32_t uuid_dst;\n    char cmd[512];\n    int loop = 1;\n    int i;\n    int len = 1024;\n    int connect_cnt = 0;\n    char ch;\n    char *buf = (char *)calloc(1, len);\n    for (i = 0; i < len; i++) {\n        buf[i] = i;\n    }\n    while (loop) {\n        memset(buf, 0, len);\n        printf(""input cmd> "");\n        ch = getchar();\n        switch (ch) {\n        case \'n\':\n            rpc_get_connect_cnt(r, &connect_cnt);\n            printf(""get connect cnt=%d\\n"", connect_cnt);\n            break;\n        case \'a\':\n            rpc_get_connect_cnt(r, &connect_cnt);\n            printf(""get connect cnt=%d\\n"", connect_cnt);\n            rpc_get_connect_list(r, connect_cnt);\n            break;\n        case \'i\':\n            rpc_client_dump_info(r);\n            break;\n        case \'p\':\n            printf(""input uuid_dst> "");\n            scanf(""%x"", &uuid_dst);\n            printf(""uuid_dst = %x\\n"", uuid_dst);\n            sprintf(buf, ""%s"", ""hello world"");\n            rpc_peer_post_msg(r, uuid_dst, buf, 12);\n            break;\n        case \'q\':\n            loop = 0;\n            break;\n        case \'s\':\n            printf(""input shell cmd> "");\n            scanf(""%c"", &ch);\n            scanf(""%[^\\n]"", cmd);\n            rpc_shell_help(r, cmd, sizeof(cmd));\n            break;\n        case \'h\':\n            cmd_usage();\n            break;\n        default:\n            break;\n        }\n    }\n    rpc_client_destroy(r);\n    exit(0);\n    return NULL;\n}\nstatic void *rpc_server_thread(struct thread *t, void *arg)\n{\n    struct rpcs *rpcs = (struct rpcs *)arg;\n    int loop = 1;\n    char ch;\n    while (loop) {\n        printf(""input cmd> "");\n        ch = getchar();\n        switch (ch) {\n        case \'q\':\n            loop = 0;\n            break;\n        case \'h\':\n            cmd_usage();\n            break;\n        default:\n            break;\n        }\n    }\n    rpc_server_destroy(rpcs);\n    exit(0);\n    return NULL;\n}\nstatic int rpc_client_test(char *ip, uint16_t port)\n{\n    struct rpc *rpc = rpc_client_create(ip, port);\n    if (!rpc) {\n        printf(""rpc_client_create failed\\n"");\n        return -1;\n    }\n    RPC_REGISTER_MSG_MAP(RPC_CLIENT_API);\n    printf(""RPC_TEST:%d\\n"", RPC_TEST);\n    printf(""RPC_GET_CONNECT_LIST:%d\\n"", RPC_GET_CONNECT_LIST);\n    printf(""RPC_PEER_POST_MSG:%d\\n"", RPC_PEER_POST_MSG);\n    printf(""RPC_SHELL_HELP:%d\\n"", RPC_SHELL_HELP);\n    printf(""RPC_GET_CONNECT_CNT:%d\\n"", RPC_GET_CONNECT_CNT);\n    g_rpc_thread = thread_create(rpc_client_thread, rpc);\n    rpc_client_dispatch(rpc);\n    return 0;\n}\nstatic int rpc_server_test(uint16_t port)\n{\n    struct rpcs *rpcs = rpc_server_create(NULL, port);\n    if (rpcs == NULL) {\n        printf(""rpc_server_create failed!\\n"");\n        return -1;\n    }\n    RPC_REGISTER_MSG_MAP(RPC_SERVER_API);\n    printf(""RPC_TEST:%d\\n"", RPC_TEST);\n    printf(""RPC_GET_CONNECT_LIST:%d\\n"", RPC_GET_CONNECT_LIST);\n    printf(""RPC_PEER_POST_MSG:%d\\n"", RPC_PEER_POST_MSG);\n    printf(""RPC_SHELL_HELP:%d\\n"", RPC_SHELL_HELP);\n    printf(""RPC_GET_CONNECT_CNT:%d\\n"", RPC_GET_CONNECT_CNT);\n    g_rpc_thread = thread_create(rpc_server_thread, rpcs);\n    rpc_server_dispatch(rpcs);\n    return 0;\n}\nint main(int argc, char **argv)\n{\n    uint16_t port;\n    char *ip;\n    if (argc < 2) {\n        usage();\n        exit(0);\n    }\n    if (!strcmp(argv[1], ""-s"") && argc > 2) {\n        port = atoi(argv[2]);\n        rpc_server_test(port);\n    } else if (!strcmp(argv[1], ""-c"") && argc > 3) {\n        ip = argv[2];\n        port = atoi(argv[3]);\n        rpc_client_test(ip, port);\n    } else {\n        usage();\n        exit(0);\n    }\n    return 0;\n}'"
"('Provide me with a prompt where you need code for implementing mathematical functions for complex numbers in C programming. The code should include functions for calculating the square root, exponential, logarithm, inverse cosine, inverse sine, inverse tangent, and an approximate argument for a complex number.","float complex liquid_csqrtf(float complex _z)\n{\n    float r = cabsf(_z);            \n    float a = crealf(_z);           \n    float re = sqrtf(0.5f*(r+a));   \n    float im = sqrtf(0.5f*(r-a));   \n    return cimagf(_z) > 0 ? re + _Complex_I*im :\n                            re - _Complex_I*im;\n}\nfloat complex liquid_cexpf(float complex _z)\n{\n    float r = expf( crealf(_z) );\n    float re = cosf( cimagf(_z) );\n    float im = sinf( cimagf(_z) );\n    return r * ( re + _Complex_I*im );\n}\nfloat complex liquid_clogf(float complex _z)\n{\n    return logf(cabsf(_z)) + _Complex_I*cargf(_z);\n}\nfloat complex liquid_casinf(float complex _z)\n{\n    return 0.5f*M_PI - liquid_cacosf(_z);\n}\nfloat complex liquid_cacosf(float complex _z)\n{\n    int sign_i = crealf(_z) > 0;\n    int sign_q = cimagf(_z) > 0;\n    if (sign_i == sign_q) {\n        return -_Complex_I*liquid_clogf(_z + liquid_csqrtf(_z*_z - 1.0f));\n    } else {\n        return -_Complex_I*liquid_clogf(_z - liquid_csqrtf(_z*_z - 1.0f));\n    }\n    return 0.0f;\n}\nfloat complex liquid_catanf(float complex _z)\n{\n    float complex t0 = 1.0f - _Complex_I*_z;\n    float complex t1 = 1.0f + _Complex_I*_z;\n    return 0.5f*_Complex_I*liquid_clogf( t0 / t1 );\n}\n#if 0\nfloat liquid_cargf_approx(float complex _x)\n{\n    float theta;\n    float xi = crealf(_x);\n    float xq = cimagf(_x);\n    if (xi == 0.0f) {\n        if (xq == 0.0f)\n            return 0.0f;\n        return xq > 0.0f ? M_PI_2 : -M_PI_2;\n    } else {\n        theta = xq / fabsf(xi);\n    }\n    if (theta >  M_PI_2)\n        theta =  M_PI_2;\n    else if (theta < -M_PI_2)\n        theta = -M_PI_2;\n    return theta;\n}\n#endif')
"
"('Prompt: In a high-performance computing scenario where matrix multiplication operations are frequently performed, you need a function that can efficiently multiply two matrices of size 16x16. Write a benchmarking function in C called `benchmark_matrixf_mul_n16` that takes in two 16x16 matrices and measures the performance of the matrix multiplication operation.","//...\nvoid benchmark_matrixf_mul_n16     M\n//...')
"
"'Prompt: You are working on a real-time embedded system using a TMS570 microcontroller. You need to implement a debug console output functionality using the serial communication interface (SCI). Please provide the necessary code to initialize the debug console, send output characters, receive input characters, and set the attributes for communication at a baud rate of 115200. Additionally, ensure that the console output is set up early during system initialization.","#define TMS570_CONSOLE (&driver_context_table[0])\nstatic void tms570_debug_console_out(char ch)\n{\n  tms570_sci_context *ctx = TMS570_CONSOLE;\n  volatile tms570_sci_t *regs = ctx->regs;\n  while ( true ) {\n    rtems_interrupt_level level;\n    while ( ( regs->FLR & TMS570_SCI_FLR_TXRDY ) == 0) {\n    }\n    rtems_interrupt_disable( level );\n    if ( ( regs->FLR & TMS570_SCI_FLR_TXRDY ) != 0) {\n      regs->TD = ch;\n      rtems_interrupt_enable( level );\n      break;\n    }\n    rtems_interrupt_enable( level );\n  }\n  while ( ( regs->FLR & TMS570_SCI_FLR_TX_EMPTY ) == 0) {\n  }\n}\nstatic void tms570_debug_console_init(void)\n{\n  tms570_sci_context *ctx = TMS570_CONSOLE;\n  struct termios term;\n  tms570_sci_initialize(ctx);\n  memset(&term, 0, sizeof(term));\n  term.c_ospeed = B115200;\n  tms570_sci_set_attributes(&ctx->base, &term);\n  BSP_output_char = tms570_debug_console_out;\n}\nstatic void tms570_debug_console_early_init(char c)\n{\n  tms570_debug_console_init();\n  tms570_debug_console_out(c);\n}\nstatic int tms570_debug_console_in( void )\n{\n  tms570_sci_context *ctx = TMS570_CONSOLE;\n  volatile tms570_sci_t *regs = ctx->regs;\n  rtems_interrupt_level level;\n  int c;\n  rtems_interrupt_disable(level);\n  if ( regs->FLR & TMS570_SCI_FLR_RXRDY ) {\n      c = (unsigned char) regs->RD;\n  } else {\n      c = -1;\n  }\n  rtems_interrupt_enable(level);\n  return c;\n}\nBSP_output_char_function_type BSP_output_char =\n  tms570_debug_console_early_init;\nBSP_polling_getchar_function_type BSP_poll_char = tms570_debug_console_in;\nRTEMS_SYSINIT_ITEM(\n  tms570_debug_console_init,\n  RTEMS_SYSINIT_BSP_START,\n  RTEMS_SYSINIT_ORDER_LAST_BUT_5\n);'"
"('Prompt: Please provide a test case function that tests the modulation and demodulation processes for a QAM64 modem implementation.. . Code Response:. ```c. void modemcf_test_mod_demod(modulation_scheme _ms). {.     modemcf mod   = modemcf_create(_ms);.     modemcf demod = modemcf_create(_ms);.     unsigned int i, s, M = 1 << modemcf_get_bps(mod);.     float complex x;.     float e = 0.0f;.     for (i=0; i<M; i++) {.         modemcf_modulate(mod, i, &x);.         modemcf_demodulate(demod, x, &s);.         CONTEND_EQUALITY(s, i);.         CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);.         CONTEND_DELTA( modemcf_get_demodulator_evm(demod), ","//...\nvoid modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_qam64()     { modemcf_test_mod_demod(LIQUID_MODEM_QAM64);     }\n//...')
"
"('Prompt: You are working on testing a function for generating m-sequences used in signal processing. Write a code snippet using C language that includes a function called `autotest_msequence_period_m2` which calls another function `msequence_test_period` with an input parameter of 2. Within the `msequence_test_period` function, there should be an m-sequence created using a default function and then a period measurement taken using `msequence_measure_period`. The period should be compared with the expected value (2^m - 1) using `CONTEND_EQUALITY` macro. Finally, the m-sequence should be destroyed. Additionally, include another function `autotest_msequence_period_m27` which tests the same functionality but with an input parameter of 27.","//...\nvoid autotest_msequence_period_m2()  { msequence_test_period(2);  }\nvoid msequence_test_period(unsigned int _m)\n{\n    msequence q = msequence_create_default(_m);\n    unsigned int n = (1U << _m) - 1;\n    unsigned int p = msequence_measure_period(q);\n    CONTEND_EQUALITY(p,n)\n    msequence_destroy(q);\n}\nvoid autotest_msequence_period_m27() { msequence_test_period(27); }\n//...')
"
"(""Prompt: You are creating a program that handles a custom structure called `g2412p_s`, which consists of an array of unsigned characters `msg_buf`, another array `reg0`, and two unsigned integers `r` and `d`. You need to implement a function `g2412p_save_col` that takes in a pointer to a `g2412p` structure and an unsigned integer `_col`. This function should iterate through the `reg0` array and save each element's value into the `msg_buf` at the corresponding column `_col` (24 elements per column). Write the C code for this function.","//...\nstruct g2412p_s {\n    unsigned char msg_buf[576]; \n    unsigned char reg0[24];     \n    unsigned int  r;\n    unsigned int  d;\n};\ntypedef struct g2412p_s * g2412p;\nvoid g2412p_save_col(g2412p       _q,\n                     unsigned int _col)\n{\n    unsigned int r;\n    for (r=0; r<24; r++)\n        _q->msg_buf[24*r + _col] = _q->reg0[r];\n}\n//...')
"
"('To generate test cases for some FEC configuration functions:. . 1. The task is to test the configuration of forward error correction (FEC) encoding and decoding schemes in a software-defined radio (SDR) library..    .    Would you please provide test cases to ensure the correct configuration of FEC encoding and decoding schemes for different error correction algorithms in the SDR library?. . 2. The scenario requires validating the mapping of string-based FEC schemes to their corresponding enumeration values, as well as checking properties of various FEC schemes like convolutional, punctured, Reed-Solomon, and Hamming.. .    Could you please devise test scenarios to validate the correct mapping of string-based FEC schemes to their respective enumeration values and to check if the FEC schemes exhibit properties like being convolutional, punctured, Reed-Solomon, or Hamming in the SDR library?","void autotest_fec_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping fec_hamming3126 config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_EQUALITY(fec_golay2412_encode_symbol(1u<<12), 0)\n    CONTEND_EQUALITY(fec_golay2412_decode_symbol(1u<<24), 0)\n    CONTEND_EQUALITY(fec_hamming3126_encode_symbol(1u<<26), 0)\n    CONTEND_EQUALITY(fec_hamming3126_decode_symbol(1u<<31), 0)\n    CONTEND_EQUALITY(fec_hamming1511_encode_symbol(1u<<11), 0)\n    CONTEND_EQUALITY(fec_hamming1511_decode_symbol(1u<<15), 0)\n    CONTEND_EQUALITY(fec_hamming128_encode_symbol(1u<<8), 0)\n    CONTEND_EQUALITY(fec_hamming128_decode_symbol(1u<<12), 0)\n    CONTEND_EQUALITY(liquid_print_fec_schemes(), LIQUID_OK);\n}\nvoid autotest_fec_str2fec()\n{\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n    CONTEND_EQUALITY(liquid_getopt_str2fec(""invalid scheme""), LIQUID_MODEM_UNKNOWN);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""none""),       LIQUID_FEC_NONE);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""rep3""),       LIQUID_FEC_REP3);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""rep5""),       LIQUID_FEC_REP5);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""h74""),        LIQUID_FEC_HAMMING74);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""h84""),        LIQUID_FEC_HAMMING84);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""h128""),       LIQUID_FEC_HAMMING128);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""g2412""),      LIQUID_FEC_GOLAY2412);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""secded2216""), LIQUID_FEC_SECDED2216);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""secded3932""), LIQUID_FEC_SECDED3932);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""secded7264""), LIQUID_FEC_SECDED7264);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27""),        LIQUID_FEC_CONV_V27);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29""),        LIQUID_FEC_CONV_V29);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v39""),        LIQUID_FEC_CONV_V39);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v615""),       LIQUID_FEC_CONV_V615);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27p23""),     LIQUID_FEC_CONV_V27P23);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27p34""),     LIQUID_FEC_CONV_V27P34);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27p45""),     LIQUID_FEC_CONV_V27P45);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27p56""),     LIQUID_FEC_CONV_V27P56);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27p67""),     LIQUID_FEC_CONV_V27P67);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v27p78""),     LIQUID_FEC_CONV_V27P78);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29p23""),     LIQUID_FEC_CONV_V29P23);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29p34""),     LIQUID_FEC_CONV_V29P34);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29p45""),     LIQUID_FEC_CONV_V29P45);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29p56""),     LIQUID_FEC_CONV_V29P56);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29p67""),     LIQUID_FEC_CONV_V29P67);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""v29p78""),     LIQUID_FEC_CONV_V29P78);\n    CONTEND_EQUALITY( liquid_getopt_str2fec(""rs8""),        LIQUID_FEC_RS_M8);\n}\nvoid autotest_fec_is_convolutional()\n{\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_NONE),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_REP3),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_REP5),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_HAMMING74),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_HAMMING84),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_HAMMING128),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_GOLAY2412),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_SECDED2216),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_SECDED3932),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_SECDED7264),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27),    1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29),    1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V39),    1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V615),   1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P23), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P34), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P45), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P56), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P67), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P78), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P23), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P34), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P45), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P56), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P67), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P78), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_RS_M8),       0 );\n}\nvoid autotest_fec_is_punctured()\n{\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_NONE),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_REP3),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_REP5),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_HAMMING74),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_HAMMING84),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_HAMMING128),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_GOLAY2412),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_SECDED2216),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_SECDED3932),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_SECDED7264),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27),    0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29),    0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V39),    0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V615),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27P23), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27P34), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27P45), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27P56), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27P67), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V27P78), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29P23), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29P34), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29P45), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29P56), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29P67), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_CONV_V29P78), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_punctured(LIQUID_FEC_RS_M8),       0 );\n}\nvoid autotest_fec_is_reedsolomon()\n{\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_NONE),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_REP3),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_HAMMING74),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_GOLAY2412),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_SECDED2216),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_CONV_V27),    0 );\n    CONTEND_EQUALITY( fec_scheme_is_reedsolomon(LIQUID_FEC_RS_M8),       1 );\n}\nvoid autotest_fec_is_hamming()\n{\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_NONE),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_REP3),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_HAMMING74),   1 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_HAMMING84),   1 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_HAMMING128),  1 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_GOLAY2412),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_SECDED2216),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_CONV_V27),    0 );\n    CONTEND_EQUALITY( fec_scheme_is_hamming(LIQUID_FEC_RS_M8),       0 );\n}')
"
"('Prompt: You are working on a system that involves decoding packets using a packetizer library. Your current task is to implement a function that decodes packets persistently. The function should attempt to decode the packet multiple times with various bit flips until a valid CRC is found, or until all possible permutations have been attempted. Write the C code for the `packetizer_decode_persistent` function which takes the packetizer instance, packet data, and output message buffer as input, and returns an integer indicating success or failure. It should repeatedly flip each bit in the packet data and attempt to decode the modified packet until a correct CRC is found. If a valid CRC is found, the function should return successfully, otherwise, return an error code.","//...\nint packetizer_decode_persistent(packetizer _p,\n                                 unsigned char * _pkt,\n                                 unsigned char * _msg)\n{\n    int crc_pass = packetizer_decode(_p, _pkt, _msg);\n    if (crc_pass)\n        return crc_pass;\n    unsigned int i;\n    unsigned int key=0;\n    for (i=0; i<_p->msg_len + _p->crc_length; i++) {\n        unsigned int j;\n        for (j=0; j<8; j++) {\n            unsigned char mask = 1 << (8-j-1);\n            _p->buffer_0[i] ^= mask;\n            key = 0;\n            unsigned int k;\n            for (k=0; k<_p->crc_length; k++) {\n                key <<= 8;\n                key |= _p->buffer_0[_p->msg_len+k];\n            }\n            crc_pass = crc_validate_message(_p->check,\n                                            _p->buffer_0,\n                                            _p->msg_len,\n                                            key);\n            if (crc_pass) {\n                memmove(_msg, _p->buffer_0, _p->msg_len);\n                return crc_pass;\n            } else {\n                _p->buffer_0[i] ^= mask;\n            }\n        }\n    }\n    memmove(_msg, _p->buffer_0, _p->msg_len);\n    return crc_pass;\n}\n//...')
"
"('Prompt: ""Imagine you are working on a genetic algorithm search algorithm, and you need a function that mutates the chromosomes of a population based on a mutation rate. The function should iterate through each individual in the population, randomly selecting bits of the chromosome to mutate until a certain number of mutations occur. If necessary, you can call a separate function `chromosome_mutate` that will perform the actual mutation. Can you provide a C function code snippet that accomplishes this task?""","//...\nint gasearch_mutate(gasearch _g)\n{\n    unsigned int i;\n    unsigned int index;\n    for (i=1; i<_g->population_size; i++) {\n        unsigned int num_mutations = 0;\n        while ( randf() < _g->mutation_rate || num_mutations == 0) {\n            index = rand() % _g->bits_per_chromosome;\n            chromosome_mutate( _g->population[i], index );\n            num_mutations++;\n            if (num_mutations == _g->bits_per_chromosome)\n                break;\n        }\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on a project involving coherent GMSK demodulation. You want to create a command-line tool that allows users to specify various parameters for the demodulation process and visualize the results. Can you provide a C code snippet that reads command line options for parameters such as samples per symbol, filter delay, filter roll-off, number of data symbols, and SNR? The code should also perform GMSK modulation based on the specified parameters, estimate power spectral density, and write the results to a file named ""gmskmodem_coherent_test.m"".. . Response: . . ```c. #define OUTPUT_FILENAME ""gmskmodem_coherent_test.m"". void usage(). {.     printf(""gmskmodem_coherent_test -- coherent GMSK demodulation example\\n"");.     printf(""options:\\n"");.     printf(""  h     : print help\\n"");.     printf(""  k     : samples/symbol,           default:  8\\n","#define OUTPUT_FILENAME ""gmskmodem_coherent_test.m""\nvoid usage()\n{\n    printf(""gmskmodem_coherent_test -- coherent GMSK demodulation example\\n"");\n    printf(""options:\\n"");\n    printf(""  h     : print help\\n"");\n    printf(""  k     : samples/symbol,           default:  8\\n"");\n    printf(""  m     : filter delay (symbols),   default:  3\\n"");\n    printf(""  b     : filter roll-off,          default:  0.3\\n"");\n    printf(""  n     : number of data symbols,   default: 80\\n"");\n    printf(""  s     : SNR [dB],                 default: 40\\n"");\n}\nint main(int argc, char*argv[])\n{\n    unsigned int k           = 8;       \n    unsigned int m           = 3;       \n    float        beta        = 0.25f;   \n    unsigned int num_symbols = 80;      \n    float        SNRdB       = 40.0f;   \n    int dopt;\n    while ((dopt = getopt(argc,argv,""hk:m:b:n:s:"")) != EOF) {\n        switch (dopt) {\n        case \'h\': usage();                      return 0;\n        case \'k\': k           = atoi(optarg);   break;\n        case \'m\': m           = atoi(optarg);   break;\n        case \'b\': beta        = atof(optarg);   break;\n        case \'n\': num_symbols = atoi(optarg);   break;\n        case \'s\': SNRdB       = atof(optarg);   break;\n        default:\n            exit(1);\n        }\n    }\n    unsigned int i;\n    unsigned int num_samples = k*num_symbols;\n    float nstd = powf(10.0f, -SNRdB/20.0f);\n    unsigned int  sym_in [num_symbols];     \n    float complex x      [num_samples];     \n    float complex y      [num_samples];     \n    float complex z      [num_samples];     \n    gmskmod mod = gmskmod_create(k, m, beta);\n    for (i=0; i<num_symbols; i++)\n        sym_in[i] = rand() % 2;\n    for (i=0; i<num_symbols; i++)\n        gmskmod_modulate(mod, sym_in[i], &x[k*i]);\n    gmskmod_destroy(mod);\n    for (i=0; i<num_samples; i++) {\n        y[i] = x[i] + nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n    }\n    firfilt_crcf mf = firfilt_crcf_create_rnyquist(LIQUID_FIRFILT_GMSKRX,k,m,0.8,0);\n    firfilt_crcf_set_scale(mf, 1.5f / (float)k);\n    for (i=0; i<num_samples; i++) {\n        firfilt_crcf_push(mf, y[i]);\n        firfilt_crcf_execute(mf, &z[i]);\n    }\n    firfilt_crcf_destroy(mf);\n    unsigned int nfft = 1024;\n    float psd[nfft];\n    spgramcf_estimate_psd(nfft, x, num_samples, psd);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""k = %u;\\n"", k);\n    fprintf(fid,""m = %u;\\n"", m);\n    fprintf(fid,""beta = %12.8f;\\n"", beta);\n    fprintf(fid,""num_symbols = %u;\\n"", num_symbols);\n    fprintf(fid,""num_samples = %u;\\n"", num_samples);\n    fprintf(fid,""nfft        = %u;\\n"", nfft);\n    fprintf(fid,""x   = zeros(1,num_samples);\\n"");\n    fprintf(fid,""y   = zeros(1,num_samples);\\n"");\n    for (i=0; i<num_samples; i++) {\n        fprintf(fid,""x(%4u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(x[i]), cimagf(x[i]));\n        fprintf(fid,""y(%4u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(y[i]), cimagf(y[i]));\n        fprintf(fid,""z(%4u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(z[i]), cimagf(z[i]));\n    }\n    fprintf(fid,""psd = zeros(1,nfft);\\n"");\n    for (i=0; i<nfft; i++)\n        fprintf(fid,""psd(%4u) = %12.8f;\\n"", i+1, psd[i]);\n#if 0\n    fprintf(fid,""t=[0:(num_samples-1)]/k;\\n"");\n    fprintf(fid,""i = 1:k:num_samples;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(3,4,1:3);\\n"");\n    fprintf(fid,""  plot(t,real(x),\'-\', t(i),real(x(i)),\'ob\',...\\n"");\n    fprintf(fid,""       t,imag(x),\'-\', t(i),imag(x(i)),\'og\');\\n"");\n    fprintf(fid,""  axis([0 num_symbols -1.2 1.2]);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'x(t)\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""subplot(3,4,5:7);\\n"");\n    fprintf(fid,""  plot(t,real(z),\'-\', t(i),real(z(i)),\'ob\',...\\n"");\n    fprintf(fid,""       t,imag(z),\'-\', t(i),imag(z(i)),\'og\');\\n"");\n    fprintf(fid,""  axis([0 num_symbols -1.2 1.2]);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'y(t)\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""subplot(3,4,4);\\n"");\n    fprintf(fid,""  plot(real(x),imag(x),\'-\',real(x(i)),imag(x(i)),\'rs\',\'MarkerSize\',4);\\n"");\n    fprintf(fid,""  xlabel(\'I\');\\n"");\n    fprintf(fid,""  ylabel(\'Q\');\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.2);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""subplot(3,4,8);\\n"");\n    fprintf(fid,""  plot(real(z),imag(z),\'-\',real(z(i)),imag(z(i)),\'rs\',\'MarkerSize\',4);\\n"");\n    fprintf(fid,""  xlabel(\'I\');\\n"");\n    fprintf(fid,""  ylabel(\'Q\');\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.2);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""f = [0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""subplot(3,4,9:12);\\n"");\n    fprintf(fid,""  plot(f,psd,\'LineWidth\',1.5);\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -60 20]);\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""  ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n#else\n    fprintf(fid,""i = (1+2*k*m):k:num_samples;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""hold on;\\n"");\n    fprintf(fid,""  plot(real(z),imag(z),\'-\',\'Color\',[1 1 1]*0.8);\\n"");\n    fprintf(fid,""  plot(real(z(i)),imag(z(i)),\'rs\',\'MarkerSize\',4);\\n"");\n    fprintf(fid,""  plot([-1 -1 1 1]/sqrt(2), [-1 1 -1 1]/sqrt(2), \'x\', \'MarkerSize\',8);\\n"");\n    fprintf(fid,""hold off;\\n"");\n    fprintf(fid,""axis([-1 1 -1 1]*1.5);\\n"");\n    fprintf(fid,""axis square;\\n"");\n    fprintf(fid,""xlabel(\'real\');\\n"");\n    fprintf(fid,""ylabel(\'imag\');\\n"");\n    fprintf(fid,""grid on;\\n"");\n#endif\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
"('Create a function named `testbench_nco_crcf_mix` that simulates the mixing of complex signals using an NCO (Numeric Controlled Oscillator) with the specified type, initial phase, and frequency. The function should generate two arrays of complex numbers `buf_0` and `buf_1` of length 1200. The function should then mix the signals in `buf_0` using the NCO, storing the result in `buf_1`. Finally, iterate through the arrays comparing the results to the expected value based on the phase and frequency parameters, with a tolerance of 1e-2f. If the test fails, output an error message. . . Further, create an automated test function named `autotest_nco_crcf_mix_nco_6` that initiates the `testbench_nco_crcf_mix` function with specific parameters for testing a specific scenario (LIQUID_NCO type, phase of 0, and frequency of -","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_nco_6() { testbench_nco_crcf_mix(LIQUID_NCO,  0.000f,   -M_PI); }\n//...')
"
"'Prompt: You want to create a button in an LVGL project and update a label text on each click of the button. Provide a code snippet for setting up the button and label with an event handler function that increments a counter and updates the label text accordingly. . . ```c. #if LV_BUILD_EXAMPLES && LV_USE_BUTTON. static void btn_event_cb(lv_event_t * e). {.     lv_event_code_t code = lv_event_get_code(e);.     lv_obj_t * btn = lv_event_get_target(e);.     if(code == LV_EVENT_CLICKED) {.         static uint8_t cnt = 0;.         cnt++;.         lv_obj_t * label = lv_obj_get_child(btn, 0);.         lv_label_set_text_fmt(label, ""Button: %d"", cnt);.     }. }. void lv_example_get_started_2(void). {.     lv_obj_t * btn = lv_button_create(lv_screen_active());     .     lv_obj_set_pos(btn, 10, ","#if LV_BUILD_EXAMPLES && LV_USE_BUTTON\nstatic void btn_event_cb(lv_event_t * e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * btn = lv_event_get_target(e);\n    if(code == LV_EVENT_CLICKED) {\n        static uint8_t cnt = 0;\n        cnt++;\n        lv_obj_t * label = lv_obj_get_child(btn, 0);\n        lv_label_set_text_fmt(label, ""Button: %d"", cnt);\n    }\n}\nvoid lv_example_get_started_2(void)\n{\n    lv_obj_t * btn = lv_button_create(lv_screen_active());     \n    lv_obj_set_pos(btn, 10, 10);                            \n    lv_obj_set_size(btn, 120, 50);                          \n    lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_ALL, NULL);           \n    lv_obj_t * label = lv_label_create(btn);          \n    lv_label_set_text(label, ""Button"");                     \n    lv_obj_center(label);\n}\n#endif'"
"('Prompt: You are developing a communication system that involves modulation and demodulation of signals using different schemes. Please provide a function to test the demodulation statistics for the ASK2 (Amplitude Shift Keying 2) modulation scheme. The function should validate the accuracy of demodulated symbols by comparing them with the original symbols, and ensure that the demodulator phase error is within certain specified limits.","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_ask2()     { modemcf_test_demodstats(LIQUID_MODEM_ASK2);     }\n//...')
"
"('Please provide a testing prompt for a frequency-shift keying (FSK) modem to test modulation and demodulation functionality for a given set of parameters, including the modulation index, number of bits per symbol, and bandwidth. The scenario involves creating an FSK modem and demodem, modulating and demodulating symbols, and checking for equality between input and output symbols. Finally, the modem and demodem are destroyed after testing.","//...\nvoid fskmodem_test_mod_demod(unsigned int _m,\n                             unsigned int _k,\n                             float        _bandwidth)\n{\n    if (liquid_autotest_verbose)\n        printf(""fskmodem_test_mod_demod(m=%u, k=%u, bandwidth=%g)\\n"", _m, _k, _bandwidth);\n    fskmod mod = fskmod_create(_m,_k,_bandwidth);\n    fskdem dem = fskdem_create(_m,_k,_bandwidth);\n    unsigned int M = 1 << _m;   \n    float complex buf[_k];      \n    unsigned int i;\n    for (i=0; i<M; i++) {\n        unsigned int sym_in = i;\n        fskmod_modulate(mod, sym_in, buf);\n        unsigned int sym_out = fskdem_demodulate(dem, buf);\n        CONTEND_EQUALITY(sym_in, sym_out);\n    }\n    fskmod_destroy(mod);\n    fskdem_destroy(dem);\n}\nvoid autotest_fskmodem_misc_M16()   { fskmodem_test_mod_demod( 4,   30, 0.3721451); }\n//...')
"
"'Prompt: Could you provide me with the code for implementing the quick sort algorithm in C? Specifically, could you share the implementation code located in the file quick_sort.c within the libsort directory of the gear-lib library?",../gear-lib/libsort/quick_sort.c'
"'Prompt: You need to implement a function `pthread_mutexattr_settype` which sets the type of a pthread mutex attribute to either `PTHREAD_MUTEX_FAST_NP`, `PTHREAD_MUTEX_RECURSIVE_NP`, or `PTHREAD_MUTEX_ERRORCHECK_NP`. If the attribute is NULL or invalid, return an error code of EINVAL. Can you provide the code for this function?","//...\nint\npthread_mutexattr_settype (pthread_mutexattr_t * attr, int kind)\n{\n  int result = 0;\n  if ((attr != NULL && *attr != NULL))\n    {\n      switch (kind)\n\t{\n\tcase PTHREAD_MUTEX_FAST_NP:\n\tcase PTHREAD_MUTEX_RECURSIVE_NP:\n\tcase PTHREAD_MUTEX_ERRORCHECK_NP:\n\t  (*attr)->kind = kind;\n\t  break;\n\tdefault:\n\t  result = EINVAL;\n\t  break;\n\t}\n    }\n  else\n    {\n      result = EINVAL;\n    }\n  return (result);\n}\n//...'"
"('Prompt: Write a code snippet that tests the period of a linear feedback shift register (LFSR) generated by an m-sequence with a length of 19 bits. The function should create the m-sequence, measure its period, and then compare it with the expected period calculated based on the m value. Finally, the function should destroy the m-sequence.","//...\nvoid msequence_test_period(unsigned int _m)\n{\n    msequence q = msequence_create_default(_m);\n    unsigned int n = (1U << _m) - 1;\n    unsigned int p = msequence_measure_period(q);\n    CONTEND_EQUALITY(p,n)\n    msequence_destroy(q);\n}\nvoid autotest_msequence_period_m19() { msequence_test_period(19); }\n//...')
"
'Prompt: You are working on a firmware project for an embedded system with the use of low-level drivers and need to handle CRC operations. You want to ensure that the CRC peripheral is properly deinitialized in your code. Please provide a code snippet that demonstrates how to deinitialize the CRC peripheral using low-level drivers and includes error checking using the assert_param function.,#if defined(USE_FULL_LL_DRIVER) || defined(__rtems__)\n#ifdef  USE_FULL_ASSERT\n#else\n#define assert_param(expr) ((void)0U)\n#endif \n#if defined (CRC)\nErrorStatus LL_CRC_DeInit(CRC_TypeDef *CRCx)\n{\n  ErrorStatus status = SUCCESS;\n  assert_param(IS_CRC_ALL_INSTANCE(CRCx));\n  if (CRCx == CRC)\n  {\n#if defined(LL_AHB4_GRP1_PERIPH_CRC)\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_CRC);\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_CRC);\n#else\n    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_CRC);\n    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_CRC);\n#endif \n  }\n  else\n  {\n    status = ERROR;\n  }\n  return (status);\n}\n#endif \n#endif '
"'Prompt: The scenario is that you need a code snippet in C that involves a cover check implementation in a GUI library, specifically for determining if an area is covered or masked by an object in a graphical user interface. The code should contain a function that checks whether an object covers a specific area by sending an event and setting a result in the event structure. The function should return false if the area is covered, true otherwise. Additionally, there is a helper function to get a pointer to the display being refreshed. The code must handle the case when the cover result is LV_COVER_RES_COVER or LV_COVER_RES_MASKED.. . Response:. ```c. //.... // Structure definition for cover check info. typedef struct {.     lv_cover_res_t res;.     const lv_area_t *area;. } lv_cover_check_info_t;. . // Function to get the refreshing display. lv_display_t * _lv_refr_get_disp_refreshing(void) {.     return disp_refr;. }. . // Function to","//...\n    lv_cover_check_info_t info;\n    if(info.res == LV_COVER_RES_MASKED) return NULL;\n    info.area = area_p;\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)\n{\n    if(!_lv_area_is_on(area, &obj->coords)) return true;\n    lv_cover_check_info_t info;\n    info.res = LV_COVER_RES_COVER;\n    info.area = area;\n    lv_obj_send_event(obj, LV_EVENT_COVER_CHECK, &info);\n    if(info.res == LV_COVER_RES_COVER) return false;\n    else return true;\n}\n//...'"
"('Prompt: You are working on testing an interleaver implementation that includes both hard and soft encoding and decoding. Write code for a test scenario where you generate random data, encode it using hard or soft interleaving, decode it back, and ensure the original data matches the decoded data. Additionally, create auto-test functions for different interleaver sizes like 8, 16, 64, and 256.","void interleaver_test_hard(unsigned int _n)\n{\n    unsigned int i;\n    unsigned char x[_n];\n    unsigned char y[_n];\n    unsigned char z[_n];\n    for (i=0; i<_n; i++)\n        x[i] = rand() & 0xFF;\n    interleaver q = interleaver_create(_n);\n    interleaver_encode(q,x,y);\n    interleaver_decode(q,y,z);\n    CONTEND_SAME_DATA(x, z, _n);\n    interleaver_destroy(q);\n}\nvoid interleaver_test_soft(unsigned int _n)\n{\n    unsigned int i;\n    unsigned char x[8*_n];\n    unsigned char y[8*_n];\n    unsigned char z[8*_n];\n    for (i=0; i<8*_n; i++)\n        x[i] = rand() & 0xFF;\n    interleaver q = interleaver_create(_n);\n    interleaver_encode_soft(q,x,y);\n    interleaver_decode_soft(q,y,z);\n    CONTEND_SAME_DATA(x, z, 8*_n);\n    interleaver_destroy(q);\n}\nvoid autotest_interleaver_hard_8()      { interleaver_test_hard(8   ); }\nvoid autotest_interleaver_hard_16()     { interleaver_test_hard(16  ); }\nvoid autotest_interleaver_hard_64()     { interleaver_test_hard(64  ); }\nvoid autotest_interleaver_hard_256()    { interleaver_test_hard(256 ); }\nvoid autotest_interleaver_soft_8()      { interleaver_test_soft(8   ); }\nvoid autotest_interleaver_soft_16()     { interleaver_test_soft(16  ); }\nvoid autotest_interleaver_soft_64()     { interleaver_test_soft(64  ); }\nvoid autotest_interleaver_soft_256()    { interleaver_test_soft(256 ); }')
"
"('Please provide a prompt that outlines the need for a function that sets header properties, resets the frame generator, sets header length, and reapplies configurations for encoding and modulation in a software-defined radio implementation using OFDM frame generation.","//...\n    unsigned int M;         \n    unsigned int cp_len;    \n    unsigned int taper_len; \n    unsigned char * p;      \n    unsigned int M_null;    \n    unsigned int M_pilot;   \n    unsigned int M_data;    \n    unsigned int frame_len; \n    float complex * X;          \n    float complex * buf_tx;     \n    unsigned int    buf_index;  \n    ofdmframegen fg;        \n    modemcf mod_header;           \n    packetizer p_header;          \n    unsigned int num_symbols_header;    \n    unsigned char * header_enc;   \n    unsigned char * header_mod;   \n    unsigned int header_user_len; \n    packetizer p_payload;               \n    unsigned int payload_dec_len;       \n    modemcf mod_payload;                \n    unsigned char * payload_enc;        \n    unsigned char * payload_mod;        \n    unsigned int payload_enc_len;       \n    unsigned int payload_mod_len;       \n    ofdmflexframegenprops_s props;\n    ofdmflexframegenprops_s header_props;\nint ofdmflexframegen_set_header_props(ofdmflexframegen _q,\n                                      ofdmflexframegenprops_s * _props)\n{\n    if (_props == NULL) {\n        _props = &ofdmflexframegenprops_header_default;\n    }\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframegen_setprops(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframegen_setprops(), invalid/unsupported FEC scheme"");\n    if (_props->mod_scheme == LIQUID_MODEM_UNKNOWN )\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframegen_setprops(), invalid/unsupported modulation scheme"");\n    memmove(&_q->header_props, _props, sizeof(ofdmflexframegenprops_s));\n    return ofdmflexframegen_set_header_len(_q, _q->header_user_len);\n}\nint ofdmflexframegen_reset(ofdmflexframegen _q)\n{\n    _q->symbol_number        = 0;\n    _q->state = OFDMFLEXFRAMEGEN_STATE_S0a;\n    _q->frame_assembled      = 0;\n    _q->frame_complete       = 0;\n    _q->header_symbol_index  = 0;\n    _q->payload_symbol_index = 0;\n    _q->buf_index            = _q->frame_len;\n    return ofdmframegen_reset(_q->fg);\n}\nint ofdmflexframegen_set_header_len(ofdmflexframegen _q,\n                                    unsigned int     _len)\n{\n    _q->header_user_len = _len;\n    _q->header_dec_len = OFDMFLEXFRAME_H_DEC + _q->header_user_len;\n    _q->header = realloc(_q->header, _q->header_dec_len*sizeof(unsigned char));\n    if (_q->p_header) {\n        packetizer_destroy(_q->p_header);\n    }\n    _q->p_header = packetizer_create(_q->header_dec_len,\n                                     _q->header_props.check,\n                                     _q->header_props.fec0,\n                                     _q->header_props.fec1);\n    _q->header_enc_len = packetizer_get_enc_msg_len(_q->p_header);\n    _q->header_enc = realloc(_q->header_enc, _q->header_enc_len*sizeof(unsigned char));\n    unsigned int bps = modulation_types[_q->header_props.mod_scheme].bps;\n    div_t bps_d = div(_q->header_enc_len*8, bps);\n    _q->header_sym_len = bps_d.quot + (bps_d.rem ? 1 : 0);\n    _q->header_mod = realloc(_q->header_mod, _q->header_sym_len*sizeof(unsigned char));\n    if (_q->mod_header) {\n        modemcf_destroy(_q->mod_header);\n    }\n    _q->mod_header = modemcf_create(_q->header_props.mod_scheme);\n    div_t d = div(_q->header_sym_len, _q->M_data);\n    _q->num_symbols_header = d.quot + (d.rem ? 1 : 0);\n    return LIQUID_OK;\n}\nint ofdmflexframegen_reconfigure(ofdmflexframegen _q)\n{\n    _q->p_payload = packetizer_recreate(_q->p_payload,\n                                        _q->payload_dec_len,\n                                        _q->props.check,\n                                        _q->props.fec0,\n                                        _q->props.fec1);\n    _q->payload_enc_len = packetizer_get_enc_msg_len(_q->p_payload);\n    _q->payload_enc = (unsigned char*) realloc(_q->payload_enc,\n                                               _q->payload_enc_len*sizeof(unsigned char));\n#if DEBUG_OFDMFLEXFRAMEGEN\n#endif\n    _q->mod_payload = modemcf_recreate(_q->mod_payload, _q->props.mod_scheme);\n    unsigned int bps = modulation_types[_q->props.mod_scheme].bps;\n    div_t d = div(8*_q->payload_enc_len, bps);\n    _q->payload_mod_len = d.quot + (d.rem ? 1 : 0);\n    _q->payload_mod = (unsigned char*)realloc(_q->payload_mod,\n                                              _q->payload_mod_len*sizeof(unsigned char));\n    d = div(_q->payload_mod_len, _q->M_data);\n    _q->num_symbols_payload = d.quot + (d.rem ? 1 : 0);\n    return LIQUID_OK;\n}\nint ofdmflexframegen_setprops(ofdmflexframegen _q,\n                              ofdmflexframegenprops_s * _props)\n{\n    if (_props == NULL)\n        return ofdmflexframegen_setprops(_q, &ofdmflexframegenprops_default);\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframegen_setprops(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframegen_setprops(), invalid/unsupported FEC scheme"");\n    if (_props->mod_scheme == LIQUID_MODEM_UNKNOWN )\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframegen_setprops(), invalid/unsupported modulation scheme"");\n    memmove(&_q->props, _props, sizeof(ofdmflexframegenprops_s));\n    return ofdmflexframegen_reconfigure(_q);\n}\nofdmflexframegen ofdmflexframegen_create(unsigned int              _M,\n                                         unsigned int              _cp_len,\n                                         unsigned int              _taper_len,\n                                         unsigned char *           _p,\n                                         ofdmflexframegenprops_s * _fgprops)\n{\n    if (_M < 8)\n        return liquid_error_config(""ofdmflexframegen_create(), number of subcarriers must be at least 8"");\n    if (_M % 2)\n        return liquid_error_config(""ofdmflexframegen_create(), number of subcarriers must be even"");\n    if (_cp_len > _M)\n        return liquid_error_config(""ofdmflexframegen_create(), cyclic prefix length cannot exceed number of subcarriers"");\n    ofdmflexframegen q = (ofdmflexframegen) malloc(sizeof(struct ofdmflexframegen_s));\n    q->M         = _M;          \n    q->cp_len    = _cp_len;     \n    q->taper_len = _taper_len;  \n    q->frame_len = q->M + q->cp_len;    \n    q->X         = (float complex*) malloc((q->M        )*sizeof(float complex));\n    q->buf_tx    = (float complex*) malloc((q->frame_len)*sizeof(float complex));\n    q->buf_index = q->frame_len;\n    q->p = (unsigned char*) malloc((q->M)*sizeof(unsigned char));\n    if (_p == NULL) {\n        ofdmframe_init_default_sctype(q->M, q->p);\n    } else {\n        memmove(q->p, _p, q->M*sizeof(unsigned char));\n    }\n    ofdmframe_validate_sctype(q->p, q->M, &q->M_null, &q->M_pilot, &q->M_data);\n    q->fg = ofdmframegen_create(q->M, q->cp_len, q->taper_len, q->p);\n    q->header = NULL;\n    q->p_header = NULL;\n    q->header_enc = NULL;\n    q->header_mod = NULL;\n    q->mod_header = NULL;\n    q->header_user_len = OFDMFLEXFRAME_H_USER_DEFAULT;\n    ofdmflexframegen_set_header_props(q, NULL);\n    q->payload_dec_len = 1;\n    q->p_payload = packetizer_create(q->payload_dec_len,\n                                     LIQUID_CRC_NONE,\n                                     LIQUID_FEC_NONE,\n                                     LIQUID_FEC_NONE);\n    q->payload_enc_len = packetizer_get_enc_msg_len(q->p_payload);\n    q->payload_enc = (unsigned char*) malloc(q->payload_enc_len*sizeof(unsigned char));\n    q->payload_mod_len = 1;\n    q->payload_mod = (unsigned char*) malloc(q->payload_mod_len*sizeof(unsigned char));\n    q->mod_payload = modemcf_create(LIQUID_MODEM_QPSK);\n    ofdmflexframegen_setprops(q, _fgprops);\n    ofdmflexframegen_reset(q);\n    return q;\n}\n//...')
"
"('Prompt: Can you provide a code snippet for testing an Elliptic high-pass filter design algorithm in a signal processing library? The scenario includes defining filter parameters such as order, cutoff frequency, passband ripple, and stopband attenuation, creating an Elliptic high-pass filter prototype using these parameters, calculating the power spectral density response over a specified range, and validating the filter response against predefined spectral regions. The output should also include information regarding the filter design and spectrum validation results.","//...\nvoid autotest_iirdes_ellip_highpass() {\n    unsigned int n  =    9;   \n    float        fc =  0.2;   \n    float        Ap =  0.1;   \n    float        as = 60.0;   \n    float        tol  = 1e-3f;  \n    unsigned int nfft = 800;    \n    iirfilt_crcf q = iirfilt_crcf_create_prototype(LIQUID_IIRDES_ELLIP,\n        LIQUID_IIRDES_HIGHPASS, LIQUID_IIRDES_SOS,n,fc,0.0f,Ap,as);\n    if (liquid_autotest_verbose)\n        iirfilt_crcf_print(q);\n    unsigned int i;\n    float H[nfft]; \n    for (i=0; i<nfft; i++)\n        H[i] = iirfilt_crcf_get_psd(q, (float)i/(float)nfft-0.5f);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5,   .fmax=-fc,   .pmin=-Ap-tol, .pmax=   +tol, .test_lo=1, .test_hi=1},\n      {.fmin=-0.184, .fmax=0.184, .pmin=0,       .pmax=-as+tol, .test_lo=0, .test_hi=1},\n      {.fmin=fc,     .fmax=0.5,   .pmin=-Ap-tol, .pmax=   +tol, .test_lo=1, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(H, nfft, regions, 3,\n        liquid_autotest_verbose ? ""autotest/logs/iirdes_ellip_highpass.m"" : NULL);\n    iirfilt_crcf_destroy(q);\n}\n//...')
"
"('Prompt: In a software project, you are working on a data structure implementation for vectors of complex numbers. You need to define a macro that will generate a unique name for each vector type based on the specified name input. The vector should store elements of type float complex, with a corresponding type pointer defined as float. Please provide a code snippet for the macro definition, considering these requirements.","#define VECTOR(name)    LIQUID_CONCAT(liquid_vectorcf,name)\n#define T               float complex\n#define TP              float')
"
('Given the following scenario: You are testing a function called `liquid_rosenbrock` with different input configurations in an optimization library. Your goal is to ensure that the function behaves as expected with a variety of input vectors. The function calculates the Rosenbrock function value for a given input vector using a specific algorithm. You need to write a test function named `autotest_optim_rosenbrock` that includes multiple test cases with different input vectors and expected output values. The test function should handle potential errors and unexpected behavior.,"//...\nvoid autotest_optim_rosenbrock()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping rosenbrock config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    float v_ones[8] = {1,1,1,1,1,1,1,1};\n    CONTEND_DELTA( liquid_rosenbrock(NULL, v_ones, 8), 0.0f, 1e-6f )\n    CONTEND_DELTA( liquid_rosenbrock(NULL, v_ones, 1), 0.0f, 1e-6f )\n    float v_misc[8] = {0.3, 1.0, 4.5,-2.2, 6.7,-0.2, 1.1,-0.9,};\n    CONTEND_GREATER_THAN( liquid_rosenbrock(NULL, v_misc, 8), 1000.0f )\n    CONTEND_EQUALITY( liquid_rosenbrock(NULL, v_misc, 0), 0.0f )\n}\n//...')
"
"('Prompt: I would like you to write a C function that creates a packetizer, encodes and decodes a message, and then destroys the packetizer. The function should take in four parameters: an unsigned integer _n, a CRC scheme _crc, and two FEC schemes _fec0 and _fec1. Inside the function, you should create a packetizer with the given parameters, encode a message, decode the packet, and then compare the decoded message with the original message. Additionally, check if the CRC pass is successful. Lastly, ensure the packetizer is destroyed at the end. As an example, calling this function with parameters (16, LIQUID_CRC_32, LIQUID_FEC_NONE, LIQUID_FEC_HAMMING74) should perform the specified actions.","//...\nvoid packetizer_test_codec(unsigned int _n,\n                           crc_scheme _crc,\n                           fec_scheme _fec0,\n                           fec_scheme _fec1)\n{\n    unsigned char msg_tx[_n];\n    unsigned char msg_rx[_n];\n    unsigned int pkt_len = packetizer_compute_enc_msg_len(_n,_crc,_fec0,_fec1);\n    unsigned char packet[pkt_len];\n    packetizer p = packetizer_create(_n,_crc,_fec0,_fec1);\n    if (liquid_autotest_verbose)\n        packetizer_print(p);\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg_tx[i] = i % 256;\n        msg_rx[i] = 0;\n    }\n    packetizer_encode(p, msg_tx, packet);\n    int crc_pass = packetizer_decode(p, packet, msg_rx);\n    CONTEND_SAME_DATA(msg_tx, msg_rx, _n);\n    CONTEND_EQUALITY(crc_pass, 1);\n    packetizer_destroy(p);\n}\nvoid autotest_packetizer_n16_0_2()  { packetizer_test_codec(16, LIQUID_CRC_32, LIQUID_FEC_NONE, LIQUID_FEC_HAMMING74);  }\n//...')
"
"('Prompt: You are working on a project where you need to implement Frequency Shift Keying (FSK) demodulation. You need to create a function to reset the FSK demodulator state and another function to create the FSK demodulator object with specific parameters. Can you provide me with the code for a function that resets the FSK demodulator state and another function that creates the FSK demodulator object with given parameters including bits per symbol, samples per symbol, and bandwidth? Make sure the demodulation map is unique and handle any necessary error cases.","//...\nstruct fskdem_s {\n    unsigned int    m;          \n    unsigned int    k;          \n    float           bandwidth;  \n    unsigned int    M;          \n    float           M2;         \n    unsigned int    K;          \n    float complex * buf_time;   \n    float complex * buf_freq;   \n    FFT_PLAN        fft;        \n    unsigned int *  demod_map;  \n    unsigned int    s_demod;    \n};\nint fskdem_reset(fskdem _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->K; i++) {\n        _q->buf_time[i] = 0.0f;\n        _q->buf_freq[i] = 0.0f;\n    }\n    _q->s_demod = 0;\n    return LIQUID_OK;\n}\nfskdem fskdem_create(unsigned int _m,\n                     unsigned int _k,\n                     float        _bandwidth)\n{\n    if (_m == 0)\n        return liquid_error_config(""fskdem_create(), bits/symbol must be greater than 0"");\n    if (_k < 2 || _k > 2048)\n        return liquid_error_config(""fskdem_create(), samples/symbol must be in [2^_m, 2048]"");\n    if (_bandwidth <= 0.0f || _bandwidth >= 0.5f)\n        return liquid_error_config(""fskdem_create(), bandwidth must be in (0,0.5)"");\n    fskdem q = (fskdem) malloc(sizeof(struct fskdem_s));\n    q->m         = _m;              \n    q->k         = _k;              \n    q->bandwidth = _bandwidth;      \n    q->M  = 1 << q->m;              \n    q->M2 = 0.5f*(float)(q->M-1);   \n    float        df = q->bandwidth / q->M2;         \n    float        err_min = 1e9f;                    \n    unsigned int K_min = q->k;                      \n    unsigned int K_max = q->k*4 < 16 ? 16 : q->k*4; \n    unsigned int K_hat;\n    for (K_hat=K_min; K_hat<=K_max; K_hat++) {\n        float v     = 0.5f*df*(float)K_hat;         \n        float err = fabsf( roundf(v) - v );         \n#if DEBUG_FSKDEM\n        printf(""  K_hat = %4u : v = %12.8f, err=%12.8f %s\\n"", K_hat, v, err, err < err_min ? ""*"" : """");\n#endif\n        if (K_hat==K_min || err < err_min) {\n            q->K    = K_hat;\n            err_min = err;\n        }\n        if (err < 1e-6f)\n            break;\n    }\n    q->demod_map = (unsigned int *) malloc(q->M * sizeof(unsigned int));\n    unsigned int i;\n    for (i=0; i<q->M; i++) {\n        float freq = ((float)i - q->M2) * q->bandwidth / q->M2;\n        float idx  = freq * (float)(q->K);\n        unsigned int index = (unsigned int) (idx < 0 ? roundf(idx + q->K) : roundf(idx));\n        q->demod_map[i] = index;\n#if DEBUG_FSKDEM\n        printf(""  s=%3u, f = %12.8f, index=%3u\\n"", i, freq, index);\n#endif\n    }\n    for (i=1; i<q->M; i++) {\n        if (q->demod_map[i] == q->demod_map[i-1]) {\n            liquid_error(LIQUID_EICONFIG,""fskdem_create(), demod map is not unique; consider increasing bandwidth"");\n            break;\n        }\n    }\n    q->buf_time = (float complex*) FFT_MALLOC(q->K * sizeof(float complex));\n    q->buf_freq = (float complex*) FFT_MALLOC(q->K * sizeof(float complex));\n    q->fft = FFT_CREATE_PLAN(q->K, q->buf_time, q->buf_freq, FFT_DIR_FORWARD, 0);\n    fskdem_reset(q);\n    return q;\n}\n//...')
"
'Please provide a detailed technical scenario or task that requires parsing a string representing a date and time according to a specific format using the `strptime` function in C programming language.,"//...\nchar *strptime(const char *buf, const char *fmt, struct tm *tm) {\n    char c;\n    const char *bp;\n    size_t len = 0;\n    int alt_format, i, split_year = 0;\n    static const char *day[7] = {\n\t ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"",\n\t ""Friday"", ""Saturday""\n    };\n    static const char *abday[7] = {\n\t ""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""\n    };\n    static const char *mon[12] = {\n\t ""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"",\n\t ""August"", ""September"", ""October"", ""November"", ""December""\n    };\n    static const char *abmon[12] = {\n\t ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",\n\t ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""\n    };\n    static const char *am_pm[2] = {\n\t ""AM"", ""PM""\n    };\n    bp = buf;\n    while ((c = *fmt) != \'\\0\') {\n        alt_format = 0;\n        if (isspace(c)) {\n            while (isspace(*bp)) bp++;\n            fmt++;\n            continue;\n        }\n        if ((c = *fmt++) != \'%\') goto literal;\nagain:  switch (c = *fmt++) {\n            case \'%\': \n                literal:\n                    if (c != *bp++) return (0);\n                    break;\n            case \'E\': \n                LEGAL_ALT(0);\n                alt_format |= ALT_E;\n                goto again;\n            case \'O\': \n                LEGAL_ALT(0);\n                alt_format |= ALT_O;\n                goto again;\n            case \'c\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%x %X"", tm)) == 0) return (0);\n                break;\n            case \'D\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%m/%d/%y"", tm)) == 0) return (0);\n                break;\n            case \'R\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%H:%M"", tm)) == 0) return (0);\n                break;\n            case \'r\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%I:%M:%S %p"", tm)) == 0) return (0);\n                break;\n            case \'T\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%H:%M:%S"", tm)) == 0) return (0);\n                break;\n            case \'X\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%H:%M:%S"", tm)) == 0) return (0);\n                break;\n            case \'x\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%m/%d/%y"", tm)) == 0) return (0);\n                break;\n            case \'A\': \n            case \'a\':\n                LEGAL_ALT(0);\n                for (i = 0; i < 7; i++) {\n                    len = strlen(day[i]);\n                    if (strncasecmp((char *)(day[i]), (char *)bp, len) == 0) break;\n                    len = strlen(abday[i]);\n                    if (strncasecmp((char *)(abday[i]), (char *)bp, len) == 0) break;\n                }\n                if (i == 7) return (0);\n                tm->tm_wday = i;\n                bp += len;\n                break;\n            case \'B\': \n            case \'b\':\n            case \'h\':\n                LEGAL_ALT(0);\n                for (i = 0; i < 12; i++) {\n                    len = strlen(mon[i]);\n                    if (strncasecmp((char *)(mon[i]), (char *)bp, len) == 0) break;\n                    len = strlen(abmon[i]);\n                    if (strncasecmp((char *)(abmon[i]),(char *) bp, len) == 0) break;\n                }\n                if (i == 12) return (0);\n                tm->tm_mon = i;\n                bp += len;\n                break;\n            case \'C\': \n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 99))) return (0);\n                if (split_year) {\n                    tm->tm_year = (tm->tm_year % 100) + (i * 100);\n                } else {\n                    tm->tm_year = i * 100;\n                    split_year = 1;\n                }\n                break;\n            case \'d\': \n            case \'e\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_mday, 1, 31))) return (0);\n                break;\n            case \'k\': \n                LEGAL_ALT(0);\n            case \'H\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 0, 23))) return (0);\n                break;\n            case \'l\': \n                LEGAL_ALT(0);\n            case \'I\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 1, 12))) return (0);\n                if (tm->tm_hour == 12) tm->tm_hour = 0;\n                break;\n            case \'j\': \n                LEGAL_ALT(0);\n                if (!(conv_num(&bp, &i, 1, 366))) return (0);\n                tm->tm_yday = i - 1;\n                break;\n            case \'M\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_min, 0, 59))) return (0);\n                break;\n            case \'m\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 1, 12))) return (0);\n                tm->tm_mon = i - 1;\n                break;\n            case \'S\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_sec, 0, 61))) return (0);\n                break;\n            case \'U\': \n            case \'W\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 0, 53))) return (0);\n                break;\n            case \'w\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_wday, 0, 6))) return (0);\n                break;\n            case \'Y\': \n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 9999))) return (0);\n                tm->tm_year = i - TM_YEAR_BASE;\n                break;\n            case \'y\': \n                LEGAL_ALT(ALT_E | ALT_O);\n                if (!(conv_num(&bp, &i, 0, 99))) return (0);\n                if (split_year)\n                {\n                    tm->tm_year = ((tm->tm_year / 100) * 100) + i;\n                    break;\n                }\n                split_year = 1;\n                if (i <= 68)\n                    tm->tm_year = i + 2000 - TM_YEAR_BASE;\n                else\n                    tm->tm_year = i + 1900 - TM_YEAR_BASE;\n                break;\n            case \'n\': \n            case \'t\':\n                LEGAL_ALT(0);\n                while (isspace(*bp)) bp++;\n                break;\n            default: \n                return (0);\n        }\n    }\n    return ((char *)bp);\n}\nstatic int conv_num(const char **, int *, int, int);\nstatic int strncasecmp(char *s1, char *s2, size_t n);\nchar *strptime(const char *buf, const char *fmt, struct tm *tm) {\n    char c;\n    const char *bp;\n    size_t len = 0;\n    int alt_format, i, split_year = 0;\n    static const char *day[7] = {\n\t ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"",\n\t ""Friday"", ""Saturday""\n    };\n    static const char *abday[7] = {\n\t ""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""\n    };\n    static const char *mon[12] = {\n\t ""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"",\n\t ""August"", ""September"", ""October"", ""November"", ""December""\n    };\n    static const char *abmon[12] = {\n\t ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",\n\t ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""\n    };\n    static const char *am_pm[2] = {\n\t ""AM"", ""PM""\n    };\n    bp = buf;\n    while ((c = *fmt) != \'\\0\') {\n        alt_format = 0;\n        if (isspace(c)) {\n            while (isspace(*bp)) bp++;\n            fmt++;\n            continue;\n        }\n        if ((c = *fmt++) != \'%\') goto literal;\nagain:  switch (c = *fmt++) {\n            case \'%\': \n                literal:\n                    if (c != *bp++) return (0);\n                    break;\n            case \'E\': \n                LEGAL_ALT(0);\n                alt_format |= ALT_E;\n                goto again;\n            case \'O\': \n                LEGAL_ALT(0);\n                alt_format |= ALT_O;\n                goto again;\n            case \'c\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%x %X"", tm)) == 0) return (0);\n                break;\n            case \'D\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%m/%d/%y"", tm)) == 0) return (0);\n                break;\n            case \'R\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%H:%M"", tm)) == 0) return (0);\n                break;\n            case \'r\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%I:%M:%S %p"", tm)) == 0) return (0);\n                break;\n            case \'T\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%H:%M:%S"", tm)) == 0) return (0);\n                break;\n            case \'X\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%H:%M:%S"", tm)) == 0) return (0);\n                break;\n            case \'x\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%m/%d/%y"", tm)) == 0) return (0);\n                break;\n            case \'A\': \n            case \'a\':\n                LEGAL_ALT(0);\n                for (i = 0; i < 7; i++) {\n                    len = strlen(day[i]);\n                    if (strncasecmp((char *)(day[i]), (char *)bp, len) == 0) break;\n                    len = strlen(abday[i]);\n                    if (strncasecmp((char *)(abday[i]), (char *)bp, len) == 0) break;\n                }\n                if (i == 7) return (0);\n                tm->tm_wday = i;\n                bp += len;\n                break;\n            case \'B\': \n            case \'b\':\n            case \'h\':\n                LEGAL_ALT(0);\n                for (i = 0; i < 12; i++) {\n                    len = strlen(mon[i]);\n                    if (strncasecmp((char *)(mon[i]), (char *)bp, len) == 0) break;\n                    len = strlen(abmon[i]);\n                    if (strncasecmp((char *)(abmon[i]),(char *) bp, len) == 0) break;\n                }\n                if (i == 12) return (0);\n                tm->tm_mon = i;\n                bp += len;\n                break;\n            case \'C\': \n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 99))) return (0);\n                if (split_year) {\n                    tm->tm_year = (tm->tm_year % 100) + (i * 100);\n                } else {\n                    tm->tm_year = i * 100;\n                    split_year = 1;\n                }\n                break;\n            case \'d\': \n            case \'e\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_mday, 1, 31))) return (0);\n                break;\n            case \'k\': \n                LEGAL_ALT(0);\n            case \'H\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 0, 23))) return (0);\n                break;\n            case \'l\': \n                LEGAL_ALT(0);\n            case \'I\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 1, 12))) return (0);\n                if (tm->tm_hour == 12) tm->tm_hour = 0;\n                break;\n            case \'j\': \n                LEGAL_ALT(0);\n                if (!(conv_num(&bp, &i, 1, 366))) return (0);\n                tm->tm_yday = i - 1;\n                break;\n            case \'M\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_min, 0, 59))) return (0);\n                break;\n            case \'m\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 1, 12))) return (0);\n                tm->tm_mon = i - 1;\n                break;\n            case \'S\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_sec, 0, 61))) return (0);\n                break;\n            case \'U\': \n            case \'W\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 0, 53))) return (0);\n                break;\n            case \'w\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_wday, 0, 6))) return (0);\n                break;\n            case \'Y\': \n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 9999))) return (0);\n                tm->tm_year = i - TM_YEAR_BASE;\n                break;\n            case \'y\': \n                LEGAL_ALT(ALT_E | ALT_O);\n                if (!(conv_num(&bp, &i, 0, 99))) return (0);\n                if (split_year)\n                {\n                    tm->tm_year = ((tm->tm_year / 100) * 100) + i;\n                    break;\n                }\n                split_year = 1;\n                if (i <= 68)\n                    tm->tm_year = i + 2000 - TM_YEAR_BASE;\n                else\n                    tm->tm_year = i + 1900 - TM_YEAR_BASE;\n                break;\n            case \'n\': \n            case \'t\':\n                LEGAL_ALT(0);\n                while (isspace(*bp)) bp++;\n                break;\n            default: \n                return (0);\n        }\n    }\n    return ((char *)bp);\n}\nstatic int conv_num(const char **buf, int *dest, int llim, int ulim) {\n    int result = 0;\n    int rulim = ulim;\n    if (**buf < \'0\' || **buf > \'9\') return (0);\n    do {\n        result *= 10;\n        result += *(*buf)++ - \'0\';\n        rulim /= 10;\n    } while ((result * 10 <= ulim) && rulim && **buf >= \'0\' && **buf <= \'9\');\n    if (result < llim || result > ulim) return (0);\n    *dest = result;\n    return (1);\n}\nstatic int strncasecmp(char *s1, char *s2, size_t n) {\n    if (n == 0) return 0;\n    while (n-- != 0 && tolower(*s1) == tolower(*s2)) {\n        if (n == 0 || *s1 == \'\\0\' || *s2 == \'\\0\') break;\n        s1++;\n        s2++;\n    }\n    return tolower(*(unsigned char *) s1) - tolower(*(unsigned char *) s2);\n}\nchar *strptime(const char *buf, const char *fmt, struct tm *tm) {\n    char c;\n    const char *bp;\n    size_t len = 0;\n    int alt_format, i, split_year = 0;\n    static const char *day[7] = {\n\t ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"",\n\t ""Friday"", ""Saturday""\n    };\n    static const char *abday[7] = {\n\t ""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""\n    };\n    static const char *mon[12] = {\n\t ""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"",\n\t ""August"", ""September"", ""October"", ""November"", ""December""\n    };\n    static const char *abmon[12] = {\n\t ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",\n\t ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""\n    };\n    static const char *am_pm[2] = {\n\t ""AM"", ""PM""\n    };\n    bp = buf;\n    while ((c = *fmt) != \'\\0\') {\n        alt_format = 0;\n        if (isspace(c)) {\n            while (isspace(*bp)) bp++;\n            fmt++;\n            continue;\n        }\n        if ((c = *fmt++) != \'%\') goto literal;\nagain:  switch (c = *fmt++) {\n            case \'%\': \n                literal:\n                    if (c != *bp++) return (0);\n                    break;\n            case \'E\': \n                LEGAL_ALT(0);\n                alt_format |= ALT_E;\n                goto again;\n            case \'O\': \n                LEGAL_ALT(0);\n                alt_format |= ALT_O;\n                goto again;\n            case \'c\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%x %X"", tm)) == 0) return (0);\n                break;\n            case \'D\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%m/%d/%y"", tm)) == 0) return (0);\n                break;\n            case \'R\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%H:%M"", tm)) == 0) return (0);\n                break;\n            case \'r\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%I:%M:%S %p"", tm)) == 0) return (0);\n                break;\n            case \'T\': \n                LEGAL_ALT(0);\n                if ((bp = strptime(bp, ""%H:%M:%S"", tm)) == 0) return (0);\n                break;\n            case \'X\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%H:%M:%S"", tm)) == 0) return (0);\n                break;\n            case \'x\': \n                LEGAL_ALT(ALT_E);\n                if ((bp = strptime(bp, ""%m/%d/%y"", tm)) == 0) return (0);\n                break;\n            case \'A\': \n            case \'a\':\n                LEGAL_ALT(0);\n                for (i = 0; i < 7; i++) {\n                    len = strlen(day[i]);\n                    if (strncasecmp((char *)(day[i]), (char *)bp, len) == 0) break;\n                    len = strlen(abday[i]);\n                    if (strncasecmp((char *)(abday[i]), (char *)bp, len) == 0) break;\n                }\n                if (i == 7) return (0);\n                tm->tm_wday = i;\n                bp += len;\n                break;\n            case \'B\': \n            case \'b\':\n            case \'h\':\n                LEGAL_ALT(0);\n                for (i = 0; i < 12; i++) {\n                    len = strlen(mon[i]);\n                    if (strncasecmp((char *)(mon[i]), (char *)bp, len) == 0) break;\n                    len = strlen(abmon[i]);\n                    if (strncasecmp((char *)(abmon[i]),(char *) bp, len) == 0) break;\n                }\n                if (i == 12) return (0);\n                tm->tm_mon = i;\n                bp += len;\n                break;\n            case \'C\': \n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 99))) return (0);\n                if (split_year) {\n                    tm->tm_year = (tm->tm_year % 100) + (i * 100);\n                } else {\n                    tm->tm_year = i * 100;\n                    split_year = 1;\n                }\n                break;\n            case \'d\': \n            case \'e\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_mday, 1, 31))) return (0);\n                break;\n            case \'k\': \n                LEGAL_ALT(0);\n            case \'H\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 0, 23))) return (0);\n                break;\n            case \'l\': \n                LEGAL_ALT(0);\n            case \'I\':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 1, 12))) return (0);\n                if (tm->tm_hour == 12) tm->tm_hour = 0;\n                break;\n            case \'j\': \n                LEGAL_ALT(0);\n                if (!(conv_num(&bp, &i, 1, 366))) return (0);\n                tm->tm_yday = i - 1;\n                break;\n            case \'M\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_min, 0, 59))) return (0);\n                break;\n            case \'m\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 1, 12))) return (0);\n                tm->tm_mon = i - 1;\n                break;\n            case \'S\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_sec, 0, 61))) return (0);\n                break;\n            case \'U\': \n            case \'W\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 0, 53))) return (0);\n                break;\n            case \'w\': \n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_wday, 0, 6))) return (0);\n                break;\n            case \'Y\': \n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 9999))) return (0);\n                tm->tm_year = i - TM_YEAR_BASE;\n                break;\n            case \'y\': \n                LEGAL_ALT(ALT_E | ALT_O);\n                if (!(conv_num(&bp, &i, 0, 99))) return (0);\n                if (split_year)\n                {\n                    tm->tm_year = ((tm->tm_year / 100) * 100) + i;\n                    break;\n                }\n                split_year = 1;\n                if (i <= 68)\n                    tm->tm_year = i + 2000 - TM_YEAR_BASE;\n                else\n                    tm->tm_year = i + 1900 - TM_YEAR_BASE;\n                break;\n            case \'n\': \n            case \'t\':\n                LEGAL_ALT(0);\n                while (isspace(*bp)) bp++;\n                break;\n            default: \n                return (0);\n        }\n    }\n    return ((char *)bp);\n}\n//...'"
"('Prompt: . . You are working on implementing error correction using Golay code in a communication system and you want to define a debug variable to enable/disable debugging output related to the Forward Error Correction (FEC) Golay code. Additionally, you need a function to initialize a matrix G of size 288 for Golay encoding. Write code snippets to define DEBUG_FEC_GOLAY as 1, declare an unsigned char array G of size 288, and implement a function golay_init_G() that initializes the matrix G according to Golay code specifications.","//...\n#define DEBUG_FEC_GOLAY 1\nunsigned char G[288];\n    return 0;\nvoid golay_init_G()\n{\n    unsigned int i;\n    unsigned int j;\n    for (i=0; i<12; i++) {\n        for (j=0; j<12; j++)\n            G[i*24 + j] = P[i*12 + j];\n        for (j=0; j<12; j++)\n            G[i*24 + j + 12] = (i==j) ? 1 : 0;\n    }\n}\n//...')
"
"('Please define a set of macros for complex signal processing functions in C that work with floating-point complex numbers. The macros should include definitions for extensions, symbol concatenation, and complex number printing. The extensions should be defined as ""f"" for short and ""cccf"" for full. The complex numbers should be defined as float complex. The macros should include functions for equivalent least mean square, equivalent recursive least squares, dot product, window, and matrix operations on complex numbers. Lastly, please provide a macro for printing complex values in a formatted manner.","#define EXTENSION_SHORT ""f""\n#define EXTENSION_FULL  ""cccf""\n#define EQLMS(name)     LIQUID_CONCAT(eqlms_cccf,name)\n#define EQRLS(name)     LIQUID_CONCAT(eqrls_cccf,name)\n#define DOTPROD(name)   LIQUID_CONCAT(dotprod_cccf,name)\n#define WINDOW(name)    LIQUID_CONCAT(windowcf,name)\n#define MATRIX(name)    LIQUID_CONCAT(matrixcf,name)\n#define T_COMPLEX       1\n#define T               float complex\n#define PRINTVAL(V)     printf(""%5.2f+j%5.2f "", crealf(V), cimagf(V));')
"
"('Prompt: Can you provide a code snippet for a function that prints out the values of a gradsearch struct object, including the u value and step size with a detailed format, but excluding the pnorm and delta values? The output should display the step size, parameter vector, and a newline character at the end.","//...\nvoid gradsearch_print(gradsearch _q)\n{\n    printf(""u=%12.4e "",   _q->u);       \n#if 0\n    printf(""|p|=%7.1e "",  _q->pnorm);   \n    printf(""del=%7.1e "",  _q->delta);   \n#endif\n    printf(""step=%7.1e "", _q->alpha);   \n    unsigned int i;\n    printf(""{"");\n    for (i=0; i<_q->num_parameters; i++)\n        printf(""%8.4f"", _q->v[i]);\n    printf(""}\\n"");\n}\n//...')
"
"'Prompt: You are working on a project that involves file handling in C. You need to write a function that performs various file operations using a file backend. The function should open a file, write ""hello file"" to it, sync the file, read the contents of the file, seek to the beginning of the file, and read the contents again. It should then print the read length and the content of the buffer, followed by the size of the file. Additionally, the function should dump the file contents to an IO buffer and destroy it. Please write this function code in C.","//...\n        return -1;\n    return 0;\nstatic void foo(void)\n{\n    int len = 0;\n    int i = 0;\n    file_backend_type type;\n    struct file *fw;\n    struct file *f;\n    struct iovec *iobuf;\n    char buf[128] = {0};\n    for (i = 0; i < 2; ++i) {\n        if (i == 0)\n            type = FILE_BACKEND_IO;\n        else if (i == 1)\n            type = FILE_BACKEND_FIO;\n        file_backend(type);\n        printf(""backend=%d\\n"", type);\n        fw = file_open(""lsusb"", F_CREATE);\n        file_write(fw, ""hello file\\n"", 11);\n        file_sync(fw);\n        file_seek(fw, 0, SEEK_SET);\n        memset(buf, 0, sizeof(buf));\n        len = file_read(fw, buf, sizeof(buf));\n        printf(""read len = %d, buf = %s"", len, buf);\n        file_close(fw);\n        f = file_open(""lsusb"", F_RDONLY);\n        memset(buf, 0, sizeof(buf));\n        len = file_read(f, buf, sizeof(buf));\n        printf(""read len = %d, buf = %s"", len, buf);\n        printf(""len=%zu\\n"", file_get_size(""lsusb""));\n        iobuf = file_dump(""lsusb"");\n        if (iobuf) {\n        }\n        iovec_destroy(iobuf);\n        file_close(f);\n    }\n}\n//...'"
"'Prompt: ""I need a function that retrieves the value of the i-th bit of an integer x. The function should take in two parameters - the integer x and the position i of the bit to retrieve. Can you provide me with a C++ code snippet for this function?""","//...\nstatic bool getBit(int x, int i)\n{\n    return ((x >> i) & 1) != 0;\n}\n//...'"
('Prompt: You are working on optimizing a dot product operation for complex numbers in a communication system. Your goal is to implement the operation using NEON instructions in ARM architecture for improved performance. Can you provide optimized NEON assembly code for vectorized dot product calculation for 4 complex numbers at a time?,"//...\nint dotprod_crcf_execute_neon4(dotprod_crcf    _q,\n                               float complex * _x,\n                               float complex * _y)\n{\n#if 1\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    float32x4_t v0, v1, v2, v3;  \n    float32x4_t h0, h1, h2, h3;  \n    float32x4_t s0, s1, s2, s3;  \n    float zeros[4] = {0,0,0,0};\n    float32x4_t sum0 = vld1q_f32(zeros);\n    float32x4_t sum1 = vld1q_f32(zeros);\n    float32x4_t sum2 = vld1q_f32(zeros);\n    float32x4_t sum3 = vld1q_f32(zeros);\n    unsigned int r = (n >> 4) << 2;\n    unsigned int i;\n    for (i=0; i<r; i+=4) {\n        v0 = vld1q_f32(&x[4*i+0]);\n        v1 = vld1q_f32(&x[4*i+4]);\n        v2 = vld1q_f32(&x[4*i+8]);\n        v3 = vld1q_f32(&x[4*i+12]);\n        h0 = vld1q_f32(&_q->h[4*i+0]);\n        h1 = vld1q_f32(&_q->h[4*i+4]);\n        h2 = vld1q_f32(&_q->h[4*i+8]);\n        h3 = vld1q_f32(&_q->h[4*i+12]);\n        s0 = vmulq_f32(v0, h0);\n        s1 = vmulq_f32(v1, h1);\n        s2 = vmulq_f32(v2, h2);\n        s3 = vmulq_f32(v3, h3);\n        sum0 = vaddq_f32( sum0, s0 );\n        sum1 = vaddq_f32( sum1, s1 );\n        sum2 = vaddq_f32( sum2, s2 );\n        sum3 = vaddq_f32( sum3, s3 );\n    }\n    sum0 = vaddq_f32( sum0, sum1 );\n    sum2 = vaddq_f32( sum2, sum3 );\n    sum0 = vaddq_f32( sum0, sum2 );\n    float w[4];\n    vst1q_f32(w, sum0);\n    w[0] += w[2];\n    w[1] += w[3];\n    for (i=4*r; i<n; i+=2) {\n        w[0] += x[i  ] * _q->h[i  ];\n        w[1] += x[i+1] * _q->h[i+1];\n    }\n    *_y = w[0] + w[1]*_Complex_I;\n#else\n    dotprod_crcf_execute_neon(_q, _x, _y);\n#endif\n    return LIQUID_OK;\n}\nint dotprod_crcf_execute(dotprod_crcf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 32) {\n        return dotprod_crcf_execute_neon(_q, _x, _y);\n    }\n    return dotprod_crcf_execute_neon4(_q, _x, _y);\n}\nint dotprod_crcf_execute_neon(dotprod_crcf    _q,\n                              float complex * _x,\n                              float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    float32x4_t v;   \n    float32x4_t h;   \n    float32x4_t s;   \n    float zeros[4] = {0,0,0,0};\n    float32x4_t sum = vld1q_f32(zeros);\n    unsigned int t = (n >> 2) << 2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        v = vld1q_f32(&x[i]);\n        h = vld1q_f32(&_q->h[i]);\n        s = vmulq_f32(h,v);\n        sum = vaddq_f32(sum, s);\n    }\n    float w[4];\n    vst1q_f32(w, sum);\n    w[0] += w[2];\n    w[1] += w[3];\n    for (; i<n; i+=2) {\n        w[0] += x[i  ] * _q->h[i  ];\n        w[1] += x[i+1] * _q->h[i+1];\n    }\n    *_y = w[0] + _Complex_I*w[1];\n    return LIQUID_OK;\n}\nint dotprod_crcf_execute(dotprod_crcf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 32) {\n        return dotprod_crcf_execute_neon(_q, _x, _y);\n    }\n    return dotprod_crcf_execute_neon4(_q, _x, _y);\n}\n//...')
"
"('Prompt: You are implementing an error correction library and you need a function that deallocates memory associated with a forward error correction object. Write a C function that takes a forward error correction object as input, frees the memory allocated for it, and returns an integer value representing success.","//...\nint fec_pass_destroy(fec _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
"('The prompt could have been: ""Design a set of benchmark functions for interleaving operations with different block sizes. Each benchmark function should take start and finish struct rusage pointers, a number of iterations pointer, and an input block size N. The benchmark function should calculate the number of iterations, create an interleaver with depth 4 for the given block size, and encode the input block multiple times using the interleaver. Finally, it should measure the CPU time used for the encoding operations. Design benchmark functions for block sizes 8, 16, 32, 64, 128, 256, 512, and 1024.""","#define INTERLEAVER_BENCH_API(N)        \\\n(   struct rusage *_start,              \\\n    struct rusage *_finish,             \\\n    unsigned long int *_num_iterations) \\\n{ interleaver_bench(_start, _finish, _num_iterations, N); }\nvoid interleaver_bench(struct rusage *_start,\n                       struct rusage *_finish,\n                       unsigned long int *_num_iterations,\n                       unsigned int _n)\n{\n    *_num_iterations /= 0.7f*expf( -0.883 + 0.708*logf(_n) );\n    interleaver q = interleaver_create(_n);\n    interleaver_set_depth(q, 4);\n    unsigned char x[_n];\n    unsigned char y[_n];\n    unsigned long int i;\n    for (i=0; i<_n; i++)\n        x[i] = rand() & 0xff;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        interleaver_encode(q, x, y);\n        interleaver_encode(q, x, y);\n        interleaver_encode(q, x, y);\n        interleaver_encode(q, x, y);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    interleaver_destroy(q);\n}\nvoid benchmark_interleaver_8    INTERLEAVER_BENCH_API(8     )\nvoid benchmark_interleaver_16   INTERLEAVER_BENCH_API(16    )\nvoid benchmark_interleaver_32   INTERLEAVER_BENCH_API(32    )\nvoid benchmark_interleaver_64   INTERLEAVER_BENCH_API(64    )\nvoid benchmark_interleaver_128  INTERLEAVER_BENCH_API(128   )\nvoid benchmark_interleaver_256  INTERLEAVER_BENCH_API(256   )\nvoid benchmark_interleaver_512  INTERLEAVER_BENCH_API(512   )\nvoid benchmark_interleaver_1024 INTERLEAVER_BENCH_API(1024  )')
"
"('Prompt: Given an OFDM frame synchronization module with a state machine implemented as a struct in C, provide a function that checks if the frame is open based on the state of the module. The struct includes variables M (unsigned int), p (unsigned char pointer), R (complex float pointer), and a debug flag for OFDM frame synchronization. Use embedded C code to implement the function ""ofdmframesync_is_frame_open"" that returns 1 if the state is not OFDMFRAMESYNC_STATE_SEEKPLCP, otherwise return 0.","//...\n    unsigned int M;         \n    unsigned char * p;      \n    float complex * R;      \n#define DEBUG_OFDMFRAMESYNC             0\n    for (i=0; i<_q->M; i++)\nint ofdmframesync_is_frame_open(ofdmframesync _q)\n{\n    return (_q->state == OFDMFRAMESYNC_STATE_SEEKPLCP) ? 0 : 1;\n}\n//...')
"
"('Prompt: You are working on optimizing a digital signal processing algorithm that involves calculating the dot product of two complex arrays `_h` and `_x`. One of the functions you have written takes in the arrays `_h` and `_x`, their length `_n`, and calculates the dot product in a straightforward manner. However, you suspect that there might be a more efficient way to calculate this dot product, especially for large arrays. Can you modify the code to improve performance by taking advantage of loop unrolling to process multiple elements at once in batches of 4?","//...\nint dotprod_cccf_run(float complex * _h,\n                     float complex * _x,\n                     unsigned int    _n,\n                     float complex * _y)\n{\n    float complex r = 0;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\nint dotprod_cccf_run4(float complex * _h,\n                      float complex * _x,\n                      unsigned int    _n,\n                      float complex * _y)\n{\n    float complex r = 0;\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        r += _h[i]   * _x[i];\n        r += _h[i+1] * _x[i+1];\n        r += _h[i+2] * _x[i+2];\n        r += _h[i+3] * _x[i+3];\n    }\n    for ( ; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: In a project utilizing the CEC (Consumer Electronics Control) module with the HAL library enabled, you need to initialize the CEC peripheral for communication between connected devices. Can you provide the code for CEC initialization, deinitialization, setting the device address, and handling CEC communication events using the HAL CEC API functions? This code should include error handling and callback registration for custom handling of CEC events.","#ifdef HAL_CEC_MODULE_ENABLED\n#if defined (CEC)\nHAL_StatusTypeDef HAL_CEC_Init(CEC_HandleTypeDef *hcec)\n{\n  if ((hcec == NULL) || (hcec->Init.RxBuffer == NULL))\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_CEC_ALL_INSTANCE(hcec->Instance));\n  assert_param(IS_CEC_SIGNALFREETIME(hcec->Init.SignalFreeTime));\n  assert_param(IS_CEC_TOLERANCE(hcec->Init.Tolerance));\n  assert_param(IS_CEC_BRERXSTOP(hcec->Init.BRERxStop));\n  assert_param(IS_CEC_BREERRORBITGEN(hcec->Init.BREErrorBitGen));\n  assert_param(IS_CEC_LBPEERRORBITGEN(hcec->Init.LBPEErrorBitGen));\n  assert_param(IS_CEC_BROADCASTERROR_NO_ERRORBIT_GENERATION(hcec->Init.BroadcastMsgNoErrorBitGen));\n  assert_param(IS_CEC_SFTOP(hcec->Init.SignalFreeTimeOption));\n  assert_param(IS_CEC_LISTENING_MODE(hcec->Init.ListenMode));\n  assert_param(IS_CEC_OWN_ADDRESS(hcec->Init.OwnAddress));\n#if (USE_HAL_CEC_REGISTER_CALLBACKS == 1)\n  if (hcec->gState == HAL_CEC_STATE_RESET)\n  {\n    hcec->Lock = HAL_UNLOCKED;\n    hcec->TxCpltCallback  = HAL_CEC_TxCpltCallback;  \n    hcec->RxCpltCallback = HAL_CEC_RxCpltCallback;   \n    hcec->ErrorCallback = HAL_CEC_ErrorCallback;     \n    if (hcec->MspInitCallback == NULL)\n    {\n      hcec->MspInitCallback = HAL_CEC_MspInit; \n    }\n    hcec->MspInitCallback(hcec);\n  }\n#else\n  if (hcec->gState == HAL_CEC_STATE_RESET)\n  {\n    hcec->Lock = HAL_UNLOCKED;\n    HAL_CEC_MspInit(hcec);\n  }\n#endif \n  hcec->gState = HAL_CEC_STATE_BUSY;\n  __HAL_CEC_DISABLE(hcec);\n  hcec->Instance->CFGR = hcec->Init.SignalFreeTime | hcec->Init.Tolerance | hcec->Init.BRERxStop | \\\n                         hcec->Init.BREErrorBitGen | hcec->Init.LBPEErrorBitGen | \\\n                         hcec->Init.BroadcastMsgNoErrorBitGen | \\\n                         hcec->Init.SignalFreeTimeOption | ((uint32_t)(hcec->Init.OwnAddress) << 16U) | \\\n                         hcec->Init.ListenMode;\n  __HAL_CEC_ENABLE_IT(hcec, CEC_IT_RXBR | CEC_IT_RXEND | CEC_IER_RX_ALL_ERR | CEC_IT_TXBR | CEC_IT_TXEND |\n                      CEC_IER_TX_ALL_ERR);\n  __HAL_CEC_ENABLE(hcec);\n  hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n  hcec->gState = HAL_CEC_STATE_READY;\n  hcec->RxState = HAL_CEC_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_CEC_DeInit(CEC_HandleTypeDef *hcec)\n{\n  if (hcec == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_CEC_ALL_INSTANCE(hcec->Instance));\n  hcec->gState = HAL_CEC_STATE_BUSY;\n#if (USE_HAL_CEC_REGISTER_CALLBACKS == 1)\n  if (hcec->MspDeInitCallback == NULL)\n  {\n    hcec->MspDeInitCallback = HAL_CEC_MspDeInit; \n  }\n  hcec->MspDeInitCallback(hcec);\n#else\n  HAL_CEC_MspDeInit(hcec);\n#endif \n  __HAL_CEC_DISABLE(hcec);\n  __HAL_CEC_CLEAR_FLAG(hcec, CEC_FLAG_TXEND | CEC_FLAG_TXBR | CEC_FLAG_RXBR | CEC_FLAG_RXEND | CEC_ISR_ALL_ERROR);\n  __HAL_CEC_DISABLE_IT(hcec, CEC_IT_RXBR | CEC_IT_RXEND | CEC_IER_RX_ALL_ERR | CEC_IT_TXBR | CEC_IT_TXEND |\n                       CEC_IER_TX_ALL_ERR);\n  hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n  hcec->gState = HAL_CEC_STATE_RESET;\n  hcec->RxState = HAL_CEC_STATE_RESET;\n  __HAL_UNLOCK(hcec);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_CEC_SetDeviceAddress(CEC_HandleTypeDef *hcec, uint16_t CEC_OwnAddress)\n{\n  assert_param(IS_CEC_OWN_ADDRESS(CEC_OwnAddress));\n  if ((hcec->gState == HAL_CEC_STATE_READY) && (hcec->RxState == HAL_CEC_STATE_READY))\n  {\n    __HAL_LOCK(hcec);\n    hcec->gState = HAL_CEC_STATE_BUSY;\n    __HAL_CEC_DISABLE(hcec);\n    if (CEC_OwnAddress != CEC_OWN_ADDRESS_NONE)\n    {\n      hcec->Instance->CFGR |= ((uint32_t)CEC_OwnAddress << 16);\n    }\n    else\n    {\n      hcec->Instance->CFGR &= ~(CEC_CFGR_OAR);\n    }\n    hcec->gState = HAL_CEC_STATE_READY;\n    hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n    __HAL_UNLOCK(hcec);\n    __HAL_CEC_ENABLE(hcec);\n    return  HAL_OK;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}\n__weak void HAL_CEC_MspInit(CEC_HandleTypeDef *hcec)\n{\n  UNUSED(hcec);\n}\n__weak void HAL_CEC_MspDeInit(CEC_HandleTypeDef *hcec)\n{\n  UNUSED(hcec);\n}\n#if (USE_HAL_CEC_REGISTER_CALLBACKS == 1)\nHAL_StatusTypeDef HAL_CEC_RegisterCallback(CEC_HandleTypeDef *hcec, HAL_CEC_CallbackIDTypeDef CallbackID,\n                                           pCEC_CallbackTypeDef pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (pCallback == NULL)\n  {\n    hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hcec);\n  if (hcec->gState == HAL_CEC_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CEC_TX_CPLT_CB_ID :\n        hcec->TxCpltCallback = pCallback;\n        break;\n      case HAL_CEC_ERROR_CB_ID :\n        hcec->ErrorCallback = pCallback;\n        break;\n      case HAL_CEC_MSPINIT_CB_ID :\n        hcec->MspInitCallback = pCallback;\n        break;\n      case HAL_CEC_MSPDEINIT_CB_ID :\n        hcec->MspDeInitCallback = pCallback;\n        break;\n      default :\n        hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else if (hcec->gState == HAL_CEC_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CEC_MSPINIT_CB_ID :\n        hcec->MspInitCallback = pCallback;\n        break;\n      case HAL_CEC_MSPDEINIT_CB_ID :\n        hcec->MspDeInitCallback = pCallback;\n        break;\n      default :\n        hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hcec);\n  return status;\n}\nHAL_StatusTypeDef HAL_CEC_UnRegisterCallback(CEC_HandleTypeDef *hcec, HAL_CEC_CallbackIDTypeDef CallbackID)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  __HAL_LOCK(hcec);\n  if (hcec->gState == HAL_CEC_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CEC_TX_CPLT_CB_ID :\n        hcec->TxCpltCallback = HAL_CEC_TxCpltCallback;  \n        break;\n      case HAL_CEC_ERROR_CB_ID :\n        hcec->ErrorCallback = HAL_CEC_ErrorCallback;  \n        break;\n      case HAL_CEC_MSPINIT_CB_ID :\n        hcec->MspInitCallback = HAL_CEC_MspInit;\n        break;\n      case HAL_CEC_MSPDEINIT_CB_ID :\n        hcec->MspDeInitCallback = HAL_CEC_MspDeInit;\n        break;\n      default :\n        hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else if (hcec->gState == HAL_CEC_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CEC_MSPINIT_CB_ID :\n        hcec->MspInitCallback = HAL_CEC_MspInit;\n        break;\n      case HAL_CEC_MSPDEINIT_CB_ID :\n        hcec->MspDeInitCallback = HAL_CEC_MspDeInit;\n        break;\n      default :\n        hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hcec);\n  return status;\n}\nHAL_StatusTypeDef HAL_CEC_RegisterRxCpltCallback(CEC_HandleTypeDef *hcec, pCEC_RxCallbackTypeDef pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (pCallback == NULL)\n  {\n    hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hcec);\n  if (HAL_CEC_STATE_READY == hcec->RxState)\n  {\n    hcec->RxCpltCallback = pCallback;\n  }\n  else\n  {\n    hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hcec);\n  return status;\n}\nHAL_StatusTypeDef HAL_CEC_UnRegisterRxCpltCallback(CEC_HandleTypeDef *hcec)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  __HAL_LOCK(hcec);\n  if (HAL_CEC_STATE_READY == hcec->RxState)\n  {\n    hcec->RxCpltCallback = HAL_CEC_RxCpltCallback; \n  }\n  else\n  {\n    hcec->ErrorCode |= HAL_CEC_ERROR_INVALID_CALLBACK;\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hcec);\n  return status;\n}\n#endif \nHAL_StatusTypeDef HAL_CEC_Transmit_IT(CEC_HandleTypeDef *hcec, uint8_t InitiatorAddress, uint8_t DestinationAddress,\n                                      const uint8_t *pData, uint32_t Size)\n{\n  if (hcec->gState == HAL_CEC_STATE_READY)\n  {\n    if ((pData == NULL) && (Size > 0U))\n    {\n      return  HAL_ERROR;\n    }\n    assert_param(IS_CEC_ADDRESS(DestinationAddress));\n    assert_param(IS_CEC_ADDRESS(InitiatorAddress));\n    assert_param(IS_CEC_MSGSIZE(Size));\n    __HAL_LOCK(hcec);\n    hcec->pTxBuffPtr = pData;\n    hcec->gState = HAL_CEC_STATE_BUSY_TX;\n    hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n    hcec->TxXferCount = (uint16_t)Size;\n    if (Size == 0U)\n    {\n      __HAL_CEC_LAST_BYTE_TX_SET(hcec);\n    }\n    hcec->Instance->TXDR = (uint32_t)(((uint32_t)InitiatorAddress << CEC_INITIATOR_LSB_POS) | DestinationAddress);\n    __HAL_CEC_FIRST_BYTE_TX_SET(hcec);\n    __HAL_UNLOCK(hcec);\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}\nuint32_t HAL_CEC_GetLastReceivedFrameSize(const CEC_HandleTypeDef *hcec)\n{\n  return hcec->RxXferSize;\n}\nvoid HAL_CEC_ChangeRxBuffer(CEC_HandleTypeDef *hcec, uint8_t *Rxbuffer)\n{\n  hcec->Init.RxBuffer = Rxbuffer;\n}\nvoid HAL_CEC_IRQHandler(CEC_HandleTypeDef *hcec)\n{\n  uint32_t itflag;\n  itflag = hcec->Instance->ISR;\n  if (HAL_IS_BIT_SET(itflag, CEC_FLAG_ARBLST))\n  {\n    hcec->ErrorCode = HAL_CEC_ERROR_ARBLST;\n    __HAL_CEC_CLEAR_FLAG(hcec, CEC_FLAG_ARBLST);\n  }\n  if (HAL_IS_BIT_SET(itflag, CEC_FLAG_RXBR))\n  {\n    hcec->RxState = HAL_CEC_STATE_BUSY_RX;\n    hcec->RxXferSize++;\n    *hcec->Init.RxBuffer = (uint8_t) hcec->Instance->RXDR;\n    hcec->Init.RxBuffer++;\n    __HAL_CEC_CLEAR_FLAG(hcec, CEC_FLAG_RXBR);\n  }\n  if (HAL_IS_BIT_SET(itflag, CEC_FLAG_RXEND))\n  {\n    __HAL_CEC_CLEAR_FLAG(hcec, CEC_FLAG_RXEND);\n    hcec->RxState = HAL_CEC_STATE_READY;\n    hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n    hcec->Init.RxBuffer -= hcec->RxXferSize;\n#if (USE_HAL_CEC_REGISTER_CALLBACKS == 1U)\n    hcec->RxCpltCallback(hcec, hcec->RxXferSize);\n#else\n    HAL_CEC_RxCpltCallback(hcec, hcec->RxXferSize);\n#endif \n    hcec->RxXferSize = 0U;\n  }\n  if (HAL_IS_BIT_SET(itflag, CEC_FLAG_TXBR))\n  {\n    --hcec->TxXferCount;\n    if (hcec->TxXferCount == 0U)\n    {\n      __HAL_CEC_LAST_BYTE_TX_SET(hcec);\n    }\n    hcec->Instance->TXDR = (uint8_t)*hcec->pTxBuffPtr;\n    hcec->pTxBuffPtr++;\n    __HAL_CEC_CLEAR_FLAG(hcec, CEC_FLAG_TXBR);\n  }\n  if (HAL_IS_BIT_SET(itflag, CEC_FLAG_TXEND))\n  {\n    __HAL_CEC_CLEAR_FLAG(hcec, CEC_FLAG_TXEND);\n    hcec->gState = HAL_CEC_STATE_READY;\n    __HAL_UNLOCK(hcec);\n    hcec->ErrorCode = HAL_CEC_ERROR_NONE;\n#if (USE_HAL_CEC_REGISTER_CALLBACKS == 1U)\n    hcec->TxCpltCallback(hcec);\n#else\n    HAL_CEC_TxCpltCallback(hcec);\n#endif \n  }\n  if ((itflag & (CEC_ISR_RXOVR | CEC_ISR_BRE | CEC_ISR_SBPE | CEC_ISR_LBPE | CEC_ISR_RXACKE | CEC_ISR_TXUDR |\n              CEC_ISR_TXERR | CEC_ISR_TXACKE)) != 0U)\n  {\n    hcec->ErrorCode = itflag;\n    __HAL_CEC_CLEAR_FLAG(hcec, HAL_CEC_ERROR_RXOVR | HAL_CEC_ERROR_BRE | CEC_FLAG_LBPE | CEC_FLAG_SBPE |\n                         HAL_CEC_ERROR_RXACKE | HAL_CEC_ERROR_TXUDR | HAL_CEC_ERROR_TXERR | HAL_CEC_ERROR_TXACKE);\n    if ((itflag & (CEC_ISR_RXOVR | CEC_ISR_BRE | CEC_ISR_SBPE | CEC_ISR_LBPE | CEC_ISR_RXACKE)) != 0U)\n    {\n      hcec->Init.RxBuffer -= hcec->RxXferSize;\n      hcec->RxXferSize = 0U;\n      hcec->RxState = HAL_CEC_STATE_READY;\n    }\n    else if (((itflag & CEC_ISR_ARBLST) == 0U) && ((itflag & (CEC_ISR_TXUDR | CEC_ISR_TXERR | CEC_ISR_TXACKE)) != 0U))\n    {\n      hcec->gState = HAL_CEC_STATE_READY;\n    }\n    else\n    {\n    }\n#if (USE_HAL_CEC_REGISTER_CALLBACKS == 1U)\n    hcec->ErrorCallback(hcec);\n#else\n    HAL_CEC_ErrorCallback(hcec);\n#endif \n  }\n  else\n  {\n  }\n}\n__weak void HAL_CEC_TxCpltCallback(CEC_HandleTypeDef *hcec)\n{\n  UNUSED(hcec);\n}\n__weak void HAL_CEC_RxCpltCallback(CEC_HandleTypeDef *hcec, uint32_t RxFrameSize)\n{\n  UNUSED(hcec);\n  UNUSED(RxFrameSize);\n}\n__weak void HAL_CEC_ErrorCallback(CEC_HandleTypeDef *hcec)\n{\n  UNUSED(hcec);\n}\nHAL_CEC_StateTypeDef HAL_CEC_GetState(const CEC_HandleTypeDef *hcec)\n{\n  uint32_t temp1;\n  uint32_t temp2;\n  temp1 = hcec->gState;\n  temp2 = hcec->RxState;\n  return (HAL_CEC_StateTypeDef)(temp1 | temp2);\n}\nuint32_t HAL_CEC_GetError(const CEC_HandleTypeDef *hcec)\n{\n  return hcec->ErrorCode;\n}\n#endif \n#endif '"
"('""Please write a code snippet that demonstrates testing an interleaver function for soft encoding and decoding. The code should generate random data for input, create an interleaver object, encode the input data, decode the encoded data, and then compare the original input data with the decoded data. Additionally, include an automated test function specifically for interleaver with a size of 64. Thank you.""","//...\nvoid interleaver_test_soft(unsigned int _n)\n{\n    unsigned int i;\n    unsigned char x[8*_n];\n    unsigned char y[8*_n];\n    unsigned char z[8*_n];\n    for (i=0; i<8*_n; i++)\n        x[i] = rand() & 0xFF;\n    interleaver q = interleaver_create(_n);\n    interleaver_encode_soft(q,x,y);\n    interleaver_decode_soft(q,y,z);\n    CONTEND_SAME_DATA(x, z, 8*_n);\n    interleaver_destroy(q);\n}\nvoid autotest_interleaver_soft_64()     { interleaver_test_soft(64  ); }\n//...')
"
"('Prompt: . . You are working on a communication system that involves interleaving and deinterleaving of data. You need to implement the functions `interleaver_permute_mask`, `interleaver_permute`, and `interleaver_decode` in C. . . The `interleaver_permute_mask` function takes an array of unsigned characters `_x`, and permutes the elements based on certain conditions and a mask value. It returns an integer status code.. . The `interleaver_permute` function permutes elements in a similar way as `interleaver_permute_mask`, but without a mask. It also returns an integer status code.. . The `interleaver_decode` function has an `interleaver` struct `_q`, and two arrays of unsigned characters `_msg_enc` and `_msg_dec`. It moves data from `_msg_enc` to `_msg_dec`, and then performs a series of interleaving and deinterleaving operations based on the depth of `_q","//...\nint interleaver_permute_mask(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N,\n                             unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp0;\n    unsigned char tmp1;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp0 = (_x[2*i+0] & (~_mask)) | (_x[2*j+1] & ( _mask));\n        tmp1 = (_x[2*i+0] & ( _mask)) | (_x[2*j+1] & (~_mask));\n        _x[2*i+0] = tmp0;\n        _x[2*j+1] = tmp1;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute(unsigned char * _x,\n                        unsigned int    _n,\n                        unsigned int    _M,\n                        unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp = _x[2*j+1];\n        _x[2*j+1] = _x[2*i+0];\n        _x[2*i+0] = tmp;\n    }\n    return LIQUID_OK;\n}\nint interleaver_decode(interleaver     _q,\n                       unsigned char * _msg_enc,\n                       unsigned char * _msg_dec)\n{\n    memmove(_msg_dec, _msg_enc, _q->n);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+8, 0x33);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 0) interleaver_permute(_msg_dec, _q->n, _q->M, _q->N);\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: Can you provide a function that performs an automated test for a finite impulse response (FIR) filter on a set of given data with filter length of 23 and input data length of 64? The function should test the FIR filter implementation using the provided data arrays firfilt_rrrf_data_h23x64_h, firfilt_rrrf_data_h23x64_x, and firfilt_rrrf_data_h23x64_y.","//...\nvoid autotest_firfilt_rrrf_data_h23x64()\n{\n    firfilt_rrrf_test(firfilt_rrrf_data_h23x64_h, 23,\n                      firfilt_rrrf_data_h23x64_x, 64,\n                      firfilt_rrrf_data_h23x64_y, 64);\n}\n//...')
"
"('To generate and benchmark OFDM frames with different subcarrier and cyclic prefix lengths, you could request a code snippet that defines a macro `OFDMFRAMESYNC_ACQUIRE_BENCH_API` to facilitate the benchmarking process for acquiring OFDM frames with a specific number of subcarriers and cyclic prefix length. This macro should take parameters for the number of subcarriers and cyclic prefix length, as well as pointers to `rusage` struct for start and finish times, and an unsigned long int for the number of iterations.. . You can then call this macro with different combinations of subcarrier and cyclic prefix lengths (e.g., 64, 8, 128, 16, 256, 32, 512, 64) to benchmark the `ofdmframesync_acquire_bench` function by setting up the necessary configurations and evaluating the performance for each case. This will allow you to compare the performance of acquiring OFDM frames with different configurations.","#define OFDMFRAMESYNC_ACQUIRE_BENCH_API(M,CP_LEN)   \\\n(   struct rusage *_start,                          \\\n    struct rusage *_finish,                         \\\n    unsigned long int *_num_iterations)             \\\n{ ofdmframesync_acquire_bench(_start, _finish, _num_iterations, M, CP_LEN); }\nvoid ofdmframesync_acquire_bench(struct rusage *_start,\n                                 struct rusage *_finish,\n                                 unsigned long int *_num_iterations,\n                                 unsigned int _num_subcarriers,\n                                 unsigned int _cp_len)\n{\n    unsigned int M         = _num_subcarriers;\n    unsigned int cp_len    = _cp_len;\n    unsigned int taper_len = 0;\n    unsigned int num_samples = 3*(M + cp_len);\n    ofdmframegen fg = ofdmframegen_create(M, cp_len, taper_len, NULL);\n    ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,NULL,NULL,NULL);\n    unsigned int i;\n    float complex y[num_samples];   \n    unsigned int n=0;\n    ofdmframegen_write_S0a(fg, &y[n]);\n    n += M + cp_len;\n    ofdmframegen_write_S0b(fg, &y[n]);\n    n += M + cp_len;\n    ofdmframegen_write_S1( fg, &y[n]);\n    n += M + cp_len;\n    assert(n == num_samples);\n    for (i=0; i<num_samples; i++)\n        y[i] += 0.02f*randnf()*cexpf(_Complex_I*2*M_PI*randf());\n    *_num_iterations /= M*sqrtf(M);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        ofdmframesync_execute(fs,y,num_samples);\n        ofdmframesync_reset(fs);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    ofdmframegen_destroy(fg);\n    ofdmframesync_destroy(fs);\n}\nvoid benchmark_ofdmframesync_acquire_n64    OFDMFRAMESYNC_ACQUIRE_BENCH_API(64, 8)\nvoid benchmark_ofdmframesync_acquire_n128   OFDMFRAMESYNC_ACQUIRE_BENCH_API(128,16)\nvoid benchmark_ofdmframesync_acquire_n256   OFDMFRAMESYNC_ACQUIRE_BENCH_API(256,32)\nvoid benchmark_ofdmframesync_acquire_n512   OFDMFRAMESYNC_ACQUIRE_BENCH_API(512,64)')
"
"('Prompt: Given a scenario where you are working with a communication system that utilizes Quadrature pilots synchronization, please provide a function that retrieves the Error Vector Magnitude (EVM) value from a specific instance of the Quadrature pilots synchronization object. The function should return the EVM value stored within the object.","//...\nfloat qpilotsync_get_evm(qpilotsync _q)\n{\n    return _q->evm_hat;\n}\n//...')
"
"'A prompt for this code could be:. . ""You are developing a temperature sensor (DTS) module for a microcontroller using HAL library. Write code for initializing the DTS module, including setting up callbacks, starting and stopping temperature measurements, getting temperature values, and handling interrupts. Ensure error handling and proper state management in the code.""","#ifdef HAL_DTS_MODULE_ENABLED\n#if defined(DTS)\n#define DTS_DELAY_STARTUP (1UL)\n#define TS_TIMEOUT_MS     (5UL)\n#define DTS_FACTORY_TEMPERATURE1 (30UL)\n#define DTS_FACTORY_TEMPERATURE2 (130UL)\nHAL_StatusTypeDef HAL_DTS_Init(DTS_HandleTypeDef *hdts)\n{\n  if (hdts == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_DTS_ALL_INSTANCE(hdts->Instance));\n  assert_param(IS_DTS_QUICKMEAS(hdts->Init.QuickMeasure));\n  assert_param(IS_DTS_REFCLK(hdts->Init.RefClock));\n  assert_param(IS_DTS_TRIGGERINPUT(hdts->Init.TriggerInput));\n  assert_param(IS_DTS_SAMPLINGTIME(hdts->Init.SamplingTime));\n  assert_param(IS_DTS_THRESHOLD(hdts->Init.HighThreshold));\n  assert_param(IS_DTS_THRESHOLD(hdts->Init.LowThreshold));\n  if (hdts->State == HAL_DTS_STATE_RESET)\n  {\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n    hdts->EndCallback       = HAL_DTS_EndCallback;        \n    hdts->LowCallback       = HAL_DTS_LowCallback;        \n    hdts->HighCallback      = HAL_DTS_HighCallback;       \n    hdts->AsyncEndCallback  = HAL_DTS_AsyncEndCallback;   \n    hdts->AsyncLowCallback  = HAL_DTS_AsyncLowCallback;   \n    hdts->AsyncHighCallback = HAL_DTS_AsyncHighCallback;  \n    if (hdts->MspInitCallback == NULL)\n    {\n      hdts->MspInitCallback = HAL_DTS_MspInit;\n    }\n    hdts->MspInitCallback(hdts);\n#else\n    HAL_DTS_MspInit(hdts);\n#endif \n  }\n  hdts->State = HAL_DTS_STATE_BUSY;\n  if (hdts->Instance->RAMPVALR == 0UL)\n  {\n    return HAL_ERROR;\n  }\n  if (hdts->Instance->T0VALR1 == 0UL)\n  {\n    return HAL_ERROR;\n  }\n  if (hdts->Init.QuickMeasure == DTS_QUICKMEAS_DISABLE)\n  {\n    if (hdts->Init.RefClock == DTS_REFCLKSEL_PCLK)\n    {\n      assert_param(IS_DTS_DIVIDER_RATIO_NUMBER(hdts->Init.Divider));\n    }\n    CLEAR_BIT(hdts->Instance->CFGR1, DTS_CFGR1_Q_MEAS_OPT);\n  }\n  else\n  {\n    if (hdts->Init.RefClock != DTS_REFCLKSEL_LSE)\n    {\n      return HAL_ERROR;\n    }\n    SET_BIT(hdts->Instance->CFGR1, DTS_CFGR1_Q_MEAS_OPT);\n  }\n  if (hdts->Init.RefClock == DTS_REFCLKSEL_LSE)\n  {\n    SET_BIT(hdts->Instance->CFGR1, DTS_CFGR1_REFCLK_SEL);\n  }\n  else\n  {\n    CLEAR_BIT(hdts->Instance->CFGR1, DTS_CFGR1_REFCLK_SEL);\n  }\n  MODIFY_REG(hdts->Instance->CFGR1, DTS_CFGR1_HSREF_CLK_DIV, (hdts->Init.Divider << DTS_CFGR1_HSREF_CLK_DIV_Pos));\n  MODIFY_REG(hdts->Instance->CFGR1, DTS_CFGR1_TS1_SMP_TIME, hdts->Init.SamplingTime);\n  MODIFY_REG(hdts->Instance->CFGR1, DTS_CFGR1_TS1_INTRIG_SEL, hdts->Init.TriggerInput);\n  MODIFY_REG(hdts->Instance->ITR1, DTS_ITR1_TS1_HITTHD, (hdts->Init.HighThreshold << DTS_ITR1_TS1_HITTHD_Pos));\n  MODIFY_REG(hdts->Instance->ITR1, DTS_ITR1_TS1_LITTHD, hdts->Init.LowThreshold);\n  hdts->State = HAL_DTS_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DTS_DeInit(DTS_HandleTypeDef *hdts)\n{\n  if (hdts == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_DTS_ALL_INSTANCE(hdts->Instance));\n  CLEAR_REG(hdts->Instance->CFGR1);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n  if (hdts->MspDeInitCallback == NULL)\n  {\n    hdts->MspDeInitCallback = HAL_DTS_MspDeInit;\n  }\n  hdts->MspDeInitCallback(hdts);\n#else\n  HAL_DTS_MspDeInit(hdts);\n#endif \n  hdts->State = HAL_DTS_STATE_RESET;\n  return HAL_OK;\n}\n__weak void HAL_DTS_MspInit(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n__weak void HAL_DTS_MspDeInit(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\nHAL_StatusTypeDef HAL_DTS_RegisterCallback(DTS_HandleTypeDef        *hdts,\n                                           HAL_DTS_CallbackIDTypeDef CallbackID,\n                                           pDTS_CallbackTypeDef      pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (pCallback == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    if (hdts->State == HAL_DTS_STATE_READY)\n    {\n      switch (CallbackID)\n      {\n        case HAL_DTS_MEAS_COMPLETE_CB_ID :\n          hdts->EndCallback = pCallback;\n          break;\n        case HAL_DTS_ASYNC_MEAS_COMPLETE_CB_ID :\n          hdts->AsyncEndCallback = pCallback;\n          break;\n        case HAL_DTS_LOW_THRESHOLD_CB_ID :\n          hdts->LowCallback = pCallback;\n          break;\n        case HAL_DTS_ASYNC_LOW_THRESHOLD_CB_ID :\n          hdts->AsyncLowCallback = pCallback;\n          break;\n        case HAL_DTS_HIGH_THRESHOLD_CB_ID :\n          hdts->HighCallback = pCallback;\n          break;\n        case HAL_DTS_ASYNC_HIGH_THRESHOLD_CB_ID :\n          hdts->AsyncHighCallback = pCallback;\n          break;\n        case HAL_DTS_MSPINIT_CB_ID :\n          hdts->MspInitCallback = pCallback;\n          break;\n        case HAL_DTS_MSPDEINIT_CB_ID :\n          hdts->MspDeInitCallback = pCallback;\n          break;\n        default :\n          status = HAL_ERROR;\n          break;\n      }\n    }\n    else if (hdts->State == HAL_DTS_STATE_RESET)\n    {\n      switch (CallbackID)\n      {\n        case HAL_DTS_MSPINIT_CB_ID :\n          hdts->MspInitCallback = pCallback;\n          break;\n        case HAL_DTS_MSPDEINIT_CB_ID :\n          hdts->MspDeInitCallback = pCallback;\n          break;\n        default :\n          status = HAL_ERROR;\n          break;\n      }\n    }\n    else\n    {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_DTS_UnRegisterCallback(DTS_HandleTypeDef        *hdts,\n                                             HAL_DTS_CallbackIDTypeDef CallbackID)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (hdts->State == HAL_DTS_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_DTS_MEAS_COMPLETE_CB_ID :\n        hdts->EndCallback = HAL_DTS_EndCallback;\n        break;\n      case HAL_DTS_ASYNC_MEAS_COMPLETE_CB_ID :\n        hdts->AsyncEndCallback = HAL_DTS_AsyncEndCallback;\n        break;\n      case HAL_DTS_LOW_THRESHOLD_CB_ID :\n        hdts->LowCallback = HAL_DTS_LowCallback;\n        break;\n      case HAL_DTS_ASYNC_LOW_THRESHOLD_CB_ID :\n        hdts->AsyncLowCallback = HAL_DTS_AsyncLowCallback;\n        break;\n      case HAL_DTS_HIGH_THRESHOLD_CB_ID :\n        hdts->HighCallback = HAL_DTS_HighCallback;\n        break;\n      case HAL_DTS_ASYNC_HIGH_THRESHOLD_CB_ID :\n        hdts->AsyncHighCallback = HAL_DTS_AsyncHighCallback;\n        break;\n      case HAL_DTS_MSPINIT_CB_ID :\n        hdts->MspInitCallback = HAL_DTS_MspInit;\n        break;\n      case HAL_DTS_MSPDEINIT_CB_ID :\n        hdts->MspDeInitCallback = HAL_DTS_MspDeInit;\n        break;\n      default :\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else if (hdts->State == HAL_DTS_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_DTS_MSPINIT_CB_ID :\n        hdts->MspInitCallback = HAL_DTS_MspInit;\n        break;\n      case HAL_DTS_MSPDEINIT_CB_ID :\n        hdts->MspDeInitCallback = HAL_DTS_MspDeInit;\n        break;\n      default :\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    status = HAL_ERROR;\n  }\n  return status;\n}\n#endif \nHAL_StatusTypeDef HAL_DTS_Start(DTS_HandleTypeDef *hdts)\n{\n  uint32_t Ref_Time;\n  if (hdts == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if (hdts->State == HAL_DTS_STATE_READY)\n  {\n    hdts->State = HAL_DTS_STATE_BUSY;\n    __HAL_DTS_ENABLE(hdts);\n    Ref_Time = HAL_GetTick();\n    while (__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_RDY) == RESET)\n    {\n      if ((HAL_GetTick() - Ref_Time) > DTS_DELAY_STARTUP)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    if (__HAL_DTS_GET_TRIGGER(hdts) == DTS_TRIGGER_HW_NONE)\n    {\n      SET_BIT(hdts->Instance->CFGR1, DTS_CFGR1_TS1_START);\n      HAL_Delay(TS_TIMEOUT_MS);\n    }\n    hdts->State = HAL_DTS_STATE_READY;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DTS_Stop(DTS_HandleTypeDef *hdts)\n{\n  if (hdts == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if (hdts->State == HAL_DTS_STATE_READY)\n  {\n    hdts->State = HAL_DTS_STATE_BUSY;\n    if (__HAL_DTS_GET_TRIGGER(hdts) == DTS_TRIGGER_HW_NONE)\n    {\n      CLEAR_BIT(hdts->Instance->CFGR1, DTS_CFGR1_TS1_START);\n    }\n    __HAL_DTS_DISABLE(hdts);\n    hdts->State = HAL_DTS_STATE_READY;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DTS_Start_IT(DTS_HandleTypeDef *hdts)\n{\n  uint32_t Ref_Time;\n  if (hdts == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if (hdts->State == HAL_DTS_STATE_READY)\n  {\n    hdts->State = HAL_DTS_STATE_BUSY;\n    if (hdts->Init.RefClock == DTS_REFCLKSEL_LSE)\n    {\n      __HAL_DTS_ENABLE_IT(hdts, DTS_IT_TS1_AITE | DTS_IT_TS1_AITL | DTS_IT_TS1_AITH);\n    }\n    else\n    {\n      __HAL_DTS_ENABLE_IT(hdts, DTS_IT_TS1_ITE | DTS_IT_TS1_ITL | DTS_IT_TS1_ITH);\n    }\n    __HAL_DTS_ENABLE(hdts);\n    Ref_Time = HAL_GetTick();\n    while (__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_RDY) == RESET)\n    {\n      if ((HAL_GetTick() - Ref_Time) > DTS_DELAY_STARTUP)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    if (__HAL_DTS_GET_TRIGGER(hdts) == DTS_TRIGGER_HW_NONE)\n    {\n      SET_BIT(hdts->Instance->CFGR1, DTS_CFGR1_TS1_START);\n      HAL_Delay(TS_TIMEOUT_MS);\n    }\n    hdts->State = HAL_DTS_STATE_READY;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DTS_Stop_IT(DTS_HandleTypeDef *hdts)\n{\n  if (hdts == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if (hdts->State == HAL_DTS_STATE_READY)\n  {\n    hdts->State = HAL_DTS_STATE_BUSY;\n    if (hdts->Init.RefClock == DTS_REFCLKSEL_LSE)\n    {\n      __HAL_DTS_DISABLE_IT(hdts, DTS_IT_TS1_AITE | DTS_IT_TS1_AITL | DTS_IT_TS1_AITH);\n    }\n    else\n    {\n      __HAL_DTS_DISABLE_IT(hdts, DTS_IT_TS1_ITE | DTS_IT_TS1_ITL | DTS_IT_TS1_ITH);\n    }\n    if (__HAL_DTS_GET_TRIGGER(hdts) == DTS_TRIGGER_HW_NONE)\n    {\n      CLEAR_BIT(hdts->Instance->CFGR1, DTS_CFGR1_TS1_START);\n    }\n    __HAL_DTS_DISABLE(hdts);\n    hdts->State = HAL_DTS_STATE_READY;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DTS_GetTemperature(DTS_HandleTypeDef *hdts, int32_t *Temperature)\n{\n  uint32_t freq_meas;\n  uint32_t samples;\n  uint32_t t0_temp;\n  uint32_t t0_freq;\n  uint32_t ramp_coeff;\n  if (hdts->State == HAL_DTS_STATE_READY)\n  {\n    hdts->State = HAL_DTS_STATE_BUSY;\n    samples = (hdts->Instance->DR & DTS_DR_TS1_MFREQ);\n    if ((hdts->Init.SamplingTime == 0UL) || (samples == 0UL))\n    {\n      hdts->State = HAL_DTS_STATE_READY;\n      return HAL_ERROR;\n    }\n    if ((hdts->Init.RefClock) == DTS_REFCLKSEL_LSE)\n    {\n      freq_meas = (LSE_VALUE * samples) / (hdts->Init.SamplingTime >> DTS_CFGR1_TS1_SMP_TIME_Pos); \n    }\n    else\n    {\n      freq_meas = (HAL_RCCEx_GetD3PCLK1Freq() * (hdts->Init.SamplingTime >> DTS_CFGR1_TS1_SMP_TIME_Pos)) / samples; \n    }\n    t0_temp = hdts->Instance->T0VALR1 >> DTS_T0VALR1_TS1_T0_Pos;\n    if (t0_temp == 0UL)\n    {\n      t0_temp = DTS_FACTORY_TEMPERATURE1; \n    }\n    else if (t0_temp == 1UL)\n    {\n      t0_temp = DTS_FACTORY_TEMPERATURE2; \n    }\n    else\n    {\n      hdts->State = HAL_DTS_STATE_READY;\n      return HAL_ERROR;\n    }\n    t0_freq = (hdts->Instance->T0VALR1 & DTS_T0VALR1_TS1_FMT0) * 100UL; \n    ramp_coeff = hdts->Instance->RAMPVALR & DTS_RAMPVALR_TS1_RAMP_COEFF; \n    if (ramp_coeff == 0UL)\n    {\n      hdts->State = HAL_DTS_STATE_READY;\n      return HAL_ERROR;\n    }\n    *Temperature = (int32_t)t0_temp + (((int32_t)freq_meas - (int32_t)t0_freq) / (int32_t)ramp_coeff);\n    hdts->State = HAL_DTS_STATE_READY;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n  return HAL_OK;\n}\nvoid HAL_DTS_IRQHandler(DTS_HandleTypeDef *hdts)\n{\n  if ((__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_AITE)) != RESET)\n  {\n      __HAL_DTS_CLEAR_FLAG(hdts, DTS_FLAG_TS1_AITE);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n      hdts->AsyncEndCallback(hdts);\n#else\n      HAL_DTS_AsyncEndCallback(hdts);\n#endif \n  }\n  if ((__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_AITL)) != RESET)\n  {\n      __HAL_DTS_CLEAR_FLAG(hdts, DTS_FLAG_TS1_AITL);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n      hdts->AsyncLowCallback(hdts);\n#else\n      HAL_DTS_AsyncLowCallback(hdts);\n#endif \n  }\n  if ((__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_AITH)) != RESET)\n  {\n      __HAL_DTS_CLEAR_FLAG(hdts, DTS_FLAG_TS1_AITH);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n      hdts->AsyncHighCallback(hdts);\n#else\n      HAL_DTS_AsyncHighCallback(hdts);\n#endif \n  }\n  if ((__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_ITE)) != RESET)\n  {\n      __HAL_DTS_CLEAR_FLAG(hdts, DTS_FLAG_TS1_ITE);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n      hdts->EndCallback(hdts);\n#else\n      HAL_DTS_EndCallback(hdts);\n#endif \n  }\n  if ((__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_ITL)) != RESET)\n  {\n      __HAL_DTS_CLEAR_FLAG(hdts, DTS_FLAG_TS1_ITL);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n      hdts->LowCallback(hdts);\n#else\n      HAL_DTS_LowCallback(hdts);\n#endif \n  }\n  if ((__HAL_DTS_GET_FLAG(hdts, DTS_FLAG_TS1_ITH)) != RESET)\n  {\n      __HAL_DTS_CLEAR_FLAG(hdts, DTS_FLAG_TS1_ITH);\n#if (USE_HAL_DTS_REGISTER_CALLBACKS == 1)\n      hdts->HighCallback(hdts);\n#else\n      HAL_DTS_HighCallback(hdts);\n#endif \n  }\n}\n__weak void HAL_DTS_EndCallback(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n__weak void HAL_DTS_LowCallback(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n__weak void HAL_DTS_HighCallback(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n__weak void HAL_DTS_AsyncEndCallback(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n__weak void HAL_DTS_AsyncLowCallback(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\n__weak void HAL_DTS_AsyncHighCallback(DTS_HandleTypeDef *hdts)\n{\n  UNUSED(hdts);\n}\nHAL_DTS_StateTypeDef HAL_DTS_GetState(DTS_HandleTypeDef *hdts)\n{\n  if (hdts == NULL)\n  {\n    return HAL_DTS_STATE_RESET;\n  }\n  return hdts->State;\n}\n#endif \n#endif '"
"'Prompt: ""I need a function to convert vg_lite_error_t enum values to strings. Additionally, I need functions to handle asynchronous drawing with VG Lite. Can you also provide functions to convert color formats, blend modes, buffer formats, and check buffer alignment?"". . Technical Scenario: You are working on integrating VG Lite into a graphics library and need assistance with error handling, asynchronous drawing, and converting between different color formats, blend modes, buffer formats, and ensuring buffer alignment.","#if LV_USE_DRAW_VGLITE\n#if LV_USE_VGLITE_DRAW_ASYNC\n    static volatile bool _cmd_buf_flushed = false;\n#endif\nconst char * vglite_error_to_string(vg_lite_error_t error)\n{\n    switch(error) {\n            ENUM_TO_STRING(VG_LITE_SUCCESS);\n            ENUM_TO_STRING(VG_LITE_INVALID_ARGUMENT);\n            ENUM_TO_STRING(VG_LITE_OUT_OF_MEMORY);\n            ENUM_TO_STRING(VG_LITE_NO_CONTEXT);\n            ENUM_TO_STRING(VG_LITE_TIMEOUT);\n            ENUM_TO_STRING(VG_LITE_OUT_OF_RESOURCES);\n            ENUM_TO_STRING(VG_LITE_GENERIC_IO);\n            ENUM_TO_STRING(VG_LITE_NOT_SUPPORT);\n            ENUM_TO_STRING(VG_LITE_ALREADY_EXISTS);\n            ENUM_TO_STRING(VG_LITE_NOT_ALIGNED);\n            ENUM_TO_STRING(VG_LITE_FLEXA_TIME_OUT);\n            ENUM_TO_STRING(VG_LITE_FLEXA_HANDSHAKE_FAIL);\n        default:\n            break;\n    }\n    return ""VG_LITE_UKNOWN_ERROR"";\n}\n#if LV_USE_VGLITE_DRAW_ASYNC\nbool vglite_cmd_buf_is_flushed(void)\n{\n    return _cmd_buf_flushed;\n}\n#endif\nvoid vglite_run(void)\n{\n#if LV_USE_VGLITE_DRAW_ASYNC\n    vg_lite_uint32_t gpu_idle = 0;\n    VGLITE_CHECK_ERROR(vg_lite_get_parameter(VG_LITE_GPU_IDLE_STATE, 1, (vg_lite_pointer)&gpu_idle));\n    if(!gpu_idle) {\n        _cmd_buf_flushed = false;\n        return;\n    }\n#endif\n#if LV_USE_VGLITE_DRAW_ASYNC\n    VGLITE_CHECK_ERROR(vg_lite_flush());\n    _cmd_buf_flushed = true;\n#else\n    VGLITE_CHECK_ERROR(vg_lite_finish());\n#endif\n}\nvg_lite_color_t vglite_get_color(lv_color32_t lv_col32, bool gradient)\n{\n    vg_lite_color_t vg_col32;\n    lv_col32.red = LV_UDIV255(lv_col32.red * lv_col32.alpha);\n    lv_col32.green = LV_UDIV255(lv_col32.green * lv_col32.alpha);\n    lv_col32.blue = LV_UDIV255(lv_col32.blue * lv_col32.alpha);\n    if(!gradient)\n        vg_col32 = ((vg_lite_color_t)lv_col32.alpha << 24) | ((vg_lite_color_t)lv_col32.blue << 16) |\n                   ((vg_lite_color_t)lv_col32.green << 8) | (vg_lite_color_t)lv_col32.red;\n    else\n        vg_col32 = ((vg_lite_color_t)lv_col32.alpha << 24) | ((vg_lite_color_t)lv_col32.red << 16) |\n                   ((vg_lite_color_t)lv_col32.green << 8) | (vg_lite_color_t)lv_col32.blue;\n    return vg_col32;\n}\nvg_lite_blend_t vglite_get_blend_mode(lv_blend_mode_t lv_blend_mode)\n{\n    vg_lite_blend_t vg_blend_mode = VG_LITE_BLEND_NONE;\n    if(vg_lite_query_feature(gcFEATURE_BIT_VG_LVGL_SUPPORT)) {\n        switch(lv_blend_mode) {\n            case LV_BLEND_MODE_NORMAL:\n                vg_blend_mode = VG_LITE_BLEND_NORMAL_LVGL;\n                break;\n            case LV_BLEND_MODE_ADDITIVE:\n                vg_blend_mode = VG_LITE_BLEND_ADDITIVE_LVGL;\n                break;\n            case LV_BLEND_MODE_SUBTRACTIVE:\n                vg_blend_mode = VG_LITE_BLEND_SUBTRACT_LVGL;\n                break;\n            case LV_BLEND_MODE_MULTIPLY:\n                vg_blend_mode = VG_LITE_BLEND_MULTIPLY_LVGL;\n                break;\n            default:\n                VGLITE_ASSERT_MSG(false, ""Unsupported blend mode."");\n                break;\n        }\n    }\n    else {\n        switch(lv_blend_mode) {\n            case LV_BLEND_MODE_NORMAL:\n                vg_blend_mode = VG_LITE_BLEND_SRC_OVER;\n                break;\n            case LV_BLEND_MODE_ADDITIVE:\n                vg_blend_mode = VG_LITE_BLEND_ADDITIVE;\n                break;\n            case LV_BLEND_MODE_SUBTRACTIVE:\n                vg_blend_mode = VG_LITE_BLEND_SUBTRACT;\n                break;\n            case LV_BLEND_MODE_MULTIPLY:\n                vg_blend_mode = VG_LITE_BLEND_MULTIPLY;\n                break;\n            default:\n                VGLITE_ASSERT_MSG(false, ""Unsupported blend mode."");\n                break;\n        }\n    }\n    return vg_blend_mode;\n}\nvg_lite_buffer_format_t vglite_get_buf_format(lv_color_format_t cf)\n{\n    vg_lite_buffer_format_t vg_buffer_format = VG_LITE_BGR565;\n    switch(cf) {\n        case LV_COLOR_FORMAT_L8:\n            vg_buffer_format = VG_LITE_L8;\n            break;\n        case LV_COLOR_FORMAT_A8:\n            vg_buffer_format = VG_LITE_A8;\n            break;\n        case LV_COLOR_FORMAT_I1:\n            vg_buffer_format = VG_LITE_INDEX_1;\n            break;\n        case LV_COLOR_FORMAT_I2:\n            vg_buffer_format = VG_LITE_INDEX_2;\n            break;\n        case LV_COLOR_FORMAT_I4:\n            vg_buffer_format = VG_LITE_INDEX_4;\n            break;\n        case LV_COLOR_FORMAT_I8:\n            vg_buffer_format = VG_LITE_INDEX_8;\n            break;\n        case LV_COLOR_FORMAT_RGB565:\n            vg_buffer_format = VG_LITE_BGR565;\n            break;\n        case LV_COLOR_FORMAT_RGB565A8:\n            vg_buffer_format = VG_LITE_ABGR8565;\n            break;\n        case LV_COLOR_FORMAT_RGB888:\n            vg_buffer_format = VG_LITE_BGR888;\n            break;\n        case LV_COLOR_FORMAT_ARGB8888:\n            vg_buffer_format = VG_LITE_BGRA8888;\n            break;\n        case LV_COLOR_FORMAT_XRGB8888:\n            vg_buffer_format = VG_LITE_BGRX8888;\n            break;\n        default:\n            VGLITE_ASSERT_MSG(false, ""Unsupported color format."");\n            break;\n    }\n    return vg_buffer_format;\n}\nuint8_t vglite_get_alignment(lv_color_format_t cf)\n{\n    uint8_t align_bytes = LV_COLOR_DEPTH / 8 * 16; \n    switch(cf) {\n        case LV_COLOR_FORMAT_I1:\n        case LV_COLOR_FORMAT_I2:\n        case LV_COLOR_FORMAT_I4:\n            align_bytes = 32;\n            break;\n        case LV_COLOR_FORMAT_I8:\n        case LV_COLOR_FORMAT_A8:\n        case LV_COLOR_FORMAT_L8:\n            align_bytes = 32;\n            break;\n        case LV_COLOR_FORMAT_RGB565:\n            align_bytes = 32;\n            break;\n        case LV_COLOR_FORMAT_RGB565A8:\n        case LV_COLOR_FORMAT_RGB888:\n            align_bytes = 48;\n            break;\n        case LV_COLOR_FORMAT_ARGB8888:\n        case LV_COLOR_FORMAT_XRGB8888:\n            align_bytes = 64;\n            break;\n        default:\n            VGLITE_ASSERT_MSG(false, ""Unsupported buffer format."");\n            break;\n    }\n    return align_bytes;\n}\nbool vglite_buf_aligned(const void * buf, uint32_t stride, lv_color_format_t cf)\n{\n    uint8_t align_bytes = vglite_get_alignment(cf);\n    if((uintptr_t)buf % align_bytes)\n        return false;\n    if(stride == 0 || stride % align_bytes)\n        return false;\n    return true;\n}\n#endif '"
"('Prompt: You are working on a programming project that involves creating a custom vector class for floating point numbers in C++. The goal is to be able to easily create multiple instances of this vector class with different names. Please provide a macro definition that takes in the name of the vector and uses it to define a new vector class with the name ""liquid_vectorf"" followed by the provided name. Additionally, define the type ""T"" as a float and ""TP"" as another float.","#define VECTOR(name)    LIQUID_CONCAT(liquid_vectorf,name)\n#define T               float\n#define TP              float')
"
"('Prompt: ""You are tasked with implementing a genetic algorithm search algorithm in C. The algorithm consists of several functions including crossover, mutation, ranking, and evolution. Can you provide the C code for these functions, including the necessary data structures and helper functions?""","//...\nint gasearch_rank(gasearch _g)\n{\n    unsigned int i, j;\n    float u_tmp;        \n    chromosome c_tmp;   \n    for (i=0; i<_g->population_size; i++) {\n        for (j=_g->population_size-1; j>i; j--) {\n            if ( optim_threshold_switch(_g->utility[j], _g->utility[j-1], !(_g->minimize)) ) {\n                c_tmp = _g->population[j];\n                _g->population[j] = _g->population[j-1];\n                _g->population[j-1] = c_tmp;\n                u_tmp = _g->utility[j];\n                _g->utility[j] = _g->utility[j-1];\n                _g->utility[j-1] = u_tmp;\n            }\n        }\n    }\n    return LIQUID_OK;\n}\nint gasearch_crossover(gasearch _g)\n{\n    chromosome p1, p2;      \n    chromosome c;           \n    unsigned int threshold;\n    unsigned int i;\n    for (i=_g->selection_size; i<_g->population_size; i++) {\n        p1 = (i==_g->selection_size) ? _g->population[0] : _g->population[rand() % _g->selection_size];\n        p2 = _g->population[rand() % _g->selection_size];\n        threshold = rand() % _g->bits_per_chromosome;\n        c = _g->population[i];\n        chromosome_crossover(p1, p2, c, threshold);\n    }\n    return LIQUID_OK;\n}\nint gasearch_mutate(gasearch _g)\n{\n    unsigned int i;\n    unsigned int index;\n    for (i=1; i<_g->population_size; i++) {\n        unsigned int num_mutations = 0;\n        while ( randf() < _g->mutation_rate || num_mutations == 0) {\n            index = rand() % _g->bits_per_chromosome;\n            chromosome_mutate( _g->population[i], index );\n            num_mutations++;\n            if (num_mutations == _g->bits_per_chromosome)\n                break;\n        }\n    }\n    return LIQUID_OK;\n}\nint gasearch_evaluate(gasearch _g)\n{\n    unsigned int i;\n    for (i=0; i<_g->population_size; i++)\n        _g->utility[i] = _g->get_utility(_g->userdata, _g->population[i]);\n    return LIQUID_OK;\n}\nint gasearch_evolve(gasearch _g)\n{\n    chromosome_init_random(_g->population[_g->population_size-1]);\n    gasearch_crossover(_g);\n    gasearch_mutate(_g);\n    gasearch_evaluate(_g);\n    gasearch_rank(_g);\n    if ( optim_threshold_switch(_g->utility_opt,\n                                _g->utility[0],\n                                _g->minimize) )\n    {\n        _g->utility_opt = _g->utility[0];\n        chromosome_copy(_g->population[0], _g->c);\n#if LIQUID_DEBUG_GA_SEARCH\n        printf(""  utility: %0.2E"", _g->utility_opt);\n        chromosome_printf(_g->c);\n#endif\n    }\n    return LIQUID_OK;\n}\n//...')
"
"'Please provide a prompt in a technical scenario where you need functions to control power domains in a microcontroller based on different power modes. This includes functions to control power domains based on CPU power modes, set point modes, and software modes. The functions should handle operations such as setting power states, saving states, triggering changes, and setting signal behaviors.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.pgmc""\n#endif\ntypedef struct\n{\n    __IO uint32_t SIGNAL; \n    __IO uint32_t DELAY;  \n    uint32_t RESERVED[2];\n} PGMC_MIF_SIGNAL_Type;\nvoid PGMC_BPC_ControlPowerDomainByCpuPowerMode(PGMC_BPC_Type *base,\n                                               pgmc_cpu_mode_t mode,\n                                               const pgmc_bpc_cpu_power_mode_option_t *option)\n{\n    assert(option != NULL);\n    uint32_t tmp32 = base->BPC_SSAR_SAVE_CTRL;\n    base->BPC_MODE = PGMC_BPC_BPC_MODE_DOMAIN_ASSIGN(option->assignDomain) |\n                     PGMC_BPC_BPC_MODE_CTRL_MODE(kPGMC_ControlledByCpuPowerMode);\n    switch (mode)\n    {\n        case kPGMC_RunMode:\n            tmp32 |= PGMC_BPC_BPC_SSAR_SAVE_CTRL_SAVE_AT_RUN_MASK;\n            break;\n        case kPGMC_WaitMode:\n            if (option->powerOff)\n            {\n                base->BPC_POWER_CTRL |= PGMC_BPC_BPC_POWER_CTRL_PWR_OFF_AT_WAIT_MASK;\n            }\n            tmp32 |= PGMC_BPC_BPC_SSAR_SAVE_CTRL_SAVE_AT_WAIT_MASK;\n            break;\n        case kPGMC_StopMode:\n            if (option->powerOff)\n            {\n                base->BPC_POWER_CTRL |= PGMC_BPC_BPC_POWER_CTRL_PWR_OFF_AT_STOP_MASK;\n            }\n            tmp32 |= PGMC_BPC_BPC_SSAR_SAVE_CTRL_SAVE_AT_SUSPEND_MASK;\n            break;\n        case kPGMC_SuspendMode:\n            if (option->powerOff)\n            {\n                base->BPC_POWER_CTRL |= PGMC_BPC_BPC_POWER_CTRL_PWR_OFF_AT_SUSPEND_MASK;\n            }\n            tmp32 |= PGMC_BPC_BPC_SSAR_SAVE_CTRL_SAVE_AT_SUSPEND_MASK;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n    if (option->stateSave)\n    {\n        base->BPC_SSAR_SAVE_CTRL = tmp32;\n    }\n}\nvoid PGMC_BPC_ControlPowerDomainBySetPointMode(PGMC_BPC_Type *base,\n                                               uint32_t setPointMap,\n                                               const pgmc_bpc_setpoint_mode_option_t *option)\n{\n    assert(option != NULL);\n    setPointMap &= 0xFFFFU;\n    base->BPC_MODE = PGMC_BPC_BPC_MODE_CTRL_MODE(kPGMC_ControlledBySetPoint);\n    if (option->powerOff)\n    {\n        base->BPC_POWER_CTRL |= PGMC_BPC_BPC_POWER_CTRL_PWR_OFF_AT_SP(setPointMap);\n    }\n    if (option->stateSave)\n    {\n        base->BPC_SSAR_SAVE_CTRL = PGMC_BPC_BPC_SSAR_SAVE_CTRL_SAVE_AT_SP(setPointMap);\n    }\n}\nvoid PGMC_BPC_ControlPowerDomainBySoftwareMode(PGMC_BPC_Type *base, bool powerOff)\n{\n    if (powerOff)\n    {\n        base->BPC_POWER_CTRL |= (PGMC_BPC_BPC_POWER_CTRL_PSW_OFF_SOFT_MASK | PGMC_BPC_BPC_POWER_CTRL_ISO_ON_SOFT_MASK);\n    }\n    else\n    {\n        base->BPC_POWER_CTRL |= (PGMC_BPC_BPC_POWER_CTRL_PSW_ON_SOFT_MASK | PGMC_BPC_BPC_POWER_CTRL_ISO_OFF_SOFT_MASK);\n    }\n}\nvoid PGMC_CPC_CORE_PowerOffByCpuPowerMode(PGMC_CPC_Type *base, pgmc_cpu_mode_t mode)\n{\n    base->CPC_CORE_MODE = PGMC_CPC_CPC_CORE_MODE_CTRL_MODE(kPGMC_ControlledByCpuPowerMode);\n    switch (mode)\n    {\n        case kPGMC_RunMode:\n            break;\n        case kPGMC_WaitMode:\n            base->CPC_CORE_POWER_CTRL |= PGMC_CPC_CPC_CORE_POWER_CTRL_PWR_OFF_AT_WAIT_MASK;\n            break;\n        case kPGMC_StopMode:\n            base->CPC_CORE_POWER_CTRL |= PGMC_CPC_CPC_CORE_POWER_CTRL_PWR_OFF_AT_STOP_MASK;\n            break;\n        case kPGMC_SuspendMode:\n            base->CPC_CORE_POWER_CTRL |= PGMC_CPC_CPC_CORE_POWER_CTRL_PWR_OFF_AT_SUSPEND_MASK;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n}\nvoid PGMC_CPC_CACHE_ControlByCpuPowerMode(PGMC_CPC_Type *base,\n                                          pgmc_cpu_mode_t mode,\n                                          pgmc_memory_low_power_level_t memoryLowPowerLevel)\n{\n    uint32_t temp32;\n    base->CPC_CACHE_MODE = PGMC_CPC_CPC_CACHE_MODE_CTRL_MODE(kPGMC_ControlledByCpuPowerMode);\n    temp32               = base->CPC_CACHE_CM_CTRL;\n    switch (mode)\n    {\n        case kPGMC_RunMode:\n            temp32 &= ~PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_RUN_MASK;\n            base->CPC_CACHE_CM_CTRL = temp32 | PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_RUN(memoryLowPowerLevel);\n            break;\n        case kPGMC_WaitMode:\n            temp32 &= ~PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_WAIT_MASK;\n            base->CPC_CACHE_CM_CTRL = temp32 | PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_WAIT(memoryLowPowerLevel);\n            break;\n        case kPGMC_StopMode:\n            temp32 &= ~PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_STOP_MASK;\n            base->CPC_CACHE_CM_CTRL = temp32 | PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_STOP(memoryLowPowerLevel);\n            break;\n        case kPGMC_SuspendMode:\n            temp32 &= ~PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_SUSPEND_MASK;\n            base->CPC_CACHE_CM_CTRL = temp32 | PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_AT_SUSPEND(memoryLowPowerLevel);\n            break;\n        default:\n            assert(false);\n            break;\n    }\n}\nvoid PGMC_CPC_CACHE_ControlBySetPointMode(PGMC_CPC_Type *base,\n                                          uint32_t setPointMap,\n                                          pgmc_memory_low_power_level_t memoryLowPowerLevel)\n{\n    uint32_t setPointIndex             = 0UL;\n    uint32_t tmp32                     = 0UL;\n    uint32_t regIndex                  = 0UL;\n    volatile uint32_t *ptrMemSpCtrlReg = NULL;\n    setPointMap &= 0xFFFFU;\n    base->CPC_CACHE_MODE = PGMC_CPC_CPC_CACHE_MODE_CTRL_MODE(kPGMC_ControlledBySetPoint);\n    ptrMemSpCtrlReg = &(base->CPC_CACHE_SP_CTRL_0);\n    for (regIndex = 0UL; regIndex < 2UL; regIndex++)\n    {\n        ptrMemSpCtrlReg += regIndex;\n        tmp32 = *ptrMemSpCtrlReg;\n        for (setPointIndex = 0UL; setPointIndex < 8UL; setPointIndex++)\n        {\n            if (0UL != (setPointMap & (1UL << ((regIndex * 8UL) + setPointIndex))))\n            {\n                tmp32 &= ~((uint32_t)PGMC_CPC_CPC_CACHE_SP_CTRL_0_MLPL_AT_SP0_MASK << (setPointIndex * 4U));\n                tmp32 |= ((uint32_t)memoryLowPowerLevel << (setPointIndex * 4U));\n            }\n        }\n        *ptrMemSpCtrlReg = tmp32;\n    }\n}\nvoid PGMC_CPC_CACHE_TriggerMLPLSoftwareChange(PGMC_CPC_Type *base)\n{\n    base->CPC_CACHE_CM_CTRL |= PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_SOFT_MASK;\n    while (0UL != ((base->CPC_CACHE_CM_CTRL) & PGMC_CPC_CPC_CACHE_CM_CTRL_MLPL_SOFT_MASK))\n    {\n    }\n}\nvoid PGMC_CPC_LMEM_ControlByCpuPowerMode(PGMC_CPC_Type *base,\n                                         pgmc_cpu_mode_t mode,\n                                         pgmc_memory_low_power_level_t memoryLowPowerLevel)\n{\n    uint32_t temp32;\n    base->CPC_LMEM_MODE = PGMC_CPC_CPC_LMEM_MODE_CTRL_MODE(kPGMC_ControlledByCpuPowerMode);\n    temp32 = base->CPC_LMEM_CM_CTRL;\n    switch (mode)\n    {\n        case kPGMC_RunMode:\n            temp32 &= ~PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_RUN_MASK;\n            base->CPC_LMEM_CM_CTRL = temp32 | PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_RUN(memoryLowPowerLevel);\n            break;\n        case kPGMC_WaitMode:\n            temp32 &= ~PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_WAIT_MASK;\n            base->CPC_LMEM_CM_CTRL = temp32 | PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_WAIT(memoryLowPowerLevel);\n            break;\n        case kPGMC_StopMode:\n            temp32 &= ~PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_STOP_MASK;\n            base->CPC_LMEM_CM_CTRL = temp32 | PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_STOP(memoryLowPowerLevel);\n            break;\n        case kPGMC_SuspendMode:\n            temp32 &= ~PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_SUSPEND_MASK;\n            base->CPC_LMEM_CM_CTRL = temp32 | PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_AT_SUSPEND(memoryLowPowerLevel);\n            break;\n        default:\n            assert(false);\n            break;\n    }\n}\nvoid PGMC_CPC_LMEM_ControlBySetPointMode(PGMC_CPC_Type *base,\n                                         uint32_t setPointMap,\n                                         pgmc_memory_low_power_level_t memoryLowPowerLevel)\n{\n    uint32_t setPointIndex             = 0UL;\n    uint32_t tmp32                     = 0UL;\n    uint32_t regIndex                  = 0UL;\n    volatile uint32_t *ptrMemSpCtrlReg = NULL;\n    setPointMap &= 0xFFFFU;\n    base->CPC_LMEM_MODE = PGMC_CPC_CPC_LMEM_MODE_CTRL_MODE(kPGMC_ControlledBySetPoint);\n    ptrMemSpCtrlReg = &(base->CPC_LMEM_SP_CTRL_0);\n    for (regIndex = 0UL; regIndex < 2UL; regIndex++)\n    {\n        ptrMemSpCtrlReg += regIndex;\n        tmp32 = *ptrMemSpCtrlReg;\n        for (setPointIndex = 0UL; setPointIndex < 8UL; setPointIndex++)\n        {\n            if (0UL != (setPointMap & (1UL << ((regIndex * 8UL) + setPointIndex))))\n            {\n                tmp32 &= ~((uint32_t)PGMC_CPC_CPC_LMEM_SP_CTRL_0_MLPL_AT_SP0_MASK << (setPointIndex * 4U));\n                tmp32 |= ((uint32_t)memoryLowPowerLevel << (setPointIndex * 4U));\n            }\n        }\n        *ptrMemSpCtrlReg = tmp32;\n    }\n}\nvoid PGMC_CPC_LMEM_TriggerMLPLSoftwareChange(PGMC_CPC_Type *base)\n{\n    base->CPC_LMEM_CM_CTRL |= PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_SOFT_MASK;\n    while (0UL != ((base->CPC_LMEM_CM_CTRL) & PGMC_CPC_CPC_LMEM_CM_CTRL_MLPL_SOFT_MASK))\n    {\n    }\n}\nvoid PGMC_MIF_SetSignalBehaviour(PGMC_MIF_Type *base, pgmc_memory_low_power_level_t memoryLevel, uint32_t mask)\n{\n    uint8_t signalIndex           = 0U;\n    uint32_t temp32               = 0U;\n    PGMC_MIF_SIGNAL_Type *MIF_SIG = (PGMC_MIF_SIGNAL_Type *)(uint32_t)(&(base->MIF_MLPL_SLEEP));\n    for (signalIndex = 0U; signalIndex < 11U; signalIndex++)\n    {\n        temp32 = MIF_SIG[signalIndex].SIGNAL;\n        temp32 &= ~(1UL << (uint32_t)memoryLevel);\n        temp32 |= ((uint32_t)(mask & (1UL << signalIndex)) << (uint32_t)memoryLevel);\n        MIF_SIG[signalIndex].SIGNAL = temp32;\n    }\n}\nvoid PGMC_PPC_ControlByCpuPowerMode(PGMC_PPC_Type *base, pgmc_cpu_mode_t mode)\n{\n    base->PPC_MODE = PGMC_PPC_PPC_MODE_CTRL_MODE(kPGMC_ControlledByCpuPowerMode);\n    switch (mode)\n    {\n        case kPGMC_RunMode:\n            break;\n        case kPGMC_WaitMode:\n            base->PPC_STBY_CM_CTRL |= PGMC_PPC_PPC_STBY_CM_CTRL_STBY_ON_AT_WAIT_MASK;\n            break;\n        case kPGMC_StopMode:\n            base->PPC_STBY_CM_CTRL |= PGMC_PPC_PPC_STBY_CM_CTRL_STBY_ON_AT_STOP_MASK;\n            break;\n        case kPGMC_SuspendMode:\n            base->PPC_STBY_CM_CTRL |= PGMC_PPC_PPC_STBY_CM_CTRL_STBY_ON_AT_SUSPEND_MASK;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n}\nvoid PGMC_PPC_ControlBySetPointMode(PGMC_PPC_Type *base, uint32_t setPointMap, bool enableStandby)\n{\n    setPointMap &= 0xFFFFU;\n    base->PPC_MODE = PGMC_PPC_PPC_MODE_CTRL_MODE(kPGMC_ControlledBySetPoint);\n    if (enableStandby)\n    {\n        base->PPC_STBY_SP_CTRL = (setPointMap << PGMC_PPC_PPC_STBY_SP_CTRL_STBY_ON_AT_SP_SLEEP_SHIFT);\n    }\n    else\n    {\n        base->PPC_STBY_SP_CTRL = setPointMap;\n    }\n}'"
"'Prompt: You are tasked with initializing the Error Signaling Module (ESM) on a TMS570 microcontroller. The ESM needs to be configured with specific values for its registers to ensure proper functionality. Please write a function tms570_esm_init() that sets the necessary values for the ESM registers as follows:. - Configure DEPAPR1, IEPCR4, IECR1, IECR4, SR[0], SR[1], SSR2, SR[2], SR4, and LTCPR registers to 0xFFFFFFFFU.. - If EPSR register is 0, set EKR to 0x0000000AU and then to 0x00000000U.. - Set ILCR1, ILCR4, ILSR1, ILSR4, EEPAPR1, IEPSR4, IESR1, and IESR4 registers to 0x00000000.. Please",void tms570_esm_init( void )\n{\n  TMS570_ESM.DEPAPR1 = 0xFFFFFFFFU;\n  TMS570_ESM.IEPCR4 = 0xFFFFFFFFU;\n  TMS570_ESM.IECR1 = 0xFFFFFFFFU;\n  TMS570_ESM.IECR4 = 0xFFFFFFFFU;\n  TMS570_ESM.SR[0U] = 0xFFFFFFFFU;\n  TMS570_ESM.SR[1U] = 0xFFFFFFFFU;\n  TMS570_ESM.SSR2   = 0xFFFFFFFFU;\n  TMS570_ESM.SR[2U] = 0xFFFFFFFFU;\n  TMS570_ESM.SR4    = 0xFFFFFFFFU;\n  TMS570_ESM.LTCPR = 16384U - 1U;\n  if (TMS570_ESM.EPSR == 0U) {\n    TMS570_ESM.EKR = 0x0000000AU;\n    TMS570_ESM.EKR = 0x00000000U;\n  }\n  TMS570_ESM.ILCR1 = 0xFFFFFFFFU;\n  TMS570_ESM.ILCR4 = 0xFFFFFFFFU;\n  TMS570_ESM.ILSR1 = 0x00000000;\n  TMS570_ESM.ILSR4 = 0x00000000;\n  TMS570_ESM.EEPAPR1 = 0x00000000;\n  TMS570_ESM.IEPSR4 = 0x00000000;\n  TMS570_ESM.IESR1 = 0x00000000;\n  TMS570_ESM.IESR4 = 0x00000000;\n}'
"(""Prompt: You are working on a signal processing application where you need to estimate the required filter length based on a given bandwidth and stopband level. You want a function that can estimate the required filter length using Herrmann's method as well as using Kaiser's method. Additionally, you need a function that estimates the stopband level given the bandwidth and the desired filter length. Please provide the code to achieve these functionalities.","//...\nfloat estimate_req_filter_len_Herrmann(float _df,\n                                       float _as)\n{\n    if (_df > 0.5f || _df <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""estimate_req_filter_len_Herrmann(), invalid bandwidth : %f"", _df);\n        return 0.0f;\n    } else if (_as <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""estimate_req_filter_len(), invalid stopband level : %f"", _as);\n        return 0.0f;\n    }\n    if (_as > 105.0f)\n        return estimate_req_filter_len_Kaiser(_df,_as);\n    _as += 7.4f;\n    float d1, d2;\n    d1 = d2 = powf(10.0, -_as/20.0);\n    float t1 = log10f(d1);\n    float t2 = log10f(d2);\n    float Dinf = (0.005309f*t1*t1 + 0.07114f*t1 - 0.4761f)*t2 -\n                 (0.002660f*t1*t1 + 0.59410f*t1 + 0.4278f);\n    float f = 11.012f + 0.51244f*(t1-t2);\n    float h_len = (Dinf - f*_df*_df) / _df + 1.0f;\n    return h_len;\n}\nfloat estimate_req_filter_len_Kaiser(float _df,\n                                     float _as)\n{\n    if (_df > 0.5f || _df <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""estimate_req_filter_len_Kaiser(), invalid bandwidth : %f"", _df);\n        return 0.0f;\n    } else if (_as <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""estimate_req_filter_len(), invalid stopband level : %f"", _as);\n        return 0.0f;\n    }\n    return (_as - 7.95f)/(14.26f*_df);\n}\nunsigned int estimate_req_filter_len(float _df,\n                                     float _as)\n{\n    if (_df > 0.5f || _df <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""estimate_req_filter_len(), invalid bandwidth : %f"", _df);\n        return 0;\n    } else if (_as <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""estimate_req_filter_len(), invalid stopband level : %f"", _as);\n        return 0;\n    }\n#if ESTIMATE_REQ_FILTER_LEN_METHOD == ESTIMATE_REQ_FILTER_LEN_METHOD_KAISER\n    unsigned int h_len = (unsigned int) estimate_req_filter_len_Kaiser(_df,_as);\n#elif ESTIMATE_REQ_FILTER_LEN_METHOD == ESTIMATE_REQ_FILTER_LEN_METHOD_HERRMANN\n    unsigned int h_len = (unsigned int) estimate_req_filter_len_Herrmann(_df,_as);\n#else\n#   error ""invalid required filter length estimation method""\n#endif\n    return h_len;\n}\nfloat estimate_req_filter_As(float        _df,\n                             unsigned int _n)\n{\n    float as0   = 0.01f;    \n    float as1   = 200.0f;   \n    float as_hat = 0.0f;    \n    float N_hat = 0.0f;     \n    unsigned int num_iterations = 20;\n    unsigned int i;\n    for (i=0; i<num_iterations; i++) {\n        as_hat = 0.5f*(as1 + as0);\n#if ESTIMATE_REQ_FILTER_LEN_METHOD == ESTIMATE_REQ_FILTER_LEN_METHOD_KAISER\n        N_hat = estimate_req_filter_len_Kaiser(_df, as_hat);\n#elif ESTIMATE_REQ_FILTER_LEN_METHOD == ESTIMATE_REQ_FILTER_LEN_METHOD_HERRMANN\n        N_hat = estimate_req_filter_len_Herrmann(_df, as_hat);\n#else\n#       error ""invalid required filter length estimation method""\n#endif\n        if (N_hat < (float)_n) {\n            as0 = as_hat;\n        } else {\n            as1 = as_hat;\n        }\n    }\n    return as_hat;\n}\n//...')
"
"('Prompt: You are implementing a software-defined radio system that uses Frequency Shift Keying (FSK) modulation to receive signals. You need to calculate the energy of a symbol in the demodulated FSK signal. Write a function `fskdem_get_symbol_energy` that takes in the FSK demodulator object `_q`, the symbol index `_s`, and a range `_range`, and returns the energy of the symbol. Ensure to handle cases where the symbol index exceeds the maximum, and limit the range to avoid overflow errors.","//...\nfloat fskdem_get_symbol_energy(fskdem       _q,\n                               unsigned int _s,\n                               unsigned int _range)\n{\n    if (_s >= _q->M) {\n        liquid_error(LIQUID_EICONFIG,""fskdem_get_symbol_energy(), input symbol (%u) exceeds maximum (%u)"",\n                _s, _q->M);\n        _s = 0;\n    }\n    if (_range > _q->K)\n        _range = _q->K;\n    unsigned int index = _q->demod_map[_s];\n    float complex v = _q->buf_freq[index];\n    float energy = crealf(v)*crealf(v) + cimagf(v)*cimagf(v);\n    int i;\n    for (i=0; i<_range; i++) {\n        unsigned int i0 = (index         + i) % _q->K;\n        unsigned int i1 = (index + _q->K - i) % _q->K;\n        float complex v0 = _q->buf_freq[i0];\n        float complex v1 = _q->buf_freq[i1];\n        energy += crealf(v0)*crealf(v0) + cimagf(v0)*cimagf(v0);\n        energy += crealf(v1)*crealf(v1) + cimagf(v1)*cimagf(v1);\n    }\n    return energy;\n}\n//...')
"
"('Prompt: ""I need a C program that creates a digital DC blocker filter and applies it to a signal with a DC offset. It should generate and plot the original input signal, the signal with DC offset, and the DC-blocked output. The program should also write the results to a file named \'firfilt_crcf_dcblocker_example.m\'. Can you do that for me?"". . Code response:. . ```c. #define OUTPUT_FILENAME ""firfilt_crcf_dcblocker_example.m"". int main() {.     unsigned int num_samples = 1200;    .     unsigned int m           = 25;      .     float        As          = 30.0f;   .     firfilt_crcf q = firfilt_crcf_create_dc_blocker(m,As);.     firfilt_crcf_print(q);.     float complex x[num_samples];   .     float complex y[num_samples];   .     float complex z[num_samples];   .     unsigned int i;.     for (i=0; i","#define OUTPUT_FILENAME ""firfilt_crcf_dcblocker_example.m""\nint main() {\n    unsigned int num_samples = 1200;    \n    unsigned int m           = 25;      \n    float        As          = 30.0f;   \n    firfilt_crcf q = firfilt_crcf_create_dc_blocker(m,As);\n    firfilt_crcf_print(q);\n    float complex x[num_samples];   \n    float complex y[num_samples];   \n    float complex z[num_samples];   \n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        x[i] = cexpf( (0.170f*i + 1e-4f*i*i)*_Complex_I );\n        y[i] = x[i] + 2.0f*cexpf( 0.007f*_Complex_I*i );\n        firfilt_crcf_push   (q, y[i]);\n        firfilt_crcf_execute(q, &z[i]);\n    }\n    firfilt_crcf_destroy(q);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""\\n"");\n    fprintf(fid,""num_samples=%u;\\n"",num_samples);\n    fprintf(fid,""x=zeros(1,num_samples);\\n"");\n    fprintf(fid,""y=zeros(1,num_samples);\\n"");\n    for (i=0; i<num_samples; i++) {\n        fprintf(fid,""x(%4u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(x[i]), cimagf(x[i]));\n        fprintf(fid,""y(%4u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(y[i]), cimagf(y[i]));\n        fprintf(fid,""z(%4u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(z[i]), cimagf(z[i]));\n    }\n    fprintf(fid,""t=0:(num_samples-1);\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(3,1,1);\\n"");\n    fprintf(fid,""  plot(t,real(x),\'-\',\'Color\',[1 1 1]*0.5,\'LineWidth\',1,...\\n"");\n    fprintf(fid,""       t,imag(x),\'-\',\'Color\',[0 0.2 0.5],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'original input\');\\n"");\n    fprintf(fid,""  legend(\'real\',\'imag\',\'location\',\'northeast\');\\n"");\n    fprintf(fid,""  axis([0 num_samples -3 3]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""subplot(3,1,2);\\n"");\n    fprintf(fid,""  plot(t,real(y),\'-\',\'Color\',[1 1 1]*0.5,\'LineWidth\',1,...\\n"");\n    fprintf(fid,""       t,imag(y),\'-\',\'Color\',[0 0.5 0.2],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'input with DC offset\');\\n"");\n    fprintf(fid,""  legend(\'real\',\'imag\',\'location\',\'northeast\');\\n"");\n    fprintf(fid,""  axis([0 num_samples -3 3]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""subplot(3,1,3);\\n"");\n    fprintf(fid,""  plot(t,real(z),\'-\',\'Color\',[1 1 1]*0.5,\'LineWidth\',1,...\\n"");\n    fprintf(fid,""       t,imag(z),\'-\',\'Color\',[0 0.2 0.5],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'DC-blocked output\');\\n"");\n    fprintf(fid,""  legend(\'real\',\'imag\',\'location\',\'northeast\');\\n"");\n    fprintf(fid,""  axis([0 num_samples -3 3]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Please write a function that applies a phase delay to a complex signal in the time domain. The function should take in the following parameters: pointer to the input signal `_h`, pointer to the output signal `_h_prime`, length of the signals `_h_len`, and the delay `_dt`. The delay should be applied in the frequency domain by multiplying each frequency component by a complex exponential term based on the given delay. Use Fast Fourier Transform (FFT) functions to convert the signals between the time and frequency domains.","//...\nvoid apply_delay(float *      _h,\n                 float *      _h_prime,\n                 unsigned int _h_len,\n                 float        _dt)\n{\n    unsigned int L = _h_len % 2;\n    unsigned int m = (_h_len - L)/2;\n    float complex buf_time[_h_len];\n    float complex buf_freq[_h_len];\n    unsigned int i;\n    for (i=0; i<_h_len; i++)\n        buf_time[i] = _h[(i + m)%_h_len];\n    fft_run(_h_len, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    for (i=0; i<_h_len; i++) {\n        float v = (float)i - (float)m;\n        buf_freq[(i+m+L)%_h_len] *= cexpf(-_Complex_I*_dt*2.*M_PI*v/(float)_h_len);;\n    }\n#if 0\n    for (i=0; i<_h_len; i++)\n        printf(""H(%3u) = %12.8f + %12.8fi;\\n"", i+1, crealf(buf_freq[i]), cimagf(buf_freq[i]));\n    printf(""\\n"");\n#endif\n    fft_run(_h_len, buf_freq, buf_time, LIQUID_FFT_BACKWARD, 0);\n#if 0\n    for (i=0; i<_h_len; i++)\n        printf(""g(%3u) = %12.8f + %12.8fi;\\n"", i+1, crealf(buf_time[i]), cimagf(buf_time[i]));\n    printf(""\\n"");\n#endif\n    for (i=0; i<_h_len; i++) {\n        _h_prime[(i+m)%_h_len] = crealf( buf_time[i] );\n    }\n#if 0\n    for (i=0; i<_h_len; i++)\n        printf(""h(%3u) = %12.8f;\\n"", i+1, _h_prime[i]);\n#endif\n}\n//...')
"
"('Prompt: Calculate the output of a given FIR filter with coefficients and input data provided as complex arrays, using the C programming language. . . Response:. ```c. #include <liquid/liquid.h>. . float firfilt_crcf_data_h23x64_h[] = {.     0.158654410967,.    -0.020397216842,.    -0.054283334982,.     0.077922310650,.    -0.072938526203,.    -0.018649195029,.     0.037699516688,.     0.039617662775,.    -0.201106990060,.    -0.045133363773,.    -0.083275831491,.    -0.080588772189,.    -0.009860694810,.     0.086105167459,.     0.145475786114,.    -0.015729607185,.    -0","float firfilt_crcf_data_h23x64_h[] = {\n    0.158654410967,\n   -0.020397216842,\n   -0.054283334982,\n    0.077922310650,\n   -0.072938526203,\n   -0.018649195029,\n    0.037699516688,\n    0.039617662775,\n   -0.201106990060,\n   -0.045133363773,\n   -0.083275831491,\n   -0.080588772189,\n   -0.009860694810,\n    0.086105167459,\n    0.145475786114,\n   -0.015729607185,\n   -0.064199255334,\n   -0.041339777246,\n    0.031333251672,\n   -0.178929283974,\n   -0.144469434532,\n   -0.088642880661,\n    0.061210119166};\nfloat complex firfilt_crcf_data_h23x64_x[] = {\n   -0.061754655621 +   0.035123551291*_Complex_I,\n   -0.042987945529 +   0.204710494551*_Complex_I,\n   -0.115448103025 +  -0.048546960311*_Complex_I,\n   -0.107929842580 +  -0.067280385493*_Complex_I,\n   -0.138103588190 +   0.010448310166*_Complex_I,\n   -0.001556297552 +   0.087792883061*_Complex_I,\n    0.046355639811 +   0.064514990229*_Complex_I,\n   -0.073718979418 +   0.103212389197*_Complex_I,\n   -0.167000830993 +  -0.051389222147*_Complex_I,\n   -0.014426416714 +   0.176317900074*_Complex_I,\n   -0.107373342455 +  -0.005804161965*_Complex_I,\n    0.080493073150 +  -0.061646586042*_Complex_I,\n    0.027796421084 +  -0.154117176222*_Complex_I,\n    0.146227243025 +  -0.085442723323*_Complex_I,\n   -0.069720789489 +   0.186876621048*_Complex_I,\n    0.062823376713 +   0.065977046975*_Complex_I,\n    0.090031816754 +   0.114581114467*_Complex_I,\n    0.086442323768 +   0.125045380084*_Complex_I,\n    0.019615700330 +  -0.022164049481*_Complex_I,\n    0.002010913947 +   0.016348332723*_Complex_I,\n    0.115492888651 +  -0.140112679132*_Complex_I,\n   -0.000370552599 +   0.115418598778*_Complex_I,\n    0.171462023973 +   0.045787506437*_Complex_I,\n   -0.044111687463 +  -0.011704116119*_Complex_I,\n   -0.267816339997 +   0.084734013406*_Complex_I,\n    0.013814245144 +   0.002740227971*_Complex_I,\n    0.090220778414 +   0.134830380675*_Complex_I,\n   -0.106145737111 +  -0.024658098491*_Complex_I,\n   -0.112807070004 +   0.044997920710*_Complex_I,\n   -0.192053613103 +  -0.062114377970*_Complex_I,\n   -0.079637314543 +   0.045259089396*_Complex_I,\n    0.012470128523 +  -0.117498759881*_Complex_I,\n   -0.029098880159 +   0.100511335166*_Complex_I,\n    0.076820185739 +  -0.000579442122*_Complex_I,\n   -0.146557365265 +   0.068919305920*_Complex_I,\n    0.046650052137 +   0.086754950098*_Complex_I,\n    0.049312254431 +   0.100155311839*_Complex_I,\n   -0.018181427657 +  -0.155695073922*_Complex_I,\n   -0.020818721382 +   0.050839229113*_Complex_I,\n    0.075624933038 +  -0.140809485613*_Complex_I,\n    0.024131064286 +  -0.061085135867*_Complex_I,\n   -0.031646019927 +  -0.020171616314*_Complex_I,\n    0.029466323016 +  -0.143095954720*_Complex_I,\n   -0.000140873686 +   0.104732973661*_Complex_I,\n    0.124462359562 +  -0.105079943629*_Complex_I,\n   -0.058374142846 +   0.033466529094*_Complex_I,\n    0.026595988216 +   0.220281782376*_Complex_I,\n   -0.007221829817 +   0.141135026450*_Complex_I,\n   -0.021218003577 +  -0.050066565886*_Complex_I,\n    0.035694484054 +   0.231602026762*_Complex_I,\n    0.102466686268 +  -0.099286054817*_Complex_I,\n   -0.054792214672 +   0.060392934122*_Complex_I,\n   -0.001852582407 +   0.025794064903*_Complex_I,\n    0.071274514129 +   0.142237231718*_Complex_I,\n    0.029476880291 +   0.023165981190*_Complex_I,\n   -0.027797892310 +  -0.051616914281*_Complex_I,\n    0.061786844168 +   0.001190554171*_Complex_I,\n    0.041304624689 +  -0.028506531399*_Complex_I,\n   -0.075701492591 +  -0.019189579127*_Complex_I,\n   -0.043195431393 +  -0.100084431779*_Complex_I,\n    0.039964361882 +   0.004559897250*_Complex_I,\n   -0.252729884604 +  -0.091698894534*_Complex_I,\n   -0.056671384848 +   0.100393269844*_Complex_I,\n    0.047875493425 +  -0.053453060952*_Complex_I};\nfloat complex firfilt_crcf_data_h23x64_y[] = {\n   -0.009797648512 +   0.005572506341*_Complex_I,\n   -0.005560604075 +   0.031761800240*_Complex_I,\n   -0.014087267678 +  -0.013784337240*_Complex_I,\n   -0.017247262021 +  -0.018059567129*_Complex_I,\n   -0.012287793463 +   0.019054948700*_Complex_I,\n    0.003719976223 +  -0.002001383647*_Complex_I,\n    0.013367035883 +   0.003682443788*_Complex_I,\n   -0.017360179024 +   0.026029334165*_Complex_I,\n   -0.009179615321 +  -0.007210433367*_Complex_I,\n    0.014210107693 +  -0.025365792504*_Complex_I,\n    0.004045839585 +  -0.004700697501*_Complex_I,\n    0.037185762921 +  -0.032401586998*_Complex_I,\n    0.069046316115 +  -0.013271584282*_Complex_I,\n    0.033064747039 +  -0.020579633062*_Complex_I,\n   -0.010997016057 +   0.045070901497*_Complex_I,\n    0.004422576554 +   0.002390243257*_Complex_I,\n    0.033125238067 +  -0.006016697456*_Complex_I,\n   -0.016975087630 +  -0.035483520861*_Complex_I,\n    0.038314599881 +  -0.033008052971*_Complex_I,\n    0.036960796853 +   0.013280585218*_Complex_I,\n    0.048652304550 +  -0.021208466846*_Complex_I,\n   -0.029006820125 +   0.022587827802*_Complex_I,\n    0.028022156827 +   0.005836099363*_Complex_I,\n    0.022094506847 +   0.031041275846*_Complex_I,\n   -0.052928165220 +  -0.021052052066*_Complex_I,\n    0.018511503181 +  -0.110568047514*_Complex_I,\n    0.013151749885 +  -0.084455750067*_Complex_I,\n   -0.002103151576 +  -0.014246866235*_Complex_I,\n   -0.004981810769 +   0.036099080474*_Complex_I,\n    0.027562144328 +  -0.004142628424*_Complex_I,\n   -0.062965485082 +  -0.000721660223*_Complex_I,\n    0.001355528130 +   0.039494603193*_Complex_I,\n   -0.013676340973 +   0.019821560124*_Complex_I,\n    0.017190322837 +  -0.023603201848*_Complex_I,\n   -0.013639010839 +  -0.090413596530*_Complex_I,\n    0.035568646535 +  -0.005785803158*_Complex_I,\n    0.009541669638 +  -0.037656127703*_Complex_I,\n   -0.037436737172 +  -0.045380997215*_Complex_I,\n   -0.001373976193 +  -0.005853270514*_Complex_I,\n    0.037863401295 +   0.058080181959*_Complex_I,\n    0.036122757372 +  -0.031465040781*_Complex_I,\n   -0.080256218002 +   0.010144726857*_Complex_I,\n   -0.012130289685 +  -0.064577476905*_Complex_I,\n    0.001740193468 +  -0.024376309816*_Complex_I,\n    0.062877940058 +  -0.049615721082*_Complex_I,\n    0.020116976889 +  -0.036592663265*_Complex_I,\n   -0.000380054511 +   0.039223753313*_Complex_I,\n    0.017068821785 +   0.021526831643*_Complex_I,\n    0.021954695055 +   0.037691348334*_Complex_I,\n    0.067990755649 +   0.068783656132*_Complex_I,\n    0.037145711035 +   0.043650952232*_Complex_I,\n   -0.014003385917 +  -0.065891325372*_Complex_I,\n   -0.048189055475 +   0.056129109261*_Complex_I,\n    0.057414520047 +  -0.036184434048*_Complex_I,\n   -0.016064913162 +  -0.054756587631*_Complex_I,\n   -0.016229690128 +  -0.092689300019*_Complex_I,\n    0.009080345865 +   0.006957646952*_Complex_I,\n    0.017213929524 +  -0.068928651567*_Complex_I,\n   -0.036862824002 +   0.024446597685*_Complex_I,\n   -0.018313177259 +   0.012846228600*_Complex_I,\n   -0.002556177228 +   0.060786016298*_Complex_I,\n   -0.069716561264 +   0.004791194532*_Complex_I,\n   -0.004221111697 +  -0.015828369005*_Complex_I,\n    0.018252044788 +   0.020184229477*_Complex_I};')
"
"('Sure, the prompt for this code could be: ""Implement a function in C that calculates the dot product of two complex vectors using AVX-512 instructions. The function should have two versions: one for processing vectors with less than 128 elements and another for vectors with 128 or more elements. Ensure that the AVX-512 instructions are utilized efficiently for maximum performance.""","//...\nint dotprod_cccf_execute_avx512f(dotprod_cccf    _q,\n                             float complex * _x,\n                             float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    __m512 v;   \n    __m512 hi;  \n    __m512 hq;  \n    __m512 ci;  \n    __m512 cq;  \n    __m512 s;   \n    __m512 sum = _mm512_setzero_ps(); \n    __m512 one = _mm512_set1_ps(1.0f); \n    unsigned int t = (n >> 4) << 4;\n    unsigned int i;\n    for (i=0; i<t; i+=16) {\n        v = _mm512_loadu_ps(&x[i]);\n        hi = _mm512_load_ps(&_q->hi[i]);\n        hq = _mm512_load_ps(&_q->hq[i]);\n        ci = _mm512_mul_ps(v, hi);\n        cq = _mm512_mul_ps(v, hq);\n        cq = _mm512_shuffle_ps( cq, cq, _MM_SHUFFLE(2,3,0,1) );\n        s = _mm512_fmaddsub_ps( ci, one, cq );\n        sum = _mm512_add_ps(sum, s);\n    }\n    float w[2];\n    w[0] = _mm512_mask_reduce_add_ps(0x5555, sum);\n    w[1] = _mm512_mask_reduce_add_ps(0xAAAA, sum);\n    float complex total = w[0] + w[1] * _Complex_I;\n    for (i=t/2; i<_q->n; i++)\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    *_y = total;\n    return LIQUID_OK;\n}\nint dotprod_cccf_execute(dotprod_cccf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 128) {\n        return dotprod_cccf_execute_avx512f(_q, _x, _y);\n    }\n    return dotprod_cccf_execute_avx512f4(_q, _x, _y);\n}\nint dotprod_cccf_execute_avx512f4(dotprod_cccf    _q,\n                              float complex * _x,\n                              float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    __m512 v0,  v1,  v2,  v3;   \n    __m512 hi0, hi1, hi2, hi3;  \n    __m512 hq0, hq1, hq2, hq3;  \n    __m512 ci0, ci1, ci2, ci3;  \n    __m512 cq0, cq1, cq2, cq3;  \n    __m512 sumi = _mm512_setzero_ps();\n    __m512 sumq = _mm512_setzero_ps();\n    __m512 one = _mm512_set1_ps(1.0f); \n    unsigned int r = (n >> 6) << 4;\n    unsigned int i;\n    for (i=0; i<r; i+=16) {\n        v0 = _mm512_loadu_ps(&x[4*i+0]);\n        v1 = _mm512_loadu_ps(&x[4*i+16]);\n        v2 = _mm512_loadu_ps(&x[4*i+32]);\n        v3 = _mm512_loadu_ps(&x[4*i+48]);\n        hi0 = _mm512_load_ps(&_q->hi[4*i+0]);\n        hi1 = _mm512_load_ps(&_q->hi[4*i+16]);\n        hi2 = _mm512_load_ps(&_q->hi[4*i+32]);\n        hi3 = _mm512_load_ps(&_q->hi[4*i+48]);\n        hq0 = _mm512_load_ps(&_q->hq[4*i+0]);\n        hq1 = _mm512_load_ps(&_q->hq[4*i+16]);\n        hq2 = _mm512_load_ps(&_q->hq[4*i+32]);\n        hq3 = _mm512_load_ps(&_q->hq[4*i+48]);\n        ci0 = _mm512_mul_ps(v0, hi0);\n        ci1 = _mm512_mul_ps(v1, hi1);\n        ci2 = _mm512_mul_ps(v2, hi2);\n        ci3 = _mm512_mul_ps(v3, hi3);\n        cq0 = _mm512_mul_ps(v0, hq0);\n        cq1 = _mm512_mul_ps(v1, hq1);\n        cq2 = _mm512_mul_ps(v2, hq2);\n        cq3 = _mm512_mul_ps(v3, hq3);\n        sumi = _mm512_add_ps(sumi, ci0);   sumq = _mm512_add_ps(sumq, cq0);\n        sumi = _mm512_add_ps(sumi, ci1);   sumq = _mm512_add_ps(sumq, cq1);\n        sumi = _mm512_add_ps(sumi, ci2);   sumq = _mm512_add_ps(sumq, cq2);\n        sumi = _mm512_add_ps(sumi, ci3);   sumq = _mm512_add_ps(sumq, cq3);\n    }\n    sumq = _mm512_shuffle_ps( sumq, sumq, _MM_SHUFFLE(2,3,0,1) );\n    sumi = _mm512_fmaddsub_ps( sumi, one, sumq );\n    float w[2];\n    w[0] = _mm512_mask_reduce_add_ps(0x5555, sumi);\n    w[1] = _mm512_mask_reduce_add_ps(0xAAAA, sumi);\n    float complex total = w[0] + w[1] * _Complex_I;\n    for (i=2*r; i<_q->n; i++) {\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    }\n    *_y = total;\n    return LIQUID_OK;\n}\nint dotprod_cccf_execute(dotprod_cccf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 128) {\n        return dotprod_cccf_execute_avx512f(_q, _x, _y);\n    }\n    return dotprod_cccf_execute_avx512f4(_q, _x, _y);\n}\n//...')
"
"('Prompt: You are working on a statistical computing project that requires implementing functions for generating random numbers and calculating probability density functions and cumulative distribution functions. Specifically, you need functions to generate random numbers from a Nakagami-m distribution and calculate its PDF and CDF. The Nakagami-m distribution is characterized by two parameters: m and omega. . . Given this scenario, could you provide code for three functions: randnakmf(float _m, float _omega) for generating random numbers, randnakmf_pdf(float _x, float _m, float _omega) for calculating the PDF, and randnakmf_cdf(float _x, float _m, float _omega) for calculating the CDF of the Nakagami-m distribution? The functions should include error checking for parameter validity such as m not less than 0.5 and omega greater than zero.","float randnakmf(float _m,\n                float _omega)\n{\n    if (_m < 0.5f) {\n        liquid_error(LIQUID_EICONFIG,""randnakmf(), m cannot be less than 0.5"");\n        return 0.0f;\n    } else if (_omega <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randnakmf(), omega must be greater than zero"");\n        return 0.0f;\n    }\n    float alpha = _m;\n    float beta  = _omega / _m;\n    float x = randgammaf(alpha,beta);\n    return sqrtf(x);\n}\nfloat randnakmf_pdf(float _x,\n                    float _m,\n                    float _omega)\n{\n    if (_m < 0.5f) {\n        liquid_error(LIQUID_EICONFIG,""randnakmf_pdf(), m cannot be less than 0.5"");\n        return 0.0f;\n    } else if (_omega <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randnakmf_pdf(), omega must be greater than zero"");\n        return 0.0f;\n    }\n    if (_x <= 0.0f)\n        return 0.0f;\n    float t0 = liquid_lngammaf(_m);\n    float t1 = _m * logf(_m/_omega);\n    float t2 = (2*_m - 1.0f) * logf(_x);\n    float t3 = -(_m/_omega)*_x*_x;\n    return 2.0f * expf( -t0 + t1 + t2 + t3 );\n}\nfloat randnakmf_cdf(float _x,\n                    float _m,\n                    float _omega)\n{\n    if (_m < 0.5f) {\n        liquid_error(LIQUID_EICONFIG,""randnakmf_cdf(), m cannot be less than 0.5"");\n        return 0.0f;\n    } else if (_omega <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randnakmf_cdf(), omega must be greater than zero"");\n        return 0.0f;\n    }\n    if (_x <= 0.0f)\n        return 0.0f;\n    float t0 = liquid_lnlowergammaf(_m, _x*_x*_m/_omega);\n    float t1 = liquid_lngammaf(_m);\n    return expf( t0 - t1 );\n}')
"
"('Prompt: **Design a test scenario for a function that involves scrambling and unscrambling data for soft bits processing.**. . Response code:. ```c. void liquid_scramble_soft_test(unsigned int _n). {.     unsigned char msg_org[_n];      .     unsigned char msg_enc[_n];      .     unsigned char msg_soft[8*_n];   .     unsigned char msg_dec[_n];      .     unsigned int i;.     for (i=0; i<_n; i++).         msg_org[i] = rand() & 0xff; // Generate random data.     memmove(msg_enc, msg_org, _n); // Move original data to encoded message.     scramble_data(msg_enc, _n); // Scramble encoded data.     for (i=0; i<_n; i++).         liquid_unpack_soft_bits(msg_enc[i], 8, &msg_soft[8*i]); // Unpack soft bits.     unscramble_data_soft(msg","//...\nvoid liquid_scramble_soft_test(unsigned int _n)\n{\n    unsigned char msg_org[_n];      \n    unsigned char msg_enc[_n];      \n    unsigned char msg_soft[8*_n];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++)\n        msg_org[i] = rand() & 0xff;\n    memmove(msg_enc, msg_org, _n);\n    scramble_data(msg_enc,_n);\n    for (i=0; i<_n; i++)\n        liquid_unpack_soft_bits(msg_enc[i], 8, &msg_soft[8*i]);\n    unscramble_data_soft(msg_soft, _n);\n    for (i=0; i<_n; i++) {\n        unsigned int sym_out;\n        liquid_pack_soft_bits(&msg_soft[8*i], 8, &sym_out);\n        msg_dec[i] = sym_out;\n    }\n    CONTEND_SAME_DATA(msg_org, msg_dec, _n);\n}\n//...')
"
'Please provide a prompt related to initializing and setting up the LPTIM module with various functionalities and callbacks.,"#ifdef HAL_LPTIM_MODULE_ENABLED\n#if defined (LPTIM1) || defined (LPTIM2) || defined (LPTIM3) || defined (LPTIM4) || defined (LPTIM5)\n#define TIMEOUT                                     1000UL \n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\nstatic void LPTIM_ResetCallback(LPTIM_HandleTypeDef *lptim);\n#endif \nstatic HAL_StatusTypeDef LPTIM_WaitForFlag(LPTIM_HandleTypeDef *hlptim, uint32_t flag);\nHAL_StatusTypeDef HAL_LPTIM_Init(LPTIM_HandleTypeDef *hlptim)\n{\n  uint32_t tmpcfgr;\n  if (hlptim == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_CLOCK_SOURCE(hlptim->Init.Clock.Source));\n  assert_param(IS_LPTIM_CLOCK_PRESCALER(hlptim->Init.Clock.Prescaler));\n  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)\n      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    assert_param(IS_LPTIM_CLOCK_POLARITY(hlptim->Init.UltraLowPowerClock.Polarity));\n    assert_param(IS_LPTIM_CLOCK_SAMPLE_TIME(hlptim->Init.UltraLowPowerClock.SampleTime));\n  }\n  assert_param(IS_LPTIM_TRG_SOURCE(hlptim->Init.Trigger.Source));\n  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    assert_param(IS_LPTIM_EXT_TRG_POLARITY(hlptim->Init.Trigger.ActiveEdge));\n    assert_param(IS_LPTIM_TRIG_SAMPLE_TIME(hlptim->Init.Trigger.SampleTime));\n  }\n  assert_param(IS_LPTIM_OUTPUT_POLARITY(hlptim->Init.OutputPolarity));\n  assert_param(IS_LPTIM_UPDATE_MODE(hlptim->Init.UpdateMode));\n  assert_param(IS_LPTIM_COUNTER_SOURCE(hlptim->Init.CounterSource));\n  if (hlptim->State == HAL_LPTIM_STATE_RESET)\n  {\n    hlptim->Lock = HAL_UNLOCKED;\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n    LPTIM_ResetCallback(hlptim);\n    if (hlptim->MspInitCallback == NULL)\n    {\n      hlptim->MspInitCallback = HAL_LPTIM_MspInit;\n    }\n    hlptim->MspInitCallback(hlptim);\n#else\n    HAL_LPTIM_MspInit(hlptim);\n#endif \n  }\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  tmpcfgr = hlptim->Instance->CFGR;\n  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)\n      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKPOL | LPTIM_CFGR_CKFLT));\n  }\n  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_TRGFLT | LPTIM_CFGR_TRIGSEL));\n  }\n  tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKSEL | LPTIM_CFGR_TRIGEN | LPTIM_CFGR_PRELOAD |\n                          LPTIM_CFGR_WAVPOL | LPTIM_CFGR_PRESC | LPTIM_CFGR_COUNTMODE));\n  tmpcfgr |= (hlptim->Init.Clock.Source    |\n              hlptim->Init.Clock.Prescaler |\n              hlptim->Init.OutputPolarity  |\n              hlptim->Init.UpdateMode      |\n              hlptim->Init.CounterSource);\n  if (hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC)\n  {\n    tmpcfgr |= (hlptim->Init.Trigger.SampleTime |\n                hlptim->Init.UltraLowPowerClock.SampleTime);\n  }\n  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)\n      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |\n                hlptim->Init.UltraLowPowerClock.SampleTime);\n  }\n  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    tmpcfgr |= (hlptim->Init.Trigger.Source     |\n                hlptim->Init.Trigger.ActiveEdge |\n                hlptim->Init.Trigger.SampleTime);\n  }\n  hlptim->Instance->CFGR = tmpcfgr;\n  if ((hlptim->Instance == LPTIM1) || (hlptim->Instance == LPTIM2))\n  {\n    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance, hlptim->Init.Input1Source));\n    assert_param(IS_LPTIM_INPUT2_SOURCE(hlptim->Instance, hlptim->Init.Input2Source));\n    hlptim->Instance->CFGR2 = (hlptim->Init.Input1Source | hlptim->Init.Input2Source);\n  }\n  else\n  {\n    if (hlptim->Instance == LPTIM3)\n    {\n      assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance, hlptim->Init.Input1Source));\n      hlptim->Instance->CFGR2 = hlptim->Init.Input1Source;\n    }\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_DeInit(LPTIM_HandleTypeDef *hlptim)\n{\n  if (hlptim == NULL)\n  {\n    return HAL_ERROR;\n  }\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n  if (hlptim->MspDeInitCallback == NULL)\n  {\n    hlptim->MspDeInitCallback = HAL_LPTIM_MspDeInit;\n  }\n  hlptim->MspDeInitCallback(hlptim);\n#else\n  HAL_LPTIM_MspDeInit(hlptim);\n#endif \n  hlptim->State = HAL_LPTIM_STATE_RESET;\n  __HAL_UNLOCK(hlptim);\n  return HAL_OK;\n}\n__weak void HAL_LPTIM_MspInit(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_MspDeInit(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\nHAL_StatusTypeDef HAL_LPTIM_PWM_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_PWM_Stop(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_PWM_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPOK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_PWM_Stop_IT(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPOK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_OnePulse_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_START_SINGLE(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_OnePulse_Stop(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_OnePulse_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPOK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_START_SINGLE(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_OnePulse_Stop_IT(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPOK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_SetOnce_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR |= LPTIM_CFGR_WAVE;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_START_SINGLE(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_SetOnce_Stop(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_SetOnce_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR |= LPTIM_CFGR_WAVE;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPOK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_START_SINGLE(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_SetOnce_Stop_IT(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPOK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Encoder_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period)\n{\n  uint32_t          tmpcfgr;\n  assert_param(IS_LPTIM_ENCODER_INTERFACE_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC);\n  assert_param(hlptim->Init.Clock.Prescaler == LPTIM_PRESCALER_DIV1);\n  assert_param(IS_LPTIM_CLOCK_POLARITY(hlptim->Init.UltraLowPowerClock.Polarity));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  tmpcfgr = hlptim->Instance->CFGR;\n  tmpcfgr &= (uint32_t)(~LPTIM_CFGR_CKPOL);\n  tmpcfgr |=  hlptim->Init.UltraLowPowerClock.Polarity;\n  hlptim->Instance->CFGR = tmpcfgr;\n  hlptim->Instance->CFGR |= LPTIM_CFGR_ENC;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Encoder_Stop(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_ENCODER_INTERFACE_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_ENC;\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Encoder_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period)\n{\n  uint32_t          tmpcfgr;\n  assert_param(IS_LPTIM_ENCODER_INTERFACE_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC);\n  assert_param(hlptim->Init.Clock.Prescaler == LPTIM_PRESCALER_DIV1);\n  assert_param(IS_LPTIM_CLOCK_POLARITY(hlptim->Init.UltraLowPowerClock.Polarity));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  tmpcfgr = hlptim->Instance->CFGR;\n  tmpcfgr &= (uint32_t)(~LPTIM_CFGR_CKPOL);\n  tmpcfgr |=  hlptim->Init.UltraLowPowerClock.Polarity;\n  hlptim->Instance->CFGR = tmpcfgr;\n  hlptim->Instance->CFGR |= LPTIM_CFGR_ENC;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_DOWN);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_UP);\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Encoder_Stop_IT(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_ENCODER_INTERFACE_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_ENC;\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_DOWN);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_UP);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_TimeOut_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Timeout)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Timeout));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR |= LPTIM_CFGR_TIMOUT;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Timeout);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_TimeOut_Stop(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_TIMOUT;\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_TimeOut_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Timeout)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Timeout));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  hlptim->Instance->CFGR |= LPTIM_CFGR_TIMOUT;\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n  __HAL_LPTIM_COMPARE_SET(hlptim, Timeout);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_TimeOut_Stop_IT(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_TIMOUT;\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Counter_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM)\n      && (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    assert_param(IS_LPTIM_CLOCK_PRESCALERDIV1(hlptim->Init.Clock.Prescaler));\n    hlptim->Instance->CFGR &= ~LPTIM_CFGR_PRESC;\n  }\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Counter_Stop(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Counter_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM)\n      && (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    assert_param(IS_LPTIM_CLOCK_PRESCALERDIV1(hlptim->Init.Clock.Prescaler));\n    hlptim->Instance->CFGR &= ~LPTIM_CFGR_PRESC;\n  }\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n  __HAL_LPTIM_ENABLE(hlptim);\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_LPTIM_Counter_Stop_IT(LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n  __HAL_LPTIM_DISABLE(hlptim);\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n  hlptim->State = HAL_LPTIM_STATE_READY;\n  return HAL_OK;\n}\nuint32_t HAL_LPTIM_ReadCounter(const LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  return (hlptim->Instance->CNT);\n}\nuint32_t HAL_LPTIM_ReadAutoReload(const LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  return (hlptim->Instance->ARR);\n}\nuint32_t HAL_LPTIM_ReadCompare(const LPTIM_HandleTypeDef *hlptim)\n{\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  return (hlptim->Instance->CMP);\n}\nvoid HAL_LPTIM_IRQHandler(LPTIM_HandleTypeDef *hlptim)\n{\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPM) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPM) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPM);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->CompareMatchCallback(hlptim);\n#else\n      HAL_LPTIM_CompareMatchCallback(hlptim);\n#endif \n    }\n  }\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARRM) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARRM) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARRM);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->AutoReloadMatchCallback(hlptim);\n#else\n      HAL_LPTIM_AutoReloadMatchCallback(hlptim);\n#endif \n    }\n  }\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_EXTTRIG) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_EXTTRIG) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_EXTTRIG);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->TriggerCallback(hlptim);\n#else\n      HAL_LPTIM_TriggerCallback(hlptim);\n#endif \n    }\n  }\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPOK) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPOK) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->CompareWriteCallback(hlptim);\n#else\n      HAL_LPTIM_CompareWriteCallback(hlptim);\n#endif \n    }\n  }\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARROK) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARROK) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->AutoReloadWriteCallback(hlptim);\n#else\n      HAL_LPTIM_AutoReloadWriteCallback(hlptim);\n#endif \n    }\n  }\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UP) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UP) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UP);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->DirectionUpCallback(hlptim);\n#else\n      HAL_LPTIM_DirectionUpCallback(hlptim);\n#endif \n    }\n  }\n  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_DOWN) != RESET)\n  {\n    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_DOWN) != RESET)\n    {\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_DOWN);\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n      hlptim->DirectionDownCallback(hlptim);\n#else\n      HAL_LPTIM_DirectionDownCallback(hlptim);\n#endif \n    }\n  }\n}\n__weak void HAL_LPTIM_CompareMatchCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_AutoReloadMatchCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_TriggerCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_CompareWriteCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_AutoReloadWriteCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_DirectionUpCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n__weak void HAL_LPTIM_DirectionDownCallback(LPTIM_HandleTypeDef *hlptim)\n{\n  UNUSED(hlptim);\n}\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\nHAL_StatusTypeDef HAL_LPTIM_RegisterCallback(LPTIM_HandleTypeDef        *hlptim,\n                                             HAL_LPTIM_CallbackIDTypeDef CallbackID,\n                                             pLPTIM_CallbackTypeDef      pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (pCallback == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if (hlptim->State == HAL_LPTIM_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_LPTIM_MSPINIT_CB_ID :\n        hlptim->MspInitCallback = pCallback;\n        break;\n      case HAL_LPTIM_MSPDEINIT_CB_ID :\n        hlptim->MspDeInitCallback = pCallback;\n        break;\n      case HAL_LPTIM_COMPARE_MATCH_CB_ID :\n        hlptim->CompareMatchCallback = pCallback;\n        break;\n      case HAL_LPTIM_AUTORELOAD_MATCH_CB_ID :\n        hlptim->AutoReloadMatchCallback = pCallback;\n        break;\n      case HAL_LPTIM_TRIGGER_CB_ID :\n        hlptim->TriggerCallback = pCallback;\n        break;\n      case HAL_LPTIM_COMPARE_WRITE_CB_ID :\n        hlptim->CompareWriteCallback = pCallback;\n        break;\n      case HAL_LPTIM_AUTORELOAD_WRITE_CB_ID :\n        hlptim->AutoReloadWriteCallback = pCallback;\n        break;\n      case HAL_LPTIM_DIRECTION_UP_CB_ID :\n        hlptim->DirectionUpCallback = pCallback;\n        break;\n      case HAL_LPTIM_DIRECTION_DOWN_CB_ID :\n        hlptim->DirectionDownCallback = pCallback;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else if (hlptim->State == HAL_LPTIM_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_LPTIM_MSPINIT_CB_ID :\n        hlptim->MspInitCallback = pCallback;\n        break;\n      case HAL_LPTIM_MSPDEINIT_CB_ID :\n        hlptim->MspDeInitCallback = pCallback;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    status =  HAL_ERROR;\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_LPTIM_UnRegisterCallback(LPTIM_HandleTypeDef        *hlptim,\n                                               HAL_LPTIM_CallbackIDTypeDef CallbackID)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (hlptim->State == HAL_LPTIM_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_LPTIM_MSPINIT_CB_ID :\n        hlptim->MspInitCallback = HAL_LPTIM_MspInit;\n        break;\n      case HAL_LPTIM_MSPDEINIT_CB_ID :\n        hlptim->MspDeInitCallback = HAL_LPTIM_MspDeInit;\n        break;\n      case HAL_LPTIM_COMPARE_MATCH_CB_ID :\n        hlptim->CompareMatchCallback = HAL_LPTIM_CompareMatchCallback;\n        break;\n      case HAL_LPTIM_AUTORELOAD_MATCH_CB_ID :\n        hlptim->AutoReloadMatchCallback = HAL_LPTIM_AutoReloadMatchCallback;\n        break;\n      case HAL_LPTIM_TRIGGER_CB_ID :\n        hlptim->TriggerCallback = HAL_LPTIM_TriggerCallback;\n        break;\n      case HAL_LPTIM_COMPARE_WRITE_CB_ID :\n        hlptim->CompareWriteCallback = HAL_LPTIM_CompareWriteCallback;\n        break;\n      case HAL_LPTIM_AUTORELOAD_WRITE_CB_ID :\n        hlptim->AutoReloadWriteCallback = HAL_LPTIM_AutoReloadWriteCallback;\n        break;\n      case HAL_LPTIM_DIRECTION_UP_CB_ID :\n        hlptim->DirectionUpCallback = HAL_LPTIM_DirectionUpCallback;\n        break;\n      case HAL_LPTIM_DIRECTION_DOWN_CB_ID :\n        hlptim->DirectionDownCallback = HAL_LPTIM_DirectionDownCallback;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else if (hlptim->State == HAL_LPTIM_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_LPTIM_MSPINIT_CB_ID :\n        hlptim->MspInitCallback = HAL_LPTIM_MspInit;\n        break;\n      case HAL_LPTIM_MSPDEINIT_CB_ID :\n        hlptim->MspDeInitCallback = HAL_LPTIM_MspDeInit;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    status =  HAL_ERROR;\n  }\n  return status;\n}\n#endif \nHAL_LPTIM_StateTypeDef HAL_LPTIM_GetState(LPTIM_HandleTypeDef *hlptim)\n{\n  return hlptim->State;\n}\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\nstatic void LPTIM_ResetCallback(LPTIM_HandleTypeDef *lptim)\n{\n  lptim->CompareMatchCallback    = HAL_LPTIM_CompareMatchCallback;\n  lptim->AutoReloadMatchCallback = HAL_LPTIM_AutoReloadMatchCallback;\n  lptim->TriggerCallback         = HAL_LPTIM_TriggerCallback;\n  lptim->CompareWriteCallback    = HAL_LPTIM_CompareWriteCallback;\n  lptim->AutoReloadWriteCallback = HAL_LPTIM_AutoReloadWriteCallback;\n  lptim->DirectionUpCallback     = HAL_LPTIM_DirectionUpCallback;\n  lptim->DirectionDownCallback   = HAL_LPTIM_DirectionDownCallback;\n}\n#endif \nstatic HAL_StatusTypeDef LPTIM_WaitForFlag(LPTIM_HandleTypeDef *hlptim, uint32_t flag)\n{\n  HAL_StatusTypeDef result = HAL_OK;\n  uint32_t count = TIMEOUT * (SystemCoreClock / 20UL / 1000UL);\n  do\n  {\n    count--;\n    if (count == 0UL)\n    {\n      result = HAL_TIMEOUT;\n    }\n  } while ((!(__HAL_LPTIM_GET_FLAG((hlptim), (flag)))) && (count != 0UL));\n  return result;\n}\nvoid LPTIM_Disable(LPTIM_HandleTypeDef *hlptim)\n{\n  uint32_t tmpclksource = 0;\n  uint32_t tmpIER;\n  uint32_t tmpCFGR;\n  uint32_t tmpCMP;\n  uint32_t tmpARR;\n  uint32_t primask_bit;\n  uint32_t tmpCFGR2;\n  primask_bit = __get_PRIMASK();\n  __set_PRIMASK(1) ;\n  switch ((uint32_t)hlptim->Instance)\n  {\n    case LPTIM1_BASE:\n      tmpclksource = __HAL_RCC_GET_LPTIM1_SOURCE();\n      break;\n    case LPTIM2_BASE:\n      tmpclksource = __HAL_RCC_GET_LPTIM2_SOURCE();\n      break;\n#if defined(LPTIM3)\n    case LPTIM3_BASE:\n      tmpclksource = __HAL_RCC_GET_LPTIM3_SOURCE();\n      break;\n#endif \n#if defined(LPTIM4)\n    case LPTIM4_BASE:\n      tmpclksource = __HAL_RCC_GET_LPTIM4_SOURCE();\n      break;\n#endif \n#if defined(LPTIM5)\n    case LPTIM5_BASE:\n      tmpclksource = __HAL_RCC_GET_LPTIM5_SOURCE();\n      break;\n#endif \n    default:\n      break;\n  }\n  tmpIER = hlptim->Instance->IER;\n  tmpCFGR = hlptim->Instance->CFGR;\n  tmpCMP = hlptim->Instance->CMP;\n  tmpARR = hlptim->Instance->ARR;\n  tmpCFGR2 = hlptim->Instance->CFGR2;\n  switch ((uint32_t)hlptim->Instance)\n  {\n    case LPTIM1_BASE:\n      __HAL_RCC_LPTIM1_FORCE_RESET();\n      __HAL_RCC_LPTIM1_RELEASE_RESET();\n      break;\n    case LPTIM2_BASE:\n      __HAL_RCC_LPTIM2_FORCE_RESET();\n      __HAL_RCC_LPTIM2_RELEASE_RESET();\n      break;\n#if defined(LPTIM3)\n    case LPTIM3_BASE:\n      __HAL_RCC_LPTIM3_FORCE_RESET();\n      __HAL_RCC_LPTIM3_RELEASE_RESET();\n      break;\n#endif \n#if defined(LPTIM4)\n    case LPTIM4_BASE:\n      __HAL_RCC_LPTIM4_FORCE_RESET();\n      __HAL_RCC_LPTIM4_RELEASE_RESET();\n      break;\n#endif \n#if defined(LPTIM5)\n    case LPTIM5_BASE:\n      __HAL_RCC_LPTIM5_FORCE_RESET();\n      __HAL_RCC_LPTIM5_RELEASE_RESET();\n      break;\n#endif \n    default:\n      break;\n  }\n  if ((tmpCMP != 0UL) || (tmpARR != 0UL))\n  {\n    switch ((uint32_t)hlptim->Instance)\n    {\n      case LPTIM1_BASE:\n        __HAL_RCC_LPTIM1_CONFIG(RCC_LPTIM1CLKSOURCE_D2PCLK1);\n        break;\n      case LPTIM2_BASE:\n        __HAL_RCC_LPTIM2_CONFIG(RCC_LPTIM2CLKSOURCE_D3PCLK1);\n        break;\n#if defined(LPTIM3)\n      case LPTIM3_BASE:\n        __HAL_RCC_LPTIM3_CONFIG(RCC_LPTIM3CLKSOURCE_D3PCLK1);\n        break;\n#endif \n#if defined(LPTIM4)\n      case LPTIM4_BASE:\n        __HAL_RCC_LPTIM4_CONFIG(RCC_LPTIM4CLKSOURCE_D3PCLK1);\n        break;\n#endif \n#if defined(LPTIM5)\n      case LPTIM5_BASE:\n        __HAL_RCC_LPTIM5_CONFIG(RCC_LPTIM5CLKSOURCE_D3PCLK1);\n        break;\n#endif \n      default:\n        break;\n    }\n    if (tmpCMP != 0UL)\n    {\n      hlptim->Instance->CR |= LPTIM_CR_ENABLE;\n      hlptim->Instance->CMP = tmpCMP;\n      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n      {\n        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;\n      }\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n    }\n    if (tmpARR != 0UL)\n    {\n      hlptim->Instance->CR |= LPTIM_CR_ENABLE;\n      hlptim->Instance->ARR = tmpARR;\n      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n      {\n        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;\n      }\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n    }\n    switch ((uint32_t)hlptim->Instance)\n    {\n      case LPTIM1_BASE:\n        __HAL_RCC_LPTIM1_CONFIG(tmpclksource);\n        break;\n      case LPTIM2_BASE:\n        __HAL_RCC_LPTIM2_CONFIG(tmpclksource);\n        break;\n#if defined(LPTIM3)\n      case LPTIM3_BASE:\n        __HAL_RCC_LPTIM3_CONFIG(tmpclksource);\n        break;\n#endif \n#if defined(LPTIM4)\n      case LPTIM4_BASE:\n        __HAL_RCC_LPTIM4_CONFIG(tmpclksource);\n        break;\n#endif \n#if defined(LPTIM5)\n      case LPTIM5_BASE:\n        __HAL_RCC_LPTIM5_CONFIG(tmpclksource);\n        break;\n#endif \n      default:\n        break;\n    }\n  }\n  hlptim->Instance->CR &= ~(LPTIM_CR_ENABLE);\n  hlptim->Instance->IER = tmpIER;\n  hlptim->Instance->CFGR = tmpCFGR;\n  hlptim->Instance->CFGR2 = tmpCFGR2;\n  __set_PRIMASK(primask_bit);\n}\n#endif \n#endif '"
"('Prompt: You are working on a software project that involves implementing forward error correction (FEC) schemes. You need a function that takes a FEC scheme as input and returns the rate associated with that scheme. The rates for different FEC schemes are defined in a switch statement based on the input scheme. Additionally, some FEC schemes are dependent on the availability of a library (libfec). Can you provide a function that achieves this functionality and handles cases where certain FEC schemes are unavailable due to missing library support?","//...\nconst char * fec_scheme_str[LIQUID_FEC_NUM_SCHEMES][2] = {\nfloat fec_get_rate(fec_scheme _scheme)\n{\n    switch (_scheme) {\n    case LIQUID_FEC_UNKNOWN:        return 0;\n    case LIQUID_FEC_NONE:           return 1.;\n    case LIQUID_FEC_REP3:           return 1./3.;\n    case LIQUID_FEC_REP5:           return 1./5.;\n    case LIQUID_FEC_HAMMING74:      return 4./7.;\n    case LIQUID_FEC_HAMMING84:      return 4./8.;\n    case LIQUID_FEC_HAMMING128:     return 8./12.;\n    case LIQUID_FEC_GOLAY2412:      return 1./2.;\n    case LIQUID_FEC_SECDED2216:     return 2./3.;   \n    case LIQUID_FEC_SECDED3932:     return 4./5.;   \n    case LIQUID_FEC_SECDED7264:     return 8./9.;\n#if LIBFEC_ENABLED\n    case LIQUID_FEC_CONV_V27:       return 1./2.;\n    case LIQUID_FEC_CONV_V29:       return 1./2.;\n    case LIQUID_FEC_CONV_V39:       return 1./3.;\n    case LIQUID_FEC_CONV_V615:      return 1./6.;\n    case LIQUID_FEC_CONV_V27P23:    return 2./3.;\n    case LIQUID_FEC_CONV_V27P34:    return 3./4.;\n    case LIQUID_FEC_CONV_V27P45:    return 4./5.;\n    case LIQUID_FEC_CONV_V27P56:    return 5./6.;\n    case LIQUID_FEC_CONV_V27P67:    return 6./7.;\n    case LIQUID_FEC_CONV_V27P78:    return 7./8.;\n    case LIQUID_FEC_CONV_V29P23:    return 2./3.;\n    case LIQUID_FEC_CONV_V29P34:    return 3./4.;\n    case LIQUID_FEC_CONV_V29P45:    return 4./5.;\n    case LIQUID_FEC_CONV_V29P56:    return 5./6.;\n    case LIQUID_FEC_CONV_V29P67:    return 6./7.;\n    case LIQUID_FEC_CONV_V29P78:    return 7./8.;\n    case LIQUID_FEC_RS_M8:          return 223./255.;\n#else\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n        liquid_error(LIQUID_EUMODE,""fec_get_rate(), convolutional codes unavailable (install libfec)"");\n        return 0.0f;\n    case LIQUID_FEC_RS_M8:\n        liquid_error(LIQUID_EUMODE,""fec_get_rate(), Reed-Solomon codes unavailable (install libfec)"");\n        return 0.0f;\n#endif\n    default:\n        liquid_error(LIQUID_EIMODE,""fec_get_rate(), unknown/unsupported scheme: %d"", _scheme);\n        return 0.0f;\n    }\n    return liquid_error(LIQUID_EINT,""internal error"");\n    return 0.0f;\n}\n//...')
"
"'Prompt: You are tasked with writing a function that sets up a UDP server on a specified host and port, receives data packets from connected clients, and prints out the received data. Additionally, you need to handle potential errors related to the communication.. . Response:. ```c. static int server(const char *host, uint16_t port). {.     int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);.     if (-1 == fd) {.         return -1;.     }.     ptcp_socket_t ptcp = ptcp_socket_by_fd(fd);.     if (ptcp == NULL) {.         printf(""ptcp_socket error!\\n"");.         return -1;.     }.     struct sockaddr_in si;.     si.sin_family = AF_INET;.     si.sin_addr.s_addr = host ? inet_addr(host) : INADDR_ANY;.     si.sin_port = htons(port);.     ptcp_bind(ptcp, (struct sockaddr*)&si, sizeof(si));.     ptcp_listen(ptcp","//...\nstatic int server(const char *host, uint16_t port)\n{\n    int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    if (-1 == fd) {\n        return -1;\n    }\n    ptcp_socket_t ptcp = ptcp_socket_by_fd(fd);\n    if (ptcp == NULL) {\n        printf(""ptcp_socket error!\\n"");\n        return -1;\n    }\n    struct sockaddr_in si;\n    si.sin_family = AF_INET;\n    si.sin_addr.s_addr = host ? inet_addr(host) : INADDR_ANY;\n    si.sin_port = htons(port);\n    ptcp_bind(ptcp, (struct sockaddr*)&si, sizeof(si));\n    ptcp_listen(ptcp, 0);\n    struct sockaddr remote;\n    socklen_t addrlen;\n    ptcp_accept(ptcp, &remote, &addrlen);\n#if 1\n    int len;\n    char buf[32] = {0};\n    while (1) {\n        memset(buf, 0, sizeof(buf));\n        len = ptcp_recv(ptcp, buf, sizeof(buf), 0);\n        buf[sizeof(buf)-1] = \'\\0\';\n        if (len > 0) {\n            printf(""ptcp_recv len=%d, buf=%s\\n"", len, buf);\n#if 0\n        } else if (ptcp_is_closed(sock)) {\n            printf(""ptcp is closed\\n"");\n            return -1;\n        } else if (EWOULDBLOCK == ptcp_get_error(sock)){\n            printf(""ptcp is error: %d\\n"", ptcp_get_error(sock));\n#endif\n        }\n        usleep(10 * 1000);\n    }\n#endif\n    ptcp_close_by_fd(ptcp, fd);\n    close(fd);\n    return 0;\n}\n//...'"
"'Prompt: You are tasked with configuring a TWI (Two-Wire Interface) communication protocol in an embedded system using an Atmel MCU. Provide functions for configuring TWI as master and slave, implementing read and write operations, handling interrupts, and sending STOP conditions. The TWI protocol should support various interrupt sources defined in the TWIHS_IT macro. Please write the necessary C code to achieve this functionality.","#define TWIHS_IT    (TWIHS_IER_TXCOMP | TWIHS_IER_TXCOMP | TWIHS_IER_RXRDY \\\n\t\t\t\t\t  | TWIHS_IER_TXRDY | TWIHS_IER_SVACC | TWIHS_IER_GACC | \\\n\t\t\t\t\t  TWIHS_IER_OVRE | TWIHS_IER_UNRE | TWIHS_IER_NACK | \\\n\t\t\t\t\t  TWIHS_IER_ARBLST | TWIHS_IER_SCL_WS | TWIHS_IER_EOSACC | \\\n\t\t\t\t\t  TWIHS_IER_MCACK | TWIHS_IER_TOUT | TWIHS_IER_PECERR |\\\n\t\t\t\t\t  TWIHS_IER_SMBDAM | TWIHS_IER_SMBHHM)\nuint32_t twi_send_stop = 0;\nvoid TWI_ConfigureMaster(Twihs *pTwi, uint32_t dwTwCk, uint32_t dwMCk)\n{\n\tuint32_t dwCkDiv = 0;\n\tuint32_t dwClDiv;\n\tuint32_t dwOk = 0;\n\tTRACE_DEBUG(""TWI_ConfigureMaster()\\n\\r"");\n\tassert(pTwi);\n\tpTwi->TWIHS_CR = TWIHS_CR_SWRST;\n\twhile (!dwOk) {\n\t\tdwClDiv = ((dwMCk / (2 * dwTwCk)) - 4) / (1 << dwCkDiv);\n\t\tif (dwClDiv <= 255)\n\t\t\tdwOk = 1;\n\t\telse\n\t\t\tdwCkDiv++;\n\t}\n\tassert(dwCkDiv < 8);\n\tTRACE_DEBUG(""Using CKDIV = %u and CLDIV/CHDIV = %u\\n\\r"", dwCkDiv, dwClDiv);\n\tpTwi->TWIHS_CWGR = (dwCkDiv << 16) | (dwClDiv << 8) | dwClDiv;\n\tpTwi->TWIHS_CR = TWIHS_CR_SVDIS;\n\tpTwi->TWIHS_CR = TWIHS_CR_MSEN;\n}\nvoid TWI_ConfigureSlave(Twihs *pTwi, uint8_t slaveAddress)\n{\n\tpTwi->TWIHS_CR = TWIHS_CR_SWRST;\n\tpTwi->TWIHS_SMR = TWIHS_SMR_SADR(slaveAddress);\n\tpTwi->TWIHS_CR = TWIHS_CR_MSDIS;\n\tpTwi->TWIHS_CR = TWIHS_CR_SVEN;\n\tassert((pTwi->TWIHS_CR & TWIHS_CR_SVDIS) != TWIHS_CR_SVDIS);\n}\nvoid TWI_Stop(Twihs *pTwi)\n{\n\tassert(pTwi != NULL);\n\tpTwi->TWIHS_CR = TWIHS_CR_STOP;\n}\nvoid TWI_StartRead(\n\tTwihs *pTwi,\n\tuint8_t address,\n\tuint32_t iaddress,\n\tuint8_t isize)\n{\n\tassert(pTwi != NULL);\n\tassert((address & 0x80) == 0);\n\tassert((iaddress & 0xFF000000) == 0);\n\tassert(isize < 4);\n\tpTwi->TWIHS_MMR = 0;\n\tpTwi->TWIHS_MMR = (isize << 8) | TWIHS_MMR_MREAD | (address << 16);\n\tpTwi->TWIHS_IADR = 0;\n\tpTwi->TWIHS_IADR = iaddress;\n\tif (0 == twi_send_stop)\n\t\tpTwi->TWIHS_CR = TWIHS_CR_START;\n\telse {\n\t\ttwi_send_stop = 0;\n\t\tpTwi->TWIHS_CR = TWIHS_CR_START | TWIHS_CR_STOP;\n\t}\n}\nuint8_t TWI_ReadByte(Twihs *pTwi)\n{\n\tassert(pTwi != NULL);\n\treturn pTwi->TWIHS_RHR;\n}\nvoid TWI_WriteByte(Twihs *pTwi, uint8_t byte)\n{\n\tassert(pTwi != NULL);\n\tpTwi->TWIHS_THR = byte;\n}\nvoid TWI_StartWrite(\n\tTwihs *pTwi,\n\tuint8_t address,\n\tuint32_t iaddress,\n\tuint8_t isize,\n\tuint8_t byte)\n{\n\tassert(pTwi != NULL);\n\tassert((address & 0x80) == 0);\n\tassert((iaddress & 0xFF000000) == 0);\n\tassert(isize < 4);\n\tpTwi->TWIHS_MMR = 0;\n\tpTwi->TWIHS_MMR = (isize << 8) | (address << 16);\n\tpTwi->TWIHS_IADR = 0;\n\tpTwi->TWIHS_IADR = iaddress;\n\tTWI_WriteByte(pTwi, byte);\n}\nuint8_t TWI_ByteReceived(Twihs *pTwi)\n{\n\treturn ((pTwi->TWIHS_SR & TWIHS_SR_RXRDY) == TWIHS_SR_RXRDY);\n}\nuint8_t TWI_ByteSent(Twihs *pTwi)\n{\n\treturn ((pTwi->TWIHS_SR & TWIHS_SR_TXRDY) == TWIHS_SR_TXRDY);\n}\nuint8_t TWI_TransferComplete(Twihs *pTwi)\n{\n\treturn ((pTwi->TWIHS_SR & TWIHS_SR_TXCOMP) == TWIHS_SR_TXCOMP);\n}\nvoid TWI_EnableIt(Twihs *pTwi, uint32_t sources)\n{\n\tassert(pTwi != NULL);\n\tassert((sources & TWIHS_IT));\n\tpTwi->TWIHS_IER = sources;\n}\nvoid TWI_DisableIt(Twihs *pTwi, uint32_t sources)\n{\n\tassert(pTwi != NULL);\n\tassert(sources & TWIHS_IT);\n\tpTwi->TWIHS_IDR = sources;\n}\nuint32_t TWI_GetStatus(Twihs *pTwi)\n{\n\tassert(pTwi != NULL);\n\treturn pTwi->TWIHS_SR;\n}\nuint32_t TWI_GetMaskedStatus(Twihs *pTwi)\n{\n\tuint32_t status;\n\tassert(pTwi != NULL);\n\tstatus = pTwi->TWIHS_SR;\n\tstatus &= pTwi->TWIHS_IMR;\n\treturn status;\n}\nvoid TWI_SendSTOPCondition(Twihs *pTwi)\n{\n\tassert(pTwi != NULL);\n\tpTwi->TWIHS_CR |= TWIHS_CR_STOP;\n}'"
"""Prompt: You are working on a GUI project using the LittlevGL library and want to create a slider with a corresponding label that displays the slider value in percentage. Write a function that sets up a slider and a label below it, updating the label text to reflect the slider's value as it changes. Make sure to include event handling for when the slider value changes.","#if LV_USE_SLIDER && LV_BUILD_EXAMPLES\nstatic void slider_event_cb(lv_event_t * e);\nstatic lv_obj_t * slider_label;\nvoid lv_example_slider_1(void)\n{\n    lv_obj_t * slider = lv_slider_create(lv_screen_active());\n    lv_obj_center(slider);\n    lv_obj_add_event_cb(slider, slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    lv_obj_set_style_anim_duration(slider, 2000, 0);\n    slider_label = lv_label_create(lv_screen_active());\n    lv_label_set_text(slider_label, ""0%"");\n    lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);\n}\nstatic void slider_event_cb(lv_event_t * e)\n{\n    lv_obj_t * slider = lv_event_get_target(e);\n    char buf[8];\n    lv_snprintf(buf, sizeof(buf), ""%d%%"", (int)lv_slider_get_value(slider));\n    lv_label_set_text(slider_label, buf);\n    lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);\n}\n#endif'"
"('Prompt: You are working on testing the synchronization functionality of an OFDM frame processing module. The module takes input in the form of complex numbers, processes the data, and then outputs a synchronized output. Your task is to create a callback function that will be invoked during the testing process and implement a test function to verify the synchronization accuracy. The test function should initialize necessary parameters, create an OFDM frame generator and synchronizer, generate test data, run the synchronization process, and then verify the output against the expected values. The test should be for a scenario where the number of subcarriers is 512, cyclic prefix length is 64, and taper length is 0. The test should check the synchronization accuracy and handle any discrepancies. You have been provided with the code for the callback function and the test function for this particular scenario.","//...\nint ofdmframesync_autotest_callback(float complex * _X,\n                                    unsigned char * _p,\n                                    unsigned int    _M,\n                                    void * _userdata)\n{\n    if (liquid_autotest_verbose)\n        printf(""******** callback invoked!\\n"");\n    float complex * X = (float complex *)_userdata;\n    memmove(X, _X, _M*sizeof(float complex));\n    return 0;\n}\nvoid ofdmframesync_acquire_test(unsigned int _num_subcarriers,\n                                unsigned int _cp_len,\n                                unsigned int _taper_len)\n{\n    unsigned int M         = _num_subcarriers;  \n    unsigned int cp_len    = _cp_len;           \n    unsigned int taper_len = _taper_len;        \n    float tol              = 1e-2f;             \n    float dphi = 1.0f / (float)M;       \n    unsigned char p[M];\n    ofdmframe_init_default_sctype(M, p);\n    unsigned int num_samples = (3 + 1)*(M + cp_len);\n    ofdmframegen fg = ofdmframegen_create(M, cp_len, taper_len, p);\n    float complex X[M];         \n    float complex X_test[M];    \n    ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,p,ofdmframesync_autotest_callback,(void*)X_test);\n    unsigned int i;\n    float complex y[num_samples];   \n    unsigned int n=0;\n    ofdmframegen_write_S0a(fg, &y[n]);\n    n += M + cp_len;\n    ofdmframegen_write_S0b(fg, &y[n]);\n    n += M + cp_len;\n    ofdmframegen_write_S1( fg, &y[n]);\n    n += M + cp_len;\n    for (i=0; i<M; i++) {\n        X[i]      = cexpf(_Complex_I*2*M_PI*randf());\n        X_test[i] = 0.0f;\n    }\n    ofdmframegen_writesymbol(fg, X, &y[n]);\n    n += M + cp_len;\n    assert(n == num_samples);\n    for (i=0; i<num_samples; i++)\n        y[i] *= cexpf(_Complex_I*dphi*i);\n    ofdmframesync_execute(fs,y,num_samples);\n    for (i=0; i<M; i++) {\n        if (p[i] == OFDMFRAME_SCTYPE_DATA) {\n            float e = crealf( (X[i] - X_test[i])*conjf(X[i] - X_test[i]) );\n            CONTEND_DELTA( fabsf(e), 0.0f, tol );\n        }\n    }\n    ofdmframegen_destroy(fg);\n    ofdmframesync_destroy(fs);\n}\nvoid autotest_ofdmframesync_acquire_n512()  { ofdmframesync_acquire_test(512, 64, 0); }\n//...')
"
"('Prompt: You have a task to implement two vector multiplication functions in a C program. The first function `VECTOR(_mul)` takes two arrays `_x` and `_y` of type `T`, multiplies corresponding elements of the arrays together, and stores the result in another array `_z`. The second function `VECTOR(_mulscalar)` takes an array `_x` of type `T`, a scalar value `_v` of type `T`, multiplies each element of `_x` with the scalar value, and stores the result in array `_y`. Both functions should handle arrays of length `_n`, where `_n` is an unsigned integer. The functions should optimize the multiplication process by using SIMD operations when possible. Can you provide the C code for these functions?","void VECTOR(_mul)(T *          _x,\n                  T *          _y,\n                  unsigned int _n,\n                  T *          _z)\n{\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        _z[i  ] = _x[i  ] * _y[i  ];\n        _z[i+1] = _x[i+1] * _y[i+1];\n        _z[i+2] = _x[i+2] * _y[i+2];\n        _z[i+3] = _x[i+3] * _y[i+3];\n    }\n    for ( ; i<_n; i++)\n        _z[i] = _x[i] * _y[i];\n}\nvoid VECTOR(_mulscalar)(T *          _x,\n                        unsigned int _n,\n                        T            _v,\n                        T *          _y)\n{\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        _y[i  ] = _x[i  ] * _v;\n        _y[i+1] = _x[i+1] * _v;\n        _y[i+2] = _x[i+2] * _v;\n        _y[i+3] = _x[i+3] * _v;\n    }\n    for ( ; i<_n; i++)\n        _y[i] = _x[i] * _v;\n}')
"
"('You could have asked me to provide a code snippet that demonstrates automated testing of a forward error correction (FEC) codec using the given functions and macros. In this scenario, the code includes a function `fec_test_codec` that checks if the required FEC schemes are enabled in the library. If not enabled, it displays a warning message. It then proceeds to encode and decode a random message using the specified FEC scheme.. . Additionally, the code contains specific test functions `autotest_fec_v29` and `autotest_fec_v29p45` that automatically test FEC encoding and decoding for the V.29 and V.29P45 schemes, respectively, using a message length of 64 bytes.","//...\nvoid fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    fec q = fec_create(_fs,_opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,_n);\n    unsigned char msg[_n];          \n    unsigned char msg_enc[n_enc];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg[i] = rand() & 0xff;\n        msg_dec[i] = 0;\n    }\n    fec_encode(q,_n,msg,msg_enc);\n    msg_enc[0] ^= 0x01;\n    fec_decode(q,_n,msg_enc,msg_dec);\n    CONTEND_SAME_DATA(msg,msg_dec,_n);\n    fec_destroy(q);\n}\nvoid autotest_fec_v29()     { fec_test_codec(LIQUID_FEC_CONV_V29,      64, NULL); }\nvoid autotest_fec_v29p45()  { fec_test_codec(LIQUID_FEC_CONV_V29P45,   64, NULL); }\n//...')
"
"('Please provide the prompt that describes a scenario where you need to generate filters for a digital communication system using different filter shapes such as exponential, sech, and arcsech.","//...\nint liquid_firdes_fexp(unsigned int _k,\n                       unsigned int _m,\n                       float _beta,\n                       float _dt,\n                       float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FEXP, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_farcsech_freqresponse(unsigned int _k,\n                                        unsigned int _m,\n                                        float        _beta,\n                                        float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    float zeta  = 1.0f / (2.0f * _beta * B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f - (zeta/gamma)*liquid_asechf(zeta*(B*(1+_beta) - f));\n            } else {\n                _H[i] = (zeta/gamma)*liquid_asechf(zeta*(f - B*(1-_beta)));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_fsech(unsigned int _k,\n                        unsigned int _m,\n                        float _beta,\n                        float _dt,\n                        float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fexp_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(2.0f)/(_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = expf(gamma*(B*(1-_beta) - f));\n            } else {\n                _H[i] = 1.0f - expf(gamma*(f - (1+_beta)*B));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nfloat liquid_asechf(float _z)\n{\n    if (_z <= 0.0f || _z > 1.0f) {\n        liquid_error(LIQUID_EICONFIG,""liquid_asechf(), input (_z=%g)out of range (0,1)"", _z);\n        return 0.0f;\n    }\n    float z_inv = 1.0f / _z;\n    return logf( sqrtf(z_inv - 1.0f)*sqrtf(z_inv + 1.0f) + z_inv );\n}\nint liquid_firdes_fsech_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f / coshf(gamma*(f - B*(1-_beta)));\n            } else {\n                _H[i] = 1.0f - 1.0f / coshf(gamma*(B*(1+_beta) - f));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_farcsech(unsigned int _k,\n                           unsigned int _m,\n                           float _beta,\n                           float _dt,\n                           float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FARCSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fnyquist(liquid_firfilt_type _type,\n                           int                 _root,\n                           unsigned int        _k,\n                           unsigned int        _m,\n                           float               _beta,\n                           float               _dt,\n                           float *             _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): beta must be in [0,1]"");\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m+1;   \n    float H_prime[h_len];   \n    float complex H[h_len]; \n    float complex h[h_len]; \n    switch (_type) {\n    case LIQUID_FIRFILT_FEXP:\n        liquid_firdes_fexp_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FSECH:\n        liquid_firdes_fsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FARCSECH:\n        liquid_firdes_farcsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    default:\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(), unknown/unsupported filter type"");\n    }\n    for (i=0; i<h_len; i++)\n        H[i] = _root ? sqrtf(H_prime[i]) : H_prime[i];\n    fft_run(h_len, H, h, LIQUID_FFT_BACKWARD, 0);\n    for (i=0; i<h_len; i++)\n        _h[i] = crealf( h[(i+_k*_m+1)%h_len] ) * (float)_k / (float)(h_len);\n    return LIQUID_OK;\n}\nint liquid_firdes_farcsech(unsigned int _k,\n                           unsigned int _m,\n                           float _beta,\n                           float _dt,\n                           float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FARCSECH, 0, _k, _m, _beta, _dt, _h);\n}\n//...')
"
"'Prompt: . You are working on a project that involves using the LittlevGL library with grid functionality in embedded systems. You need to create a grid layout with 3 rows and 3 columns, each cell containing a button with a label displaying the position of the cell (column, row). Please provide a function that sets up this grid layout and populates it with buttons and labels accordingly. The grid layout should have each column and row of equal size.","#if LV_USE_GRID && LV_BUILD_EXAMPLES\nvoid lv_example_grid_1(void)\n{\n    static int32_t col_dsc[] = {70, 70, 70, LV_GRID_TEMPLATE_LAST};\n    static int32_t row_dsc[] = {50, 50, 50, LV_GRID_TEMPLATE_LAST};\n    lv_obj_t * cont = lv_obj_create(lv_screen_active());\n    lv_obj_set_style_grid_column_dsc_array(cont, col_dsc, 0);\n    lv_obj_set_style_grid_row_dsc_array(cont, row_dsc, 0);\n    lv_obj_set_size(cont, 300, 220);\n    lv_obj_center(cont);\n    lv_obj_set_layout(cont, LV_LAYOUT_GRID);\n    lv_obj_t * label;\n    lv_obj_t * obj;\n    uint32_t i;\n    for(i = 0; i < 9; i++) {\n        uint8_t col = i % 3;\n        uint8_t row = i / 3;\n        obj = lv_button_create(cont);\n        lv_obj_set_grid_cell(obj, LV_GRID_ALIGN_STRETCH, col, 1,\n                             LV_GRID_ALIGN_STRETCH, row, 1);\n        label = lv_label_create(obj);\n        lv_label_set_text_fmt(label, ""c%d, r%d"", col, row);\n        lv_obj_center(label);\n    }\n}\n#endif'"
"(""Prompt: Suppose you have a scenario where you need to perform a test using FFT filtering for complex signals with the following data: signal h of length 13x256, signal x of length 256, and signal y of length 256. Write a function called 'autotest_fftfilt_cccf_data_h13x256' that calls 'fftfilt_cccf_test' function with the specified data arrays for testing.","//...\nvoid autotest_fftfilt_cccf_data_h13x256()\n{\n    fftfilt_cccf_test(fftfilt_cccf_data_h13x256_h, 13,\n                      fftfilt_cccf_data_h13x256_x, 256,\n                      fftfilt_cccf_data_h13x256_y, 256);\n}\n//...')
"
"('Prompt: You have a set of coefficients and an input signal, you need to implement an algorithm that calculates the coefficients of a Levinson-Durbin recursion model using the liquid_levinson function. The function should handle cases where the filter order exceeds the maximum allowable.","//...\nvoid liquid_levinson(float * _r,\n                     unsigned int _p,\n                     float * _a,\n                     float * _e)\n{\n    if (_p > LIQUID_LEVINSON_MAXORDER) {\n        liquid_error(LIQUID_EICONFIG,""liquid_levinson(), filter order (%u) exceeds maximum (%u)"",_p,LIQUID_LEVINSON_MAXORDER);\n        return;\n    }\n    float a0[_p+1]; \n    float a1[_p+1]; \n    float e[_p+1];  \n    float k[_p+1];  \n    k[0] = 1.0f;\n    e[0] = _r[0];\n    unsigned int i;\n    for (i=0; i<_p+1; i++) {\n        a0[i] = (i==0) ? 1.0f : 0.0f;\n        a1[i] = (i==0) ? 1.0f : 0.0f;\n    }\n    unsigned int n;\n    for (n=1; n<_p+1; n++) {\n        float q = 0.0f;\n        for (i=0; i<n; i++)\n            q += a0[i]*_r[n-i];\n        k[n] = -q/e[n-1];\n        e[n] = e[n-1]*(1.0f - k[n]*k[n]);\n        for (i=0; i<n; i++)\n            a1[i] = a0[i] + k[n]*a0[n-i];\n        a1[n] = k[n];\n#if 0\n        printf(""iteration [n=%u]\\n"", n);\n        for (i=0; i<n; i++)\n            printf(""  ** i = %3u, n-i = %3u\\n"", i, n-i);\n        printf(""  k   = %12.8f\\n"", k[n]);\n        printf(""  q   = %12.8f\\n"", q);\n        printf(""  e   = %12.8f\\n"", e[n]);\n        printf(""  a_%u = {"", n-1);\n        for (i=0; i<n; i++)\n            printf(""%6.3f, "", a0[i]);\n        printf(""}\\n"");\n        printf(""  a_%u = {"", n);\n        for (i=0; i<n+1; i++)\n            printf(""%6.3f, "", a1[i]);\n        printf(""}\\n"");\n#endif\n        memmove(a0, a1, (_p+1)*sizeof(float));\n    }\n    memmove(_a, a1, (_p+1)*sizeof(float));\n    memmove(_e,  e, (_p+1)*sizeof(float));\n}\n//...')
"
"('Prompt: You are implementing an automated testing function for a random number generator called `randricekf` that generates Rice-distributed random numbers. In this scenario, your task is to write a code snippet that conducts a Monte Carlo simulation by calling `randricekf` a specified number of times and calculating the mean and variance of the generated samples. The code should keep track of the accumulated values of mean and squared mean, and at the end of the simulation, it should calculate the average mean and variance. Lastly, the test should check if the calculated mean and variance are within a predefined tolerance range.","//...\nvoid autotest_randricekf()\n{\n    unsigned long int N = LIQUID_RANDOM_AUTOTEST_NUM_TRIALS;\n    unsigned long int i;\n    float x, m1=0.0f, m2=0.0f;\n    float tol = LIQUID_RANDOM_AUTOTEST_ERROR_TOL;\n    float K=2.0f, omega=1.0f;\n    for (i=0; i<N; i++) {\n        x = randricekf(K, omega);\n        m1 += x;\n        m2 += x*x;\n    }\n    m1 /= (float) N;\n    m2 = (m2 / (float)N);\n    CONTEND_DELTA(m1, 0.92749f, tol);\n    CONTEND_DELTA(m2, omega, tol);\n}\n//...')
"
"'Prompt: Develop a function `sock_client_connect` that establishes a client connection to a server using TCP, UDP, or PTCP protocol. The function should handle setting up the socket connection, creating an event for receiving data, and invoking the appropriate callbacks for buffer received, connection established, and disconnection. Handle the scenario where PTCP is enabled. Ensure proper error handling throughout the process.","//...\n#ifdef ENABLE_PTCP\n    return s;\n        sc.remote.port = port;\n    e = gevent_create(afd, on_ptcp_recv, NULL, on_error, s);\n        return;\n        s->fd = sock_udp_bind(host, port);\n    s->type = type;\n        return -1;\n        return NULL;\n        break;\n        s->fd64 = sock_ptcp_bind_listen(host, port);\n    s->evbase = gevent_base_create();\n    struct sock_client *c = (struct sock_client *)arg;\n    c->host = strdup(host);\n    c->on_connect = on_connect;\n    return 0;\nint sock_server_set_callback(struct sock_server *s,\n        void (*on_connect)(struct sock_server *s, struct sock_connection *conn),\n        void (*on_buffer)(struct sock_server *s, void *buf, size_t len),\n        void (*on_disconnect)(struct sock_server *s, struct sock_connection *conn))\n{\n    struct gevent *e;\n    if (!s) {\n        return -1;\n    }\n    s->on_connect = on_connect;\n    s->on_buffer = on_buffer;\n    s->on_disconnect = on_disconnect;\n    switch (s->type) {\n    case SOCK_TYPE_UDP:\n        e = gevent_create(s->fd, on_recv, NULL, on_error, s);\n        break;\n    case SOCK_TYPE_TCP:\n        e = gevent_create(s->fd, on_tcp_connect, NULL, on_error, s);\n        break;\n#ifdef ENABLE_PTCP\n    case SOCK_TYPE_PTCP: {\n        ptcp_socket_t ptcp = *(ptcp_socket_t *) &s->fd64;\n        int fd = ptcp_get_socket_fd(ptcp);\n        printf(""ptcp_get_socket_fd fd=%d\\n"", fd);\n        e = gevent_create(fd, on_ptcp_connect, NULL, on_error, s);\n    } break;\n#endif\n    default:\n        break;\n    }\n    if (-1 == gevent_add(s->evbase, &e)) {\n        printf(""event_add failed!\\n"");\n        return -1;\n    }\n    return 0;\n}\nstatic void on_tcp_connect(int fd, void *arg)\n{\n    int afd;\n    uint32_t ip;\n    uint16_t port;\n    struct gevent *e = NULL;\n    struct sock_server *s = (struct sock_server *)arg;\n    struct sock_connection sc;\n    afd = sock_accept(fd, &ip, &port);\n    if (afd == -1) {\n        printf(""errno=%d %s\\n"", errno, strerror(errno));\n        return;\n    }\n    if (s->on_connect) {\n        sc.fd = afd;\n        sc.type = SOCK_STREAM;\n        if (-1 == sock_getaddr_by_fd(sc.fd, &sc.local)) {\n            printf(""sock_getaddr_by_fd failed: %s\\n"", strerror(errno));\n        }\n        sc.remote.ip = ip;\n        sc.remote.port = port;\n        sock_addr_ntop(sc.remote.ip_str, ip);\n        s->on_connect(s, &sc);\n    }\n    e = gevent_create(afd, on_recv, NULL, on_error, s);\n    if (-1 == gevent_add(s->evbase, &e)) {\n        printf(""event_add failed!\\n"");\n    }\n}\nstatic void on_recv(int fd, void *arg)\n{\n    struct sock_server *s;\n    char buf[2048];\n    int ret=0;\n    memset(buf, 0, sizeof(buf));\n    s = (struct sock_server *)arg;\n    ret = sock_recv(fd, buf, 2048);\n    if (ret > 0) {\n        s->on_buffer(s, buf, ret);\n    } else if (ret == 0) {\n        printf(""delete connection fd:%d\\n"", fd);\n        if (s->on_disconnect) {\n            s->on_disconnect(s, NULL);\n        }\n    } else if (ret < 0) {\n        printf(""%s:%d recv failed!\\n"", __func__, __LINE__);\n    }\n}\nstatic void on_error(int fd, void *arg)\n{\n    printf(""error: %d\\n"", errno);\n}\nstatic void on_client_recv(int fd, void *arg)\n{\n    struct sock_client *c;\n    char buf[2048];\n    int ret=0;\n    memset(buf, 0, sizeof(buf));\n    c = (struct sock_client *)arg;\n    ret = sock_recv(fd, buf, 2048);\n    if (ret > 0) {\n        c->on_buffer(c, buf, ret);\n    } else if (ret == 0) {\n        printf(""delete connection fd:%d\\n"", fd);\n        if (c->on_disconnect) {\n            c->on_disconnect(c, NULL);\n        }\n    } else if (ret < 0) {\n        printf(""%s:%d recv failed!\\n"", __func__, __LINE__);\n    }\n}\nGEAR_API int sock_client_connect(struct sock_client *c)\n{\n    struct gevent *e;\n    c->conn = sock_tcp_connect(c->host, c->port);\n    if (!c->conn) {\n        printf(""sock_tcp_connect %s:%d failed!\\n"", c->host, c->port);\n        return -1;\n    }\n    switch (c->type) {\n    case SOCK_TYPE_TCP:\n    case SOCK_TYPE_UDP:\n        c->fd = c->conn->fd;\n        break;\n#ifdef ENABLE_PTCP\n    case SOCK_TYPE_PTCP:\n        c->fd = c->conn->fd64;\n        break;\n#endif\n    default:\n        printf(""invalid sock_type!\\n"");\n        break;\n    }\n    e = gevent_create(c->fd, on_client_recv, NULL, on_error, c);\n    if (-1 == gevent_add(c->evbase, &e)) {\n        printf(""event_add failed!\\n"");\n    }\n    if (c->conn) {\n        if (c->on_connect) {\n            c->on_connect(c, c->conn);\n        }\n    }\n    c->thread = thread_create(sock_client_thread, c);\n    return 0;\n}\n//...'"
"'Prompt: You are working on a project that involves creating a slider widget with specific styling. The slider should have a main style with a light gray background color, rounded corners, and a slight negative vertical padding. The indicator should have a cyan background color with rounded corners and a smooth transition effect when changing values. The knob should have a cyan background color, a darker border, rounded corners, and a padding of 6 on all sides. When pressed, both the indicator and knob should darken slightly. Can you provide the code for implementing this slider widget with the specified styles and behavior?","#if LV_USE_SLIDER && LV_BUILD_EXAMPLES\nvoid lv_example_slider_2(void)\n{\n    static const lv_style_prop_t props[] = {LV_STYLE_BG_COLOR, 0};\n    static lv_style_transition_dsc_t transition_dsc;\n    lv_style_transition_dsc_init(&transition_dsc, props, lv_anim_path_linear, 300, 0, NULL);\n    static lv_style_t style_main;\n    static lv_style_t style_indicator;\n    static lv_style_t style_knob;\n    static lv_style_t style_pressed_color;\n    lv_style_init(&style_main);\n    lv_style_set_bg_opa(&style_main, LV_OPA_COVER);\n    lv_style_set_bg_color(&style_main, lv_color_hex3(0xbbb));\n    lv_style_set_radius(&style_main, LV_RADIUS_CIRCLE);\n    lv_style_set_pad_ver(&style_main, -2); \n    lv_style_init(&style_indicator);\n    lv_style_set_bg_opa(&style_indicator, LV_OPA_COVER);\n    lv_style_set_bg_color(&style_indicator, lv_palette_main(LV_PALETTE_CYAN));\n    lv_style_set_radius(&style_indicator, LV_RADIUS_CIRCLE);\n    lv_style_set_transition(&style_indicator, &transition_dsc);\n    lv_style_init(&style_knob);\n    lv_style_set_bg_opa(&style_knob, LV_OPA_COVER);\n    lv_style_set_bg_color(&style_knob, lv_palette_main(LV_PALETTE_CYAN));\n    lv_style_set_border_color(&style_knob, lv_palette_darken(LV_PALETTE_CYAN, 3));\n    lv_style_set_border_width(&style_knob, 2);\n    lv_style_set_radius(&style_knob, LV_RADIUS_CIRCLE);\n    lv_style_set_pad_all(&style_knob, 6); \n    lv_style_set_transition(&style_knob, &transition_dsc);\n    lv_style_init(&style_pressed_color);\n    lv_style_set_bg_color(&style_pressed_color, lv_palette_darken(LV_PALETTE_CYAN, 2));\n    lv_obj_t * slider = lv_slider_create(lv_screen_active());\n    lv_obj_remove_style_all(slider);        \n    lv_obj_add_style(slider, &style_main, LV_PART_MAIN);\n    lv_obj_add_style(slider, &style_indicator, LV_PART_INDICATOR);\n    lv_obj_add_style(slider, &style_pressed_color, LV_PART_INDICATOR | LV_STATE_PRESSED);\n    lv_obj_add_style(slider, &style_knob, LV_PART_KNOB);\n    lv_obj_add_style(slider, &style_pressed_color, LV_PART_KNOB | LV_STATE_PRESSED);\n    lv_obj_center(slider);\n}\n#endif'"
('Please provide a prompt detailing a scenario where we need to create a DSSS frame synchronizer for a software-defined radio application and implement functions for frame synchronization and payload decoding.,"int dsssframesync_execute_seekpn    (dsssframesync _q, float complex _x);\nint dsssframesync_step              (dsssframesync _q, float complex _x, float complex * _y);\nint dsssframesync_execute_rxpreamble(dsssframesync _q, float complex _x);\nint dsssframesync_decode_header     (dsssframesync _q);\nint dsssframesync_decode_payload    (dsssframesync _q);\nint dsssframesync_execute_rxheader  (dsssframesync _q, float complex _x);\nint dsssframesync_execute_rxpayload (dsssframesync _q, float complex _x);\nint dsssframesync_configure_payload (dsssframesync _q);\nstatic dsssframegenprops_s dsssframesyncprops_header_default = {\n    DSSSFRAME_H_CRC,\n    DSSSFRAME_H_FEC0,\n    DSSSFRAME_H_FEC1,\n};\nenum state {\n    DSSSFRAMESYNC_STATE_DETECTFRAME = 0,\n    DSSSFRAMESYNC_STATE_RXPREAMBLE,\n    DSSSFRAMESYNC_STATE_RXHEADER,\n    DSSSFRAMESYNC_STATE_RXPAYLOAD,\n};\nstruct dsssframesync_s {\n    framesync_callback  callback;\n    void *              userdata;\n    framesyncstats_s    framesyncstats;\n    framedatastats_s    framedatastats;\n    unsigned int        k;\n    unsigned int        m;\n    float               beta;\n    qdetector_cccf      detector;\n    float               tau_hat;\n    float               dphi_hat;\n    float               phi_hat;\n    float               gamma_hat;\n    nco_crcf            mixer;\n    nco_crcf            pll;\n    firpfb_crcf         mf;\n    unsigned int        npfb;\n    int                 mf_counter;\n    unsigned int        pfb_index;\n    float complex *     preamble_pn;\n    float complex *     preamble_rx;\n    synth_crcf          header_synth;\n    synth_crcf          payload_synth;\n    int                 header_soft;\n    flexframegenprops_s header_props;\n    float complex *     header_spread;\n    unsigned int        header_spread_len;\n    qpacketmodem        header_decoder;\n    unsigned int        header_user_len;\n    unsigned int        header_dec_len;\n    unsigned char *     header_dec;\n    int                 header_valid;\n    int                 payload_soft;\n    float complex *     payload_spread;\n    unsigned int        payload_spread_len;\n    qpacketmodem        payload_decoder;\n    unsigned int        payload_dec_len;\n    unsigned char *     payload_dec;\n    int                 payload_valid;\n    unsigned int        preamble_counter;\n    unsigned int        symbol_counter;\n    enum state          state;\n};\ndsssframesync dsssframesync_create(framesync_callback _callback, void * _userdata)\n{\n    dsssframesync q = (dsssframesync)calloc(1, sizeof(struct dsssframesync_s));\n    q->callback     = _callback;\n    q->userdata     = _userdata;\n    q->k    = 2;\n    q->m    = 7;\n    q->beta = 0.3f;\n    unsigned int i;\n    q->preamble_pn = (float complex *)calloc(64, sizeof(float complex));\n    q->preamble_rx = (float complex *)calloc(64, sizeof(float complex));\n    msequence ms   = msequence_create(7, 0x0089, 1);\n    for (i = 0; i < 64; i++) {\n        q->preamble_pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        q->preamble_pn[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;\n    }\n    msequence_destroy(ms);\n    float complex * pn = (float complex *)calloc(64, sizeof(float complex));\n    ms                        = msequence_create(7, 0x00cb, 0x53);\n    for (i = 0; i < 64; i++) {\n        pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        pn[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;\n    }\n    q->header_synth  = synth_crcf_create(pn, 64);\n    q->payload_synth = synth_crcf_create(pn, 64);\n    synth_crcf_pll_set_bandwidth(q->header_synth, 1e-4f);\n    synth_crcf_pll_set_bandwidth(q->payload_synth, 1e-4f);\n    free(pn);\n    msequence_destroy(ms);\n    q->detector = qdetector_cccf_create_linear(\n        q->preamble_pn, 64, LIQUID_FIRFILT_ARKAISER, q->k, q->m, q->beta);\n    qdetector_cccf_set_threshold(q->detector, 0.5f);\n    q->npfb = 32;\n    q->mf   = firpfb_crcf_create_rnyquist(LIQUID_FIRFILT_ARKAISER, q->npfb, q->k, q->m, q->beta);\n    q->mixer = nco_crcf_create(LIQUID_NCO);\n    q->pll   = nco_crcf_create(LIQUID_NCO);\n    nco_crcf_pll_set_bandwidth(q->pll, 1e-4f); \n    q->header_decoder  = qpacketmodem_create();\n    q->header_user_len = DSSSFRAME_H_USER_DEFAULT;\n    dsssframesync_set_header_props(q, NULL);\n    q->payload_decoder    = qpacketmodem_create();\n    q->payload_spread_len = 64;\n    q->payload_spread\n        = (float complex *)malloc(q->payload_spread_len * sizeof(float complex));\n    dsssframesync_reset_framedatastats(q);\n    dsssframesync_reset(q);\n    return q;\n}\nint dsssframesync_destroy(dsssframesync _q)\n{\n    if (_q == NULL)\n        return liquid_error(LIQUID_EIOBJ,""dsssframesync_destroy(), NULL pointer passed"");\n    free(_q->preamble_pn);\n    free(_q->preamble_rx);\n    free(_q->header_spread);\n    free(_q->header_dec);\n    free(_q->payload_spread);\n    free(_q->payload_dec);\n    qpacketmodem_destroy(_q->header_decoder);\n    qpacketmodem_destroy(_q->payload_decoder);\n    qdetector_cccf_destroy(_q->detector);\n    firpfb_crcf_destroy(_q->mf);\n    nco_crcf_destroy(_q->mixer);\n    nco_crcf_destroy(_q->pll);\n    synth_crcf_destroy(_q->header_synth);\n    synth_crcf_destroy(_q->payload_synth);\n    free(_q);\n    return LIQUID_OK;\n}\nint dsssframesync_print(dsssframesync _q)\n{\n    printf(""dsssframesync:\\n"");\n    return framedatastats_print(&_q->framedatastats);\n}\nint dsssframesync_reset(dsssframesync _q)\n{\n    qdetector_cccf_reset(_q->detector);\n    nco_crcf_reset(_q->mixer);\n    nco_crcf_reset(_q->pll);\n    firpfb_crcf_reset(_q->mf);\n    _q->state            = DSSSFRAMESYNC_STATE_DETECTFRAME;\n    _q->preamble_counter = 0;\n    _q->symbol_counter   = 0;\n    _q->framesyncstats.evm = 0.f;\n    return LIQUID_OK;\n}\nint dsssframesync_is_frame_open(dsssframesync _q)\n{\n    return (_q->state == DSSSFRAMESYNC_STATE_DETECTFRAME) ? 0 : 1;\n}\nint dsssframesync_set_header_len(dsssframesync _q, unsigned int _len)\n{\n    _q->header_user_len = _len;\n    _q->header_dec_len  = DSSSFRAME_H_DEC + _q->header_user_len;\n    _q->header_dec\n        = (unsigned char *)realloc(_q->header_dec, _q->header_dec_len * sizeof(unsigned char));\n    qpacketmodem_configure(_q->header_decoder,\n                           _q->header_dec_len,\n                           _q->header_props.check,\n                           _q->header_props.fec0,\n                           _q->header_props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->header_spread_len = synth_crcf_get_length(_q->header_synth);\n    _q->header_spread     = (float complex *)realloc(\n        _q->header_spread, _q->header_spread_len * sizeof(float complex));\n    return LIQUID_OK;\n}\nint dsssframesync_decode_header_soft(dsssframesync _q, int _soft)\n{\n    _q->header_soft = _soft;\n    return LIQUID_OK;\n}\nint dsssframesync_decode_payload_soft(dsssframesync _q, int _soft)\n{\n    _q->payload_soft = _soft;\n    return LIQUID_OK;\n}\nint dsssframesync_set_header_props(dsssframesync _q, dsssframegenprops_s * _props)\n{\n    if (_props == NULL)\n        _props = &dsssframesyncprops_header_default;\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_set_header_props(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_set_header_props(), invalid/unsupported FEC scheme"");\n    memmove(&_q->header_props, _props, sizeof(dsssframegenprops_s));\n    return dsssframesync_set_header_len(_q, _q->header_user_len);\n}\nint dsssframesync_execute(dsssframesync _q, float complex * _x, unsigned int _n)\n{\n    unsigned int i;\n    for (i = 0; i < _n; i++) {\n        switch (_q->state) {\n        case DSSSFRAMESYNC_STATE_DETECTFRAME:\n            dsssframesync_execute_seekpn(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPREAMBLE:\n            dsssframesync_execute_rxpreamble(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXHEADER:\n            dsssframesync_execute_rxheader(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPAYLOAD:\n            dsssframesync_execute_rxpayload(_q, _x[i]);\n            break;\n        default:\n            return liquid_error(LIQUID_EINT,""dsssframesync_execute(), invalid internal state"");\n        }\n    }\n    return LIQUID_OK;\n}\nint dsssframesync_execute_seekpn(dsssframesync _q, float complex _x)\n{\n    float complex * v = qdetector_cccf_execute(_q->detector, _x);\n    if (v == NULL)\n        return LIQUID_OK;\n    _q->tau_hat   = qdetector_cccf_get_tau(_q->detector);\n    _q->gamma_hat = qdetector_cccf_get_gamma(_q->detector);\n    _q->dphi_hat  = qdetector_cccf_get_dphi(_q->detector);\n    _q->phi_hat   = qdetector_cccf_get_phi(_q->detector);\n    if (_q->tau_hat > 0) {\n        _q->pfb_index  = (unsigned int)(_q->tau_hat * _q->npfb) % _q->npfb;\n        _q->mf_counter = 0;\n    } else {\n        _q->pfb_index  = (unsigned int)((1.0f + _q->tau_hat) * _q->npfb) % _q->npfb;\n        _q->mf_counter = 1;\n    }\n    firpfb_crcf_set_scale(_q->mf, 0.5f / _q->gamma_hat);\n    nco_crcf_set_frequency(_q->mixer, _q->dphi_hat);\n    nco_crcf_set_phase(_q->mixer, _q->phi_hat);\n    _q->state = DSSSFRAMESYNC_STATE_RXPREAMBLE;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q->detector);\n    return dsssframesync_execute(_q, v, buf_len);\n}\nint dsssframesync_step(dsssframesync _q, float complex _x, float complex * _y)\n{\n    float complex v;\n    nco_crcf_mix_down(_q->mixer, _x, &v);\n    nco_crcf_step(_q->mixer);\n    firpfb_crcf_push(_q->mf, v);\n    firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);\n    _q->mf_counter++;\n    int sample_available = (_q->mf_counter >= 1) ? 1 : 0;\n    if (sample_available) {\n        *_y = v;\n        _q->mf_counter -= _q->k;\n    }\n    return sample_available;\n}\nint dsssframesync_execute_rxpreamble(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.0f;\n    int           sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    unsigned int delay = _q->k * _q->m; \n    if (_q->preamble_counter >= delay) {\n        unsigned int index     = _q->preamble_counter - delay;\n        _q->preamble_rx[index] = mf_out;\n    }\n    _q->preamble_counter++;\n    if (_q->preamble_counter == 64 + delay)\n        _q->state = DSSSFRAMESYNC_STATE_RXHEADER;\n    return LIQUID_OK;\n}\nint dsssframesync_execute_rxheader(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int           sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->header_spread[_q->symbol_counter % synth_crcf_get_length(_q->header_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->header_synth))\n        return LIQUID_OK;\n    int header_complete = dsssframesync_decode_header(_q);\n    if (!header_complete)\n        return LIQUID_OK;\n    if (_q->header_valid) {\n        _q->symbol_counter = 0;\n        _q->state = DSSSFRAMESYNC_STATE_RXPAYLOAD;\n        return LIQUID_OK;\n    }\n    ++_q->framedatastats.num_frames_detected;\n    if (_q->callback != NULL) {\n        _q->framesyncstats.evm           = 0.f;\n        _q->framesyncstats.rssi          = 20 * log10f(_q->gamma_hat);\n        _q->framesyncstats.cfo           = nco_crcf_get_frequency(_q->mixer);\n        _q->framesyncstats.framesyms     = NULL;\n        _q->framesyncstats.num_framesyms = 0;\n        _q->framesyncstats.check         = LIQUID_CRC_UNKNOWN;\n        _q->framesyncstats.fec0          = LIQUID_FEC_UNKNOWN;\n        _q->framesyncstats.fec1          = LIQUID_FEC_UNKNOWN;\n        _q->callback(\n            _q->header_dec, _q->header_valid, NULL, 0, 0, _q->framesyncstats, _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\nint dsssframesync_decode_header(dsssframesync _q)\n{\n    float complex prev_corr, corr, next_corr;\n    nco_crcf_mix_block_down(\n        _q->pll, _q->header_spread, _q->header_spread, synth_crcf_get_length(_q->header_synth));\n    synth_crcf_despread_triple(_q->header_synth, _q->header_spread, &prev_corr, &corr, &next_corr);\n    int   complete    = qpacketmodem_decode_soft_sym(_q->header_decoder, corr);\n    float phase_error = qpacketmodem_get_demodulator_phase_error(_q->header_decoder);\n    nco_crcf_pll_step(_q->pll, synth_crcf_get_length(_q->header_synth) * phase_error);\n    if (!complete) {\n        return 0;\n    }\n    dsssframesync_configure_payload(_q);\n    return 1;\n}\nint dsssframesync_configure_payload(dsssframesync _q)\n{\n    _q->header_valid = qpacketmodem_decode_soft_payload(_q->header_decoder, _q->header_dec);\n    if (!_q->header_valid)\n        return LIQUID_OK;\n    unsigned int n = _q->header_user_len;\n    unsigned int protocol = _q->header_dec[n + 0];\n    if (protocol != DSSSFRAME_PROTOCOL) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), invalid framing protocol %u (expected %u)\\n"",protocol,DSSSFRAME_PROTOCOL);\n    }\n    unsigned int payload_dec_len = (_q->header_dec[n + 1] << 8) | (_q->header_dec[n + 2]);\n    _q->payload_dec_len          = payload_dec_len;\n    unsigned int check = (_q->header_dec[n + 3] >> 5) & 0x07;\n    unsigned int fec0  = (_q->header_dec[n + 3]) & 0x1f;\n    unsigned int fec1  = (_q->header_dec[n + 4]) & 0x1f;\n    if (check == LIQUID_CRC_UNKNOWN || check >= LIQUID_CRC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded CRC exceeds available\\n"");\n    } else if (fec0 == LIQUID_FEC_UNKNOWN || fec0 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded FEC (inner) exceeds available\\n"");\n        return LIQUID_OK;\n    } else if (fec1 == LIQUID_FEC_UNKNOWN || fec1 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded FEC (outer) exceeds available\\n"");\n    }\n    _q->payload_dec\n        = (unsigned char *)realloc(_q->payload_dec, (_q->payload_dec_len) * sizeof(unsigned char));\n    qpacketmodem_configure(\n        _q->payload_decoder, _q->payload_dec_len, check, fec0, fec1, LIQUID_MODEM_BPSK);\n    synth_crcf_set_frequency(_q->payload_synth, synth_crcf_get_frequency(_q->header_synth));\n    return LIQUID_OK;\n}\nint dsssframesync_execute_rxpayload(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int                  sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->payload_spread[_q->symbol_counter % synth_crcf_get_length(_q->payload_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->payload_synth) != 0)\n        return LIQUID_OK;\n    int payload_complete = dsssframesync_decode_payload(_q);\n    if (!payload_complete)\n        return LIQUID_OK;\n    _q->framesyncstats.check = qpacketmodem_get_crc(_q->payload_decoder);\n    _q->framesyncstats.fec0  = qpacketmodem_get_fec0(_q->payload_decoder);\n    _q->framesyncstats.fec1  = qpacketmodem_get_fec1(_q->payload_decoder);\n    if (_q->callback != NULL) {\n        _q->callback(_q->header_dec,\n                     _q->header_valid,\n                     _q->payload_dec,\n                     _q->payload_dec_len,\n                     _q->payload_valid,\n                     _q->framesyncstats,\n                     _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\nint dsssframesync_decode_payload(dsssframesync _q)\n{\n    float complex prev_corr, corr, next_corr;\n    nco_crcf_mix_block_down(\n        _q->pll, _q->payload_spread, _q->payload_spread, synth_crcf_get_length(_q->payload_synth));\n    synth_crcf_despread_triple(\n        _q->payload_synth, _q->payload_spread, &prev_corr, &corr, &next_corr);\n    int   complete    = qpacketmodem_decode_soft_sym(_q->payload_decoder, corr);\n    float phase_error = qpacketmodem_get_demodulator_phase_error(_q->payload_decoder);\n    nco_crcf_pll_step(_q->pll, synth_crcf_get_length(_q->payload_synth) * phase_error);\n    if (!complete) {\n        return 0;\n    }\n    _q->payload_valid = qpacketmodem_decode_soft_payload(_q->payload_decoder, _q->payload_dec);\n    return 1;\n}\nint dsssframesync_reset_framedatastats(dsssframesync _q)\n{\n    return framedatastats_reset(&_q->framedatastats);\n}\nframedatastats_s dsssframesync_get_framedatastats(dsssframesync _q)\n{\n    return _q->framedatastats;\n}\nint dsssframesync_debug_enable(dsssframesync _q)\n{\n    return liquid_error(LIQUID_EIMODE,""dsssframesync_debug_enable(), mode not supported"");\n}\nint dsssframesync_debug_disable(dsssframesync _q)\n{\n    return liquid_error(LIQUID_EIMODE,""dsssframesync_debug_disable(), mode not supported"");\n}\nint dsssframesync_debug_print(dsssframesync _q, const char * _filename)\n{\n    return liquid_error(LIQUID_EIMODE,""dsssframesync_debug_print(), mode not supported"");\n}')
"
"(""Prompt: You are implementing a unit test for a digital communication modem library, and you need to validate the 'modemcf_test_copy' function for copying a modem configuration. Please provide the code snippet that tests the 'modemcf_test_copy' function specifically for BPSK modulation scheme.","//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_bpsk()      { modemcf_test_copy(LIQUID_MODEM_BPSK);      }\n//...')
"
"('I need you to help me determine the function for calculating the length of the encoded message for a convolutional code. This function should take in the length of the decoded message, the constraint length of the code, and the code rate. The function should calculate the number of bits in the encoded message and return the length in bytes. The formula for calculating the length of the encoded message is based on the decoded message length, constraint length, and code rate.","//...\nconst char * fec_scheme_str[LIQUID_FEC_NUM_SCHEMES][2] = {\nunsigned int fec_conv_get_enc_msg_len(unsigned int _dec_msg_len,\n                                      unsigned int _K,\n                                      unsigned int _p)\n{\n    unsigned int num_bits_in = _dec_msg_len*8;\n    unsigned int n = num_bits_in + _K - 1;\n    unsigned int num_bits_out = n + (n+_p-1)/_p;\n    unsigned int num_bytes_out = num_bits_out/8 + (num_bits_out%8 ? 1 : 0);\n#if 0\n    printf(""msg len :       %3u\\n"", _dec_msg_len);\n    printf(""num bits in :   %3u\\n"", num_bits_in);\n    printf(""n (constraint): %3u\\n"", n);\n    printf(""num bits out:   %3u"", num_bits_out);\n    printf("" = n+(n+p-1)/p = %u+(%u+%u-1)/%u\\n"", n,n,_p,_p);\n    printf(""num bytes out:  %3u\\n"", num_bytes_out);\n#endif\n    return num_bytes_out;\n}\n//...')
"
"'You are setting up a Real-Time Clock (RTC) driver for the LPC32XX microcontroller. You want to initialize the RTC, get the current time from the RTC, and set the time on the RTC. The code provided includes functions for setting the RTC, resetting the RTC, initializing the RTC, getting the time from the RTC, setting the time on the RTC, and probing the RTC.. . As a response, here is the code snippet for the RTC driver setup for LPC32XX microcontroller:. . ```c. #define LPC32XX_RTC_COUNT 1U. #define LPC32XX_RTC_COUNTER_DELTA 0xfffffffeU. #define LPC32XX_RTC_KEY 0xb5c13f27U. #define LPC32XX_RTC_CTRL_FORCE_ONSW (1U << 7). #define LPC32XX_RTC_CTRL_STOP (1U << 6). #define LPC32XX_RTC_CTRL_RESET (1U << 4). #define LPC32XX_RTC_CTRL_MATCH_1_ONSW (1","#define LPC32XX_RTC_COUNT 1U\n#define LPC32XX_RTC_COUNTER_DELTA 0xfffffffeU\n#define LPC32XX_RTC_KEY 0xb5c13f27U\n#define LPC32XX_RTC_CTRL_FORCE_ONSW (1U << 7)\n#define LPC32XX_RTC_CTRL_STOP (1U << 6)\n#define LPC32XX_RTC_CTRL_RESET (1U << 4)\n#define LPC32XX_RTC_CTRL_MATCH_1_ONSW (1U << 3)\n#define LPC32XX_RTC_CTRL_MATCH_0_ONSW (1U << 2)\n#define LPC32XX_RTC_CTRL_MATCH_1_INTR (1U << 1)\n#define LPC32XX_RTC_CTRL_MATCH_0_INTR (1U << 0)\nstatic void lpc32xx_rtc_set(uint32_t val)\n{\n  unsigned i = lpc32xx_arm_clk() / LPC32XX_OSCILLATOR_RTC;\n  lpc32xx.rtc.ctrl |= LPC32XX_RTC_CTRL_STOP;\n  lpc32xx.rtc.ucount = val;\n  lpc32xx.rtc.dcount = LPC32XX_RTC_COUNTER_DELTA - val;\n  lpc32xx.rtc.ctrl &= ~LPC32XX_RTC_CTRL_STOP;\n  while (i != 0) {\n    __asm__ volatile (""nop"");\n    --i;\n  }\n}\nstatic void lpc32xx_rtc_reset(void)\n{\n  lpc32xx.rtc.ctrl = LPC32XX_RTC_CTRL_RESET;\n  lpc32xx.rtc.ctrl = 0;\n  lpc32xx.rtc.key = LPC32XX_RTC_KEY;\n  lpc32xx_rtc_set(0);\n}\nstatic void lpc32xx_rtc_initialize(int minor)\n{\n  uint32_t up_first = 0;\n  uint32_t up_second = 0;\n  uint32_t down_first = 0;\n  uint32_t down_second = 0;\n  if (lpc32xx.rtc.key != LPC32XX_RTC_KEY) {\n    lpc32xx_rtc_reset();\n  }\n  do {\n    up_first = lpc32xx.rtc.ucount;\n    down_first = lpc32xx.rtc.dcount;\n    up_second = lpc32xx.rtc.ucount;\n    down_second = lpc32xx.rtc.dcount;\n  } while (up_first != up_second || down_first != down_second);\n  if (up_first + down_first != LPC32XX_RTC_COUNTER_DELTA) {\n    lpc32xx_rtc_reset();\n  }\n}\nstatic int lpc32xx_rtc_get_time(int minor, rtems_time_of_day *tod)\n{\n  struct timeval now = {\n    .tv_sec = lpc32xx.rtc.ucount,\n    .tv_usec = 0\n  };\n  struct tm time;\n  gmtime_r(&now.tv_sec, &time);\n  tod->year   = time.tm_year + 1900;\n  tod->month  = time.tm_mon + 1;\n  tod->day    = time.tm_mday;\n  tod->hour   = time.tm_hour;\n  tod->minute = time.tm_min;\n  tod->second = time.tm_sec;\n  tod->ticks  = 0;\n  return RTEMS_SUCCESSFUL;\n}\nstatic int lpc32xx_rtc_set_time(int minor, const rtems_time_of_day *tod)\n{\n  lpc32xx_rtc_set(_TOD_To_seconds(tod));\n  return 0;\n}\nstatic bool lpc32xx_rtc_probe(int minor)\n{\n  return true;\n}\nconst rtc_fns lpc32xx_rtc_ops = {\n  .deviceInitialize = lpc32xx_rtc_initialize,\n  .deviceGetTime = lpc32xx_rtc_get_time,\n  .deviceSetTime = lpc32xx_rtc_set_time\n};\nsize_t RTC_Count = LPC32XX_RTC_COUNT;\nrtc_tbl\tRTC_Table [LPC32XX_RTC_COUNT] = {\n  {\n    .sDeviceName = ""/dev/rtc"",\n    .deviceType = RTC_CUSTOM,\n    .pDeviceFns = &lpc32xx_rtc_ops,\n    .deviceProbe = lpc32xx_rtc_probe,\n    .pDeviceParams = NULL,\n    .ulCtrlPort1 = 0,\n    .ulDataPort = 0,\n    .getRegister = NULL,\n    .setRegister = NULL\n  }\n};'"
"('Prompt: You are designing a matrix multiplication function in C that takes in three matrices (_x, _y, _z) and their respective dimensions (_mx, _nx; _my, _ny; _mz, _nz). The function should perform binary matrix multiplication of _x and _y and store the result in _z. If the dimensions of the matrices are not compatible for multiplication (mismatch in row and column sizes), it should throw an error message and exit. The multiplication should be done by iterating through the rows and columns of the result matrix and calculating the dot product between rows of _x and columns of _y modulo 2. Write the C function matrix2_mul that implements this logic.","//...\n    return 0;\nvoid matrix2_mul(unsigned char * _x, unsigned int _mx, unsigned int _nx,\n                 unsigned char * _y, unsigned int _my, unsigned int _ny,\n                 unsigned char * _z, unsigned int _mz, unsigned int _nz)\n{\n    if (_mz != _mx || _nz != _ny || _nx != _my ) {\n        fprintf(stderr,""error: matrix2_mul(), invalid dimensions\\n"");\n        exit(1);\n    }\n    unsigned int r, c, i;\n    for (r=0; r<_mz; r++) {\n        for (c=0; c<_nz; c++) {\n            unsigned int sum = 0;\n            for (i=0; i<_nx; i++) {\n                sum += matrix_access(_x,_mx,_nx,r,i) *\n                       matrix_access(_y,_my,_ny,i,c);\n            }\n            matrix_access(_z,_mz,_nz,r,c) = sum % 2;\n        }\n    }\n}\n//...')
"
"('Prompt: You are working on a test bench for a software that simulates a water cascade algorithm. The algorithm calculates the force of gravity on water columns at different points and compares the calculated values. Write a function in C that compares two floating-point values for the simulation. The function should take two pointers to void as input parameters and cast them to float pointers to compare the values. The function should return 1 if the first value is greater than the second, and -1 if the second value is greater.","//...\nint testbench_spwaterfallcf_compare(const void * _v0, const void * _v1)\n    { return *(float*)_v0 > *(float*)_v1 ? 1 : -1; }\n//...')
"
"('Please provide a command line prompt specifying the parameters for a frequency-shift keying example simulation. The prompt should include options for setting the number of bits per symbol, samples per symbol, signal bandwidth, number of data symbols, and SNR. Additionally, include information on the default values for each parameter.","#define OUTPUT_FILENAME ""fskmodem_example.m""\nvoid usage()\n{\n    printf(""fskmodem_example -- frequency-shift keying example\\n"");\n    printf(""options:\\n"");\n    printf(""  h     : print help\\n"");\n    printf(""  m     : bits/symbol,              default:  3\\n"");\n    printf(""  k     : samples/symbol,           default:  2*2^m\\n"");\n    printf(""  b     : signal bandwidth          default:  0.2\\n"");\n    printf(""  n     : number of data symbols,   default: 80\\n"");\n    printf(""  s     : SNR [dB],                 default: 40\\n"");\n}\nint main(int argc, char*argv[])\n{\n    unsigned int m           =   3;     \n    unsigned int k           =   0;     \n    unsigned int num_symbols = 8000;    \n    float        SNRdB       = 40.0f;   \n    float        bandwidth   = 0.20;    \n    unsigned int nfft        = 1200;    \n    int dopt;\n    while ((dopt = getopt(argc,argv,""hm:k:b:n:s:"")) != EOF) {\n        switch (dopt) {\n        case \'h\': usage();                      return 0;\n        case \'m\': m           = atoi(optarg);   break;\n        case \'k\': k           = atoi(optarg);   break;\n        case \'b\': bandwidth   = atof(optarg);   break;\n        case \'n\': num_symbols = atoi(optarg);   break;\n        case \'s\': SNRdB       = atof(optarg);   break;\n        default:\n            exit(1);\n        }\n    }\n    unsigned int i;\n    unsigned int j;\n    if (k == 0)\n        k = 2 << m; \n    unsigned int M    = 1 << m;\n    float        nstd = powf(10.0f, -SNRdB/20.0f);\n    if (k < M) {\n        fprintf(stderr,""errors: %s, samples/symbol must be at least modulation size (M=%u)\\n"", __FILE__,M);\n        exit(1);\n    } else if (k > 2048) {\n        fprintf(stderr,""errors: %s, samples/symbol exceeds maximum (2048)\\n"", __FILE__);\n        exit(1);\n    } else if (M > 1024) {\n        fprintf(stderr,""errors: %s, modulation size (M=%u) exceeds maximum (1024)\\n"", __FILE__, M);\n        exit(1);\n    } else if (bandwidth <= 0.0f || bandwidth >= 0.5f) {\n        fprintf(stderr,""errors: %s, bandwidth must be in (0,0.5)\\n"", __FILE__);\n        exit(1);\n    }\n    fskmod mod = fskmod_create(m,k,bandwidth);\n    fskdem dem = fskdem_create(m,k,bandwidth);\n    fskdem_print(dem);\n    float complex buf_tx[k];    \n    float complex buf_rx[k];    \n    spgramcf periodogram = spgramcf_create_default(nfft);\n    unsigned int num_symbol_errors = 0;\n    for (i=0; i<num_symbols; i++) {\n        unsigned int sym_in = rand() % M;\n        fskmod_modulate(mod, sym_in, buf_tx);\n        for (j=0; j<k; j++)\n            buf_rx[j] = buf_tx[j] + nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n        unsigned int sym_out = fskdem_demodulate(dem, buf_rx);\n        num_symbol_errors += (sym_in == sym_out) ? 0 : 1;\n        spgramcf_write(periodogram, buf_rx, k);\n    }\n    fskmod_destroy(mod);\n    fskdem_destroy(dem);\n    printf(""symbol errors: %u / %u\\n"", num_symbol_errors, num_symbols);\n    float psd[nfft];\n    spgramcf_get_psd(periodogram, psd);\n    spgramcf_destroy(periodogram);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""k = %u;\\n"", k);\n    fprintf(fid,""M = %u;\\n"", M);\n    fprintf(fid,""num_symbols = %u;\\n"", num_symbols);\n    fprintf(fid,""nfft        = %u;\\n"", nfft);\n    fprintf(fid,""psd = zeros(1,nfft);\\n"");\n    for (i=0; i<nfft; i++)\n        fprintf(fid,""psd(%4u) = %12.8f;\\n"", i+1, psd[i]);\n    fprintf(fid,""figure(\'Color\',\'white\');\\n"");\n    fprintf(fid,""f = [0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""plot(f,psd,\'LineWidth\',1.5,\'Color\',[0.5 0 0]);\\n"");\n    fprintf(fid,""axis([-0.5 0.5 -40 20]);\\n"");\n    fprintf(fid,""xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
"'Prompt: Write a function in C that takes in a pthread_mutexattr_t attribute and an integer pointer, and returns 0 if successful or EINVAL if the attribute is invalid. The function should extract the type of the mutex attribute and store it in the integer pointer.","//...\nint\npthread_mutexattr_gettype (const pthread_mutexattr_t * attr, int *kind)\n{\n  int result = 0;\n  if (attr != NULL && *attr != NULL && kind != NULL)\n    {\n      *kind = (*attr)->kind;\n    }\n  else\n    {\n      result = EINVAL;\n    }\n  return (result);\n}\n//...'"
"('Prompt: Design and implement a function that performs testing for a FIR decimator that operates on complex input data. The function should take as input parameters the decimation factor (_M), the filter coefficients (_h), the length of the filter (_h_len), the input signal (_x), the length of the input signal (_x_len), the expected output signal (_y), and the length of the expected output signal (_y_len). The function should create an FIR decimator instance, process the input signal, compare the output with the expected output within a certain tolerance (tol), and destroy the decimator afterwards.","//...\nvoid firdecim_crcf_test(unsigned int    _M,\n                        float *         _h,\n                        unsigned int    _h_len,\n                        float complex * _x,\n                        unsigned int    _x_len,\n                        float complex * _y,\n                        unsigned int    _y_len)\n{\n    float tol = 0.001f;\n    firdecim_crcf q = firdecim_crcf_create(_M, _h, _h_len);\n    float complex y_test[_y_len];\n    unsigned int i;\n    for (i=0; i<_y_len; i++) {\n        firdecim_crcf_execute(q, &_x[_M*i], &y_test[i]);\n        CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );\n        CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );\n    }\n    firdecim_crcf_destroy(q);\n}\n//...')
"
"('Prompt: You are testing a GMSK detector with a sequence length of 64. Write a C function that creates the GMSK sequence, runs the detector test, and evaluates the results to determine if the frame was detected correctly. Remember to handle potential false positives and compare the estimated parameters with the actual ones with specific tolerances for each.","//...\nvoid qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    unsigned char sequence[_sequence_len];\n    unsigned int i;\n    for (i=0; i<_sequence_len; i++)\n        sequence[i] = rand() & 0x01;\n    qdetector_cccf q = qdetector_cccf_create_gmsk(sequence, _sequence_len, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_gmsk_n64()     { qdetector_cccf_runtest_gmsk  (  64); }\n//...')
"
('Prompt: You are developing a software library for digital communication systems and need help testing the functionality of the `modemcf_test_copy` function that tests the copying of modems for differential phase shift keying (DPSK) modulation scheme with 8 symbols. Can you provide a test case specifically for the `autotest_modem_copy_dpsk8` function that calls `modemcf_test_copy` with the DPSK8 modulation scheme?,"//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_dpsk8()     { modemcf_test_copy(LIQUID_MODEM_DPSK8);     }\n//...')
"
"('Prompt: You are working on testing the functionality of a signal processing library that includes the ability to copy an IIR filter. You want to verify that the copied filter behaves exactly the same as the original filter using a specific filter format. Please write a testbench function that creates an IIR filter prototype with the specified characteristics, generates random input samples, executes the filter on these samples, copies the filter, and then compares the outputs of the original and copied filters for equality. Finally, ensure the memory for both filters is properly freed.","//...\nvoid testbench_iirfilt_copy(liquid_iirdes_format _format)\n{\n    iirfilt_crcf q0 = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_ELLIP, LIQUID_IIRDES_LOWPASS, _format,\n        9,0.2f,0.0f,0.1f,60.0f);\n    unsigned int i, num_samples = 80;\n    float complex y0, y1;\n    for (i=0; i<num_samples; i++) {\n        float complex v = randnf() + _Complex_I*randnf();\n        iirfilt_crcf_execute(q0, v, &y0);\n    }\n    iirfilt_crcf q1 = iirfilt_crcf_copy(q0);\n    for (i=0; i<num_samples; i++) {\n        float complex v = randnf() + _Complex_I*randnf();\n        iirfilt_crcf_execute(q0, v, &y0);\n        iirfilt_crcf_execute(q1, v, &y1);\n        CONTEND_EQUALITY(y0, y1);\n    }\n    iirfilt_crcf_destroy(q0);\n    iirfilt_crcf_destroy(q1);\n}\nvoid autotest_iirfilt_copy_sos() { testbench_iirfilt_copy(LIQUID_IIRDES_SOS); }\n//...')
"
"('Prompt: You are working on testing a digital signal processing library that includes a function for a finite impulse response (FIR) interpolator with a Nyquist filter. You need to create a testbench function that will simulate the interpolation process for a given set of input symbols. The function should compare the output of the interpolator with the expected results and provide detailed output for each step. In addition, you need to create an automated test function that will use the testbench function with specific parameters (filter type, interpolation rate, delay, and beta value) to ensure the correctness of the interpolation algorithm.","//...\nvoid testbench_firinterp_crcf_nyquist(int          _ftype,\n                                      unsigned int _M,\n                                      unsigned int _m,\n                                      float        _beta)\n{\n    float tol = 1e-6;\n    firinterp_crcf q = firinterp_crcf_create_prototype(_ftype, _M, _m, _beta, 0);\n    unsigned int num_symbols = _m+16;   \n    float complex x[num_symbols];       \n    float complex y[_M];                \n    unsigned int i;\n    for (i=0; i<num_symbols; i++)\n        x[i] = cexpf(_Complex_I*0.7f*(float)i);\n    for (i=0; i<num_symbols; i++) {\n        firinterp_crcf_execute(q, x[i], y);\n        if (i >= _m) {\n            CONTEND_DELTA( crealf(x[i-_m]), crealf(y[0]), tol);\n            CONTEND_DELTA( cimagf(x[i-_m]), cimagf(y[0]), tol);\n            if (liquid_autotest_verbose) {\n                printf(""%3u: x=%8.4f + j%8.4f, y=%8.4f + j%8.4f;\\n"", i+1,\n                        crealf(x[i-_m]), cimagf(x[i-_m]),\n                        crealf(y[   0]), cimagf(y[   0]));\n            }\n        }\n    }\n    firinterp_crcf_destroy(q);\n}\nvoid autotest_firinterp_crcf_rnyquist_1() \n    { testbench_firinterp_crcf_nyquist(LIQUID_FIRFILT_KAISER, 3, 9,0.3f); }\n//...')
"
"('Prompt: You are developing a signal processing application that involves using an Infinite Impulse Response (IIR) Hilbert Transform filter with decimation. You need to implement an automated test to ensure the accuracy of the `iirhilbf_copy` function, which creates a copy of an existing IIR Hilbert Transform filter. Write a test function that creates an IIR Hilbert Transform filter with specific design parameters, performs multiple decimation executions using random input samples, creates a copy of the filter, and compares the output of the original and copied filters using the `CONTEND_EQUALITY` macro. Finally, make sure to destroy both filters after testing.","//...\nvoid autotest_iirhilbf_copy_decim()\n{\n    iirhilbf q0 = iirhilbf_create(LIQUID_IIRDES_ELLIP,7,0.1f,80.0f);\n    unsigned int i;\n    float x[2];\n    float complex y0, y1;\n    for (i=0; i<80; i++) {\n        x[0] = randnf();\n        x[1] = randnf();\n        iirhilbf_decim_execute(q0, x, &y0);\n    }\n    iirhilbf q1 = iirhilbf_copy(q0);\n    for (i=0; i<80; i++) {\n        x[0] = randnf();\n        x[1] = randnf();\n        iirhilbf_decim_execute(q0, x, &y0);\n        iirhilbf_decim_execute(q1, x, &y1);\n        if (liquid_autotest_verbose) {\n            printf(""%3u : {%12.8f %12.8f} > %12.8f +j%12.8f, %12.8f +j%12.8f\\n"",\n                    i, x[0], x[1], crealf(y0), cimagf(y0), crealf(y1), cimagf(y1));\n        }\n        CONTEND_EQUALITY(y0, y1);\n    }\n    iirhilbf_destroy(q0);\n    iirhilbf_destroy(q1);\n}\n//...')
"
"('Prompt: . You are working on testing a complex square root function in C. The function you need to create is called `sandbox_csqrtf` and takes a float complex number as input. The function should calculate the square root of the input number and return a float complex result. To test this function, you need to write a `main` function that initializes an array of `float complex` numbers, calculates the square root using your function, and compares it with the built-in square root function. Finally, you need to print the results for each test case, including the maximum error, the input array, and the calculated square roots. Can you provide the code for this scenario?","#define sandbox_randf() ((float) rand() / (float) RAND_MAX)\nfloat complex sandbox_csqrtf(float complex _z)\n{\n    float r = cabsf(_z);            \n    float a = crealf(_z);           \n    float re = sqrtf(0.5f*(r+a));   \n    float im = sqrtf(0.5f*(r-a));   \n    return cimagf(_z) > 0 ? re + _Complex_I*im :\n                            re - _Complex_I*im;\n}\nint main() {\n    unsigned int n=32;  \n    unsigned int d=2;   \n    float complex z[n];\n    float complex test[n];\n    float complex err_max = 0.0f;\n    unsigned int i;\n    for (i=0; i<n; i++) {\n        z[i] = 2.0f*(2.0f*sandbox_randf() - 1.0f) +\n               2.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;\n        test[i] = csqrtf(z[i]);\n        float complex sqrtz_hat = sandbox_csqrtf(z[i]);\n        float complex err = test[i] - sqrtz_hat;\n        printf(""%3u: z=%6.2f+j%6.2f, sqrt(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\\n"",\n                i,\n                crealf(test[i]),    cimagf(z[i]),\n                crealf(test[i]),    cimagf(test[i]),\n                crealf(sqrtz_hat),  cimagf(sqrtz_hat),\n                cabsf(err));\n        if ( cabsf(err) > cabsf(err_max) )\n            err_max = err;\n    }\n    printf(""maximum error: %12.4e;\\n"", cabsf(err_max));\n    printf(""\\n"");\n    printf(""    float complex z[%u] = {\\n      "", n);\n    for (i=0; i<n; i++) {\n        printf(""%12.4e+_Complex_I*%12.4e"", crealf(z[i]), cimagf(z[i]));\n        if ( i == n-1)\n            printf("" "");\n        else if ( ((i+1)%d)==0 )\n            printf("",\\n      "");\n        else\n            printf("", "");\n    }\n    printf(""};\\n"");\n    printf(""\\n"");\n    printf(""    float complex test[%u] = {\\n      "", n);\n    for (i=0; i<n; i++) {\n        printf(""%12.4e+_Complex_I*%12.4e"", crealf(test[i]), cimagf(test[i]));\n        if ( i == n-1)\n            printf("" "");\n        else if ( ((i+1)%d)==0 )\n            printf("",\\n      "");\n        else\n            printf("", "");\n    }\n    printf(""};\\n"");\n    printf(""done.\\n"");\n    return 0;\n}')
"
'You are tasked with creating a program that utilizes STUN (Session Traversal Utilities for NAT) to establish UDP connections between peers. Your program should be able to send and receive messages between peers. . . Prompt: Develop a C program that employs STUN to facilitate UDP connections between peers. The program should prompt the user to input a STUN server IP address and optional local IP address and port for connection. The program should be able to continuously send messages to a specified peer and receive messages from them through UDP. Ensure proper error handling and functionality for establishing and managing the connections.,"#define MAX_EPOLL_EVENT 16\ntypedef struct addr_info{\n    int fd;\n    char ip[64];\n    uint16_t port;\n} addr_info_t;\nstatic char stun_server_ip[64] = {0};\nstatic void usage(void)\n{\n    printf(""./test -s <stun_srv>\\n""\n           ""./test -s <stun_srv> [-c <local_ip> <local_port>]\\n"");\n}\nstatic int udp_send(int fd, const char* ip, uint16_t port, const void* buf, uint32_t len)\n{\n    int ret = 0;\n    struct sockaddr_in sa;\n    sa.sin_family = AF_INET;\n    sa.sin_addr.s_addr = inet_addr(ip);\n    sa.sin_port = htons(port);\n#if 0\n    if (-1 == connect(fd, (struct sockaddr*)&sa, sizeof(sa))) {\n        perror(""connect"");\n        return -1;\n    }\n#endif\n    ret = sendto(fd, buf, len, 0, (struct sockaddr*)&sa, sizeof(sa));\n    if (ret == -1) {\n        close(fd);\n    }\n    return ret;\n}\nstatic void *keep_alive(void *args)\n{\n    while (1) {\n        sleep(30);\n    }\n    return NULL;\n}\nstatic void *send_msg(void *args)\n{\n    struct addr_info *tmp = (struct addr_info *)args;\n    int fd = tmp->fd;\n    char *ip = tmp->ip;\n    uint16_t port = tmp->port;\n    char buf[1024] = {0};\n    int ret, i;\n    while (1) {\n        memset(buf, 0, sizeof(buf));\n        printf(""send msg> "");\n        scanf(""%s"", buf);\n        if (port == 0) {\n            for (i = 1025; i < 65535; i++) {\n                ret = udp_send(fd, ip, i, buf, strlen(buf));\n            }\n        } else {\n            ret = udp_send(fd, ip, port, buf, strlen(buf));\n        }\n        if (ret == -1) {\n            printf(""errno = %d: %s\\n"", errno, strerror(errno));\n        }\n    }\n    return NULL;\n}\nstatic void recv_msg(int fd)\n{\n    int ret;\n    char buf[1024] = {0};\n#if 0\n    ret = recv(fd, buf, sizeof(buf), 0);\n    if (ret == -1) {\n        printf(""%s:%d: errno = %d: %s\\n"", __func__, __LINE__, errno, strerror(errno));\n    }\n#endif\n    struct sockaddr_in si, si2;\n    socklen_t si_len = sizeof(si);\n    memset(&si, 0, sizeof(si));\n    memset(&si2, 0, sizeof(si));\n    ret = recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr *)&si, &si_len);\n    if (ret == -1) {\n        printf(""%s:%d: errno = %d: %s\\n"", __func__, __LINE__, errno, strerror(errno));\n    }\n    if (-1 == getsockname(fd, (struct sockaddr *)&si2, &si_len)) {\n        perror(""getsockname failed!\\n"");\n    }\n    printf(""\\nrecv from ip = %s port = %d to ip = %s port = %d msg > %s\\n"", inet_ntoa(si.sin_addr), ntohs(si.sin_port), inet_ntoa(si2.sin_addr), ntohs(si2.sin_port), buf);\n}\nstatic int test(const char *local_ip, uint16_t local_port)\n{\n    int i;\n    int ret;\n    int epfd, fd;\n    struct in_addr sa;\n    struct sockaddr_in si;\n    socklen_t si_len;\n    struct epoll_event event;\n    struct epoll_event evbuf[MAX_EPOLL_EVENT];\n    stun_addr mapped;\n    pthread_t tid;\n    struct addr_info args;\n    char ip[64] = {0};\n    uint16_t port;\n    struct stun_t stun;\n    if (0 != stun_init(&stun, stun_server_ip)) {\n        printf(""stun init failed!\\n"");\n        return -1;\n    }\n    printf(""stun init ok!\\n"");\n    printf(""stun_socket %s:%d\\n"", local_ip, local_port);\n    fd = stun_socket(&stun, local_ip, local_port, &mapped);\n    if (fd == -1) {\n        printf(""stun open socket failed!\\n"");\n        return -1;\n    }\n    memset(&si, 0, sizeof(si));\n    if (-1 == getsockname(fd, (struct sockaddr *)&si, &si_len)) {\n        perror(""getsockname failed!\\n"");\n    }\n    printf(""ip = %s port = %d\\n"", inet_ntoa(si.sin_addr), ntohs(si.sin_port));\n    stun_nat_type(&stun);\n    pthread_create(&tid, NULL, keep_alive, (void *)&fd);\n    sa.s_addr = ntohl(mapped.addr);\n    printf(""mapped ip = %s, port = %d\\n"", inet_ntoa(sa), mapped.port);\n    printf(""input peer ip: "");\n    scanf(""%s"", ip);\n    printf(""input peer port: "");\n    scanf(""%hd"", &port);\n    if (-1 == (epfd = epoll_create(1))) {\n        perror(""epoll_create"");\n        return -1;\n    }\n    memset(&event, 0, sizeof(event));\n    event.data.fd = fd;\n    event.events = EPOLLIN | EPOLLET;\n    if (-1 == epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event)) {\n        perror(""epoll_ctl"");\n        close(epfd);\n        return -1;\n    }\n    args.fd = fd;\n    args.port = port;\n    strcpy(args.ip, ip);\n    pthread_create(&tid, NULL, send_msg, (void *)&args);\n    while (1) {\n        ret = epoll_wait(epfd, evbuf, MAX_EPOLL_EVENT, -1);\n        if (ret == -1) {\n            perror(""epoll_wait"");\n            continue;\n        }\n        for (i = 0; i < ret; i++) {\n            if (evbuf[i].data.fd == -1)\n                continue;\n            if (evbuf[i].events & (EPOLLERR | EPOLLHUP)) {\n                perror(""epoll error"");\n            }\n            if (evbuf[i].events & EPOLLOUT) {\n                perror(""epoll out"");\n            }\n            if (evbuf[i].events & EPOLLIN) {\n                recv_msg(evbuf[i].data.fd);\n            }\n        }\n    }\n}\nint main(int argc, char **argv)\n{\n    char *ip = NULL;\n    uint16_t port = 0;\n    if (argc != 3 && argc != 6) {\n        usage();\n        exit(0);\n    }\n    if (!strcmp(argv[1], ""-s"")) {\n        strcpy(stun_server_ip, argv[2]);\n    }\n    if (argc == 6) {\n        ip = argv[4];\n        port = atoi(argv[5]);\n    }\n    test(ip, port);\n    return 0;\n}'"
'Prompt: You are working on a multi-threaded application that uses pthread barriers for synchronization. The existing code for the pthread_barrier_wait function needs to be improved for better performance and reliability. Can you provide a revised implementation that addresses potential race conditions and ensures proper synchronization using locking mechanisms?,"#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_barrier_wait (pthread_barrier_t * barrier)\n{\n  int result;\n  pthread_barrier_t b;\n  __ptw32_mcs_local_node_t node;\n  if (barrier == NULL || *barrier == (pthread_barrier_t)  __PTW32_OBJECT_INVALID)\n    {\n      return EINVAL;\n    }\n  __ptw32_mcs_lock_acquire(&(*barrier)->lock, &node);\n  b = *barrier;\n  if (--b->nCurrentBarrierHeight == 0)\n    {\n      __ptw32_mcs_node_transfer(&b->proxynode, &node);\n      result = (b->nInitialBarrierHeight > 1\n                ? sem_post_multiple (&(b->semBarrierBreeched),\n\t\t\t\t     b->nInitialBarrierHeight - 1) : 0);\n    }\n  else\n    {\n      __ptw32_mcs_lock_release(&node);\n      result = __ptw32_semwait (&(b->semBarrierBreeched));\n    }\n  if  ((__PTW32_INTERLOCKED_LONG)__PTW32_INTERLOCKED_INCREMENT_LONG ((__PTW32_INTERLOCKED_LONGPTR)&b->nCurrentBarrierHeight)\n\t\t  ==  (__PTW32_INTERLOCKED_LONG)b->nInitialBarrierHeight)\n    {\n      __ptw32_mcs_lock_release(&b->proxynode);\n      if (0 == result)\n        {\n          result = PTHREAD_BARRIER_SERIAL_THREAD;\n        }\n    }\n  return (result);\n}'"
"'Prompt: Imagine you are working on a project that involves using the PXP module on a microcontroller. Your project is running on FreeRTOS. You need to implement functions for initializing, deinitializing, running, and waiting for the PXP module to complete its operation. Additionally, you need to handle interrupts generated by the PXP module. Write the necessary code to fulfill these requirements.","#if LV_USE_DRAW_PXP\n#if defined(SDK_OS_FREE_RTOS)\n#endif\nstatic void _pxp_interrupt_init(void);\nstatic void _pxp_interrupt_deinit(void);\nstatic void _pxp_run(void);\nstatic void _pxp_wait(void);\n#if defined(SDK_OS_FREE_RTOS)\n    static SemaphoreHandle_t xPXPIdleSemaphore;\n#endif\nstatic volatile bool ucPXPIdle;\nstatic pxp_cfg_t _pxp_default_cfg = {\n    .pxp_interrupt_init = _pxp_interrupt_init,\n    .pxp_interrupt_deinit = _pxp_interrupt_deinit,\n    .pxp_run = _pxp_run,\n    .pxp_wait = _pxp_wait,\n};\nvoid PXP_IRQHandler(void)\n{\n#if defined(SDK_OS_FREE_RTOS)\n    BaseType_t xHigherPriorityTaskWoken = pdFALSE;\n#endif\n    if(kPXP_CompleteFlag & PXP_GetStatusFlags(PXP_ID)) {\n        PXP_ClearStatusFlags(PXP_ID, kPXP_CompleteFlag);\n#if defined(SDK_OS_FREE_RTOS)\n        xSemaphoreGiveFromISR(xPXPIdleSemaphore, &xHigherPriorityTaskWoken);\n        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n#else\n        ucPXPIdle = true;\n#endif\n    }\n}\npxp_cfg_t * pxp_get_default_cfg(void)\n{\n    return &_pxp_default_cfg;\n}\nstatic void _pxp_interrupt_init(void)\n{\n#if defined(SDK_OS_FREE_RTOS)\n    xPXPIdleSemaphore = xSemaphoreCreateBinary();\n    PXP_ASSERT_MSG(xPXPIdleSemaphore, ""xSemaphoreCreateBinary failed!"");\n    NVIC_SetPriority(PXP_IRQ_ID, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 1);\n#endif\n    ucPXPIdle = true;\n    NVIC_EnableIRQ(PXP_IRQ_ID);\n}\nstatic void _pxp_interrupt_deinit(void)\n{\n    NVIC_DisableIRQ(PXP_IRQ_ID);\n#if defined(SDK_OS_FREE_RTOS)\n    vSemaphoreDelete(xPXPIdleSemaphore);\n#endif\n}\nstatic void _pxp_run(void)\n{\n    ucPXPIdle = false;\n    PXP_EnableInterrupts(PXP_ID, kPXP_CompleteInterruptEnable);\n    PXP_Start(PXP_ID);\n}\nstatic void _pxp_wait(void)\n{\n#if defined(SDK_OS_FREE_RTOS)\n    if(ucPXPIdle == true)\n        return;\n    if(xSemaphoreTake(xPXPIdleSemaphore, portMAX_DELAY) == pdTRUE)\n        ucPXPIdle = true;\n#else\n    while(ucPXPIdle == false) {\n    }\n#endif\n}\n#endif '"
'Give me a code snippet that includes a function to check if a specific area is within the coordinates of an object and to wait for a display to finish flushing in the LittlevGL graphics library scenario.,"//...\n    if(_lv_area_is_in(area_p, &obj->coords, 0) == false) return NULL;\n    for(i = child_cnt - 1; i >= 0; i--) {\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic void wait_for_flushing(lv_display_t * disp)\n{\n    LV_PROFILER_BEGIN;\n    LV_LOG_TRACE(""begin"");\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_START, NULL);\n    if(disp->flush_wait_cb) {\n        disp->flush_wait_cb(disp);\n    }\n    else {\n        while(disp->flushing);\n    }\n    disp->flushing_last = 0;\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_FINISH, NULL);\n    LV_LOG_TRACE(""end"");\n    LV_PROFILER_END;\n}\n//...'"
"('You are developing a framework for generating DSSS frames in a digital communications system. This framework includes a data structure `dsssframegen_s` which contains various parameters related to frame generation. The code snippet provided includes functions for configuring the header and payload encoders, setting header properties, and reconfiguring the DSSS frame generator.. . To proceed, please provide the prompt for which you would like to receive the code snippet as a response, considering the technical scenario in developing a DSSS frame generation framework.","//...\nstruct dsssframegen_s {\n    unsigned int        k;             \n    unsigned int        m;             \n    float               beta;          \n    firinterp_crcf      interp;        \n    float complex       buf_interp[2]; \n    dsssframegenprops_s props;        \n    dsssframegenprops_s header_props; \n    float complex *     preamble_pn; \n    synth_crcf          header_synth;\n    synth_crcf          payload_synth;\n    unsigned char *     header;          \n    unsigned int        header_user_len; \n    unsigned int        header_dec_len;  \n    qpacketmodem        header_encoder;  \n    unsigned int        header_mod_len;  \n    float complex *     header_mod;\n    unsigned int        payload_dec_len; \n    qpacketmodem        payload_encoder;\n    unsigned int        payload_mod_len;\n    float complex *     payload_mod;\n    unsigned int        symbol_counter; \n    unsigned int        sample_counter; \n    unsigned int        bit_counter;    \n    int                 bit_high;       \n    float complex       sym;\n    int                 frame_assembled; \n    int                 frame_complete;  \n    enum state          state;           \n};\nint           dsssframegen_reconfigure       (dsssframegen _q);\n        return 0.f;\n        _q->frame_assembled = 0;\nint dsssframegen_reconfigure_header(dsssframegen _q)\n{\n    qpacketmodem_configure(_q->header_encoder,\n                           _q->header_dec_len,\n                           _q->header_props.check,\n                           _q->header_props.fec0,\n                           _q->header_props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_encoder);\n    _q->header_mod     = (float complex *)realloc(\n        _q->header_mod, _q->header_mod_len * sizeof(float complex));\n    return LIQUID_OK;\n}\nint dsssframegen_reconfigure(dsssframegen _q)\n{\n    qpacketmodem_configure(_q->payload_encoder,\n                           _q->payload_dec_len,\n                           _q->props.check,\n                           _q->props.fec0,\n                           _q->props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->payload_mod_len = qpacketmodem_get_frame_len(_q->payload_encoder);\n    _q->payload_mod     = (float complex *)realloc(\n        _q->payload_mod, _q->payload_mod_len * sizeof(float complex));\n    return LIQUID_OK;\n}\nint dsssframegen_set_header_props(dsssframegen _q, dsssframegenprops_s * _props)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_set_header_props(), frame is already assembled; must reset() first"");\n    if (_props == NULL)\n        _props = &dsssframegenprops_header_default;\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EIMODE,""dsssframegen_set_header_props(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EIMODE,""dsssframegen_set_header_props(), invalid/unsupported FEC scheme"");\n    memmove(&_q->header_props, _props, sizeof(dsssframegenprops_s));\n    return dsssframegen_reconfigure_header(_q);\n}\n//...')
"
('Prompt: You are working on a numerical computing library and have a function called `liquid_Qf` that computes a specific type of mathematical function. Write a series of test cases for this function using a predefined macro `CONTEND_DELTA` to check if the results are within a tolerable range. Each test case should compare the output of `liquid_Qf` for specific input values against expected values with a given tolerance.,"//...\nvoid autotest_Q()\n{\n    float tol = 1e-6f;\n    CONTEND_DELTA(liquid_Qf(-4.0f), 0.999968329f, tol);\n    CONTEND_DELTA(liquid_Qf(-3.0f), 0.998650102f, tol);\n    CONTEND_DELTA(liquid_Qf(-2.0f), 0.977249868f, tol);\n    CONTEND_DELTA(liquid_Qf(-1.0f), 0.841344746f, tol);\n    CONTEND_DELTA(liquid_Qf( 0.0f), 0.5f,         tol);\n    CONTEND_DELTA(liquid_Qf( 1.0f), 0.158655254f, tol);\n    CONTEND_DELTA(liquid_Qf( 2.0f), 0.022750132f, tol);\n    CONTEND_DELTA(liquid_Qf( 3.0f), 0.001349898f, tol);\n    CONTEND_DELTA(liquid_Qf( 4.0f), 0.000031671f, tol);\n}\n//...')
"
"'Prompt: ""Imagine you are working on an embedded systems project using RTEMS. You need to implement a set of functions for configuring pin functions on a TMS570 microcontroller. The functions should include setting and clearing pin functions, applying configurations, and completing the configuration process. Can you provide me with the code for these functions?""","RTEMS_STATIC_ASSERT(\n  TMS570_PIN_CLEAR_RQ_MASK == TMS570_PIN_FNC_CLEAR << TMS570_PIN_FNC_SHIFT,\n  TMS570_PIN_CONFIG\n);\nstatic inline void\ntms570_bsp_pin_to_pinmmrx(volatile uint32_t **pinmmrx, uint32_t *pin_shift,\n                          uint32_t config)\n{\n  uint32_t pin_num = (config & TMS570_PIN_NUM_MASK) >> TMS570_PIN_NUM_SHIFT;\n  *pinmmrx = TMS570_PINMUX + (pin_num >> 2);\n  *pin_shift = (pin_num & 0x3)*8;\n}\nvoid\ntms570_bsp_pin_set_function(int pin_num, int pin_fnc)\n{\n  unsigned int pin_shift;\n  volatile uint32_t *pinmmrx;\n  if ( pin_fnc == TMS570_PIN_FNC_AUTO ) {\n    pin_fnc = (pin_num & TMS570_PIN_FNC_MASK) >> TMS570_PIN_FNC_SHIFT;\n  }\n  tms570_bsp_pin_to_pinmmrx(&pinmmrx, &pin_shift, pin_num);\n  *pinmmrx = (*pinmmrx & ~(0xff << pin_shift)) | (1 << (pin_fnc + pin_shift));\n}\nvoid\ntms570_bsp_pin_clear_function(int pin_num, int pin_fnc)\n{\n  unsigned int pin_shift;\n  volatile uint32_t *pinmmrx;\n  if ( pin_fnc == TMS570_PIN_FNC_AUTO ) {\n    pin_fnc = (pin_num & TMS570_PIN_FNC_MASK) >> TMS570_PIN_FNC_SHIFT;\n  }\n  tms570_bsp_pin_to_pinmmrx(&pinmmrx, &pin_shift, pin_num);\n  *pinmmrx = *pinmmrx & ~(1 << (pin_fnc+pin_shift));\n}\nvoid\ntms570_bsp_pin_config_one(uint32_t pin_num_and_fnc)\n{\n  rtems_interrupt_level intlev;\n  rtems_interrupt_disable(intlev);\n  tms570_pin_config_prepare();\n  tms570_pin_config_apply(pin_num_and_fnc);\n  tms570_pin_config_complete();\n  rtems_interrupt_enable(intlev);\n}\nvoid\ntms570_bsp_pinmmr_config(const uint32_t *pinmmr_values, int reg_start, int reg_count)\n{\n  volatile uint32_t *pinmmrx;\n  const uint32_t *pval;\n  int cnt;\n  if ( reg_count <= 0)\n    return;\n  tms570_pin_config_prepare();\n  pinmmrx = TMS570_PINMUX + reg_start;\n  pval = pinmmr_values;\n  cnt = reg_count;\n  do {\n    *pinmmrx = *pval;\n    pinmmrx++;\n    pval++;\n  } while( --cnt );\n  tms570_pin_config_complete();\n}\nvoid tms570_pin_config_prepare(void)\n{\n  TMS570_IOMM.KICK_REG0 = 0x83E70B13U;\n  TMS570_IOMM.KICK_REG1 = 0x95A4F1E0U;\n}\nstatic void\ntms570_pin_set_function(uint32_t config)\n{\n  volatile uint32_t *pinmmrx;\n  uint32_t pin_shift;\n  uint32_t pin_fnc;\n  uint32_t bit;\n  uint32_t val;\n  tms570_bsp_pin_to_pinmmrx(&pinmmrx, &pin_shift, config);\n  pin_fnc = (config & TMS570_PIN_FNC_MASK) >> TMS570_PIN_FNC_SHIFT;\n  bit = 1U << (pin_fnc + pin_shift);\n  val = *pinmmrx;\n  val &= ~(0xffU << pin_shift);\n  if ((config & TMS570_PIN_CLEAR_RQ_MASK) == 0) {\n    val |= bit;\n  }\n  *pinmmrx = val;\n}\nvoid tms570_pin_config_apply(uint32_t config)\n{\n  uint32_t pin_in_alt;\n  uint32_t pin_num_and_fnc;\n  pin_in_alt = config & TMS570_PIN_IN_ALT_MASK;\n  if (pin_in_alt != 0) {\n    pin_in_alt >>= TMS570_PIN_IN_ALT_SHIFT;\n    tms570_pin_set_function(pin_in_alt);\n  }\n  pin_num_and_fnc = config & TMS570_PIN_NUM_FNC_MASK;\n  tms570_pin_set_function(pin_num_and_fnc);\n}\nvoid tms570_pin_config_array_apply(const uint32_t *config, size_t count)\n{\n  size_t i;\n  for (i = 0; i < count; ++i) {\n    tms570_pin_config_apply(config[i]);\n  }\n}\nvoid tms570_pin_config_complete(void)\n{\n  TMS570_IOMM.KICK_REG0 = 0;\n  TMS570_IOMM.KICK_REG1 = 0;\n}'"
('Prompt: You are working on a project to implement a Gaussian minimum-shift keying (GMSK) modem for transmitting data symbols over a wireless medium. Can you provide a function that prints the usage instructions and available options for the GMSK modem test application? The function should display the default values for each option and explain the purpose of each parameter.,"//...\nvoid usage()\n{\n    printf(""gmskmodem_test -- Gaussian minimum-shift keying modem example\\n"");\n    printf(""options (default values in <>):\\n"");\n    printf(""  u/h   : print usage/help\\n"");\n    printf(""  k     : samples/symbol <4>\\n"");\n    printf(""  m     : filter delay [symbols], <3>\\n"");\n    printf(""  n     : number of data symbols <32>\\n"");\n    printf(""  b     : bandwidth-time product, 0 <= b <= 1, <0.3>\\n"");\n    printf(""  s     : SNR [dB] <30>\\n"");\n}\n//...')
"
"('Prompt: ""You need to implement a print function for a structure called \'gmskframesync\' in C. The structure contains an unsigned int variable \'m\' and another structure \'framedatastats_s\' named \'framedatastats\'. The function should print the contents of \'gmskframesync\' along with calling a function \'framedatastats_print\' to print the contents of \'framedatastats\'. Additionally, there is a preprocessor directive defined as \'GMSKFRAMESYNC_PREFILTER\' with a value of \'1\'. Can you write the code for this print function?""","//...\n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int m;                 \n    framedatastats_s framedatastats;\nint gmskframesync_print(gmskframesync _q)\n{\n    printf(""gmskframesync:\\n"");\n    return framedatastats_print(&_q->framedatastats);\n}\n//...')
"
"('Prompt: You are working on a project that involves error detection and correction using a SEC-DED (Single Error Correction, Double Error Detection) code known as secded2216. You need to implement a function to compute the parity bit for this code. Could you provide a C function that takes an unsigned char array of length 2 as input and returns the computed parity bit according to the secded2216 specifications?","//...\n#define DEBUG_FEC_SECDED2216 0\nunsigned char fec_secded2216_compute_parity(unsigned char * _m)\n{\n    unsigned char parity = 0x00;\n    unsigned int i;\n    for (i=0; i<6; i++) {\n        parity <<= 1;\n        unsigned int p = liquid_c_ones[ secded2216_P[2*i+0] & _m[0] ] +\n                         liquid_c_ones[ secded2216_P[2*i+1] & _m[1] ];\n        parity |= p & 0x01;\n    }\n    return parity;\n}\n//...')
"
"'Please provide a prompt that explains a technical scenario where the CORDIC (Coordinate Rotation Digital Computer) module is being used in a HAL (Hardware Abstraction Layer) implementation in an embedded system project. The prompt should specify the need for functions to initialize, deinitialize, configure, and perform calculations using the CORDIC module. It should also mention the usage of DMA (Direct Memory Access) for data transfer in the context of CORDIC operations.","#if defined(CORDIC)\n#ifdef HAL_CORDIC_MODULE_ENABLED\nstatic void CORDIC_WriteInDataIncrementPtr(const CORDIC_HandleTypeDef *hcordic, const int32_t **ppInBuff);\nstatic void CORDIC_ReadOutDataIncrementPtr(const CORDIC_HandleTypeDef *hcordic, int32_t **ppOutBuff);\nstatic void CORDIC_DMAInCplt(DMA_HandleTypeDef *hdma);\nstatic void CORDIC_DMAOutCplt(DMA_HandleTypeDef *hdma);\nstatic void CORDIC_DMAError(DMA_HandleTypeDef *hdma);\nHAL_StatusTypeDef HAL_CORDIC_Init(CORDIC_HandleTypeDef *hcordic)\n{\n  if (hcordic == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_CORDIC_ALL_INSTANCE(hcordic->Instance));\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\n  if (hcordic->State == HAL_CORDIC_STATE_RESET)\n  {\n    hcordic->Lock = HAL_UNLOCKED;\n    hcordic->ErrorCallback         = HAL_CORDIC_ErrorCallback;         \n    hcordic->CalculateCpltCallback = HAL_CORDIC_CalculateCpltCallback; \n    if (hcordic->MspInitCallback == NULL)\n    {\n      hcordic->MspInitCallback = HAL_CORDIC_MspInit;                   \n    }\n    hcordic->MspInitCallback(hcordic);\n  }\n#else\n  if (hcordic->State == HAL_CORDIC_STATE_RESET)\n  {\n    hcordic->Lock = HAL_UNLOCKED;\n    HAL_CORDIC_MspInit(hcordic);\n  }\n#endif \n  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;\n  hcordic->pInBuff = NULL;\n  hcordic->pOutBuff = NULL;\n  hcordic->NbCalcToOrder = 0U;\n  hcordic->NbCalcToGet = 0U;\n  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;\n  hcordic->State = HAL_CORDIC_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_CORDIC_DeInit(CORDIC_HandleTypeDef *hcordic)\n{\n  if (hcordic == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_CORDIC_ALL_INSTANCE(hcordic->Instance));\n  hcordic->State = HAL_CORDIC_STATE_BUSY;\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\n  if (hcordic->MspDeInitCallback == NULL)\n  {\n    hcordic->MspDeInitCallback = HAL_CORDIC_MspDeInit;\n  }\n  hcordic->MspDeInitCallback(hcordic);\n#else\n  HAL_CORDIC_MspDeInit(hcordic);\n#endif \n  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;\n  hcordic->pInBuff = NULL;\n  hcordic->pOutBuff = NULL;\n  hcordic->NbCalcToOrder = 0U;\n  hcordic->NbCalcToGet = 0U;\n  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;\n  hcordic->State = HAL_CORDIC_STATE_RESET;\n  hcordic->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n__weak void HAL_CORDIC_MspInit(CORDIC_HandleTypeDef *hcordic)\n{\n  UNUSED(hcordic);\n}\n__weak void HAL_CORDIC_MspDeInit(CORDIC_HandleTypeDef *hcordic)\n{\n  UNUSED(hcordic);\n}\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\nHAL_StatusTypeDef HAL_CORDIC_RegisterCallback(CORDIC_HandleTypeDef *hcordic, HAL_CORDIC_CallbackIDTypeDef CallbackID,\n                                              void (* pCallback)(CORDIC_HandleTypeDef *_hcordic))\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (pCallback == NULL)\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n    return HAL_ERROR;\n  }\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CORDIC_ERROR_CB_ID :\n        hcordic->ErrorCallback = pCallback;\n        break;\n      case HAL_CORDIC_CALCULATE_CPLT_CB_ID :\n        hcordic->CalculateCpltCallback = pCallback;\n        break;\n      case HAL_CORDIC_MSPINIT_CB_ID :\n        hcordic->MspInitCallback = pCallback;\n        break;\n      case HAL_CORDIC_MSPDEINIT_CB_ID :\n        hcordic->MspDeInitCallback = pCallback;\n        break;\n      default :\n        hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else if (hcordic->State == HAL_CORDIC_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CORDIC_MSPINIT_CB_ID :\n        hcordic->MspInitCallback = pCallback;\n        break;\n      case HAL_CORDIC_MSPDEINIT_CB_ID :\n        hcordic->MspDeInitCallback = pCallback;\n        break;\n      default :\n        hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n#endif \n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\nHAL_StatusTypeDef HAL_CORDIC_UnRegisterCallback(CORDIC_HandleTypeDef *hcordic, HAL_CORDIC_CallbackIDTypeDef CallbackID)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CORDIC_ERROR_CB_ID :\n        hcordic->ErrorCallback = HAL_CORDIC_ErrorCallback;\n        break;\n      case HAL_CORDIC_CALCULATE_CPLT_CB_ID :\n        hcordic->CalculateCpltCallback = HAL_CORDIC_CalculateCpltCallback;\n        break;\n      case HAL_CORDIC_MSPINIT_CB_ID :\n        hcordic->MspInitCallback = HAL_CORDIC_MspInit;\n        break;\n      case HAL_CORDIC_MSPDEINIT_CB_ID :\n        hcordic->MspDeInitCallback = HAL_CORDIC_MspDeInit;\n        break;\n      default :\n        hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else if (hcordic->State == HAL_CORDIC_STATE_RESET)\n  {\n    switch (CallbackID)\n    {\n      case HAL_CORDIC_MSPINIT_CB_ID :\n        hcordic->MspInitCallback = HAL_CORDIC_MspInit;\n        break;\n      case HAL_CORDIC_MSPDEINIT_CB_ID :\n        hcordic->MspDeInitCallback = HAL_CORDIC_MspDeInit;\n        break;\n      default :\n        hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_INVALID_CALLBACK;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n#endif \nHAL_StatusTypeDef HAL_CORDIC_Configure(CORDIC_HandleTypeDef *hcordic, const CORDIC_ConfigTypeDef *sConfig)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_CORDIC_FUNCTION(sConfig->Function));\n  assert_param(IS_CORDIC_PRECISION(sConfig->Precision));\n  assert_param(IS_CORDIC_SCALE(sConfig->Scale));\n  assert_param(IS_CORDIC_NBWRITE(sConfig->NbWrite));\n  assert_param(IS_CORDIC_NBREAD(sConfig->NbRead));\n  assert_param(IS_CORDIC_INSIZE(sConfig->InSize));\n  assert_param(IS_CORDIC_OUTSIZE(sConfig->OutSize));\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    MODIFY_REG(hcordic->Instance->CSR,                                                         \\\n               (CORDIC_CSR_FUNC | CORDIC_CSR_PRECISION | CORDIC_CSR_SCALE |                    \\\n                CORDIC_CSR_NARGS | CORDIC_CSR_NRES | CORDIC_CSR_ARGSIZE | CORDIC_CSR_RESSIZE), \\\n               (sConfig->Function | sConfig->Precision | sConfig->Scale |                      \\\n                sConfig->NbWrite | sConfig->NbRead | sConfig->InSize | sConfig->OutSize));\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_NOT_READY;\n    status = HAL_ERROR;\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_CORDIC_Calculate(CORDIC_HandleTypeDef *hcordic, const int32_t *pInBuff, int32_t *pOutBuff,\n                                       uint32_t NbCalc, uint32_t Timeout)\n{\n  uint32_t tickstart;\n  uint32_t index;\n  const int32_t *p_tmp_in_buff = pInBuff;\n  int32_t *p_tmp_out_buff = pOutBuff;\n  if ((pInBuff == NULL) || (pOutBuff == NULL) || (NbCalc == 0U))\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_PARAM;\n    return HAL_ERROR;\n  }\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;\n    hcordic->State = HAL_CORDIC_STATE_BUSY;\n    tickstart = HAL_GetTick();\n    CORDIC_WriteInDataIncrementPtr(hcordic, &p_tmp_in_buff);\n    for (index = (NbCalc - 1U); index > 0U; index--)\n    {\n      CORDIC_WriteInDataIncrementPtr(hcordic, &p_tmp_in_buff);\n      do\n      {\n        if (Timeout != HAL_MAX_DELAY)\n        {\n          if ((HAL_GetTick() - tickstart) > Timeout)\n          {\n            hcordic->ErrorCode = HAL_CORDIC_ERROR_TIMEOUT;\n            hcordic->State = HAL_CORDIC_STATE_READY;\n            return HAL_ERROR;\n          }\n        }\n      } while (HAL_IS_BIT_CLR(hcordic->Instance->CSR, CORDIC_CSR_RRDY));\n      CORDIC_ReadOutDataIncrementPtr(hcordic, &p_tmp_out_buff);\n    }\n    CORDIC_ReadOutDataIncrementPtr(hcordic, &p_tmp_out_buff);\n    hcordic->State = HAL_CORDIC_STATE_READY;\n    return HAL_OK;\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_NOT_READY;\n    return HAL_ERROR;\n  }\n}\nHAL_StatusTypeDef HAL_CORDIC_CalculateZO(CORDIC_HandleTypeDef *hcordic, const int32_t *pInBuff, int32_t *pOutBuff,\n                                         uint32_t NbCalc, uint32_t Timeout)\n{\n  uint32_t tickstart;\n  uint32_t index;\n  const int32_t *p_tmp_in_buff = pInBuff;\n  int32_t *p_tmp_out_buff = pOutBuff;\n  if ((pInBuff == NULL) || (pOutBuff == NULL) || (NbCalc == 0U))\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_PARAM;\n    return HAL_ERROR;\n  }\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;\n    hcordic->State = HAL_CORDIC_STATE_BUSY;\n    tickstart = HAL_GetTick();\n    CORDIC_WriteInDataIncrementPtr(hcordic, &p_tmp_in_buff);\n    for (index = (NbCalc - 1U); index > 0U; index--)\n    {\n      CORDIC_WriteInDataIncrementPtr(hcordic, &p_tmp_in_buff);\n      CORDIC_ReadOutDataIncrementPtr(hcordic, &p_tmp_out_buff);\n      if (Timeout != HAL_MAX_DELAY)\n      {\n        if ((HAL_GetTick() - tickstart) > Timeout)\n        {\n          hcordic->ErrorCode = HAL_CORDIC_ERROR_TIMEOUT;\n          hcordic->State = HAL_CORDIC_STATE_READY;\n          return HAL_ERROR;\n        }\n      }\n    }\n    CORDIC_ReadOutDataIncrementPtr(hcordic, &p_tmp_out_buff);\n    hcordic->State = HAL_CORDIC_STATE_READY;\n    return HAL_OK;\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_NOT_READY;\n    return HAL_ERROR;\n  }\n}\nHAL_StatusTypeDef HAL_CORDIC_Calculate_IT(CORDIC_HandleTypeDef *hcordic, const int32_t *pInBuff, int32_t *pOutBuff,\n                                          uint32_t NbCalc)\n{\n  const int32_t *tmp_pInBuff = pInBuff;\n  if ((pInBuff == NULL) || (pOutBuff == NULL) || (NbCalc == 0U))\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_PARAM;\n    return HAL_ERROR;\n  }\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;\n    hcordic->State = HAL_CORDIC_STATE_BUSY;\n    if (HAL_IS_BIT_SET(hcordic->Instance->CSR, CORDIC_CSR_NARGS))\n    {\n      tmp_pInBuff++;\n      tmp_pInBuff++;\n    }\n    else\n    {\n      tmp_pInBuff++;\n    }\n    hcordic->pInBuff = tmp_pInBuff;\n    hcordic->pOutBuff = pOutBuff;\n    hcordic->NbCalcToOrder = NbCalc - 1U;\n    hcordic->NbCalcToGet = NbCalc;\n    __HAL_CORDIC_ENABLE_IT(hcordic, CORDIC_IT_IEN);\n    tmp_pInBuff = pInBuff;\n    WRITE_REG(hcordic->Instance->WDATA, (uint32_t)*tmp_pInBuff);\n    if (HAL_IS_BIT_SET(hcordic->Instance->CSR, CORDIC_CSR_NARGS))\n    {\n      tmp_pInBuff++;\n      WRITE_REG(hcordic->Instance->WDATA, (uint32_t)*tmp_pInBuff);\n    }\n    return HAL_OK;\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_NOT_READY;\n    return HAL_ERROR;\n  }\n}\nHAL_StatusTypeDef HAL_CORDIC_Calculate_DMA(CORDIC_HandleTypeDef *hcordic, const int32_t *pInBuff, int32_t *pOutBuff,\n                                           uint32_t NbCalc, uint32_t DMADirection)\n{\n  uint32_t sizeinbuff;\n  uint32_t sizeoutbuff;\n  uint32_t inputaddr;\n  uint32_t outputaddr;\n  assert_param(IS_CORDIC_DMA_DIRECTION(DMADirection));\n  if (NbCalc == 0U)\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_PARAM;\n    return HAL_ERROR;\n  }\n  if ((DMADirection == CORDIC_DMA_DIR_OUT) || (DMADirection == CORDIC_DMA_DIR_IN_OUT))\n  {\n    if (pOutBuff == NULL)\n    {\n      hcordic->ErrorCode |= HAL_CORDIC_ERROR_PARAM;\n      return HAL_ERROR;\n    }\n  }\n  if ((DMADirection == CORDIC_DMA_DIR_IN) || (DMADirection == CORDIC_DMA_DIR_IN_OUT))\n  {\n    if (pInBuff == NULL)\n    {\n      hcordic->ErrorCode |= HAL_CORDIC_ERROR_PARAM;\n      return HAL_ERROR;\n    }\n  }\n  if (hcordic->State == HAL_CORDIC_STATE_READY)\n  {\n    hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;\n    hcordic->State = HAL_CORDIC_STATE_BUSY;\n    hcordic->DMADirection = DMADirection;\n    if ((DMADirection == CORDIC_DMA_DIR_OUT) || (DMADirection == CORDIC_DMA_DIR_IN_OUT))\n    {\n      hcordic->hdmaOut->XferCpltCallback = CORDIC_DMAOutCplt;\n      hcordic->hdmaOut->XferErrorCallback = CORDIC_DMAError;\n      if (HAL_IS_BIT_SET(hcordic->Instance->CSR, CORDIC_CSR_NRES))\n      {\n        sizeoutbuff = 2U * NbCalc;\n      }\n      else\n      {\n        sizeoutbuff = NbCalc;\n      }\n      outputaddr = (uint32_t)pOutBuff;\n      if (HAL_DMA_Start_IT(hcordic->hdmaOut, (uint32_t)&hcordic->Instance->RDATA, outputaddr, sizeoutbuff) != HAL_OK)\n      {\n        hcordic->ErrorCode |= HAL_CORDIC_ERROR_DMA;\n        return HAL_ERROR;\n      }\n      SET_BIT(hcordic->Instance->CSR, CORDIC_DMA_REN);\n    }\n    if ((DMADirection == CORDIC_DMA_DIR_IN) || (DMADirection == CORDIC_DMA_DIR_IN_OUT))\n    {\n      hcordic->hdmaIn->XferCpltCallback = CORDIC_DMAInCplt;\n      hcordic->hdmaIn->XferErrorCallback = CORDIC_DMAError;\n      if (HAL_IS_BIT_SET(hcordic->Instance->CSR, CORDIC_CSR_NARGS))\n      {\n        sizeinbuff = 2U * NbCalc;\n      }\n      else\n      {\n        sizeinbuff = NbCalc;\n      }\n      inputaddr  = (uint32_t)pInBuff;\n      if (HAL_DMA_Start_IT(hcordic->hdmaIn, inputaddr, (uint32_t)&hcordic->Instance->WDATA, sizeinbuff) != HAL_OK)\n      {\n        hcordic->ErrorCode |= HAL_CORDIC_ERROR_DMA;\n        return HAL_ERROR;\n      }\n      SET_BIT(hcordic->Instance->CSR, CORDIC_DMA_WEN);\n    }\n    return HAL_OK;\n  }\n  else\n  {\n    hcordic->ErrorCode |= HAL_CORDIC_ERROR_NOT_READY;\n    return HAL_ERROR;\n  }\n}\n__weak void HAL_CORDIC_ErrorCallback(CORDIC_HandleTypeDef *hcordic)\n{\n  UNUSED(hcordic);\n}\n__weak void HAL_CORDIC_CalculateCpltCallback(CORDIC_HandleTypeDef *hcordic)\n{\n  UNUSED(hcordic);\n}\nvoid HAL_CORDIC_IRQHandler(CORDIC_HandleTypeDef *hcordic)\n{\n  if (__HAL_CORDIC_GET_IT_SOURCE(hcordic, CORDIC_IT_IEN) != 0U)\n  {\n    if (__HAL_CORDIC_GET_FLAG(hcordic, CORDIC_FLAG_RRDY) != 0U)\n    {\n      hcordic->NbCalcToGet--;\n      CORDIC_ReadOutDataIncrementPtr(hcordic, &(hcordic->pOutBuff));\n      if (hcordic->NbCalcToOrder > 0U)\n      {\n        hcordic->NbCalcToOrder--;\n        CORDIC_WriteInDataIncrementPtr(hcordic, &(hcordic->pInBuff));\n      }\n      if (hcordic->NbCalcToGet == 0U)\n      {\n        __HAL_CORDIC_DISABLE_IT(hcordic, CORDIC_IT_IEN);\n        hcordic->State = HAL_CORDIC_STATE_READY;\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\n        hcordic->CalculateCpltCallback(hcordic);\n#else\n        HAL_CORDIC_CalculateCpltCallback(hcordic);\n#endif \n      }\n    }\n  }\n}\nHAL_CORDIC_StateTypeDef HAL_CORDIC_GetState(const CORDIC_HandleTypeDef *hcordic)\n{\n  return hcordic->State;\n}\nuint32_t HAL_CORDIC_GetError(const CORDIC_HandleTypeDef *hcordic)\n{\n  return hcordic->ErrorCode;\n}\nstatic void CORDIC_WriteInDataIncrementPtr(const CORDIC_HandleTypeDef *hcordic, const int32_t **ppInBuff)\n{\n  WRITE_REG(hcordic->Instance->WDATA, (uint32_t) **ppInBuff);\n  (*ppInBuff)++;\n  if (HAL_IS_BIT_SET(hcordic->Instance->CSR, CORDIC_CSR_NARGS))\n  {\n    WRITE_REG(hcordic->Instance->WDATA, (uint32_t) **ppInBuff);\n    (*ppInBuff)++;\n  }\n}\nstatic void CORDIC_ReadOutDataIncrementPtr(const CORDIC_HandleTypeDef *hcordic, int32_t **ppOutBuff)\n{\n  **ppOutBuff = (int32_t)READ_REG(hcordic->Instance->RDATA);\n  (*ppOutBuff)++;\n  if (HAL_IS_BIT_SET(hcordic->Instance->CSR, CORDIC_CSR_NRES))\n  {\n    **ppOutBuff = (int32_t)READ_REG(hcordic->Instance->RDATA);\n    (*ppOutBuff)++;\n  }\n}\nstatic void CORDIC_DMAInCplt(DMA_HandleTypeDef *hdma)\n{\n  CORDIC_HandleTypeDef *hcordic = (CORDIC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\n  CLEAR_BIT(hcordic->Instance->CSR, CORDIC_DMA_WEN);\n  if (hcordic->DMADirection == CORDIC_DMA_DIR_IN)\n  {\n    hcordic->DMADirection = CORDIC_DMA_DIR_NONE;\n    hcordic->State = HAL_CORDIC_STATE_READY;\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\n    hcordic->CalculateCpltCallback(hcordic);\n#else\n    HAL_CORDIC_CalculateCpltCallback(hcordic);\n#endif \n  }\n}\nstatic void CORDIC_DMAOutCplt(DMA_HandleTypeDef *hdma)\n{\n  CORDIC_HandleTypeDef *hcordic = (CORDIC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\n  CLEAR_BIT(hcordic->Instance->CSR, CORDIC_DMA_REN);\n  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;\n  hcordic->State = HAL_CORDIC_STATE_READY;\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\n  hcordic->CalculateCpltCallback(hcordic);\n#else\n  HAL_CORDIC_CalculateCpltCallback(hcordic);\n#endif \n}\nstatic void CORDIC_DMAError(DMA_HandleTypeDef *hdma)\n{\n  CORDIC_HandleTypeDef *hcordic = (CORDIC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\n  hcordic->State = HAL_CORDIC_STATE_READY;\n  hcordic->ErrorCode |= HAL_CORDIC_ERROR_DMA;\n#if USE_HAL_CORDIC_REGISTER_CALLBACKS == 1\n  hcordic->ErrorCallback(hcordic);\n#else\n  HAL_CORDIC_ErrorCallback(hcordic);\n#endif \n}\n#endif \n#endif '"
"('Please provide a prompt requesting a code that reads command-line arguments for testing pre-demodulation synchronization. The code should include options for filter settings, symbol parameters, and signal characteristics such as SNR and frequency offset. The code also generates sample data and performs synchronization testing to output results in a MATLAB-compatible file named ""predemod_sync_test.m"".","#define OUTPUT_FILENAME ""predemod_sync_test.m""\nvoid usage()\n{\n    printf(""predemod_sync_test -- test pre-demodulation synchronization\\n"");\n    printf(""options:\\n"");\n    printf(""  h     : print usage/help\\n"");\n    printf(""  k     : samples/symbol, default: 2\\n"");\n    printf(""  m     : filter delay [symbols], default: 4\\n"");\n    printf(""  n     : number of data symbols, default: 64\\n"");\n    printf(""  b     : bandwidth-time product, (0,1), default: 0.3\\n"");\n    printf(""  t     : fractional sample offset, (-0.5,0.5), default: 0\\n"");\n    printf(""  F     : frequency offset, default: 0\\n"");\n    printf(""  P     : phase offset, default: 0\\n"");\n    printf(""  s     : SNR [dB], default: 30\\n"");\n}\nint main(int argc, char*argv[])\n{\n    srand(time(NULL));\n    unsigned int k=2;                   \n    unsigned int m=4;                   \n    float beta=0.3f;                    \n    float dt = 0.0f;                    \n    unsigned int num_sync_symbols = 64; \n    float SNRdB = 30.0f;                \n    float dphi = 0.0f;                  \n    float phi  = 0.0f;                  \n    unsigned int num_delay_symbols = 12;\n    unsigned int num_dphi_hat = 21;     \n    float dphi_hat_step = 0.01f;        \n    int dopt;\n    while ((dopt = getopt(argc,argv,""uhk:m:n:b:t:F:P:s:"")) != EOF) {\n        switch (dopt) {\n        case \'h\': usage();              return 0;\n        case \'k\': k     = atoi(optarg); break;\n        case \'m\': m     = atoi(optarg); break;\n        case \'n\': num_sync_symbols = atoi(optarg); break;\n        case \'b\': beta  = atof(optarg); break;\n        case \'t\': dt    = atof(optarg); break;\n        case \'F\': dphi  = atof(optarg); break;\n        case \'P\': phi   = atof(optarg); break;\n        case \'s\': SNRdB = atof(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    unsigned int i;\n    if (beta <= 0.0f || beta >= 1.0f) {\n        fprintf(stderr,""error: %s, bandwidth-time product must be in (0,1)\\n"", argv[0]);\n        exit(1);\n    } else if (dt < -0.5 || dt > 0.5) {\n        fprintf(stderr,""error: %s, fractional sample offset must be in (0,1)\\n"", argv[0]);\n        exit(1);\n    }\n    unsigned int num_symbols = num_delay_symbols + num_sync_symbols + 2*m;\n    unsigned int num_samples = k*num_symbols;\n    unsigned int num_sync_samples = k*num_sync_symbols;\n    float nstd = powf(10.0f, -SNRdB/20.0f);\n    float complex seq[num_sync_symbols];    \n    float complex s0[num_sync_samples];     \n    float complex x[num_samples];           \n    float complex y[num_samples];           \n    float rxy[num_dphi_hat][num_samples];   \n    for (i=0; i<num_sync_symbols; i++) {\n        float sym_i = rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2;\n        float sym_q = rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2;\n        seq[i] = sym_i + _Complex_I*sym_q;\n    }\n    firinterp_crcf interp_seq = firinterp_crcf_create_prototype(LIQUID_FIRFILT_RRC,k,m,beta,0.0f);\n    for (i=0; i<num_sync_symbols+m; i++) {\n        if      (i < m)                firinterp_crcf_execute(interp_seq, seq[i], &s0[0]);\n        else if (i < num_sync_symbols) firinterp_crcf_execute(interp_seq, seq[i], &s0[k*(i-m)]);\n        else                           firinterp_crcf_execute(interp_seq,      0, &s0[k*(i-m)]);\n    }\n    firinterp_crcf_destroy(interp_seq);\n    float g = 0.0f;\n    for (i=0; i<num_sync_samples; i++)\n        g += crealf( s0[i]*conjf(s0[i]) );\n    firinterp_crcf interp_tx = firinterp_crcf_create_prototype(LIQUID_FIRFILT_RRC,k,m,beta,dt);\n    unsigned int n=0;\n    for (i=0; i<num_delay_symbols; i++) {\n        firinterp_crcf_execute(interp_tx, 0, &x[k*n]);\n        n++;\n    }\n    for (i=0; i<num_sync_symbols; i++) {\n        firinterp_crcf_execute(interp_tx, seq[i], &x[k*n]);\n        n++;\n    }\n    for (i=0; i<2*m; i++) {\n        firinterp_crcf_execute(interp_tx, 0, &x[k*n]);\n        n++;\n    }\n    assert(n==num_symbols);\n    firinterp_crcf_destroy(interp_tx);\n    for (i=0; i<num_samples; i++) {\n        y[i] = x[i]*cexp(_Complex_I*(dphi*i + phi)) + nstd*( randnf() + _Complex_I*randnf() );\n    }\n    float complex z;    \n    for (n=0; n<num_dphi_hat; n++) {\n        float dphi_hat = ((float)n - 0.5*(float)(num_dphi_hat-1)) * dphi_hat_step;\n        printf(""  dphi_hat : %12.8f\\n"", dphi_hat);\n        float complex s1[num_sync_samples];\n        for (i=0; i<num_sync_samples; i++)\n            s1[i] = conjf( s0[num_sync_samples-i-1]*cexpf(_Complex_I*(dphi_hat*i)) );\n        firfilt_cccf fsync = firfilt_cccf_create(s1, num_sync_samples);\n        for (i=0; i<num_samples; i++) {\n            firfilt_cccf_push(fsync, y[i]);\n            firfilt_cccf_execute(fsync, &z);\n            rxy[n][i] = cabsf(z) / g;\n        }\n        firfilt_cccf_destroy(fsync);\n    }\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""k = %u;\\n"", k);\n    fprintf(fid,""m = %u;\\n"", m);\n    fprintf(fid,""beta = %f;\\n"", beta);\n    fprintf(fid,""num_sync_symbols = %u;\\n"", num_sync_symbols);\n    fprintf(fid,""num_sync_samples = k*num_sync_symbols;\\n"");\n    fprintf(fid,""num_symbols = %u;\\n"", num_symbols);\n    fprintf(fid,""num_samples = %u;\\n"", num_samples);\n    fprintf(fid,""num_dphi_hat = %u;\\n"", num_dphi_hat);\n    fprintf(fid,""dphi_hat_step = %f;\\n"", dphi_hat_step);\n    fprintf(fid,""seq = zeros(1,num_sync_symbols);\\n"");\n    for (i=0; i<num_sync_symbols; i++)\n        fprintf(fid,""seq(%4u)   = %12.8f + j*%12.8f;\\n"", i+1, crealf(seq[i]), cimagf(seq[i]));\n    fprintf(fid,""s   = zeros(1,num_sync_samples);\\n"");\n    for (i=0; i<num_sync_samples; i++)\n        fprintf(fid,""s(%4u)     = %12.8f + j*%12.8f;\\n"", i+1, crealf(s0[i]), cimagf(s0[i]));\n    fprintf(fid,""x = zeros(1,num_samples);\\n"");\n    fprintf(fid,""y = zeros(1,num_samples);\\n"");\n    for (i=0; i<num_samples; i++) {\n        fprintf(fid,""x(%6u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(x[i]),   cimagf(x[i]));\n        fprintf(fid,""y(%6u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(y[i]),   cimagf(y[i]));\n    }\n    fprintf(fid,""rxy = zeros(num_dphi_hat,num_samples);\\n"");\n    for (n=0; n<num_dphi_hat; n++) {\n        for (i=0; i<num_samples; i++) {\n            fprintf(fid,""rxy(%6u,%6u) = %12.8f;\\n"", n+1, i+1, rxy[n][i]);\n        }\n    }\n    fprintf(fid,""t=[0:(num_samples-1)]/k;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""plot(1:length(s),real(s), 1:length(s),imag(s));\\n"");\n    fprintf(fid,""dphi_hat = ( [0:(num_dphi_hat-1)] - (num_dphi_hat-1)/2 ) * dphi_hat_step;\\n"");\n    fprintf(fid,""mesh(dphi_hat, t, rxy\');\\n"");\n#if 0\n    fprintf(fid,""z = abs( z );\\n"");\n    fprintf(fid,""[zmax i] = max(z);\\n"");\n    fprintf(fid,""plot(1:length(z),z,\'-x\');\\n"");\n    fprintf(fid,""axis([(i-8*k) (i+8*k) 0 zmax*1.2]);\\n"");\n    fprintf(fid,""grid on\\n"");\n#endif\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
"('Prompt: You are working on testing a software-defined radio (SDR) application that involves generating and detecting OFDM (Orthogonal Frequency Division Multiplexing) frames. You want to test the functionality of generating an OFDM frame with specific parameters such as modulation scheme (QPSK), cyclic prefix length, taper length, and payload length. Can you provide a testbench function that generates an OFDM frame with these parameters and verifies its successful reception?","//...\nvoid testbench_ofdmflexframe(unsigned int      _M,\n                             unsigned int      _cp_len,\n                             unsigned int      _taper_len,\n                             unsigned int      _payload_len,\n                             modulation_scheme _ms)\n{\n    ofdmflexframegenprops_s fgprops;\n    ofdmflexframegenprops_init_default(&fgprops);\n    fgprops.check        = LIQUID_CRC_32;\n    fgprops.fec0         = LIQUID_FEC_NONE;\n    fgprops.fec1         = LIQUID_FEC_NONE;\n    fgprops.mod_scheme   = _ms;\n    ofdmflexframegen  fg = ofdmflexframegen_create( _M, _cp_len, _taper_len, NULL, &fgprops);\n    ofdmflexframesync fs = ofdmflexframesync_create(_M, _cp_len, _taper_len, NULL, NULL, NULL);\n    unsigned char header[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    unsigned char payload[_payload_len];\n    memset(payload, 0x00, _payload_len);\n    ofdmflexframegen_assemble(fg, header, payload, _payload_len);\n    if (liquid_autotest_verbose)\n        ofdmflexframegen_print(fg);\n    unsigned int  buf_len = 1024;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = ofdmflexframegen_write(fg, buf, buf_len);\n        ofdmflexframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        ofdmflexframesync_print(fs);\n    framedatastats_s stats = ofdmflexframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY( stats.num_frames_detected, 1 );\n    CONTEND_EQUALITY( stats.num_headers_valid,   1 );\n    CONTEND_EQUALITY( stats.num_payloads_valid,  1 );\n    CONTEND_EQUALITY( stats.num_bytes_received,  _payload_len );\n    ofdmflexframegen_destroy(fg);\n    ofdmflexframesync_destroy(fs);\n}\nvoid autotest_ofdmflexframe_03() { testbench_ofdmflexframe(1024, 16,  8,  800, LIQUID_MODEM_QPSK); }\n//...')
"
"('In a program that executes benchmark scripts for the liquid-dsp library, you want the user to be able to specify various options via command line arguments. You want to provide a help option that displays the available options and their functionality. You ask for a code snippet that defines the `usage()` function which prints out the usage guide for the program.. . Prompt: ""I want to create a command-line tool for benchmarking liquid-dsp library functions. Please provide me with a code snippet that defines a `usage()` function which displays the available options and their functionality when users run the program.""","//...\n            else if (strcmp(optarg,""fftw"")==0)      fftbench.library = LIB_FFTW;\n        case \'q\':   fftbench.verbose = 0;    break;\n            else if (strcmp(optarg,""single"")==0)    fftbench.mode = RUN_SINGLE;\n\n    for (i=0; i<1e6; i++) {\nvoid usage()\n{\n    printf(""Usage: benchmark [OPTION]\\n"");\n    printf(""Execute benchmark scripts for liquid-dsp library.\\n"");\n    printf(""  -h            display this help and exit\\n"");\n    printf(""  -v/q          verbose/quiet\\n"");\n    printf(""  -t[SECONDS]   set minimum execution time (s)\\n"");\n    printf(""  -o[FILENAME]  export output\\n"");\n    printf(""  -n[NFFT_MIN]  minimum FFT size (benchmark single FFT)\\n"");\n    printf(""  -N[NFFT_MAX]  maximum FFT size\\n"");\n    printf(""  -m[MODE]      mode: all, radix2, composite, prime, fftwbench, single\\n"");\n    printf(""  -l[library]   library: float, fftw\\n"");\n}\n//...')
"
('Prompt: . You are working on testing a function that repacks bytes. The function takes an input array of bytes and repacks them into a new array following certain rules. Your task is to write a test case code snippet to ensure the function works correctly in a scenario where the input array has 3 elements and you expect the output array to have 5 elements. The expected output array values after repacking are specified. You need to test if the function properly repacks the bytes according to the rules.,"//...\nvoid autotest_repack_bytes_02() {\n    unsigned char input[] = {\n        0x01,   \n        0x02,   \n        0x04    \n    };\n    unsigned char output_test[] = {\n        0x00,   \n        0x02,   \n        0x01,   \n        0x00,   \n        0x04    \n    };\n    unsigned char output[5];\n    unsigned int N;\n    liquid_repack_bytes( input, 5, 3, output, 3, 5, &N );\n    CONTEND_EQUALITY( N, 5 );\n    CONTEND_SAME_DATA( output, output_test, 5 );\n}\n//...')
"
"'You need the code for an array of pin configurations for an Atmel SAM microcontroller. Each entry in the array represents a pin configuration with the specified parameters. Additionally, you need to define the size of the array and a specific configuration value for a system input/output settings register.","const Pin atsam_pin_config[] = {\n  {PIO_PA21A_RXD1, PIOA, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT},\n  {PIO_PB4D_TXD1, PIOB, ID_PIOB, PIO_PERIPH_D, PIO_DEFAULT},\n   {0x000000FF, PIOC, ID_PIOC, PIO_PERIPH_A, PIO_DEFAULT},\n   {0x0000003F, PIOE, ID_PIOE, PIO_PERIPH_A, PIO_DEFAULT},\n   {0x00018000, PIOA, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT},\n   {0x3FF00000, PIOC, ID_PIOC, PIO_PERIPH_A, PIO_DEFAULT},\n   {0x00002000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x00020000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x00010000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x00004000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x00800000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x00008000, PIOC, ID_PIOC, PIO_PERIPH_A, PIO_DEFAULT},\n   {0x00040000, PIOC, ID_PIOC, PIO_PERIPH_A, PIO_DEFAULT},\n   {0x00008000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x20000000, PIOD, ID_PIOD, PIO_PERIPH_C, PIO_DEFAULT},\n   {0x00100000, PIOA, ID_PIOA, PIO_PERIPH_C, PIO_DEFAULT}\n};\nconst size_t atsam_pin_config_count = PIO_LISTSIZE(atsam_pin_config);\nconst uint32_t atsam_matrix_ccfg_sysio = 0x20400010;'"
"('Please provide a prompt for a scenario in which you need to test the functionality of an Infinite Impulse Response (IIR) Hilbert transformer and demonstrate its interpolation and decimation capabilities using autotesting.. . The scenario involves testing the interpolation and decimation functions of an IIR Hilbert transformer to ensure their proper functionality. You need to write a code snippet that initializes the necessary parameters for the test, performs interpolation and decimation operations on a signal, and validates the results by comparing the power spectral density (PSD) of the original and processed signals.. . Would you like to see the implementation code for testing the interpolation and decimation functionalities of an IIR Hilbert transformer using autotesting?","void autotest_iirhilbf_interp_decim()\n{\n    float        tol  = 1;  \n    float        bw = 0.4f; \n    float        As = 60.0f;\n    unsigned int p    = 40; \n    unsigned int m    =  5; \n    iirhilbf q = iirhilbf_create_default(m);\n    iirhilbf_print(q);\n    unsigned int h_len       = 2*p+1; \n    unsigned int num_samples = h_len + 2*m + 8;\n    unsigned int i;\n    float complex buf_0[num_samples  ];\n    float         buf_1[num_samples*2];\n    float complex buf_2[num_samples  ];\n    float h[h_len];\n    float w = 0.36f * bw; \n    liquid_firdes_kaiser(h_len,w,80.0f,0.0f,h);\n    for (i=0; i<num_samples; i++)\n        buf_0[i] = i < h_len ? 2*w*h[i] : 0.0f;\n    iirhilbf_interp_execute_block(q, buf_0, num_samples, buf_1);\n    iirhilbf_reset(q);\n    iirhilbf_decim_execute_block(q, buf_1, num_samples, buf_2);\n    autotest_psd_s regions_orig[] = {\n      {.fmin=-0.5,    .fmax=-0.5*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin=-0.3*bw, .fmax=+0.3*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin=+0.5*bw, .fmax=+0.5,    .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signal(buf_0, num_samples, regions_orig, 3,\n        liquid_autotest_verbose ? ""autotest/logs/iirhilbf_orig.m"" : NULL);\n    autotest_psd_s regions_interp[] = {\n      {.fmin=-0.5,          .fmax=-0.25-0.25*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin=-0.25-0.15*bw, .fmax=-0.25+0.15*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin=-0.25+0.25*bw, .fmax=+0.25-0.25*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin= 0.25-0.15*bw, .fmax= 0.25+0.15*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin= 0.25+0.25*bw, .fmax= 0.5,          .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signalf(buf_1, 2*num_samples, regions_interp, 5,\n        liquid_autotest_verbose ? ""autotest/logs/iirhilbf_interp.m"" : NULL);\n    liquid_autotest_validate_psd_signal(buf_2, num_samples, regions_orig, 3,\n        liquid_autotest_verbose ? ""autotest/logs/iirhilbf_decim.m"" : NULL);\n    iirhilbf_destroy(q);\n}\nvoid autotest_iirhilbf_filter()\n{\n    float        tol  = 1;  \n    float        bw = 0.2f; \n    float        f0 = 0.3f; \n    float        ft =-0.3f; \n    float        As = 60.0f;\n    unsigned int p    = 50; \n    unsigned int m    =  7; \n    iirhilbf q = iirhilbf_create_default(m);\n    iirhilbf_print(q);\n    unsigned int h_len       = 2*p+1; \n    unsigned int num_samples = h_len + 2*m + 8;\n    unsigned int i;\n    float complex buf_0[num_samples];\n    float         buf_1[num_samples];\n    float complex buf_2[num_samples];\n    float h[h_len];\n    float w = 0.36f * bw; \n    liquid_firdes_kaiser(h_len,w,80.0f,0.0f,h);\n    for (i=0; i<num_samples; i++)\n        buf_0[i] = i < h_len ? 2*w*h[i]*cexpf(_Complex_I*2*M_PI*f0*i) : 0.0f;\n    for (i=0; i<num_samples; i++)\n        buf_0[i] += i < h_len ? 1e-3f*liquid_kaiser(i,num_samples,10)*cexpf(_Complex_I*2*M_PI*ft*i) : 0.0f;\n    iirhilbf_c2r_execute_block(q, buf_0, num_samples, buf_1);\n    for (i=0; i<num_samples; i++)\n        buf_1[i] *= 2;\n    iirhilbf_reset(q);\n    iirhilbf_r2c_execute_block(q, buf_1, num_samples, buf_2);\n    for (i=0; i<num_samples; i++)\n        buf_2[i] *= 0.5f;\n    autotest_psd_s regions_orig[] = {\n      {.fmin=-0.5,       .fmax= ft-0.03,   .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin= ft-0.01,   .fmax= ft+0.01,   .pmin=-40,.pmax= 0,      .test_lo=1, .test_hi=0},\n      {.fmin= ft+0.03,   .fmax= f0-0.5*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin= f0-0.3*bw, .fmax= f0+0.3*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin=+f0+0.5*bw, .fmax=+0.5,       .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signal(buf_0, num_samples, regions_orig, 5,\n        liquid_autotest_verbose ? ""autotest/logs/iirhilbf_filter_orig.m"" : NULL);\n    autotest_psd_s regions_c2r[] = {\n      {.fmin=-0.5,       .fmax=-f0-0.5*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin=-f0-0.3*bw, .fmax=-f0+0.3*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin=-f0+0.5*bw, .fmax=+f0-0.5*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin= f0-0.3*bw, .fmax= f0+0.3*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin=+f0+0.5*bw, .fmax=+0.5,       .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signalf(buf_1, num_samples, regions_c2r, 5,\n        liquid_autotest_verbose ? ""autotest/logs/iirhilbf_filter_c2r.m"" : NULL);\n    autotest_psd_s regions_r2c[] = {\n      {.fmin=-0.5,       .fmax= f0-0.5*bw, .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n      {.fmin= f0-0.3*bw, .fmax= f0+0.3*bw, .pmin=-1, .pmax=+1,      .test_lo=1, .test_hi=1},\n      {.fmin=+f0+0.5*bw, .fmax=+0.5,       .pmin= 0, .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signal(buf_2, num_samples, regions_r2c, 3,\n        liquid_autotest_verbose ? ""autotest/logs/iirhilbf_filter_r2c.m"" : NULL);\n    iirhilbf_destroy(q);\n}\nvoid autotest_iirhilbf_invalid_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping iirhilbf config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(iirhilbf_create(LIQUID_IIRDES_BUTTER, 0, 0.1f, 60.0f)); \n    CONTEND_ISNULL(iirhilbf_create_default(0)); \n    iirhilbf q = iirhilbf_create(LIQUID_IIRDES_BUTTER,5,0.1f,60.0f);\n    iirhilbf_print(q);\n    iirhilbf_destroy(q);\n}\nvoid autotest_iirhilbf_copy_interp()\n{\n    iirhilbf q0 = iirhilbf_create(LIQUID_IIRDES_ELLIP,7,0.1f,80.0f);\n    unsigned int i;\n    float y0[2], y1[2];\n    for (i=0; i<80; i++) {\n        float complex x = randnf() + _Complex_I*randnf();\n        iirhilbf_interp_execute(q0, x, y0);\n    }\n    iirhilbf q1 = iirhilbf_copy(q0);\n    for (i=0; i<80; i++) {\n        float complex x = randnf() + _Complex_I*randnf();\n        iirhilbf_interp_execute(q0, x, y0);\n        iirhilbf_interp_execute(q1, x, y1);\n        if (liquid_autotest_verbose) {\n            printf(""%3u : %12.8f +j%12.8f > {%12.8f, %12.8f}, {%12.8f, %12.8f}\\n"",\n                    i, crealf(x), cimagf(x), y0[0], y0[1], y1[0], y1[1]);\n        }\n        CONTEND_EQUALITY(y0[0], y1[0]);\n        CONTEND_EQUALITY(y0[1], y1[1]);\n    }\n    iirhilbf_destroy(q0);\n    iirhilbf_destroy(q1);\n}\nvoid autotest_iirhilbf_copy_decim()\n{\n    iirhilbf q0 = iirhilbf_create(LIQUID_IIRDES_ELLIP,7,0.1f,80.0f);\n    unsigned int i;\n    float x[2];\n    float complex y0, y1;\n    for (i=0; i<80; i++) {\n        x[0] = randnf();\n        x[1] = randnf();\n        iirhilbf_decim_execute(q0, x, &y0);\n    }\n    iirhilbf q1 = iirhilbf_copy(q0);\n    for (i=0; i<80; i++) {\n        x[0] = randnf();\n        x[1] = randnf();\n        iirhilbf_decim_execute(q0, x, &y0);\n        iirhilbf_decim_execute(q1, x, &y1);\n        if (liquid_autotest_verbose) {\n            printf(""%3u : {%12.8f %12.8f} > %12.8f +j%12.8f, %12.8f +j%12.8f\\n"",\n                    i, x[0], x[1], crealf(y0), cimagf(y0), crealf(y1), cimagf(y1));\n        }\n        CONTEND_EQUALITY(y0, y1);\n    }\n    iirhilbf_destroy(q0);\n    iirhilbf_destroy(q1);\n}')
"
"('Prompt: You are working on a software application that requires generating random numbers following a gamma distribution. To do this, you need a function to generate a random float number with the gamma distribution specified by the parameters alpha and beta. In addition, you need a function that calculates the cumulative distribution function (CDF) of a given float number x, with alpha and beta parameters. Can you provide code for both these functions, handling error cases where alpha or beta are less than or equal to zero, and ensuring that the random number generation follows the gamma distribution accurately?","//...\nfloat randgammaf(float _alpha,\n                 float _beta)\n{\n    if (_alpha <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randgammaf(), alpha must be greater than zero"");\n        return 0.0f;\n    } else if (_beta <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randgammaf(), beta must be greater than zero"");\n        return 0.0f;\n    }\n    unsigned int n = (unsigned int) floorf(_alpha);\n    float delta = _alpha - (float)n;\n    float x_n = 0.0f;\n    unsigned int i;\n    for (i=0; i<n; i++) {\n        float u = randf();\n        x_n += - logf(u);\n    }\n    float x_delta = randgammaf_delta(delta);\n    return _beta * (x_delta + x_n);\n}\nfloat randgammaf_delta(float _delta)\n{\n    if ( _delta < 0.0f || _delta >= 1.0f ) {\n        liquid_error(LIQUID_EICONFIG,""randgammaf_delta(), delta must be in [0,1)"");\n        return 0.0f;\n    }\n    float delta_inv = 1.0f / _delta;\n    float e = expf(1.0f);\n    float v0 = e / (e + _delta);\n    float V0 = 0.0f;\n    float V1 = 0.0f;\n    float V2 = 0.0f;\n    float xi = 0.0f;\n    float eta = 0.0f;\n    while (1) {\n        V0 = randf();\n        V1 = randf();\n        V2 = randf();\n        if (V2 <= v0) {\n            xi = powf(V1, delta_inv);\n            eta = V0 * powf(xi, _delta - 1.0f);\n        } else {\n            xi = 1.0f - logf(V1);\n            eta = V0 * expf(-xi);\n        }\n        if ( eta > powf(xi,_delta-1.0f)*expf(-xi) ) {\n        } else {\n            break;\n        }\n    }\n    return xi;\n}\nfloat randgammaf_cdf(float _x,\n                     float _alpha,\n                     float _beta)\n{\n    if (_alpha <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randgammaf_cdf(), alpha must be greater than zero"");\n        return 0.0f;\n    } else if (_beta <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randgammaf_cdf(), beta must be greater than zero"");\n        return 0.0f;\n    }\n    if (_x <= 0.0f)\n        return 0.0f;\n    return liquid_lowergammaf(_alpha, _x/_beta) / liquid_gammaf(_alpha);\n}\n//...')
"
"('Prompt: Develop a testbench function for testing noise generation in a spectral periodogram using a specific window type and noise floor level. The function should create a spectral periodogram object and push noise samples into it while checking specific properties and testing against expected results. Additionally, create an autotest function specifically for testing noise generation with a Hamming window, a noise floor of -80.0 dB, and 800 samples for FFT analysis.","//...\nvoid testbench_spgramcf_noise(unsigned int _nfft,\n                              unsigned int _wlen,\n                              unsigned int _delay,\n                              int          _wtype,\n                              float        _noise_floor)\n{\n    unsigned int num_samples = 2000*_nfft;  \n    float        nstd        = powf(10.0f,_noise_floor/20.0f); \n    float        tol         = 0.5f; \n    if (liquid_autotest_verbose) {\n        printf(""  spgramcf test  (noise): nfft=%6u, wtype=%24s, noise floor=%6.1f\\n"",\n                _nfft, liquid_window_str[_wtype][1], _noise_floor);\n    }\n    spgramcf q = NULL;\n    if (_wlen==0 || _delay==0 || _wtype==LIQUID_WINDOW_UNKNOWN)\n        q = spgramcf_create_default(_nfft);\n    else\n        q = spgramcf_create(_nfft, _wtype, _wlen, _delay);\n    unsigned int i;\n    for (i=0; i<num_samples; i++)\n        spgramcf_push(q, nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2);\n    CONTEND_EQUALITY(spgramcf_get_num_samples(q),       num_samples);\n    CONTEND_EQUALITY(spgramcf_get_num_samples_total(q), num_samples);\n    float psd[_nfft];\n    spgramcf_get_psd(q, psd);\n    for (i=0; i<_nfft; i++)\n        CONTEND_DELTA(psd[i], _noise_floor, tol)\n    spgramcf_destroy(q);\n}\nvoid autotest_spgramcf_noise_hamming        () { testbench_spgramcf_noise(800, 0, 0, LIQUID_WINDOW_HAMMING,        -80.0); }\n//...')
"
"('Prompt: ""You need to implement a gradient search algorithm in C that performs line search and calculates the norm of vectors. The algorithm should be able to execute with a specified maximum number of iterations and a target utility value. Can you provide the code for this scenario?""","//...\nstruct gradsearch_s {\n    float * v;                  \n    unsigned int num_parameters;\n    float u;                    \n    float delta;                \n    float alpha;                \n    float * p;                  \n    float pnorm;                \n    utility_function utility;   \n    void * userdata;            \n    int direction;              \n};\nfloat gradsearch_step(gradsearch _q)\n{\n    unsigned int i;\n    unsigned int n=20;\n    for (i=0; i<n; i++) {\n        gradsearch_gradient(_q->utility, _q->userdata, _q->v, _q->num_parameters, _q->delta, _q->p);\n        _q->pnorm = gradsearch_norm(_q->p, _q->num_parameters);\n        if (_q->pnorm > 0.0f) {\n            if (1e-4f*_q->pnorm < _q->delta)\n                _q->delta *= 0.90f;\n            else if ( 1e-5f*_q->pnorm > _q->delta)\n                _q->delta *= 1.10f;\n            break;\n        } else {\n            _q->delta *= 10.0f;\n        }\n    }\n    if (i == n) {\n        liquid_error(LIQUID_ENOCONV,""gradsearch_step(), function ill-conditioned"");\n        return _q->utility(_q->userdata, _q->v, _q->num_parameters);\n    }\n    _q->alpha = gradsearch_linesearch(_q->utility,\n                                      _q->userdata,\n                                      _q->direction,\n                                      _q->num_parameters,\n                                      _q->v,\n                                      _q->p,\n                                      _q->delta);\n    float dir = _q->direction == LIQUID_OPTIM_MINIMIZE ? 1.0f : -1.0f;\n    for (i=0; i<_q->num_parameters; i++)\n        _q->v[i] = _q->v[i] - dir*_q->alpha*_q->p[i];\n    _q->u = _q->utility(_q->userdata, _q->v, _q->num_parameters);\n    return _q->u;\n}\nfloat gradsearch_linesearch(utility_function _utility,\n                            void  *          _userdata,\n                            int              _direction,\n                            unsigned int     _n,\n                            float *          _x,\n                            float *          _p,\n                            float            _alpha)\n{\n#if DEBUG_GRADSEARCH\n    unsigned int i;\n    printf(""  linesearch v: {"");\n    for (i=0; i<_n; i++)\n        printf(""%8.4f"", _x[i]);\n    printf(""}\\n"");\n    printf(""  linesearch g: {"");\n    for (i=0; i<_n; i++)\n        printf(""%8.4f"", _p[i]);\n    printf(""}\\n"");\n#endif\n    float u0 = _utility(_userdata, _x, _n);\n    float alpha = _alpha;\n    float dir = _direction == LIQUID_OPTIM_MINIMIZE ? 1.0f : -1.0f;\n    float x_prime[_n];\n    int continue_running = 1;\n    unsigned int num_iterations = 0;\n    unsigned int max_iterations = 250;\n    float gamma = 2.00;\n    while (continue_running) {\n        num_iterations++;\n        unsigned int i;\n        for (i=0; i<_n; i++)\n            x_prime[i] = _x[i] - dir*alpha*_p[i];\n        float uls = _utility(_userdata, x_prime, _n);\n#if DEBUG_GRADSEARCH\n        printf(""  linesearch %6u : alpha=%12.6f, u0=%12.8f, uls=%12.8f\\n"", num_iterations, alpha, u0, uls);\n#endif\n        if ( (_direction == LIQUID_OPTIM_MINIMIZE && uls > u0) ||\n             (_direction == LIQUID_OPTIM_MAXIMIZE && uls < u0) )\n        {\n            alpha *= 1.0f/gamma;\n            continue_running = 0;\n        } else if ( num_iterations >= max_iterations ) {\n            continue_running = 0;\n        } else {\n            u0 = uls;\n            alpha *= gamma;\n        }\n    }\n    return alpha;\n}\nfloat gradsearch_norm(float *      _v,\n                      unsigned int _n)\n{\n    float vnorm = liquid_vectorf_norm(_v, _n);\n    float scale = vnorm == 0.0f ? 0.0f : 1.0f / vnorm;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        _v[i] *= scale;\n    return vnorm;\n}\nvoid gradsearch_gradient(utility_function _utility,\n                         void  *          _userdata,\n                         float *          _x,\n                         unsigned int     _n,\n                         float            _delta,\n                         float *          _gradient)\n{\n    float x_prime[_n];\n    float u_prime;\n    float u0 = _utility(_userdata, _x, _n);\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        memmove(x_prime, _x, _n*sizeof(float));\n        x_prime[i] += _delta;\n        u_prime = _utility(_userdata, x_prime, _n);\n        _gradient[i] = (u_prime - u0) / _delta;\n    }\n}\nfloat gradsearch_execute(gradsearch   _q,\n                         unsigned int _max_iterations,\n                         float        _target_utility)\n{\n    int continue_running = 1;\n    unsigned int num_iterations = 0;\n    float u = 0.0f;\n    while (continue_running) {\n        num_iterations++;\n        u = gradsearch_step(_q);\n        if ( (num_iterations >= _max_iterations                            ) ||\n             (_q->direction == LIQUID_OPTIM_MINIMIZE && u < _target_utility) ||\n             (_q->direction == LIQUID_OPTIM_MAXIMIZE && u > _target_utility) )\n        {\n            continue_running = 0;\n        }\n    }\n    return u;\n}\n//...')
"
"'Prompt: You are developing a TCP state machine for handling various events in a network application. The application involves both server and client interactions, including connection establishment, data transfer, and connection teardown. Write a function in C that initializes the state machine with the provided TCP event table and sets up an event listener to trigger state transitions based on incoming events. The function should read input from a file descriptor, map the input to an event ID, and pass it to the state machine for processing. The event table and state machine structure are already defined - you just need to implement the initialization function and event handling.","//...\nenum tcp_event {\n    EV_SRV_LISTEN,\n    EV_CLI_SEND_SYN,\n    EV_CLI_RECV_SYN_SEND_SYN_ACK,\n    EV_CLI_RECV_RST,\n    EV_CLI_SEND_FIN,\n    EV_SRV_RECV_SYN_SEND_SYN_ACK,\n    EV_SRV_RECV_ACK,\n    EV_CLI_SEND_FIN_AND_DISCONNECT,\n    EV_CLI_RECV_ACK,\n    EV_CLI_RECV_FIN,\n    EV_CLI_RECV_FIN_SEND_ACK,\n    EV_SRV_RECV_FIN,\n    EV_SRV_RECV_FIN_SEND_ACK,\n    EV_SRV_SEND_FIN,\n    EV_DISCONNECT_TIMEOUT,\n    EV_WAIT_2MSL,\n};\nstatic struct fsm *fsm = NULL;\nstruct gevent_base *evbase = NULL;\nstatic struct fsm *fsm = NULL;\nstatic void ev_in(int fd, void *arg)\n{\n    int event_id;\n    char c[8];\n    struct fsm *fsm = (struct fsm *)arg;\n    read(fd, &c, sizeof(c));\n    event_id = c[0] - \'a\';\n    printf(""event_id=%d\\n"", event_id);\n    fsm_action(fsm, event_id, fsm);\n}\nint init()\n{\n    fsm = fsm_create();\n    fsm->table = tcp_event_tbl;\n    fsm->table_num = sizeof(tcp_event_tbl)/sizeof(struct fsm_event_table);\n    printf(""table_num = %d\\n"", fsm->table_num);\n    fsm_state_init(fsm, TCP_CLOSE);\n    evbase = gevent_base_create();\n    struct gevent *ev = gevent_create(0, ev_in, NULL, NULL, fsm);\n    gevent_add(evbase, &ev);\n    return 0;\n}\n//...'"
"('Prompt: You are testing a function that calculates the dot product of two complex arrays. The function takes in an array of complex numbers and an array of float numbers as input. The function also calculates the dot product for each input and returns the result as a complex number. Write a test function that tests the accuracy of this dot product function using randomly generated input arrays and a predefined test value. The test function should compare the calculated result with the expected result with a certain tolerance level. Additionally, the test function should print the calculated result and the expected result if the test is run in verbose mode.","//...\nvoid autotest_dotprod_crcf_rand02()\n{\n    float h[16] = {\n      4.7622e-01,   7.1453e-01,  -7.1370e-01,  -1.6457e-01, \n     -1.1573e-01,   6.4114e-01,  -1.0688e+00,  -1.6761e+00, \n     -1.0376e+00,  -1.0991e+00,  -2.4161e-01,   4.6065e-01, \n     -1.0403e+00,  -1.1424e-01,  -1.2371e+00,  -7.9723e-01\n    };\n    float complex x[16] = {\n     -8.3558e-01+  3.0504e-01*_Complex_I,  -6.3004e-01+  2.4680e-01*_Complex_I, \n      9.6908e-01+  1.2978e+00*_Complex_I,  -2.0587e+00+  9.5385e-01*_Complex_I, \n      2.5692e-01+ -1.7314e+00*_Complex_I,  -1.2237e+00+ -6.2139e-02*_Complex_I, \n      5.0300e-02+ -9.2092e-01*_Complex_I,  -1.8816e-01+  7.0746e-02*_Complex_I, \n     -2.4177e+00+  8.3177e-01*_Complex_I,   1.6871e-01+ -8.5129e-02*_Complex_I, \n      6.5203e-01+  2.0739e-02*_Complex_I,  -1.2331e-01+ -9.7920e-01*_Complex_I, \n      8.2352e-01+  9.1093e-01*_Complex_I,   1.5161e+00+ -9.1865e-01*_Complex_I, \n     -2.0892e+00+  2.7759e-02*_Complex_I,  -2.5188e-01+  2.5568e-01*_Complex_I\n    };\n    float complex y;\n    float complex test = 2.11053363855085 - 2.04167493441477*_Complex_I;\n    float tol = 1e-3f;\n    dotprod_crcf_run(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_run4(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf q = dotprod_crcf_create(h,16);\n    dotprod_crcf_execute(q,x,&y);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod : %12.8f + j%12.8f (expected: %12.8f + j%12.8f)\\n"",\n                crealf(y), cimagf(y), crealf(test), cimagf(test));\n    }\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_destroy(q);\n}\n//...')
"
"('Please provide me with a prompt to create a Polyphase Filterbank (FIRPFB) object using a Kaiser window for filter design, given the number of filters, filter delay, filter cut-off frequency, and filter excess bandwidth factor.","struct FIRPFB(_s) {\n    unsigned int h_len;         \n    unsigned int h_sub_len;     \n    unsigned int num_filters;   \n    WINDOW() w;                 \n    DOTPROD() * dp;             \n    TC scale;                   \n};\nFIRPFB() FIRPFB(_create)(unsigned int _num_filters,\n                         TC *         _h,\n                         unsigned int _h_len)\n{\n    if (_num_filters == 0)\n        return liquid_error_config(""firpfb_%s_create(), number of filters must be greater than zero"",EXTENSION_FULL);\n    if (_h_len == 0)\n        return liquid_error_config(""firpfb_%s_create(), filter length must be greater than zero"",EXTENSION_FULL);\n    FIRPFB() q = (FIRPFB()) malloc(sizeof(struct FIRPFB(_s)));\n    q->num_filters = _num_filters;\n    q->h_len       = _h_len;\n    q->dp = (DOTPROD()*) malloc((q->num_filters)*sizeof(DOTPROD()));\n    unsigned int h_sub_len = _h_len / q->num_filters;\n    TC h_sub[h_sub_len];\n    unsigned int i, n;\n    for (i=0; i<q->num_filters; i++) {\n        for (n=0; n<h_sub_len; n++) {\n            h_sub[h_sub_len-n-1] = _h[i + n*(q->num_filters)];\n        }\n        q->dp[i] = DOTPROD(_create)(h_sub,h_sub_len);\n    }\n    q->h_sub_len = h_sub_len;\n    q->w = WINDOW(_create)(q->h_sub_len);\n    q->scale = 1;\n    FIRPFB(_reset)(q);\n    return q;\n}\nFIRPFB() FIRPFB(_create_default)(unsigned int _num_filters,\n                                 unsigned int _m)\n{\n    return FIRPFB(_create_kaiser)(_num_filters, _m, 0.5f, 60.0f);\n}\nFIRPFB() FIRPFB(_create_kaiser)(unsigned int _num_filters,\n                                unsigned int _m,\n                                float        _fc,\n                                float        _as)\n{\n    if (_num_filters == 0)\n        return liquid_error_config(""firpfb_%s_create_kaiser(), number of filters must be greater than zero"", EXTENSION_FULL);\n    if (_m == 0)\n        return liquid_error_config(""firpfb_%s_create_kaiser(), filter delay must be greater than 0"", EXTENSION_FULL);\n    if (_fc < 0.0f || _fc > 0.5f)\n        return liquid_error_config(""firpfb_%s_create_kaiser(), filter cut-off frequence must be in (0,0.5)"", EXTENSION_FULL);\n    if (_as < 0.0f)\n        return liquid_error_config(""firpfb_%s_create_kaiser(), filter excess bandwidth factor must be in [0,1]"", EXTENSION_FULL);\n    unsigned int H_len = 2*_num_filters*_m + 1;\n    float Hf[H_len];\n    liquid_firdes_kaiser(H_len, _fc/(float)_num_filters, _as, 0.0f, Hf);\n    unsigned int i;\n    TC Hc[H_len];\n    for (i=0; i<H_len; i++)\n        Hc[i] = Hf[i];\n    return FIRPFB(_create)(_num_filters, Hc, H_len);\n}\nFIRPFB() FIRPFB(_create_rnyquist)(int          _type,\n                                  unsigned int _num_filters,\n                                  unsigned int _k,\n                                  unsigned int _m,\n                                  float        _beta)\n{\n    if (_num_filters == 0)\n        return liquid_error_config(""firpfb_%s_create_rnyquist(), number of filters must be greater than zero"", EXTENSION_FULL);\n    if (_k < 2)\n        return liquid_error_config(""firpfb_%s_create_rnyquist(), filter samples/symbol must be greater than 1"", EXTENSION_FULL);\n    if (_m == 0)\n        return liquid_error_config(""firpfb_%s_create_rnyquist(), filter delay must be greater than 0"", EXTENSION_FULL);\n    if (_beta < 0.0f || _beta > 1.0f)\n        return liquid_error_config(""firpfb_%s_create_rnyquist(), filter excess bandwidth factor must be in [0,1]"", EXTENSION_FULL);\n    unsigned int H_len = 2*_num_filters*_k*_m + 1;\n    float Hf[H_len];\n    liquid_firdes_prototype(_type,_num_filters*_k,_m,_beta,0,Hf);\n    unsigned int i;\n    TC Hc[H_len];\n    for (i=0; i<H_len; i++)\n        Hc[i] = Hf[i];\n    return FIRPFB(_create)(_num_filters, Hc, H_len);\n}\nFIRPFB() FIRPFB(_create_drnyquist)(int          _type,\n                                   unsigned int _num_filters,\n                                   unsigned int _k,\n                                   unsigned int _m,\n                                   float        _beta)\n{\n    if (_num_filters == 0)\n        return liquid_error_config(""firpfb_%s_create_drnyquist(), number of filters must be greater than zero"", EXTENSION_FULL);\n    if (_k < 2)\n        return liquid_error_config(""firpfb_%s_create_drnyquist(), filter samples/symbol must be greater than 1"", EXTENSION_FULL);\n    if (_m == 0)\n        return liquid_error_config(""firpfb_%s_create_drnyquist(), filter delay must be greater than 0"", EXTENSION_FULL);\n    if (_beta < 0.0f || _beta > 1.0f)\n        return liquid_error_config(""firpfb_%s_create_drnyquist(), filter excess bandwidth factor must be in [0,1]"", EXTENSION_FULL);\n    unsigned int H_len = 2*_num_filters*_k*_m + 1;\n    float Hf[H_len];\n    liquid_firdes_prototype(_type,_num_filters*_k,_m,_beta,0,Hf);\n    float dHf[H_len];\n    float HdH_max = 0.0f;\n    unsigned int i;\n    for (i=0; i<H_len; i++) {\n        if (i==0) {\n            dHf[i] = Hf[i+1] - Hf[H_len-1];\n        } else if (i==H_len-1) {\n            dHf[i] = Hf[0]   - Hf[i-1];\n        } else {\n            dHf[i] = Hf[i+1] - Hf[i-1];\n        }\n        if ( fabsf(Hf[i]*dHf[i]) > HdH_max )\n            HdH_max = fabsf(Hf[i]*dHf[i]);\n    }\n    TC Hc[H_len];\n    for (i=0; i<H_len; i++)\n        Hc[i] = dHf[i] * 0.06f / HdH_max;\n    return FIRPFB(_create)(_num_filters, Hc, H_len);\n}\nFIRPFB() FIRPFB(_recreate)(FIRPFB()     _q,\n                           unsigned int _num_filters,\n                           TC *         _h,\n                           unsigned int _h_len)\n{\n    if (_h_len != _q->h_len || _num_filters != _q->num_filters) {\n        FIRPFB(_destroy)(_q);\n        _q = FIRPFB(_create)(_num_filters,_h,_h_len);\n        return _q;\n    }\n    TC h_sub[_q->h_sub_len];\n    unsigned int i, n;\n    for (i=0; i<_q->num_filters; i++) {\n        for (n=0; n<_q->h_sub_len; n++) {\n            h_sub[_q->h_sub_len-n-1] = _h[i + n*(_q->num_filters)];\n        }\n        _q->dp[i] = DOTPROD(_recreate)(_q->dp[i],h_sub,_q->h_sub_len);\n    }\n    return _q;\n}\nFIRPFB() FIRPFB(_copy)(FIRPFB() q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""firpfb_%s_create(), object cannot be NULL"", EXTENSION_FULL);\n    FIRPFB() q_copy     = (FIRPFB()) malloc(sizeof(struct FIRPFB(_s)));\n    q_copy->h_len       = q_orig->h_len;\n    q_copy->h_sub_len   = q_orig->h_sub_len;\n    q_copy->num_filters = q_orig->num_filters;\n    q_copy->w           = WINDOW(_copy)(q_orig->w);\n    q_copy->dp = (DOTPROD()*) malloc((q_copy->num_filters)*sizeof(DOTPROD()));\n    unsigned int i;\n    for (i=0; i<q_copy->num_filters; i++)\n        q_copy->dp[i] = DOTPROD(_copy)(q_orig->dp[i]);\n    q_copy->scale = q_orig->scale;\n    return q_copy;\n}\nint FIRPFB(_destroy)(FIRPFB() _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->num_filters; i++)\n        DOTPROD(_destroy)(_q->dp[i]);\n    free(_q->dp);\n    WINDOW(_destroy)(_q->w);\n    free(_q);\n    return LIQUID_OK;\n}\nint FIRPFB(_print)(FIRPFB() _q)\n{\n    printf(""fir polyphase filterbank [%u] :\\n"", _q->num_filters);\n    unsigned int i;\n    for (i=0; i<_q->num_filters; i++) {\n        printf(""  bank %3u: "",i);\n        DOTPROD(_print)(_q->dp[i]);\n    }\n    return LIQUID_OK;\n}\nint FIRPFB(_reset)(FIRPFB() _q)\n{\n    return WINDOW(_reset)(_q->w);\n}\nint FIRPFB(_set_scale)(FIRPFB() _q,\n                         TC      _scale)\n{\n    _q->scale = _scale;\n    return LIQUID_OK;\n}\nint FIRPFB(_get_scale)(FIRPFB() _q,\n                         TC *    _scale)\n{\n    *_scale = _q->scale;\n    return LIQUID_OK;\n}\nint FIRPFB(_push)(FIRPFB() _q, TI _x)\n{\n    return WINDOW(_push)(_q->w, _x);\n}\nint FIRPFB(_write)(FIRPFB()     _q,\n                    TI *         _x,\n                    unsigned int _n)\n{\n    return WINDOW(_write)(_q->w, _x, _n);\n}\nint FIRPFB(_execute)(FIRPFB()     _q,\n                     unsigned int _i,\n                     TO *         _y)\n{\n    if (_i >= _q->num_filters) {\n        return liquid_error(LIQUID_EICONFIG,""firpfb_execute(), filterbank index (%u) exceeds maximum (%u)"",_i,_q->num_filters);\n    }\n    TI *r;\n    WINDOW(_read)(_q->w, &r);\n    DOTPROD(_execute)(_q->dp[_i], r, _y);\n    *_y *= _q->scale;\n    return LIQUID_OK;\n}\nint FIRPFB(_execute_block)(FIRPFB()     _q,\n                           unsigned int _i,\n                           TI *         _x,\n                           unsigned int _n,\n                           TO *         _y)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        FIRPFB(_push)(_q, _x[i]);\n        FIRPFB(_execute)(_q, _i, &_y[i]);\n    }\n    return LIQUID_OK;\n}')
"
"('Prompt: ""I need to test three different FIR decimator implementations in C, one for real floating-point data, one for complex floating-point data, and one for complex complex data. Can you provide me with test functions for each implementation that take in the decimation factor, filter taps, input data, and expected output data, and check if the output matches the expected values within a tolerance of 0.001?"". . Response: Here are three test functions for FIR decimator implementations in C, one for real floating-point data, one for complex floating-point data, and one for complex complex data. Each function takes in the decimation factor, filter taps, input data, output data, and performs the decimation operation while checking if the output matches the expected values within a tolerance of 0.001.","void firdecim_rrrf_test(unsigned int    _M,\n                        float *         _h,\n                        unsigned int    _h_len,\n                        float *         _x,\n                        unsigned int    _x_len,\n                        float *         _y,\n                        unsigned int    _y_len)\n{\n    float tol = 0.001f;\n    firdecim_rrrf q = firdecim_rrrf_create(_M, _h, _h_len);\n    float y_test[_y_len];\n    unsigned int i;\n    for (i=0; i<_y_len; i++) {\n        firdecim_rrrf_execute(q, &_x[_M*i], &y_test[i]);\n        CONTEND_DELTA( y_test[i], _y[i], tol );\n    }\n    firdecim_rrrf_destroy(q);\n}\nvoid firdecim_crcf_test(unsigned int    _M,\n                        float *         _h,\n                        unsigned int    _h_len,\n                        float complex * _x,\n                        unsigned int    _x_len,\n                        float complex * _y,\n                        unsigned int    _y_len)\n{\n    float tol = 0.001f;\n    firdecim_crcf q = firdecim_crcf_create(_M, _h, _h_len);\n    float complex y_test[_y_len];\n    unsigned int i;\n    for (i=0; i<_y_len; i++) {\n        firdecim_crcf_execute(q, &_x[_M*i], &y_test[i]);\n        CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );\n        CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );\n    }\n    firdecim_crcf_destroy(q);\n}\nvoid firdecim_cccf_test(unsigned int    _M,\n                        float complex * _h,\n                        unsigned int    _h_len,\n                        float complex * _x,\n                        unsigned int    _x_len,\n                        float complex * _y,\n                        unsigned int    _y_len)\n{\n    float tol = 0.001f;\n    firdecim_cccf q = firdecim_cccf_create(_M, _h, _h_len);\n    float complex y_test[_y_len];\n    unsigned int i;\n    for (i=0; i<_y_len; i++) {\n        firdecim_cccf_execute(q, &_x[_M*i], &y_test[i]);\n        CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );\n        CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );\n    }\n    firdecim_cccf_destroy(q);\n}')
"
"'Prompt: Design a program that captures real-time video using XCB backend and processes each frame by calculating the luma value and writing the frame data to a file. The program should print information about each video frame including frame ID, size, timestamp in milliseconds, and the time gap between frames. Use the avcap library for video capture and implement a callback function `on_video` that processes each video frame as described. Make sure to initialize the configuration struct with type AVCAP_TYPE_VIDEO and backend AVCAP_BACKEND_XCB before starting the video capture.","//...\nstruct avcap_config conf = {\n            .type = AVCAP_TYPE_VIDEO,\n            .backend = AVCAP_BACKEND_XCB,\n    };\nstatic struct file *fp;\nstatic int on_video(struct avcap_ctx *c, struct video_frame *video)\n{\n    static uint64_t last_ms = 0;\n    static int luma = 0;\n    static int i = 0;\n    printf(""video_frame[%"" PRIu64 ""] size=%"" PRIu64 "", ts=%"" PRIu64 "" ms, gap=%"" PRIu64 "" ms\\n"",\n          video->frame_id, video->total_size, video->timestamp/1000000, video->timestamp/1000000 - last_ms);\n    last_ms = video->timestamp/1000000;\n    luma = 2 * i++;\n    luma *= i%2 ? 1: -1;\n    avcap_ioctl(c, VIDCAP_SET_LUMA, luma);\n    file_write(fp, video->data[0], video->total_size);\n    return 0;\n}\n//...'"
"'Please provide the shell prompt in which you would like to execute the following code: . . In a software testing scenario, a developer is tasked with testing a configuration management library that supports reading and writing configuration data in various formats such as INI, JSON, and Lua. The developer needs to run a series of tests to verify the functionality of loading, setting, getting, and saving configuration data for each format. They have provided three test functions: `ini_test`, `json_test`, and `lua_test`. . . The prompt should include the setup for testing the library functions in the specified order: `ini_test()`, `json_test()`, and `lua_test()`. The developer needs to ensure that the configuration data manipulation functions work correctly for each format before proceeding to the next test.","static int ini_test(void)\n{\n    struct config *conf = conf_load(""ini/example.ini"");\n    if (!conf) {\n        printf(""conf_load failed!\\n"");\n        return -1;\n    }\n    conf_set_string(conf, ""wine:year"", ""1122"");\n    conf_set_string(conf, ""wine:aaaa"", ""ddd"");\n    conf_set_string(conf, ""wine:eeee"", ""1.234"");\n    conf_dump(conf);\n    conf_del(conf, ""wine:aaaa"");\n    printf(""year = %d\\n"", conf_get_int(conf, ""wine:year""));\n    printf(""grape = %s\\n"", conf_get_string(conf, ""wine:grape""));\n    printf(""alcohol = %f\\n"", conf_get_double(conf, ""wine:alcohol""));\n    conf_save(conf);\n    conf_unload(conf);\n    return 0;\n}\nstatic int json_test(void)\n{\n    struct config *conf = conf_load(""json/all.json"");\n    if (!conf) {\n        printf(""conf_load failed!\\n"");\n        return -1;\n    }\n    printf(""json_test\\n"");\n    printf(""id = %s\\n"", conf_get_string(conf, ""test"", ""rgn"", 1, ""id""));\n    printf(""port= %d\\n"", conf_get_int(conf, ""test"", ""rgn"", 1, ""port""));\n    conf_set_int(conf, ""test"", ""rgn"", 1, ""port"", 12345);\n    printf(""port= %d\\n"", conf_get_int(conf, ""test"", ""rgn"", 1, ""port""));\n    conf_set_string(conf, ""test"", ""rgn"", 1, ""id"", ""mymy"");\n    printf(""id= %s\\n"", conf_get_string(conf, ""test"", ""rgn"", 1, ""id""));\n    conf_save(conf);\n    conf_unload(conf);\n    return 0;\n}\nstatic int lua_test(void)\n{\n#ifdef ENABLE_LUA\n    struct config *conf = conf_load(""lua/config.lua"");\n    if (!conf) {\n        printf(""conf_load failed!\\n"");\n        return -1;\n    }\n    printf(""lua_test\\n"");\n    printf(""[type_3][sub_type_1][my]= %s\\n"", conf_get_string(conf, ""type_3"", ""sub_type_1"", ""my""));\n    printf(""[type_2][sub_type_1][my]= %s\\n"", conf_get_string(conf, ""type_2"", ""sub_type_1"", ""my""));\n    printf(""[type_1][type] = %s\\n"", conf_get_string(conf, ""type_1"", ""type""));\n    printf(""[type_1][index] = %d\\n"", conf_get_int(conf, ""type_1"", ""index""));\n    printf(""[type_2][type] = %s\\n"", conf_get_string(conf, ""type_2"", ""type""));\n    printf(""[type_2][index] = %d\\n"", conf_get_int(conf, ""type_2"", ""index""));\n    printf(""[type_2][my] = %s\\n"", conf_get_string(conf, ""type_2"", ""my""));\n    printf(""yuv_path= %s\\n"", conf_get_string(conf, ""yuv_path""));\n    conf_set_string(conf, ""yuv_path"", ""mymy"");\n    printf(""yuv_path= %s\\n"", conf_get_string(conf, ""yuv_path""));\n    printf(""md_source_type= %s\\n"", conf_get_string(conf, ""md_source_type""));\n    printf(""md_enable = %d\\n"", conf_get_boolean(conf, ""md_enable""));\n    printf(""fps= %f\\n"", conf_get_double(conf, ""fps""));\n    conf_save(conf);\n    conf_unload(conf);\n#endif\n    return 0;\n}\nint main(int argc, char **argv)\n{\n    ini_test();\n    json_test();\n    lua_test();\n    return 0;\n}'"
"('Prompt:. ""I am working on a software-defined radio application and I need assistance with calculating the total number of samples in a GMSK frame. Can you provide me with a function that calculates the frame length based on certain physical and framing properties? Additionally, I would also like a function to print out the properties of a GMSK frame including its physical properties, framing properties, and packet properties. Could you help me with this?""","//...\n    unsigned int k;             \n    unsigned int m;             \n    float BT;                   \n    unsigned int preamble_len;  \n    unsigned int header_len;    \n    unsigned int payload_len;   \n    unsigned int tail_len;      \n    crc_scheme check;           \n    fec_scheme fec0;            \n    fec_scheme fec1;            \nunsigned int gmskframegen_getframelen(gmskframegen _q)\n{\n    if (!_q->frame_assembled) {\n        liquid_error(LIQUID_EICONFIG,""gmskframegen_getframelen(), frame not assembled"");\n        return 0;\n    }\n    unsigned int num_frame_symbols =\n            _q->preamble_len +      \n            _q->header_len +        \n            _q->payload_len +       \n            2*_q->m;                \n    return num_frame_symbols*_q->k; \n}\nint gmskframegen_print(gmskframegen _q)\n{\n    printf(""gmskframegen:\\n"");\n    printf(""  physical properties\\n"");\n    printf(""    samples/symbol  :   %u\\n"", _q->k);\n    printf(""    filter delay    :   %u symbols\\n"", _q->m);\n    printf(""    bandwidth-time  :   %-8.3f\\n"", _q->BT);\n    printf(""  framing properties\\n"");\n    printf(""    preamble        :   %-4u symbols\\n"", _q->preamble_len);\n    printf(""    header          :   %-4u symbols\\n"", _q->header_len);\n    printf(""    payload         :   %-4u symbols\\n"", _q->payload_len);\n    printf(""    tail            :   %-4u symbols\\n"", _q->tail_len);\n    printf(""  packet properties\\n"");\n    printf(""    crc             :   %s\\n"", crc_scheme_str[_q->check][1]);\n    printf(""    fec (inner)     :   %s\\n"", fec_scheme_str[_q->fec0][1]);\n    printf(""    fec (outer)     :   %s\\n"", fec_scheme_str[_q->fec1][1]);\n    printf(""  total samples     :   %-4u samples\\n"", gmskframegen_getframelen(_q));\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: ""I need a function that benchmarks the performance of fitting a polynomial of degree 3 using the least squares method with 8 data points. Can you provide me with a code snippet for this scenario?""","//...\nvoid benchmark_polyf_fit_q3_n8      P\n//...')
"
"('Prompt: You are working on a project that involves optimizing a utility function using the BFGS algorithm. Could you provide a code snippet that includes the main function, utility function, and related helper functions for estimating gradients and updating matrices, and checking Wolfe conditions during optimization? The scenario involves using the BFGS algorithm to iteratively optimize the utility function over a specified number of iterations.","#define DEBUG_BFGS 0\ntypedef float (*utility)(float * _x, unsigned int _n);\nfloat myutility(float * _x, unsigned int _n);\nvoid print_vector(const char * _str, float * _v, unsigned int _n);\nvoid estimate_gradient(float * _x,\n                       unsigned int _n,\n                       utility _u,\n                       float * _gradient);\nvoid bfgs_update(unsigned int _n,\n                 float * _dx,\n                 float * _y,\n                 float * _H0,\n                 float * _H1);\nint check_wolfe_conditions(float _alpha,\n                           float _u0,\n                           float _u1,\n                           float _gamma0,\n                           float _gamma1);\nint check_wolfe_conditions2(float * _x,\n                            float * _p,\n                            unsigned int _n,\n                            float _alpha,\n                            utility _u);\nint main() {\n    unsigned int n = 4;                 \n    unsigned int num_iterations = 10;   \n    float x[n];     \n    float p[n];     \n    float dx[n];    \n    float gradient0[n];\n    float gradient1[n];\n    float y[n];\n    float H0[n*n];\n    float H1[n*n];\n    float alpha = 0.2f;\n    unsigned int i;\n    for (i=0; i<n; i++) x[i] = 0.5f;\n    for (i=0; i<n; i++) gradient1[i] = 0.0f;\n    matrixf_eye(H0, n);\n    matrixf_eye(H1, n);\n    estimate_gradient(x, n, myutility, gradient1);\n    printf(""\\n"");\n    float u = myutility(x, n);\n    printf("" -   : x =       {"");\n    for (i=0; i<n; i++) printf(""%8.4f "", x[i]);\n    printf(""} : %12.8f\\n"", u);\n    unsigned int t;\n    for (t=0; t<num_iterations; t++) {\n        memmove(gradient0, gradient1, n*sizeof(float));\n        memmove(H0, H1, n*n*sizeof(float));\n        matrixf_mul(H0,        n, n,\n                    gradient0, n, 1,\n                    p,         n, 1);\n        for (i=0; i<n; i++) p[i] = -p[i];\n        float alpha_min = 0.0f;\n        float du_min = 0.0f;\n        float u0 = myutility(x, n);\n        for (i=0; i<100; i++) {\n            alpha = 0.001f + 0.01f*i;\n            float x_prime[n];\n            unsigned int j;\n            for (j=0; j<n; j++)\n                x_prime[j] = x[j] + alpha*p[j];\n            float u1 = myutility(x_prime, n);\n            float du = u1 - u0;\n            if (i==0 || du < du_min) {\n                alpha_min = alpha;\n                du_min = du;\n            }\n        }\n        alpha = alpha_min;\n        if (check_wolfe_conditions2(x,p,n,alpha,myutility)==0)\n            printf(""warning: Wolfe conditions failed\\n"");\n        for (i=0; i<n; i++) dx[i] = alpha*p[i];\n        for (i=0; i<n; i++) x[i] += dx[i];\n        estimate_gradient(x, n, myutility, gradient1);\n        for (i=0; i<n; i++) y[i] = gradient1[i] - gradient0[i];\n        bfgs_update(n, dx, y, H0, H1);\n        u = myutility(x, n);\n        printf("" %-3u : x =       {"", t);\n        for (i=0; i<n; i++) printf(""%8.4f "", x[i]);\n        printf(""} : %12.8f\\n"", u);\n#if 0\n        print_vector(""       gradient0"", gradient0, n);\n        print_vector(""       gradient1"", gradient1, n);\n        print_vector(""       p        "", p, n);\n        print_vector(""       dx       "", dx, n);\n        print_vector(""       y        "", y, n);\n        printf(""H0 =\\n""); matrixf_print(H0, n, n);\n        printf(""H1 =\\n""); matrixf_print(H1, n, n);\n#endif\n    }\n    printf(""done.\\n"");\n    return 0;\n}\nfloat myutility(float * _x, unsigned int _n)\n{\n#if 0\n    float u = 1.0f;\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        float di = _x[i] - 1.0f;\n        float ui = expf(-di*di);\n        u *= ui;\n    }\n    return 1.0f - u;\n#else\n    return liquid_rosenbrock(NULL, _x, _n);\n#endif\n}\nvoid print_vector(const char * _str, float * _v, unsigned int _n)\n{\n    printf(""%s {"", _str);\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        printf(""%8.4f "", _v[i]);\n    printf(""}\\n"");\n}\nvoid estimate_gradient(float * _x,\n                       unsigned int _n,\n                       utility _u,\n                       float * _gradient)\n{\n    float x_prime[_n];\n    float dx = 1e-6f;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        x_prime[i] = _x[i];\n    float f0 = _u(x_prime, _n);\n    float f1 = 0.0f;\n    for (i=0; i<_n; i++) {\n        x_prime[i] = _x[i] + dx;\n        f1 = _u(x_prime, _n);\n        x_prime[i] = _x[i];\n        _gradient[i] = (f1 - f0) / dx;\n    }\n}\nvoid bfgs_update(unsigned int _n,\n                 float * _dx,\n                 float * _y,\n                 float * _H0,\n                 float * _H1)\n{\n#if DEBUG_BFGS\n    printf(""********************\\n"");\n    print_vector(""  dx      "", _dx, _n);\n    print_vector(""  y       "", _y, _n);\n    printf(""H0 = \\n"");\n    matrixf_print(_H0,_n,_n);\n#endif\n    float ydxT[_n*_n];      \n    float yTdx;             \n    float q[_n*_n];         \n    float dxdxT[_n*_n];     \n    float tmp[_n*_n];       \n    matrixf_mul(_y,     _n,     1,\n                _dx,    1,      _n,\n                ydxT,   _n,     _n);\n#if DEBUG_BFGS\n    printf(""y*dx\' = \\n"");\n    matrixf_print(ydxT,_n,_n);\n#endif\n    matrixf_mul(_y,     1,      _n,\n                _dx,    _n,     1,\n                &yTdx,  1,      1);\n    unsigned int i;\n    unsigned int j;\n    for (i=0; i<_n; i++) {\n        for (j=0; j<_n; j++) {\n            matrix_access(q,_n,_n,i,j) = (i==j ? 1.0f : 0.0f) -\n                                         matrix_access(ydxT,_n,_n,i,j)/yTdx;\n        }\n    }\n#if DEBUG_BFGS\n    printf(""q = \\n"");\n    matrixf_print(q,_n,_n);\n#endif\n    matrixf_mul(_dx,   _n,  1,\n                _dx,   1,  _n,\n                dxdxT, _n, _n);\n#if DEBUG_BFGS\n    printf(""dx*dx\' = \\n"");\n    matrixf_print(dxdxT,_n,_n);\n#endif\n    matrixf_mul(_H0, _n, _n,\n                q,   _n, _n,\n                tmp, _n, _n);\n    matrixf_trans(q, _n, _n);\n    matrixf_mul(q,   _n, _n,\n                tmp, _n, _n,\n                _H1, _n, _n);\n    for (i=0; i<_n; i++) {\n        for (j=0; j<_n; j++) {\n            matrix_access(_H1,_n,_n,i,j) += matrix_access(dxdxT,_n,_n,i,j) / yTdx;\n        }\n    }\n#if DEBUG_BFGS\n    printf(""H1 = \\n"");\n    matrixf_print(_H1,_n,_n);\n#endif\n}\nint check_wolfe_conditions(float _alpha,\n                           float _u0,\n                           float _u1,\n                           float _gamma0,\n                           float _gamma1)\n{\n    float c1 = 1e-4f;\n    float c2 = 0.9f;\n    int cond1 = (_u1 <= _u0 + c1*_alpha*_gamma0) ? 1 : 0;\n    int cond2 = ( fabsf(_gamma1) <= c2*fabsf(_gamma0) ) ? 1 : 0;\n#if 0\n    printf(""(g0: %12.8f g1: %12.8f) [%c %c]"",\n            _gamma0,\n            _gamma1,\n            cond1 ? \'1\' : \'0\',\n            cond2 ? \'1\' : \'0\');\n#endif\n    return cond1 && cond2;\n}\nint check_wolfe_conditions2(float * _x,\n                            float * _p,\n                            unsigned int _n,\n                            float _alpha,\n                            utility _u)\n{\n    float grad0[_n];\n    float grad1[_n];\n    float x_prime[_n];\n    float u0 = _u(_x,_n);\n    estimate_gradient(_x,_n,_u,grad0);\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        x_prime[i] = _x[i] + _alpha*_p[i];\n    float u1 = _u(x_prime, _n);\n    estimate_gradient(x_prime, _n, _u, grad1);\n    float gamma0 = 0.0f;\n    for (i=0; i<_n; i++)\n        gamma0 += _p[i] * grad0[i];\n    float gamma1 = 0.0f;\n    for (i=0; i<_n; i++)\n        gamma1 += _p[i] * grad1[i];\n    return check_wolfe_conditions(_alpha, u0, u1, gamma0, gamma1);\n}')
"
"('Please provide a prompt that describes a scenario where you are developing a software module for testing a synchronization algorithm in an OFDM system. The module includes a callback function that is invoked during the test, a function to perform the actual test with different OFDM frame configurations, and several additional functions for testing the common configurations, frame generation, and frame synchronization. You are asked to provide a specific code snippet that implements the callback function and the test function for acquiring OFDM frames with different numbers of subcarriers, cyclic prefix lengths, and taper lengths. Additionally, you are asked to include tests for the common configurations, frame generation, and frame synchronization scenarios in the code snippet.","int ofdmframesync_autotest_callback(float complex * _X,\n                                    unsigned char * _p,\n                                    unsigned int    _M,\n                                    void * _userdata)\n{\n    if (liquid_autotest_verbose)\n        printf(""******** callback invoked!\\n"");\n    float complex * X = (float complex *)_userdata;\n    memmove(X, _X, _M*sizeof(float complex));\n    return 0;\n}\nvoid ofdmframesync_acquire_test(unsigned int _num_subcarriers,\n                                unsigned int _cp_len,\n                                unsigned int _taper_len)\n{\n    unsigned int M         = _num_subcarriers;  \n    unsigned int cp_len    = _cp_len;           \n    unsigned int taper_len = _taper_len;        \n    float tol              = 1e-2f;             \n    float dphi = 1.0f / (float)M;       \n    unsigned char p[M];\n    ofdmframe_init_default_sctype(M, p);\n    unsigned int num_samples = (3 + 1)*(M + cp_len);\n    ofdmframegen fg = ofdmframegen_create(M, cp_len, taper_len, p);\n    float complex X[M];         \n    float complex X_test[M];    \n    ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,p,ofdmframesync_autotest_callback,(void*)X_test);\n    unsigned int i;\n    float complex y[num_samples];   \n    unsigned int n=0;\n    ofdmframegen_write_S0a(fg, &y[n]);\n    n += M + cp_len;\n    ofdmframegen_write_S0b(fg, &y[n]);\n    n += M + cp_len;\n    ofdmframegen_write_S1( fg, &y[n]);\n    n += M + cp_len;\n    for (i=0; i<M; i++) {\n        X[i]      = cexpf(_Complex_I*2*M_PI*randf());\n        X_test[i] = 0.0f;\n    }\n    ofdmframegen_writesymbol(fg, X, &y[n]);\n    n += M + cp_len;\n    assert(n == num_samples);\n    for (i=0; i<num_samples; i++)\n        y[i] *= cexpf(_Complex_I*dphi*i);\n    ofdmframesync_execute(fs,y,num_samples);\n    for (i=0; i<M; i++) {\n        if (p[i] == OFDMFRAME_SCTYPE_DATA) {\n            float e = crealf( (X[i] - X_test[i])*conjf(X[i] - X_test[i]) );\n            CONTEND_DELTA( fabsf(e), 0.0f, tol );\n        }\n    }\n    ofdmframegen_destroy(fg);\n    ofdmframesync_destroy(fs);\n}\nvoid autotest_ofdmframesync_acquire_n64()   { ofdmframesync_acquire_test(64,  8,  0); }\nvoid autotest_ofdmframesync_acquire_n128()  { ofdmframesync_acquire_test(128, 16, 0); }\nvoid autotest_ofdmframesync_acquire_n256()  { ofdmframesync_acquire_test(256, 32, 0); }\nvoid autotest_ofdmframesync_acquire_n512()  { ofdmframesync_acquire_test(512, 64, 0); }\nvoid autotest_ofdmframe_common_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping ofdmframe common config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_default_sctype(0, NULL)) \n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_sctype_range( 0, -0.4f, +0.4f, NULL)) \n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_sctype_range(64, -0.7f, +0.4f, NULL)) \n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_sctype_range(64, -0.4f, +0.7f, NULL)) \n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_sctype_range(64, -0.2f, -0.3f, NULL)) \n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_sctype_range(64,  0.3f,  0.2f, NULL)) \n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_init_sctype_range(64, -0.02f,+0.02f,NULL)) \n    unsigned int M = 120;\n    unsigned char p[M];\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframe_init_default_sctype(M, p))\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframe_validate_sctype(p, M, NULL, NULL, NULL))\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframe_init_sctype_range(M, -0.4f,+0.4f,p))\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframe_validate_sctype(p, M, NULL, NULL, NULL))\n    unsigned int i;\n    for (i=0; i<M; i++)\n        p[i] = OFDMFRAME_SCTYPE_NULL;\n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_validate_sctype(p, M, NULL, NULL, NULL))\n    p[0] = OFDMFRAME_SCTYPE_PILOT;\n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_validate_sctype(p, M, NULL, NULL, NULL))\n    p[1] = OFDMFRAME_SCTYPE_DATA;\n    CONTEND_INEQUALITY(LIQUID_OK, ofdmframe_validate_sctype(p, M, NULL, NULL, NULL))\n}\nvoid autotest_ofdmframegen_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping ofdmframegen config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(ofdmframegen_create( 0, 16, 4, NULL)) \n    CONTEND_ISNULL(ofdmframegen_create( 7, 16, 4, NULL)) \n    CONTEND_ISNULL(ofdmframegen_create(65, 16, 4, NULL)) \n    CONTEND_ISNULL(ofdmframegen_create(64, 66, 4, NULL)) \n    CONTEND_ISNULL(ofdmframegen_create(64, 16,24, NULL)) \n    ofdmframegen q = ofdmframegen_create(64, 16, 4, NULL);\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframegen_print(q))\n    ofdmframegen_destroy(q);\n}\nvoid autotest_ofdmframesync_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping ofdmframesync config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(ofdmframesync_create( 0, 16, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmframesync_create( 7, 16, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmframesync_create(65, 16, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmframesync_create(64, 66, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmframesync_create(64, 16,24, NULL, NULL, NULL)) \n    ofdmframesync q = ofdmframesync_create(64, 16, 4, NULL, NULL, NULL);\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframesync_print(q))\n    CONTEND_EQUALITY(        0, ofdmframesync_is_frame_open(q))\n    CONTEND_EQUALITY(LIQUID_OK, ofdmframesync_set_cfo(q,0.0f))\n    ofdmframesync_destroy(q);\n}')
"
"('Prompt: Design a test scenario for an automatic test function for a Numerically Controlled Oscillator (NCO) mixing operation. The function should set the frequency and phase of the NCO, perform the mixing down operation on a complex input signal, and verify that the output matches a cosine signal with a tolerance level. The test should be run for 64 iterations with a small frequency and phase difference.","//...\nvoid autotest_nco_mixing() {\n    float f = 0.1f;\n    float phi = M_PI;\n    float tol = 0.05f;\n    nco_crcf p = nco_crcf_create(LIQUID_NCO);\n    nco_crcf_set_frequency(p, f);\n    nco_crcf_set_phase(p, phi);\n    unsigned int i;\n    float nco_i, nco_q;\n    for (i=0; i<64; i++) {\n        nco_crcf_sincos(p, &nco_q, &nco_i);\n        complex float nco_cplx_in = nco_i + _Complex_I*nco_q;\n        complex float nco_cplx_out;\n        nco_crcf_mix_down(p, nco_cplx_in, &nco_cplx_out);\n        CONTEND_DELTA(crealf(nco_cplx_out), 1.0f, tol);\n        CONTEND_DELTA(cimagf(nco_cplx_out), 0.0f, tol);\n        nco_crcf_step(p);\n    }\n    nco_crcf_destroy(p);\n}\n//...')
"
"('Prompt: You are working on testing a modem implementation that includes modulation and demodulation functions. The code you need to write should test the demodulator phase error for a specific modulation scheme. Your task is to create a function that verifies if the demodulation process is working correctly by comparing the output symbol with the input symbol and checking the demodulator phase error. The function should loop through all possible input symbols, modulate them using the modulator, demodulate them using the demodulator, and then compare the results. If the output symbol does not match the input symbol, it should output a warning. Additionally, you need to check if the demodulator phase error is within certain bounds after demodulation. The function should be able to handle different modulation schemes.","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\n//...')
"
"('Prompt: You are working on a numerical library that includes a function for performing LU decomposition using the Crout method on a complex matrix. Implement an automated test function called `autotest_matrixcf_ludecomp_crout()` to verify the correctness of the LU decomposition. The function should involve initializing complex matrices A, L, U, and P of size 8x8, calling the `matrixcf_ludecomp_crout()` function, performing matrix multiplication of L and U into `LU_test`, and conducting various tests using CONTEND_DELTA macro to compare the decomposed matrices with the original matrix. Additionally, the function should print the matrices if `liquid_autotest_verbose` is enabled. The tolerance for floating-point comparisons should be set to 1e-5f.","//...\nvoid autotest_matrixcf_ludecomp_crout()\n{\n    float tol = 1e-5f;  \n    float complex L[64];\n    float complex U[64];\n    float complex P[64];\n    float complex LU_test[64];\n    matrixcf_ludecomp_crout(matrixcf_data_ludecomp_A, 8, 8, L, U, P);\n    matrixcf_mul(L,       8, 8,\n                 U,       8, 8,\n                 LU_test, 8, 8);\n    if (liquid_autotest_verbose) {\n        printf(""ludecomp_crout:\\n"");\n        printf(""  A: "");  matrixcf_print(matrixcf_data_ludecomp_A, 8, 8);\n        printf(""  L: "");  matrixcf_print(L,                        8, 8);\n        printf(""  U: "");  matrixcf_print(U,                        8, 8);\n        printf(""  LU: ""); matrixcf_print(LU_test,                  8, 8);\n    }\n    unsigned int r,c;\n    for (r=0; r<8; r++) {\n        for (c=0; c<8; c++) {\n            if (r < c) {\n                CONTEND_DELTA( crealf(matrix_access(L,8,8,r,c)), 0.0f, tol );\n                CONTEND_DELTA( cimagf(matrix_access(L,8,8,r,c)), 0.0f, tol );\n            } else if (r==c) {\n                CONTEND_DELTA( crealf(matrix_access(U,8,8,r,c)), 1.0f, tol );\n                CONTEND_DELTA( cimagf(matrix_access(U,8,8,r,c)), 0.0f, tol );\n            } else {\n                CONTEND_DELTA( crealf(matrix_access(U,8,8,r,c)), 0.0f, tol );\n                CONTEND_DELTA( cimagf(matrix_access(U,8,8,r,c)), 0.0f, tol );\n            }\n        }\n    }\n    unsigned int i;\n    for (i=0; i<64; i++) {\n        CONTEND_DELTA( crealf(matrixcf_data_ludecomp_A[i]), crealf(LU_test[i]), tol );\n        CONTEND_DELTA( cimagf(matrixcf_data_ludecomp_A[i]), cimagf(LU_test[i]), tol );\n    }\n}\n//...')
"
"'Prompt: You are working on a microcontroller project where you need to implement functions for enabling, disabling, restarting, and getting the status and period of a Watchdog Timer (WDT). Can you provide me with C code for these functions using a struct pointer to the WDT and appropriate bitwise operations?","extern void WDT_Enable(Wdt *pWDT, uint32_t dwMode)\n{\n\tpWDT->WDT_MR = dwMode;\n}\nextern void WDT_Disable(Wdt *pWDT)\n{\n\tpWDT->WDT_MR = WDT_MR_WDDIS;\n}\nextern void WDT_Restart(Wdt *pWDT)\n{\n\tpWDT->WDT_CR = 0xA5000001;\n}\nextern uint32_t WDT_GetStatus(Wdt *pWDT)\n{\n\treturn (pWDT->WDT_SR & 0x3);\n}\nextern uint32_t WDT_GetPeriod(uint32_t dwMs)\n{\n\tif ((dwMs < 4) || (dwMs > 16000))\n\t\treturn 0;\n\treturn ((dwMs << 8) / 1000);\n}'"
"('Prompt: You are tasked with writing a C function that performs vector multiplication with a sparse matrix. The function should take in a sparse matrix `smatrixf`, a vector `x`, and an output vector `y`. The sparse matrix is represented by a 2D array with non-zero elements indicated by their row and column indices, as well as their corresponding values. You need to implement the function `smatrixf_vmul` that performs the multiplication between the sparse matrix A and the vector x, storing the result in vector y. Additionally, you need to write unit tests for this function using the `CONTEND_DELTA` macro to compare the output vector y with a predetermined test vector y_test given a tolerance of 1e-6f.. . Code Response:. ```c. void autotest_smatrixf_vmul(). {.     float tol = 1e-6f;.     // Create a 4x5 sparse matrix A.     smatrixf A = smatrixf","//...\nvoid autotest_smatrixf_vmul()\n{\n    float tol = 1e-6f;\n    smatrixf A = smatrixf_create(4, 5);\n    smatrixf_set(A, 0,4, 4);\n    smatrixf_set(A, 2,3, 3);\n    smatrixf_set(A, 3,0, 2);\n    smatrixf_set(A, 3,4, 0);\n    smatrixf_set(A, 3,4, 1);\n    float x[5] = {7, 1, 5, 2, 2};\n    float y_test[4] = {8, 0, 6, 16};\n    float y[4];\n    smatrixf_vmul(A,x,y);\n    CONTEND_DELTA( y[0], y_test[0], tol );\n    CONTEND_DELTA( y[1], y_test[1], tol );\n    CONTEND_DELTA( y[2], y_test[2], tol );\n    CONTEND_DELTA( y[3], y_test[3], tol );\n    smatrixf_destroy(A);\n}\n//...')
"
"'Please provide a code snippet that defines and initializes functions to control the XBARA (Crossbar Switch A) module on a microcontroller platform. The functions should include initializing and deinitializing the XBARA module, setting signal connections, getting status flags, clearing status flags, and configuring output signal settings.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.xbara""\n#endif\n#define XBARA_CTRLx(base, index) (((volatile uint16_t *)(&((base)->CTRL0)))[(index)])\ntypedef union\n{\n    uint8_t _u8[2];\n    uint16_t _u16;\n} xbara_u8_u16_t;\nstatic uint32_t XBARA_GetInstance(XBARA_Type *base);\nstatic XBARA_Type *const s_xbaraBases[] = XBARA_BASE_PTRS;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_xbaraClock[] = XBARA_CLOCKS;\n#endif \nstatic uint32_t XBARA_GetInstance(XBARA_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_xbaraBases); instance++)\n    {\n        if (s_xbaraBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_xbaraBases));\n    return instance;\n}\nvoid XBARA_Init(XBARA_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(s_xbaraClock[XBARA_GetInstance(base)]);\n#endif \n}\nvoid XBARA_Deinit(XBARA_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_DisableClock(s_xbaraClock[XBARA_GetInstance(base)]);\n#endif \n}\nvoid XBARA_SetSignalsConnection(XBARA_Type *base, xbar_input_signal_t input, xbar_output_signal_t output)\n{\n    xbara_u8_u16_t regVal;\n    uint8_t byteInReg;\n    uint8_t outputIndex = (uint8_t)output;\n    byteInReg = outputIndex % 2U;\n    regVal._u16 = XBARA_SELx(base, outputIndex);\n    regVal._u8[byteInReg] = (uint8_t)input;\n    XBARA_SELx(base, outputIndex) = regVal._u16;\n}\nuint32_t XBARA_GetStatusFlags(XBARA_Type *base)\n{\n    uint32_t status_flag;\n    status_flag = ((uint32_t)base->CTRL0 & (XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK));\n    status_flag |= (((uint32_t)base->CTRL1 & (XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK)) << 16U);\n    return status_flag;\n}\nvoid XBARA_ClearStatusFlags(XBARA_Type *base, uint32_t mask)\n{\n    uint16_t regVal;\n    regVal = (base->CTRL0);\n    regVal &= (uint16_t)(~(XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK));\n    regVal |= (uint16_t)(mask & (XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK));\n    base->CTRL0 = regVal;\n    regVal = (base->CTRL1);\n    regVal &= (uint16_t)(~(XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK));\n    regVal |= (uint16_t)((mask >> 16U) & (XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK));\n    base->CTRL1 = regVal;\n}\nvoid XBARA_SetOutputSignalConfig(XBARA_Type *base,\n                                 xbar_output_signal_t output,\n                                 const xbara_control_config_t *controlConfig)\n{\n    uint8_t outputIndex = (uint8_t)output;\n    uint8_t regIndex;\n    uint8_t byteInReg;\n    xbara_u8_u16_t regVal;\n    assert(outputIndex < (uint32_t)FSL_FEATURE_XBARA_INTERRUPT_COUNT);\n    regIndex  = outputIndex / 2U;\n    byteInReg = outputIndex % 2U;\n    regVal._u16 = XBARA_CTRLx(base, regIndex);\n    regVal._u16 &= (uint16_t)(~(XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK));\n    regVal._u8[byteInReg] = (uint8_t)(XBARA_CTRL0_EDGE0(controlConfig->activeEdge) |\n                                      (uint16_t)(((uint32_t)controlConfig->requestType) << XBARA_CTRL0_DEN0_SHIFT));\n    XBARA_CTRLx(base, regIndex) = regVal._u16;\n}'"
"('Prompt: You are working on a library that deals with numerical algorithms for polynomial operations in C. You need to create a function that finds the roots of a polynomial with coefficients of type float. To achieve this, you can use the provided macros and definitions in the code snippet. Write a function `polyf_findroots` that takes the coefficients of the polynomial `_p`, the number of coefficients `_k`, and an array `_roots` to store the complex roots of the polynomial. Make sure to handle the conversion of types from `float` to `double` and from `double complex` to `float complex`. Remember to free the allocated memory before returning the result code.","#define MATRIX(name)    LIQUID_CONCAT(matrixf, name)\n#define POLY(name)      LIQUID_CONCAT(polyf,   name)\n#define POLY_NAME       ""polyf""\n#define EXTENSION       ""f""\n#define T               float\n#define TC              float complex\n#define T_COMPLEX       0\n#define TI_COMPLEX      1\n#define T_ABS(X)        fabsf(X)\n#define TC_ABS(X)       cabsf(X)\nint polyf_findroots(float *         _p,\n                    unsigned int    _k,\n                    float complex * _roots)\n{\n    unsigned int i;\n    double * p = (double*) malloc(_k * sizeof(double));\n    for (i=0; i<_k; i++)\n        p[i] = (double)_p[i];\n    double complex * roots = (double complex*)malloc((_k-1)*sizeof(double complex));\n    int rc = liquid_poly_findroots_bairstow(p,_k,roots);\n    qsort(roots, _k-1, sizeof(double complex), &liquid_poly_sort_roots_compare);\n    for (i=0; i<_k-1; i++)\n        _roots[i] = (float complex)roots[i];\n    free(p);\n    free(roots);\n    return rc;\n}')
"
"'Prompt: You are tasked with writing a function in C for a multi-threaded application that checks if two pthread_t variables are equal. The pthread_t data structure contains two members, p and x, which represent the thread ID. The function should return 1 if the thread IDs of both pthread_t variables are the same, and 0 otherwise. The function should have the following signature: int pthread_equal(pthread_t t1, pthread_t t2). Can you provide the code for this function?","//...\nint\npthread_equal (pthread_t t1, pthread_t t2)\n{\n  int result;\n  result = ( t1.p == t2.p && t1.x == t2.x );\n  return (result);\n}\n//...'"
"('Provide a prompt where you need a code snippet written in C for a testbench that simulates a finite impulse response (FIR) filter for a Nyquist pulse shaping filter. The prompt should detail the requirements of the testbench, specifying parameters such as filter type, coefficients, length, beta value, and time step. The code should calculate key metrics like cross-correlation, root mean square of intersymbol interference (ISI), and energy of the filter response, and ensure they meet certain criteria before printing the results for analysis.","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\n//...')
"
"'Prompt: You are working on a project that involves SPI communication and you need to create functions to flush the receive FIFO, enable lock configuration, and configure underrun behavior. Can you provide me with the code for these functions using the HAL_SPI module?","#ifdef HAL_SPI_MODULE_ENABLED\nHAL_StatusTypeDef HAL_SPIEx_FlushRxFifo(const SPI_HandleTypeDef *hspi)\n{\n  uint8_t  count  = 0;\n  uint32_t itflag = hspi->Instance->SR;\n  __IO uint32_t tmpreg;\n  while (((hspi->Instance->SR & SPI_FLAG_FRLVL) !=  SPI_RX_FIFO_0PACKET) || ((itflag & SPI_FLAG_RXWNE) !=  0UL))\n  {\n    count += (uint8_t)4UL;\n    tmpreg = hspi->Instance->RXDR;\n    UNUSED(tmpreg); \n    if (IS_SPI_HIGHEND_INSTANCE(hspi->Instance))\n    {\n      if (count > SPI_HIGHEND_FIFO_SIZE)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    else\n    {\n      if (count > SPI_LOWEND_FIFO_SIZE)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SPIEx_EnableLockConfiguration(SPI_HandleTypeDef *hspi)\n{\n  HAL_StatusTypeDef errorcode = HAL_OK;\n  __HAL_LOCK(hspi);\n  if (hspi->State != HAL_SPI_STATE_READY)\n  {\n    errorcode = HAL_BUSY;\n    hspi->State = HAL_SPI_STATE_READY;\n    __HAL_UNLOCK(hspi);\n    return errorcode;\n  }\n  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)\n  {\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_IOLOCK);\n  }\n  else\n  {\n    __HAL_SPI_DISABLE(hspi);\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_IOLOCK);\n    __HAL_SPI_ENABLE(hspi);\n  }\n  hspi->State = HAL_SPI_STATE_READY;\n  __HAL_UNLOCK(hspi);\n  return errorcode;\n}\nHAL_StatusTypeDef HAL_SPIEx_ConfigureUnderrun(SPI_HandleTypeDef *hspi, uint32_t UnderrunDetection,\n                                              uint32_t UnderrunBehaviour)\n{\n  HAL_StatusTypeDef errorcode = HAL_OK;\n  __HAL_LOCK(hspi);\n  if ((hspi->State != HAL_SPI_STATE_READY) || (hspi->Init.Mode != SPI_MODE_SLAVE))\n  {\n    errorcode = HAL_BUSY;\n    hspi->State = HAL_SPI_STATE_READY;\n    __HAL_UNLOCK(hspi);\n    return errorcode;\n  }\n  assert_param(IS_SPI_UNDERRUN_DETECTION(UnderrunDetection));\n  assert_param(IS_SPI_UNDERRUN_BEHAVIOUR(UnderrunBehaviour));\n  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)\n  {\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, UnderrunDetection);\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, UnderrunBehaviour);\n  }\n  else\n  {\n    __HAL_SPI_DISABLE(hspi);\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, UnderrunDetection);\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, UnderrunBehaviour);\n    __HAL_SPI_ENABLE(hspi);\n  }\n  hspi->State = HAL_SPI_STATE_READY;\n  __HAL_UNLOCK(hspi);\n  return errorcode;\n}\n#endif '"
('Prompt: Can you provide a function definition for retrieving the data transfer rate in bits per second (bps) from a modem object in a C program? Consider using a separate configuration function to retrieve this information within the modem object.,"//...\nunsigned int modem_get_bps(modem _q)\n    { return modemcf_get_bps(_q); }\n//...')
"
"('""Please provide a code snippet that generates a signal using a raised cosine filter with a given bandwidth, modulation order, and roll-off factor. The signal is sampled and its power spectral density is calculated using a periodogram. The signal\'s spectrum is then compared against pre-defined regions for validation. The code should output the result to an autotest log file.""","//...\nvoid testbench_symstreamrcf_psd(float        _bw,\n                                unsigned int _m,\n                                float        _beta)\n{\n    int ftype = LIQUID_FIRFILT_ARKAISER;\n    int ms    = LIQUID_MODEM_QPSK;\n    symstreamrcf gen = symstreamrcf_create_linear(ftype,_bw,_m,_beta,ms);\n    symstreamrcf_set_gain(gen, sqrtf(_bw));\n    unsigned int nfft        =   2400;      \n    unsigned int num_samples = 192000/_bw;  \n    spgramcf periodogram = spgramcf_create_default(nfft);\n    unsigned int buf_len = 1337;\n    float complex buf[buf_len];\n    unsigned int n = 0;\n    while (n < num_samples) {\n        symstreamrcf_write_samples(gen, buf, buf_len);\n        n += buf_len;\n        spgramcf_write(periodogram, buf, buf_len);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(periodogram, psd);\n    symstreamrcf_destroy(gen);\n    spgramcf_destroy(periodogram);\n    float f0 = 0.5 * (1.0f - _beta) * _bw;\n    float f1 = 0.5 * (1.0f + _beta) * _bw;\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5, .fmax=-f1,  .pmin=  0-0, .pmax=-55.0, .test_lo=0, .test_hi=1},\n      {.fmin=-f0,  .fmax= f0,  .pmin= -2.0, .pmax=  2.0, .test_lo=1, .test_hi=1},\n      {.fmin= f1,  .fmax= 0.5, .pmin=  0.0, .pmax=-55.0, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/symstreamrcf_psd_bw%u_m%u_b%.3u_autotest.m"",\n            (int)(_bw*1000), _m, (int)(_beta*100));\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\n//...')
"
"'Please provide a code snippet for implementing the destruction of a pthread read-write lock in a multithreaded environment. The code should handle cases where the lock is in use and properly release all resources associated with the lock, including mutexes and condition variables. The code should also ensure that the destruction operation is thread-safe and handles initialization edge cases.","#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_rwlock_destroy (pthread_rwlock_t * rwlock)\n{\n  pthread_rwlock_t rwl;\n  int result = 0, result1 = 0, result2 = 0;\n  if (rwlock == NULL || *rwlock == NULL)\n    {\n      return EINVAL;\n    }\n  if (*rwlock != PTHREAD_RWLOCK_INITIALIZER)\n    {\n      rwl = *rwlock;\n      if (rwl->nMagic !=  __PTW32_RWLOCK_MAGIC)\n\t{\n\t  return EINVAL;\n\t}\n      if ((result = pthread_mutex_lock (&(rwl->mtxExclusiveAccess))) != 0)\n\t{\n\t  return result;\n\t}\n      if ((result =\n\t   pthread_mutex_lock (&(rwl->mtxSharedAccessCompleted))) != 0)\n\t{\n\t  (void) pthread_mutex_unlock (&(rwl->mtxExclusiveAccess));\n\t  return result;\n\t}\n      if (rwl->nExclusiveAccessCount > 0\n\t  || rwl->nSharedAccessCount > rwl->nCompletedSharedAccessCount)\n\t{\n\t  result = pthread_mutex_unlock (&(rwl->mtxSharedAccessCompleted));\n\t  result1 = pthread_mutex_unlock (&(rwl->mtxExclusiveAccess));\n\t  result2 = EBUSY;\n\t}\n      else\n\t{\n\t  rwl->nMagic = 0;\n\t  if ((result =\n\t       pthread_mutex_unlock (&(rwl->mtxSharedAccessCompleted))) != 0)\n\t    {\n\t      pthread_mutex_unlock (&rwl->mtxExclusiveAccess);\n\t      return result;\n\t    }\n\t  if ((result =\n\t       pthread_mutex_unlock (&(rwl->mtxExclusiveAccess))) != 0)\n\t    {\n\t      return result;\n\t    }\n\t  *rwlock = NULL;\t\n\t  result = pthread_cond_destroy (&(rwl->cndSharedAccessCompleted));\n\t  result1 = pthread_mutex_destroy (&(rwl->mtxSharedAccessCompleted));\n\t  result2 = pthread_mutex_destroy (&(rwl->mtxExclusiveAccess));\n\t  (void) free (rwl);\n\t}\n    }\n  else\n    {\n      __ptw32_mcs_local_node_t node;\n      __ptw32_mcs_lock_acquire(&__ptw32_rwlock_test_init_lock, &node);\n      if (*rwlock == PTHREAD_RWLOCK_INITIALIZER)\n\t{\n\t  *rwlock = NULL;\n\t}\n      else\n\t{\n\t  result = EBUSY;\n\t}\n      __ptw32_mcs_lock_release(&node);\n    }\n  return ((result != 0) ? result : ((result1 != 0) ? result1 : result2));\n}'"
"'Prompt: ""I need a function that retrieves the process-shared attribute of a given pthread read-write lock attributes object. The function should check if the input attributes object and the output variable pointers are not NULL before retrieving the value. If successful, the function should return 0, otherwise return EINVAL. Can you provide me with the code for this scenario?""","//...\nint\npthread_rwlockattr_getpshared (const pthread_rwlockattr_t * attr,\n\t\t\t       int *pshared)\n{\n  int result;\n  if ((attr != NULL && *attr != NULL) && (pshared != NULL))\n    {\n      *pshared = (*attr)->pshared;\n      result = 0;\n    }\n  else\n    {\n      result = EINVAL;\n    }\n  return (result);\n}\n//...'"
"('Please provide a prompt in which you are requesting code for testing a FIR filter design implementation for a specific filter type and parameters. The code should calculate various metrics such as ISI (rms), As, and verify certain conditions. . . In response to this prompt, you will receive the code for a testbench function `testbench_firfilt_rnyquist` which performs the specified calculations and verification for the given FIR filter type and parameters. Additionally, an autotest function `autotest_firfilt_rnyquist_5` is provided for testing the FIR filter with specific parameters (LIQUID_FIRFILT_ARKAISER, 5, 12, 0.20, 0.0).","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\nvoid autotest_firfilt_rnyquist_5(){ testbench_firfilt_rnyquist(LIQUID_FIRFILT_ARKAISER, 5,12,0.20f,0.0f); }\n//...')
"
"('Prompt: Please write a function that tests demodulation with soft bits for QPSK modulation scheme. Ensure that the function creates a QPSK modem object, modulates and demodulates a symbol, and checks if the demodulated symbol matches the original symbol. Use liquid_pack_soft_bits() for encoding soft bits and ensure proper destruction of modem objects.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_qpsk()      { modemcf_test_demodsoft(LIQUID_MODEM_QPSK);      }\n//...')
"
"('Prompt: You are working on a digital signal processing project and need to implement a function that calculates the frequency response of a given signal. The function should take in an array of complex numbers representing the signal (_h), the length of the array (_h_len), the center frequency (_fc), and a pointer to store the resulting frequency response (_H). Write a function in C that performs this calculation and returns LIQUID_OK upon successful completion.","//...\nint liquid_freqrespcf(float complex * _h,\n                      unsigned int    _h_len,\n                      float           _fc,\n                      float complex * _H)\n{\n    float complex H = 0.0f;\n    unsigned int i;\n    for (i=0; i<_h_len; i++)\n        H += _h[i] * cexpf(-_Complex_I*2*M_PI*_fc*i);\n    *_H = H;\n    return LIQUID_OK;\n}\n//...')
"
"('Sure! The prompt scenario would be: . . ""You are working on implementing a communication system that requires encoding and interleaving data. Design a set of functions to perform interleaving on the data, based on a given interleaver structure. This should include different methods for interleaving, applying masks, and permutation. Please provide a code snippet that showcases these functionalities in C programming language.""","//...\nint interleaver_permute_mask_soft(unsigned char * _x,\n                                  unsigned int    _n,\n                                  unsigned int    _M,\n                                  unsigned int    _N,\n                                  unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int k;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        for (k=0; k<8; k++) {\n            if ( (_mask >> (8-k-1)) & 0x01 ) {\n                tmp = _x[8*(2*j+1)+k];\n                _x[8*(2*j+1)+k] = _x[8*(2*i+0)+k];\n                _x[8*(2*i+0)+k] = tmp;\n            }\n        }\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute_mask(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N,\n                             unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp0;\n    unsigned char tmp1;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp0 = (_x[2*i+0] & (~_mask)) | (_x[2*j+1] & ( _mask));\n        tmp1 = (_x[2*i+0] & ( _mask)) | (_x[2*j+1] & (~_mask));\n        _x[2*i+0] = tmp0;\n        _x[2*j+1] = tmp1;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute(unsigned char * _x,\n                        unsigned int    _n,\n                        unsigned int    _M,\n                        unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp = _x[2*j+1];\n        _x[2*j+1] = _x[2*i+0];\n        _x[2*i+0] = tmp;\n    }\n    return LIQUID_OK;\n}\nint interleaver_encode(interleaver     _q,\n                       unsigned char * _msg_dec,\n                       unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, _q->n);\n    if (_q->depth > 0) interleaver_permute(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\nint interleaver_permute_soft(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp[8];\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        memmove( tmp,            &_x[8*(2*j+1)], 8);\n        memmove( &_x[8*(2*j+1)], &_x[8*(2*i+0)], 8);\n        memmove( &_x[8*(2*i+0)], tmp,            8);\n    }\n    return LIQUID_OK;\n}\nint interleaver_encode_soft(interleaver     _q,\n                            unsigned char * _msg_dec,\n                            unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, 8*_q->n);\n    if (_q->depth > 0) interleaver_permute_soft(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: Please provide a code snippet for an automatic test function that configures a finite impulse response polyphase filterbank channelizer with strict exit enabled, while also checking for potential errors in the configuration.. . Technical Scenario: In this scenario, you need to write an automatic test function that configures a finite impulse response polyphase filterbank channelizer with strict exit enabled. The function needs to include checks for potential errors in the configuration, such as invalid parameters or configurations. The code should also handle warnings and messages related to the potential errors in case they occur during the configuration process.","//...\nvoid autotest_firpfbch_crcf_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping firpfbch_crcf config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(firpfbch_crcf_create(             77, 76, 12, NULL)) \n    CONTEND_ISNULL(firpfbch_crcf_create(LIQUID_ANALYZER,  0, 12, NULL)) \n    CONTEND_ISNULL(firpfbch_crcf_create(LIQUID_ANALYZER, 76,  0, NULL)) \n    CONTEND_ISNULL(firpfbch_crcf_create_kaiser(             77, 76, 12, 60.0f)) \n    CONTEND_ISNULL(firpfbch_crcf_create_kaiser(LIQUID_ANALYZER,  0, 12, 60.0f)) \n    CONTEND_ISNULL(firpfbch_crcf_create_kaiser(LIQUID_ANALYZER, 76,  0, 60.0f)) \n    CONTEND_ISNULL(firpfbch_crcf_create_rnyquist(             77, 76, 12, 0.2f, LIQUID_FIRFILT_ARKAISER)) \n    CONTEND_ISNULL(firpfbch_crcf_create_rnyquist(LIQUID_ANALYZER,  0, 12, 0.2f, LIQUID_FIRFILT_ARKAISER)) \n    CONTEND_ISNULL(firpfbch_crcf_create_rnyquist(LIQUID_ANALYZER, 76,  0, 0.2f, LIQUID_FIRFILT_ARKAISER)) \n    CONTEND_ISNULL(firpfbch_crcf_create_rnyquist(LIQUID_ANALYZER, 76, 12, 77.f, LIQUID_FIRFILT_ARKAISER)) \n    CONTEND_ISNULL(firpfbch_crcf_create_rnyquist(LIQUID_ANALYZER, 76, 12, 0.2f, LIQUID_FIRFILT_UNKNOWN )) \n    firpfbch_crcf q = firpfbch_crcf_create_kaiser(LIQUID_ANALYZER, 76, 12, 60.0f);\n    CONTEND_EQUALITY(LIQUID_OK, firpfbch_crcf_print(q))\n    firpfbch_crcf_destroy(q);\n}\n//...')
"
"'Prompt: ""In a project using the STM32 Low Layer (LL) drivers and the Real-Time Executive for Multiprocessor Systems (RTEMS) operating system, there is a need to properly deinitialize the Clock Recovery System (CRS). Please provide the code snippet for a function that can handle this deinitialization process, ensuring that the CRS is reset and released correctly within this context.""",#if defined(USE_FULL_LL_DRIVER) || defined(__rtems__)\n#if defined(CRS)\nErrorStatus LL_CRS_DeInit(void)\n{\n  LL_APB1_GRP2_ForceReset(LL_APB1_GRP2_PERIPH_CRS);\n  LL_APB1_GRP2_ReleaseReset(LL_APB1_GRP2_PERIPH_CRS);\n  return  SUCCESS;\n}\n#endif \n#endif '
"'Prompt: . Imagine you are working on a function that detects a specific pattern in a sequence of unsigned characters. The function should return true if the pattern is found and false otherwise. The pattern is defined as follows: the second element in the sequence should be greater than zero, the third, fifth, and sixth elements should be equal to the second element, the fourth element should be three times the second element, and either the first or last element should be greater than or equal to four times the second element. Keeping this scenario in mind, could you write a C++ function that takes in an array of 7 unsigned characters and returns true if the pattern is detected?",//...\nstatic bool hasFinderLikePattern(const unsigned char runHistory[7])\n{\n    unsigned char n = runHistory[1];\n    return n > 0 && runHistory[2] == n && runHistory[4] == n && runHistory[5] == n\n           && runHistory[3] == n * 3 && (runHistory[0] >= n * 4 || runHistory[6] >= n * 4);\n}\n//...'
"('You need a function that can perform a search for neighboring points in a complex plane based on a given reference point. The input parameters to this function should be an array of complex numbers representing all points in the plane, the size of the array, a single reference complex number, an array to store the indexes of selected neighboring points, the number of neighbors to find, and possibly a debug flag.. . Given this scenario, I would require the prompt requesting a function that searches for neighboring points in a complex plane based on a reference point, along with the necessary input parameters specified above.","//...\nvoid modemcf_arbref_search(float complex * _c,\n                         unsigned int _M,\n                         float complex * _cref,\n                         unsigned int _p,\n                         unsigned char * _index,\n                         unsigned int _s)\n{\n    if (_M < 2) {\n        fprintf(stderr,""error: modemcf_arbref_search(), input constellation size too small\\n"");\n        exit(1);\n    } else if (_s > _M) {\n        fprintf(stderr,""error: modemcf_arbref_search(), index size exceeds constellation size\\n"");\n        exit(1);\n    }\n    unsigned int i;\n    for (i=0; i<_p; i++)\n        modemcf_arbref_search_point(_c, _M, _cref[i], &_index[_s*i], _s);\n}\nvoid modemcf_arbref_search_point(float complex * _c,\n                               unsigned int _M,\n                               float complex _cref,\n                               unsigned char * _index,\n                               unsigned int _s)\n{\n#if DEBUG\n    printf(""searching neighbors to (%8.3f,%8.3f)\\n"", crealf(_cref), cimagf(_cref));\n#endif\n    unsigned char selected[_M];\n    memset(selected, 0x00, _M);\n    unsigned int i;\n    unsigned int n;\n    for (n=0; n<_s; n++) {\n        int min_found = 0;\n        float d;\n        float dmin = 0.0f;\n        unsigned int index_min = 0;\n        for (i=0; i<_M; i++) {\n            if (selected[i]==1)\n                continue;\n            d = crealf( (_c[i]-_cref)*conjf(_c[i]-_cref) );\n            if ( d < dmin || !min_found ) {\n                dmin = d;\n                index_min = i;\n                min_found = 1;\n            }\n        }\n        _index[n] = index_min;\n        selected[index_min] = 1;\n#if DEBUG\n        printf(""%6u (%8.3f,%8.3f)\\n"", index_min, crealf(_c[index_min]), cimagf(_c[index_min]));\n#endif\n    }\n}\nvoid modemcf_arbref_search_point(float complex * _c,\n                               unsigned int _M,\n                               float complex _cref,\n                               unsigned char * _index,\n                               unsigned int _s)\n{\n#if DEBUG\n    printf(""searching neighbors to (%8.3f,%8.3f)\\n"", crealf(_cref), cimagf(_cref));\n#endif\n    unsigned char selected[_M];\n    memset(selected, 0x00, _M);\n    unsigned int i;\n    unsigned int n;\n    for (n=0; n<_s; n++) {\n        int min_found = 0;\n        float d;\n        float dmin = 0.0f;\n        unsigned int index_min = 0;\n        for (i=0; i<_M; i++) {\n            if (selected[i]==1)\n                continue;\n            d = crealf( (_c[i]-_cref)*conjf(_c[i]-_cref) );\n            if ( d < dmin || !min_found ) {\n                dmin = d;\n                index_min = i;\n                min_found = 1;\n            }\n        }\n        _index[n] = index_min;\n        selected[index_min] = 1;\n#if DEBUG\n        printf(""%6u (%8.3f,%8.3f)\\n"", index_min, crealf(_c[index_min]), cimagf(_c[index_min]));\n#endif\n    }\n}\n//...')
"
"'Prompt: Given a scenario where you need to check if a sub-area is within a parent area, handle cases where the resulting response is false or masked, then go through a series of repetitive loop checks with defined assertions, can you provide code to validate these conditions that involve setting an area reference and refreshing the display, reshaping a buffer, and checking for its validity?","//...\n    if(_lv_area_is_in(area_p, &obj->coords, 0) == false) return NULL;\n    if(info.res == LV_COVER_RES_MASKED) return NULL;\n    info.area = area_p;\n    for(i = child_cnt - 1; i >= 0; i--) {\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic void layer_reshape_draw_buf(lv_layer_t * layer)\n{\n    LV_ASSERT(lv_draw_buf_reshape(\n                  layer->draw_buf,\n                  layer->color_format,\n                  lv_area_get_width(&layer->buf_area),\n                  lv_area_get_height(&layer->buf_area),\n                  0)\n              != NULL);\n}\n//...'"
"('You are tasked with implementing functions for designing a Gaussian Minimum Shift Keying (GMSK) transceiver filter. The prompt requires two functions: one for the transmitter side (liquid_firdes_gmsktx) and one for the receiver side (liquid_firdes_gmskrx).. . - The transmitter function calculates the filter coefficients based on parameters such as modulation index (_k), excess bandwidth (_beta), and filter delay (_dt).. - The receiver function implements the GMSK receiver filter design using similar parameters.. . For the code provided, the prompt could have been: ""Implement functions to design GMSK transceiver filters for both transmitter and receiver sides, considering modulation index, excess bandwidth, and filter delay.""","int liquid_firdes_gmsktx(unsigned int _k,\n                         unsigned int _m,\n                         float        _beta,\n                         float        _dt,\n                         float *      _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_gmsktx(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_gmsktx(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_gmsktx(): beta must be in [0,1]"");\n    unsigned int h_len = 2*_k*_m+1;\n    unsigned int i;\n    float t;\n    float c0 = 1.0f / sqrtf(logf(2.0f));\n    for (i=0; i<h_len; i++) {\n        t = (float)i/(float)(_k)-(float)(_m) + _dt;\n        _h[i] = liquid_Qf(2*M_PI*_beta*(t-0.5f)*c0) -\n                liquid_Qf(2*M_PI*_beta*(t+0.5f)*c0);\n    }\n    float e = 0.0f;\n    for (i=0; i<h_len; i++)\n        e += _h[i];\n    for (i=0; i<h_len; i++)\n        _h[i] *= M_PI / (2.0f * e);\n    for (i=0; i<h_len; i++)\n        _h[i] *= (float)_k;\n    return LIQUID_OK;\n}\nint liquid_firdes_gmskrx(unsigned int _k,\n                         unsigned int _m,\n                         float        _beta,\n                         float        _dt,\n                         float *      _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_gmskrx(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_gmskrx(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_gmskrx(): beta must be in [0,1]"");\n    unsigned int k = _k;\n    unsigned int m = _m;\n    float BT = _beta;\n    float beta = BT;                \n    float delta = 1e-3f;            \n    liquid_firfilt_type prototype = LIQUID_FIRFILT_KAISER;    \n    unsigned int i;\n    unsigned int h_len = 2*k*m+1;   \n    float ht[h_len];         \n    float hr[h_len];         \n    liquid_firdes_gmsktx(k,m,BT,0.0f,ht);\n    float h_primef[h_len];          \n    float g_primef[h_len];          \n    float complex h_tx[h_len];      \n    float complex h_prime[h_len];   \n    float complex g_prime[h_len];   \n    float complex h_hat[h_len];     \n    float complex H_tx[h_len];      \n    float complex H_prime[h_len];   \n    float complex G_prime[h_len];   \n    float complex H_hat[h_len];     \n    liquid_firdes_prototype(prototype,k,m,beta,0.0f,h_primef);\n    float fc = (0.7f + 0.1*beta) / (float)k;\n    float as = 60.0f;\n    liquid_firdes_kaiser(h_len, fc, as, 0.0f, g_primef);\n    for (i=0; i<h_len; i++) {\n        h_prime[i] = h_primef[ (i+k*m)%h_len ];\n        g_prime[i] = g_primef[ (i+k*m)%h_len ];\n        h_tx[i]    = ht[       (i+k*m)%h_len ];\n    }\n    fft_run(h_len, h_prime, H_prime, LIQUID_FFT_FORWARD, 0);\n    fft_run(h_len, g_prime, G_prime, LIQUID_FFT_FORWARD, 0);\n    fft_run(h_len, h_tx,    H_tx,    LIQUID_FFT_FORWARD, 0);\n    float H_tx_min = 0.0f;\n    float H_prime_min = 0.0f;\n    float G_prime_min = 0.0f;\n    for (i=0; i<h_len; i++) {\n        if (i==0 || crealf(H_tx[i])    < H_tx_min)    H_tx_min    = crealf(H_tx[i]);\n        if (i==0 || crealf(H_prime[i]) < H_prime_min) H_prime_min = crealf(H_prime[i]);\n        if (i==0 || crealf(G_prime[i]) < G_prime_min) G_prime_min = crealf(G_prime[i]);\n    }\n    for (i=0; i<h_len; i++) {\n        H_hat[i] = crealf(H_prime[i] - H_prime_min + delta) / crealf(H_tx[i] - H_tx_min + delta);\n        H_hat[i] *= crealf(G_prime[i] - G_prime_min) / crealf(G_prime[0]);\n    }\n    fft_run(h_len, H_hat, h_hat, LIQUID_FFT_BACKWARD, 0);\n    for (i=0; i<h_len; i++)\n        hr[i] = crealf( h_hat[(i+k*m+1)%h_len] ) / (float)(k*h_len);\n    for (i=0; i<h_len; i++)\n        _h[i] = hr[i]*_k*_k;\n    return LIQUID_OK;\n}')
"
"'Sure! Here is the prompt:. . Scenario: You are working on a project that involves initializing and communicating with a UART device on a particular platform. You need assistance with implementing functions for calculating baud rate, initializing the UART device, reading data in a polled manner, writing data in a polled manner, and resetting and flushing the transmit buffer of the UART device. . . You can provide me with the necessary code for these functions by describing the technical scenario and requirements for each function.","static inline volatile versal_uart *versal_uart_get_regs(\n  rtems_termios_device_context *base\n)\n{\n  versal_uart_context *ctx = (versal_uart_context *) base;\n  return ctx->regs;\n}\nuint32_t versal_uart_input_clock(void) __attribute__ ((weak));\nuint32_t versal_uart_input_clock(void)\n{\n  return VERSAL_CLOCK_UART;\n}\nint32_t versal_cal_baud_rate(\n  uint32_t baudrate,\n  uint32_t maxerror,\n  uint32_t *ibdiv,\n  uint32_t *fbdiv\n)\n{\n  uint32_t calcbaudrate;\n  uint32_t bauderror;\n  uint32_t percenterror;\n  uint32_t fbdivrnd;\n  uint32_t inputclk = versal_uart_input_clock();\n  if ((baudrate * 16) > inputclk) {\n    return -1;\n  }\n  *ibdiv = inputclk / 16 / baudrate;\n  if ( *ibdiv > 1<<16 ) {\n    return -1;\n  }\n  fbdivrnd = ((((uint64_t)inputclk / 16) << 7) / baudrate) & 0x1;\n  *fbdiv = (((((uint64_t)inputclk / 16) << 6) / baudrate) & 0x3F) + fbdivrnd;\n  calcbaudrate = (((uint64_t)inputclk / 16) << 6) / ((*ibdiv << 6) | *fbdiv);\n  if (baudrate > calcbaudrate) {\n    bauderror = baudrate - calcbaudrate;\n  } else {\n    bauderror = calcbaudrate - baudrate;\n  }\n  percenterror = (bauderror * 100) / baudrate;\n  if (maxerror < percenterror) {\n    return -1;\n  }\n  return 0;\n}\nint versal_uart_initialize(rtems_termios_device_context *base)\n{\n  volatile versal_uart *regs = versal_uart_get_regs(base);\n  uint32_t maxerr = 3;\n  uint32_t ibauddiv = 0;\n  uint32_t fbauddiv = 0;\n  int rv;\n  versal_uart_reset_tx_flush(base);\n  rv = versal_cal_baud_rate(\n      VERSAL_UART_DEFAULT_BAUD,\n      maxerr,\n      &ibauddiv,\n      &fbauddiv\n  );\n  if ( rv < 0 ) {\n    return rv;\n  }\n  regs->uartlcr_h = VERSAL_UARTLCR_H_WLEN( VERSAL_UARTLCR_H_WLEN_8 )\n    | VERSAL_UARTLCR_H_FEN;\n  regs->uartcr = VERSAL_UARTCR_RXE\n    | VERSAL_UARTCR_TXE\n    | VERSAL_UARTCR_UARTEN;\n  regs->uartibrd = VERSAL_UARTIBRD_BAUD_DIVINT(ibauddiv);\n  regs->uartfbrd = VERSAL_UARTFBRD_BAUD_DIVFRAC(fbauddiv);\n  return 0;\n}\nint versal_uart_read_polled(rtems_termios_device_context *base)\n{\n  volatile versal_uart *regs = versal_uart_get_regs(base);\n  if ((regs->uartfr & VERSAL_UARTFR_RXFE) != 0) {\n    return -1;\n  } else {\n    return VERSAL_UARTDR_DATA_GET(regs->uartdr);\n  }\n}\nvoid versal_uart_write_polled(\n  rtems_termios_device_context *base,\n  char c\n)\n{\n  volatile versal_uart *regs = versal_uart_get_regs(base);\n  while ((regs->uartfr & VERSAL_UARTFR_TXFF) != 0) {\n  }\n  regs->uartdr = VERSAL_UARTDR_DATA(c);\n}\nvoid versal_uart_reset_tx_flush(rtems_termios_device_context *base)\n{\n  volatile versal_uart *regs = versal_uart_get_regs(base);\n  int c = 4;\n  while (c-- > 0)\n    versal_uart_write_polled(base, '\\r');\n  while ((regs->uartfr & VERSAL_UARTFR_TXFE) == 0) {\n  }\n  while ((regs->uartfr & VERSAL_UARTFR_BUSY) != 0) {\n  }\n}"""
"('Prompt: Write a function in C that will perform a unit test to evaluate the correctness of the `randf()` function by generating random floating-point numbers and calculating the first- and second-order statistical moments. The test should compare the results to statistical properties of a uniform distribution, with a specified error tolerance. Also, make use of a constant `LIQUID_RANDOM_AUTOTEST_NUM_TRIALS` to determine the number of trials, and `LIQUID_RANDOM_AUTOTEST_ERROR_TOL` to set the error tolerance for the statistical moment comparisons.","//...\nvoid autotest_randf()\n{\n    unsigned long int N = LIQUID_RANDOM_AUTOTEST_NUM_TRIALS;\n    unsigned long int i;\n    float x, m1=0.0f, m2=0.0f;\n    float tol = LIQUID_RANDOM_AUTOTEST_ERROR_TOL;\n    for (i=0; i<N; i++) {\n        x = randf();\n        m1 += x;\n        m2 += x*x;\n    }\n    m1 /= (float) N;\n    m2 = (m2 / (float)N) - m1*m1;\n    CONTEND_DELTA(m1, 0.5f, tol);\n    CONTEND_DELTA(m2, 1/12.0f, tol);\n}\n//...')
"
"'Please provide a technical scenario or explanation for which you would like to initialize, start, and handle interruptions for a comparator module in a microcontroller using the STM32Cube HAL library.","#ifdef HAL_COMP_MODULE_ENABLED\n#define COMP_DELAY_STARTUP_US             (80UL)  \n#define COMP_DELAY_VOLTAGE_SCALER_STAB_US (200UL)  \nHAL_StatusTypeDef HAL_COMP_Init(COMP_HandleTypeDef *hcomp)\n{\n  uint32_t tmp_csr ;\n  uint32_t exti_line ;\n  uint32_t comp_voltage_scaler_initialized; \n  __IO uint32_t wait_loop_index = 0UL;\n  HAL_StatusTypeDef status = HAL_OK;\n  if(hcomp == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else if(__HAL_COMP_IS_LOCKED(hcomp))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n    assert_param(IS_COMP_INPUT_PLUS(hcomp->Instance, hcomp->Init.NonInvertingInput));\n    assert_param(IS_COMP_INPUT_MINUS(hcomp->Instance, hcomp->Init.InvertingInput));\n    assert_param(IS_COMP_OUTPUTPOL(hcomp->Init.OutputPol));\n    assert_param(IS_COMP_POWERMODE(hcomp->Init.Mode));\n    assert_param(IS_COMP_HYSTERESIS(hcomp->Init.Hysteresis));\n    assert_param(IS_COMP_BLANKINGSRCE(hcomp->Init.BlankingSrce)); \n    assert_param(IS_COMP_TRIGGERMODE(hcomp->Init.TriggerMode));\n    assert_param(IS_COMP_WINDOWMODE(hcomp->Init.WindowMode));\n    if(hcomp->State == HAL_COMP_STATE_RESET)\n    {\n      hcomp->Lock = HAL_UNLOCKED;\n      COMP_CLEAR_ERRORCODE(hcomp);\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\n      hcomp->TriggerCallback = HAL_COMP_TriggerCallback; \n      if (hcomp->MspInitCallback == NULL)\n      {\n        hcomp->MspInitCallback = HAL_COMP_MspInit; \n      }\n      hcomp->MspInitCallback(hcomp);\n#else\n      HAL_COMP_MspInit(hcomp);\n#endif \n    }\n    comp_voltage_scaler_initialized = READ_BIT(hcomp->Instance->CFGR, COMP_CFGRx_SCALEN);\n    tmp_csr = (hcomp->Init.InvertingInput    |  \\\n              hcomp->Init.NonInvertingInput  |  \\\n              hcomp->Init.BlankingSrce       |  \\\n              hcomp->Init.Hysteresis         |  \\\n              hcomp->Init.OutputPol          |  \\\n              hcomp->Init.Mode                );\n#if defined (COMP_CFGRx_INP2SEL)\n    MODIFY_REG(hcomp->Instance->CFGR,\n               COMP_CFGRx_PWRMODE  | COMP_CFGRx_INMSEL   | COMP_CFGRx_INPSEL  | \n               COMP_CFGRx_INP2SEL  | COMP_CFGRx_WINMODE  | COMP_CFGRx_POLARITY | COMP_CFGRx_HYST    |\n               COMP_CFGRx_BLANKING | COMP_CFGRx_BRGEN    | COMP_CFGRx_SCALEN,\n               tmp_csr\n              );\n#else\n    MODIFY_REG(hcomp->Instance->CFGR,\n               COMP_CFGRx_PWRMODE  | COMP_CFGRx_INMSEL   | COMP_CFGRx_INPSEL  | \n               COMP_CFGRx_WINMODE  | COMP_CFGRx_POLARITY | COMP_CFGRx_HYST    |\n               COMP_CFGRx_BLANKING | COMP_CFGRx_BRGEN    | COMP_CFGRx_SCALEN,\n               tmp_csr\n              );\n#endif\n    if(hcomp->Init.WindowMode == COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON)\n    {\n      SET_BIT(hcomp->Instance->CFGR, COMP_CFGRx_WINMODE);\n    }\n    else\n    {\n      CLEAR_BIT(hcomp->Instance->CFGR, COMP_CFGRx_WINMODE);\n    }\n    if ((READ_BIT(hcomp->Instance->CFGR, COMP_CFGRx_SCALEN) != 0UL) &&\n        (comp_voltage_scaler_initialized != 0UL)               )\n    {\n     wait_loop_index = ((COMP_DELAY_VOLTAGE_SCALER_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));\n     while(wait_loop_index != 0UL)\n     {\n       wait_loop_index --;\n     }\n    }\n    exti_line = COMP_GET_EXTI_LINE(hcomp->Instance);\n    if((hcomp->Init.TriggerMode & (COMP_EXTI_IT | COMP_EXTI_EVENT)) != 0UL) \n    {\n      if((hcomp->Init.TriggerMode & COMP_EXTI_RISING) != 0UL)\n      {\n        SET_BIT(EXTI->RTSR1, exti_line);\n      }\n      else\n      {\n        CLEAR_BIT(EXTI->RTSR1, exti_line);\n      }\n      if((hcomp->Init.TriggerMode & COMP_EXTI_FALLING) != 0UL)\n      {\n        SET_BIT(EXTI->FTSR1, exti_line);\n      }\n      else\n      {\n        CLEAR_BIT(EXTI->FTSR1, exti_line);\n      }\n#if !defined (CORE_CM4)\n      WRITE_REG(EXTI->PR1, exti_line);\n      if((hcomp->Init.TriggerMode & COMP_EXTI_EVENT) != 0UL)\n      {\n        SET_BIT(EXTI->EMR1, exti_line);\n      }\n      else\n      {\n        CLEAR_BIT(EXTI->EMR1, exti_line);\n      }\n      if((hcomp->Init.TriggerMode & COMP_EXTI_IT) != 0UL)\n      {\n        SET_BIT(EXTI->IMR1, exti_line);\n      }\n      else\n      {\n        CLEAR_BIT(EXTI->IMR1, exti_line);\n      }\n    }\n    else\n    {\n      CLEAR_BIT(EXTI->EMR1, exti_line);\n      CLEAR_BIT(EXTI->IMR1, exti_line);\n    }\n#else\n      WRITE_REG(EXTI->C2PR1, exti_line);\n      if((hcomp->Init.TriggerMode & COMP_EXTI_EVENT) != 0UL)\n      {\n        SET_BIT(EXTI->C2EMR1, exti_line);\n      }\n      else\n      {\n        CLEAR_BIT(EXTI->C2EMR1, exti_line);\n      }\n      if((hcomp->Init.TriggerMode & COMP_EXTI_IT) != 0UL)\n      {\n        SET_BIT(EXTI->C2IMR1, exti_line);\n      }\n      else\n      {\n        CLEAR_BIT(EXTI->C2IMR1, exti_line);\n      }\n    }\n    else\n    {\n      CLEAR_BIT(EXTI->C2EMR1, exti_line);\n      CLEAR_BIT(EXTI->C2IMR1, exti_line);\n    }\n#endif\n    if (hcomp->State == HAL_COMP_STATE_RESET)\n    {\n      hcomp->State = HAL_COMP_STATE_READY;\n    }\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_COMP_DeInit(COMP_HandleTypeDef *hcomp)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if(hcomp == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else if(__HAL_COMP_IS_LOCKED(hcomp))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n    WRITE_REG(hcomp->Instance->CFGR, 0x00000000UL);\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\n    if (hcomp->MspDeInitCallback == NULL)\n    {\n      hcomp->MspDeInitCallback = HAL_COMP_MspDeInit; \n    }\n    hcomp->MspDeInitCallback(hcomp);\n#else\n    HAL_COMP_MspDeInit(hcomp);\n#endif \n    hcomp->State = HAL_COMP_STATE_RESET;\n    __HAL_UNLOCK(hcomp);\n  }\n  return status;\n}\n__weak void HAL_COMP_MspInit(COMP_HandleTypeDef *hcomp)\n{\n  UNUSED(hcomp);\n}\n__weak void HAL_COMP_MspDeInit(COMP_HandleTypeDef *hcomp)\n{\n   UNUSED(hcomp);\n}\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\nHAL_StatusTypeDef HAL_COMP_RegisterCallback(COMP_HandleTypeDef *hcomp, HAL_COMP_CallbackIDTypeDef CallbackID, pCOMP_CallbackTypeDef pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (pCallback == NULL)\n  {\n    hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n    return HAL_ERROR;\n  }\n  if (HAL_COMP_STATE_READY == hcomp->State)\n  {\n    switch (CallbackID)\n    {\n      case HAL_COMP_TRIGGER_CB_ID :\n        hcomp->TriggerCallback = pCallback;\n        break;\n      case HAL_COMP_MSPINIT_CB_ID :\n        hcomp->MspInitCallback = pCallback;\n        break;\n      case HAL_COMP_MSPDEINIT_CB_ID :\n        hcomp->MspDeInitCallback = pCallback;\n        break;\n      default :\n        hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else if (HAL_COMP_STATE_RESET == hcomp->State)\n  {\n    switch (CallbackID)\n    {\n      case HAL_COMP_MSPINIT_CB_ID :\n        hcomp->MspInitCallback = pCallback;\n        break;\n      case HAL_COMP_MSPDEINIT_CB_ID :\n        hcomp->MspDeInitCallback = pCallback;\n        break;\n      default :\n        hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n        status = HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n    status =  HAL_ERROR;\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_COMP_UnRegisterCallback(COMP_HandleTypeDef *hcomp, HAL_COMP_CallbackIDTypeDef CallbackID)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (HAL_COMP_STATE_READY == hcomp->State)\n  {\n    switch (CallbackID)\n    {\n      case HAL_COMP_TRIGGER_CB_ID :\n        hcomp->TriggerCallback = HAL_COMP_TriggerCallback;         \n        break;\n      case HAL_COMP_MSPINIT_CB_ID :\n        hcomp->MspInitCallback = HAL_COMP_MspInit;                 \n        break;\n      case HAL_COMP_MSPDEINIT_CB_ID :\n        hcomp->MspDeInitCallback = HAL_COMP_MspDeInit;             \n        break;\n      default :\n        hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else if (HAL_COMP_STATE_RESET == hcomp->State)\n  {\n    switch (CallbackID)\n    {\n      case HAL_COMP_MSPINIT_CB_ID :\n        hcomp->MspInitCallback = HAL_COMP_MspInit;                 \n        break;\n      case HAL_COMP_MSPDEINIT_CB_ID :\n        hcomp->MspDeInitCallback = HAL_COMP_MspDeInit;             \n        break;\n      default :\n        hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    hcomp->ErrorCode |= HAL_COMP_ERROR_INVALID_CALLBACK;\n    status =  HAL_ERROR;\n  }\n  return status;\n}\n#endif \nHAL_StatusTypeDef HAL_COMP_Start(COMP_HandleTypeDef *hcomp)\n{ \n  __IO uint32_t wait_loop_index = 0UL;\n  HAL_StatusTypeDef status = HAL_OK;\n  if(hcomp == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else if(__HAL_COMP_IS_LOCKED(hcomp))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n    if(hcomp->State == HAL_COMP_STATE_READY)\n    {\n      SET_BIT(hcomp->Instance->CFGR, COMP_CFGRx_EN);\n      hcomp->State = HAL_COMP_STATE_BUSY;\n     wait_loop_index = ((COMP_DELAY_STARTUP_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));\n     while(wait_loop_index != 0UL)\n     {\n       wait_loop_index--;\n     }      \n    }\n    else\n    {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_COMP_Stop(COMP_HandleTypeDef *hcomp)\n{ \n  HAL_StatusTypeDef status = HAL_OK;\n  if(hcomp == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else if(__HAL_COMP_IS_LOCKED(hcomp))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n    if(hcomp->State != HAL_COMP_STATE_RESET)\n    {\n      CLEAR_BIT(hcomp->Instance->CFGR, COMP_CFGRx_EN);\n      hcomp->State = HAL_COMP_STATE_READY;\n    }\n    else\n    {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_COMP_Start_IT(COMP_HandleTypeDef *hcomp)\n{ \n __IO uint32_t wait_loop_index = 0UL;\n HAL_StatusTypeDef status = HAL_OK;\n  if(hcomp == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else if(__HAL_COMP_IS_LOCKED(hcomp))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n    if(hcomp->State == HAL_COMP_STATE_READY)\n    {\n    SET_BIT(hcomp->Instance->CFGR, COMP_CFGRx_EN);\n    SET_BIT(hcomp->Instance->CFGR, COMP_CFGRx_ITEN);\n    hcomp->State = HAL_COMP_STATE_BUSY; \n     wait_loop_index = ((COMP_DELAY_STARTUP_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));\n     while(wait_loop_index != 0UL)\n     {\n       wait_loop_index--;\n     }\n    }\n    else\n    {\n       status = HAL_ERROR;\n    }\n   }\n  return status;\n}\nHAL_StatusTypeDef HAL_COMP_Stop_IT(COMP_HandleTypeDef *hcomp)\n{  \n  HAL_StatusTypeDef status;\n#if !defined (CORE_CM4)\n   CLEAR_BIT(EXTI->IMR1, COMP_GET_EXTI_LINE(hcomp->Instance));\n#else\n   CLEAR_BIT(EXTI->C2IMR1, COMP_GET_EXTI_LINE(hcomp->Instance));\n#endif   \n   CLEAR_BIT(hcomp->Instance->CFGR, COMP_CFGRx_ITEN);\n  status = HAL_COMP_Stop(hcomp);\n  return status;\n}\nvoid HAL_COMP_IRQHandler(COMP_HandleTypeDef *hcomp)\n{\n  uint32_t exti_line = COMP_GET_EXTI_LINE(hcomp->Instance);\n#if defined(DUAL_CORE)\n if (HAL_GetCurrentCPUID() == CM7_CPUID)\n {\n    if(READ_BIT(EXTI->PR1, exti_line) != 0UL)\n    {    \n        if(READ_BIT(COMP12_COMMON->CFGR, COMP_CFGRx_WINMODE) != 0UL)\n        {\n          WRITE_REG(EXTI->PR1, (COMP_EXTI_LINE_COMP1 | COMP_EXTI_LINE_COMP2));\n        }\n        else\n        {\n          WRITE_REG(EXTI->PR1, exti_line);\n        }\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\n    hcomp->TriggerCallback(hcomp);\n#else\n    HAL_COMP_TriggerCallback(hcomp);\n#endif \n    }\n }\n else\n {\n    if(READ_BIT(EXTI->C2PR1, exti_line) != 0UL)\n    {    \n        if(READ_BIT(COMP12_COMMON->CFGR, COMP_CFGRx_WINMODE) != 0UL)\n        {\n          WRITE_REG(EXTI->C2PR1, (COMP_EXTI_LINE_COMP1 | COMP_EXTI_LINE_COMP2));\n        }\n        else\n        {\n          WRITE_REG(EXTI->C2PR1, exti_line);\n        }\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\n    hcomp->TriggerCallback(hcomp);\n#else\n    HAL_COMP_TriggerCallback(hcomp);\n#endif \n    } \n } \n#else\n    if(READ_BIT(EXTI->PR1, exti_line) != 0UL)\n    {    \n        if(READ_BIT(COMP12_COMMON->CFGR, COMP_CFGRx_WINMODE) != 0UL)\n        {\n          WRITE_REG(EXTI->PR1, (COMP_EXTI_LINE_COMP1 | COMP_EXTI_LINE_COMP2));\n        }\n        else\n        {\n          WRITE_REG(EXTI->PR1, exti_line);\n        }\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\n    hcomp->TriggerCallback(hcomp);\n#else\n    HAL_COMP_TriggerCallback(hcomp);\n#endif \n    }\n#endif \n  if (__HAL_COMP_GET_IT_SOURCE(hcomp, COMP_IT_EN) != RESET)\n  {\n    if((__HAL_COMP_GET_FLAG( COMP_FLAG_C1I)) != 0UL)\n    {\n         __HAL_COMP_CLEAR_C1IFLAG();\n       __HAL_COMP_DISABLE_IT(hcomp,COMP_IT_EN);\n    }\n    if((__HAL_COMP_GET_FLAG( COMP_FLAG_C2I)) != 0UL)\n    {\n       __HAL_COMP_CLEAR_C2IFLAG();\n     __HAL_COMP_DISABLE_IT(hcomp,COMP_IT_EN);\n    }\n    hcomp->State = HAL_COMP_STATE_READY;\n#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)\n    hcomp->TriggerCallback(hcomp);\n#else\n    HAL_COMP_TriggerCallback(hcomp);\n#endif \n  }    \n}\nHAL_StatusTypeDef HAL_COMP_Lock(COMP_HandleTypeDef *hcomp)\n{\n HAL_StatusTypeDef status = HAL_OK;\n  if(hcomp == NULL)\n  {\n    status = HAL_ERROR;\n  }\n  else if(__HAL_COMP_IS_LOCKED(hcomp))\n  {\n    status = HAL_ERROR;\n  }\n  else\n  {\n    assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n    switch(hcomp->State)\n    {\n      case HAL_COMP_STATE_RESET:\n        hcomp->State = HAL_COMP_STATE_RESET_LOCKED;\n        break;\n      case HAL_COMP_STATE_READY:\n        hcomp->State = HAL_COMP_STATE_READY_LOCKED;\n        break;\n      default: \n        hcomp->State = HAL_COMP_STATE_BUSY_LOCKED;\n        break;\n    }\n  }\n  if(status == HAL_OK)\n  {\n    __HAL_COMP_LOCK(hcomp);\n  }\n  return status; \n}\nuint32_t HAL_COMP_GetOutputLevel(COMP_HandleTypeDef *hcomp)\n{\n  assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n  if (hcomp->Instance == COMP1)\n  {\n    return (uint32_t)(READ_BIT(COMP12->SR, COMP_SR_C1VAL));                 \n  }\n  else\n  {\n    return (uint32_t)((READ_BIT(COMP12->SR, COMP_SR_C2VAL))>> 1UL);\n  }\n}\n__weak void HAL_COMP_TriggerCallback(COMP_HandleTypeDef *hcomp)\n{\n   UNUSED(hcomp);\n}\nHAL_COMP_StateTypeDef HAL_COMP_GetState(COMP_HandleTypeDef *hcomp)\n{\n  if(hcomp == NULL)\n  {\n    return HAL_COMP_STATE_RESET;\n  }\n  assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n  return hcomp->State;\n}\nuint32_t HAL_COMP_GetError(COMP_HandleTypeDef *hcomp)\n{\n  assert_param(IS_COMP_ALL_INSTANCE(hcomp->Instance));\n  return hcomp->ErrorCode;\n}\n#endif '"
"('Prompt: You are working on testing a modem library and need to write a function that copies a modem object for different modulation schemes. Write a test function that takes the modulation scheme as input, creates a modem object, modulates and demodulates some random data, copies the modem object, modulates and demodulates again, and checks if the output of both modulations and demodulations are equal. Ensure to handle destruction of the modem objects after testing. You need to implement this functionality for two specific modulation schemes - LIQUID_MODEM_ASK2 and LIQUID_MODEM_ASK256.","//...\nvoid autotest_modem_copy_ask2()      { modemcf_test_copy(LIQUID_MODEM_ASK2);      }\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_ask256()    { modemcf_test_copy(LIQUID_MODEM_ASK256);    }\n//...')
"
"('Prompt: . You need to write a testbench function that calculates the delay of a symmetric stream root-raised cosine filter with certain bandwidth and number of taps. The function should perform some calculations using the filter, write samples to buffers, and then calculate the delay using the generated data. Additionally, you need to create multiple auto test functions to test different combinations of bandwidths and tap numbers. Can you write the testbench function and the auto test functions for this scenario?","void testbench_symstreamrcf_delay(float        _bw,\n                                  unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamrcf gen    = symstreamrcf_create_linear(ftype,_bw,_m,beta,ms);\n    float        delay  = symstreamrcf_get_delay(gen);\n    float        tol    = 0.05; \n    unsigned int  nfft = 2*(120 + (unsigned int)(delay/sqrtf(_bw)));\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    symstreamrcf_write_samples(gen, buf_time, 1);\n    symstreamrcf_set_gain(gen, 0.0f);\n    symstreamrcf_write_samples(gen, buf_time+1, nfft-1);\n    symstreamrcf_destroy(gen);\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    unsigned int m = 0.4 * _bw * nfft; \n    float complex p = 0.0f;\n    int i;\n    for (i=-(int)m; i<(int)m; i++)\n        p += buf_freq[(nfft+i)%nfft] * conjf(buf_freq[(nfft+i+1)%nfft]);\n    float delay_meas = cargf(p) * nfft / (2*M_PI);\n    if (liquid_autotest_verbose) {\n        printf(""expected delay: %.6f, measured: %.6f, err: %.6f (tol= %.3f)\\n"",\n                delay, delay_meas, delay-delay_meas,tol);\n    }\n    CONTEND_DELTA(delay, delay_meas, tol);\n}\nvoid autotest_symstreamrcf_delay_00() { testbench_symstreamrcf_delay(0.500f, 4); }\nvoid autotest_symstreamrcf_delay_01() { testbench_symstreamrcf_delay(0.500f, 5); }\nvoid autotest_symstreamrcf_delay_02() { testbench_symstreamrcf_delay(0.500f, 6); }\nvoid autotest_symstreamrcf_delay_03() { testbench_symstreamrcf_delay(0.500f, 7); }\nvoid autotest_symstreamrcf_delay_04() { testbench_symstreamrcf_delay(0.500f, 8); }\nvoid autotest_symstreamrcf_delay_05() { testbench_symstreamrcf_delay(0.500f, 9); }\nvoid autotest_symstreamrcf_delay_06() { testbench_symstreamrcf_delay(0.500f,10); }\nvoid autotest_symstreamrcf_delay_07() { testbench_symstreamrcf_delay(0.500f,14); }\nvoid autotest_symstreamrcf_delay_08() { testbench_symstreamrcf_delay(0.500f,20); }\nvoid autotest_symstreamrcf_delay_09() { testbench_symstreamrcf_delay(0.500f,31); }\nvoid autotest_symstreamrcf_delay_10() { testbench_symstreamrcf_delay(0.800f,12); }\nvoid autotest_symstreamrcf_delay_11() { testbench_symstreamrcf_delay(0.700f,12); }\nvoid autotest_symstreamrcf_delay_12() { testbench_symstreamrcf_delay(0.600f,12); }\nvoid autotest_symstreamrcf_delay_13() { testbench_symstreamrcf_delay(0.500f,12); }\nvoid autotest_symstreamrcf_delay_14() { testbench_symstreamrcf_delay(0.400f,12); }\nvoid autotest_symstreamrcf_delay_15() { testbench_symstreamrcf_delay(0.300f,12); }\nvoid autotest_symstreamrcf_delay_16() { testbench_symstreamrcf_delay(0.200f,12); }\nvoid autotest_symstreamrcf_delay_17() { testbench_symstreamrcf_delay(0.100f,12); }\nvoid autotest_symstreamrcf_delay_18() { testbench_symstreamrcf_delay(0.050f,12); }\nvoid autotest_symstreamrcf_delay_19() { testbench_symstreamrcf_delay(0.025f,12); }')
"
"'Here is the prompt based on the code provided:. . ""Imagine you are working on a project that involves interfacing with an SRAM module using the HAL library. You need to initialize, read, and write data to the SRAM. Additionally, you want to enable DMA transfers for faster data manipulation. Can you provide a set of functions that handle SRAM initialization, data read/write operations for 8-bit, 16-bit, and 32-bit data, as well as DMA transfer functions? Also, include callback functions for DMA transfer completion and error handling. Lastly, include functions to enable/disable write operations and retrieve the current state of the SRAM module."". . Please provide the code for these functions along with the necessary callbacks and error handling mechanisms.""","#ifdef HAL_SRAM_MODULE_ENABLED\nstatic void SRAM_DMACplt(MDMA_HandleTypeDef *hmdma);\nstatic void SRAM_DMACpltProt(MDMA_HandleTypeDef *hmdma);\nstatic void SRAM_DMAError(MDMA_HandleTypeDef *hmdma);\nHAL_StatusTypeDef HAL_SRAM_Init(SRAM_HandleTypeDef *hsram, FMC_NORSRAM_TimingTypeDef *Timing,\n                                FMC_NORSRAM_TimingTypeDef *ExtTiming)\n{\n  if (hsram == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if (hsram->State == HAL_SRAM_STATE_RESET)\n  {\n    hsram->Lock = HAL_UNLOCKED;\n#if (USE_HAL_SRAM_REGISTER_CALLBACKS == 1)\n    if (hsram->MspInitCallback == NULL)\n    {\n      hsram->MspInitCallback = HAL_SRAM_MspInit;\n    }\n    hsram->DmaXferCpltCallback = HAL_SRAM_DMA_XferCpltCallback;\n    hsram->DmaXferErrorCallback = HAL_SRAM_DMA_XferErrorCallback;\n    hsram->MspInitCallback(hsram);\n#else\n    HAL_SRAM_MspInit(hsram);\n#endif \n  }\n  (void)FMC_NORSRAM_Init(hsram->Instance, &(hsram->Init));\n  (void)FMC_NORSRAM_Timing_Init(hsram->Instance, Timing, hsram->Init.NSBank);\n  (void)FMC_NORSRAM_Extended_Timing_Init(hsram->Extended, ExtTiming, hsram->Init.NSBank,\n                                         hsram->Init.ExtendedMode);\n  __FMC_NORSRAM_ENABLE(hsram->Instance, hsram->Init.NSBank);\n  __FMC_ENABLE();\n  hsram->State = HAL_SRAM_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_DeInit(SRAM_HandleTypeDef *hsram)\n{\n#if (USE_HAL_SRAM_REGISTER_CALLBACKS == 1)\n  if (hsram->MspDeInitCallback == NULL)\n  {\n    hsram->MspDeInitCallback = HAL_SRAM_MspDeInit;\n  }\n  hsram->MspDeInitCallback(hsram);\n#else\n  HAL_SRAM_MspDeInit(hsram);\n#endif \n  (void)FMC_NORSRAM_DeInit(hsram->Instance, hsram->Extended, hsram->Init.NSBank);\n  hsram->State = HAL_SRAM_STATE_RESET;\n  __HAL_UNLOCK(hsram);\n  return HAL_OK;\n}\n__weak void HAL_SRAM_MspInit(SRAM_HandleTypeDef *hsram)\n{\n  UNUSED(hsram);\n}\n__weak void HAL_SRAM_MspDeInit(SRAM_HandleTypeDef *hsram)\n{\n  UNUSED(hsram);\n}\n__weak void HAL_SRAM_DMA_XferCpltCallback(MDMA_HandleTypeDef *hmdma)\n{\n  UNUSED(hmdma);\n}\n__weak void HAL_SRAM_DMA_XferErrorCallback(MDMA_HandleTypeDef *hmdma)\n{\n  UNUSED(hmdma);\n}\nHAL_StatusTypeDef HAL_SRAM_Read_8b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint8_t *pDstBuffer,\n                                   uint32_t BufferSize)\n{\n  uint32_t size;\n  __IO uint8_t *psramaddress = (uint8_t *)pAddress;\n  uint8_t *pdestbuff = pDstBuffer;\n  HAL_SRAM_StateTypeDef state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    for (size = BufferSize; size != 0U; size--)\n    {\n      *pdestbuff = *psramaddress;\n      pdestbuff++;\n      psramaddress++;\n    }\n    hsram->State = state;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_Write_8b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint8_t *pSrcBuffer,\n                                    uint32_t BufferSize)\n{\n  uint32_t size;\n  __IO uint8_t *psramaddress = (uint8_t *)pAddress;\n  uint8_t *psrcbuff = pSrcBuffer;\n  if (hsram->State == HAL_SRAM_STATE_READY)\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    for (size = BufferSize; size != 0U; size--)\n    {\n      *psramaddress = *psrcbuff;\n      psrcbuff++;\n      psramaddress++;\n    }\n    hsram->State = HAL_SRAM_STATE_READY;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_Read_16b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint16_t *pDstBuffer,\n                                    uint32_t BufferSize)\n{\n  uint32_t size;\n  __IO uint32_t *psramaddress = pAddress;\n  uint16_t *pdestbuff = pDstBuffer;\n  uint8_t limit;\n  HAL_SRAM_StateTypeDef state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    limit = (((BufferSize % 2U) != 0U) ? 1U : 0U);\n    for (size = BufferSize; size != limit; size -= 2U)\n    {\n      *pdestbuff = (uint16_t)((*psramaddress) & 0x0000FFFFU);\n      pdestbuff++;\n      *pdestbuff = (uint16_t)(((*psramaddress) & 0xFFFF0000U) >> 16U);\n      pdestbuff++;\n      psramaddress++;\n    }\n    if (limit != 0U)\n    {\n      *pdestbuff = (uint16_t)((*psramaddress) & 0x0000FFFFU);\n    }\n    hsram->State = state;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_Write_16b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint16_t *pSrcBuffer,\n                                     uint32_t BufferSize)\n{\n  uint32_t size;\n  __IO uint32_t *psramaddress = pAddress;\n  uint16_t *psrcbuff = pSrcBuffer;\n  uint8_t limit;\n  if (hsram->State == HAL_SRAM_STATE_READY)\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    limit = (((BufferSize % 2U) != 0U) ? 1U : 0U);\n    for (size = BufferSize; size != limit; size -= 2U)\n    {\n      *psramaddress = (uint32_t)(*psrcbuff);\n      psrcbuff++;\n      *psramaddress |= ((uint32_t)(*psrcbuff) << 16U);\n      psrcbuff++;\n      psramaddress++;\n    }\n    if (limit != 0U)\n    {\n      *psramaddress = ((uint32_t)(*psrcbuff) & 0x0000FFFFU) | ((*psramaddress) & 0xFFFF0000U);\n    }\n    hsram->State = HAL_SRAM_STATE_READY;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_Read_32b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pDstBuffer,\n                                    uint32_t BufferSize)\n{\n  uint32_t size;\n  __IO uint32_t *psramaddress = pAddress;\n  uint32_t *pdestbuff = pDstBuffer;\n  HAL_SRAM_StateTypeDef state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    for (size = BufferSize; size != 0U; size--)\n    {\n      *pdestbuff = *psramaddress;\n      pdestbuff++;\n      psramaddress++;\n    }\n    hsram->State = state;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_Write_32b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pSrcBuffer,\n                                     uint32_t BufferSize)\n{\n  uint32_t size;\n  __IO uint32_t *psramaddress = pAddress;\n  uint32_t *psrcbuff = pSrcBuffer;\n  if (hsram->State == HAL_SRAM_STATE_READY)\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    for (size = BufferSize; size != 0U; size--)\n    {\n      *psramaddress = *psrcbuff;\n      psrcbuff++;\n      psramaddress++;\n    }\n    hsram->State = HAL_SRAM_STATE_READY;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_Read_DMA(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pDstBuffer,\n                                    uint32_t BufferSize)\n{\n  HAL_StatusTypeDef status;\n  HAL_SRAM_StateTypeDef state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    if (state == HAL_SRAM_STATE_READY)\n    {\n      hsram->hmdma->XferCpltCallback = SRAM_DMACplt;\n    }\n    else\n    {\n      hsram->hmdma->XferCpltCallback = SRAM_DMACpltProt;\n    }\n    hsram->hmdma->XferErrorCallback = SRAM_DMAError;\n    status = HAL_MDMA_Start_IT(hsram->hmdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)(BufferSize * 4U), 1);\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    status = HAL_ERROR;\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_SRAM_Write_DMA(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pSrcBuffer,\n                                     uint32_t BufferSize)\n{\n  HAL_StatusTypeDef status;\n  if (hsram->State == HAL_SRAM_STATE_READY)\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    hsram->hmdma->XferCpltCallback = SRAM_DMACplt;\n    hsram->hmdma->XferErrorCallback = SRAM_DMAError;\n    status = HAL_MDMA_Start_IT(hsram->hmdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)(BufferSize * 4U), 1);\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    status = HAL_ERROR;\n  }\n  return status;\n}\n#if (USE_HAL_SRAM_REGISTER_CALLBACKS == 1)\nHAL_StatusTypeDef HAL_SRAM_RegisterCallback(SRAM_HandleTypeDef *hsram, HAL_SRAM_CallbackIDTypeDef CallbackId,\n                                            pSRAM_CallbackTypeDef pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  HAL_SRAM_StateTypeDef state;\n  if (pCallback == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hsram);\n  state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_RESET) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    switch (CallbackId)\n    {\n      case HAL_SRAM_MSP_INIT_CB_ID :\n        hsram->MspInitCallback = pCallback;\n        break;\n      case HAL_SRAM_MSP_DEINIT_CB_ID :\n        hsram->MspDeInitCallback = pCallback;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hsram);\n  return status;\n}\nHAL_StatusTypeDef HAL_SRAM_UnRegisterCallback(SRAM_HandleTypeDef *hsram, HAL_SRAM_CallbackIDTypeDef CallbackId)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  HAL_SRAM_StateTypeDef state;\n  __HAL_LOCK(hsram);\n  state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    switch (CallbackId)\n    {\n      case HAL_SRAM_MSP_INIT_CB_ID :\n        hsram->MspInitCallback = HAL_SRAM_MspInit;\n        break;\n      case HAL_SRAM_MSP_DEINIT_CB_ID :\n        hsram->MspDeInitCallback = HAL_SRAM_MspDeInit;\n        break;\n      case HAL_SRAM_DMA_XFER_CPLT_CB_ID :\n        hsram->DmaXferCpltCallback = HAL_SRAM_DMA_XferCpltCallback;\n        break;\n      case HAL_SRAM_DMA_XFER_ERR_CB_ID :\n        hsram->DmaXferErrorCallback = HAL_SRAM_DMA_XferErrorCallback;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else if (state == HAL_SRAM_STATE_RESET)\n  {\n    switch (CallbackId)\n    {\n      case HAL_SRAM_MSP_INIT_CB_ID :\n        hsram->MspInitCallback = HAL_SRAM_MspInit;\n        break;\n      case HAL_SRAM_MSP_DEINIT_CB_ID :\n        hsram->MspDeInitCallback = HAL_SRAM_MspDeInit;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hsram);\n  return status;\n}\nHAL_StatusTypeDef HAL_SRAM_RegisterDmaCallback(SRAM_HandleTypeDef *hsram, HAL_SRAM_CallbackIDTypeDef CallbackId,\n                                               pSRAM_DmaCallbackTypeDef pCallback)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  HAL_SRAM_StateTypeDef state;\n  if (pCallback == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hsram);\n  state = hsram->State;\n  if ((state == HAL_SRAM_STATE_READY) || (state == HAL_SRAM_STATE_PROTECTED))\n  {\n    switch (CallbackId)\n    {\n      case HAL_SRAM_DMA_XFER_CPLT_CB_ID :\n        hsram->DmaXferCpltCallback = pCallback;\n        break;\n      case HAL_SRAM_DMA_XFER_ERR_CB_ID :\n        hsram->DmaXferErrorCallback = pCallback;\n        break;\n      default :\n        status =  HAL_ERROR;\n        break;\n    }\n  }\n  else\n  {\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hsram);\n  return status;\n}\n#endif \nHAL_StatusTypeDef HAL_SRAM_WriteOperation_Enable(SRAM_HandleTypeDef *hsram)\n{\n  if (hsram->State == HAL_SRAM_STATE_PROTECTED)\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    (void)FMC_NORSRAM_WriteOperation_Enable(hsram->Instance, hsram->Init.NSBank);\n    hsram->State = HAL_SRAM_STATE_READY;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_SRAM_WriteOperation_Disable(SRAM_HandleTypeDef *hsram)\n{\n  if (hsram->State == HAL_SRAM_STATE_READY)\n  {\n    __HAL_LOCK(hsram);\n    hsram->State = HAL_SRAM_STATE_BUSY;\n    (void)FMC_NORSRAM_WriteOperation_Disable(hsram->Instance, hsram->Init.NSBank);\n    hsram->State = HAL_SRAM_STATE_PROTECTED;\n    __HAL_UNLOCK(hsram);\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\nHAL_SRAM_StateTypeDef HAL_SRAM_GetState(SRAM_HandleTypeDef *hsram)\n{\n  return hsram->State;\n}\nstatic void SRAM_DMACplt(MDMA_HandleTypeDef *hmdma)\n{\n  SRAM_HandleTypeDef *hsram = (SRAM_HandleTypeDef *)(hmdma->Parent);\n  __HAL_MDMA_DISABLE(hmdma);\n  hsram->State = HAL_SRAM_STATE_READY;\n#if (USE_HAL_SRAM_REGISTER_CALLBACKS == 1)\n  hsram->DmaXferCpltCallback(hmdma);\n#else\n  HAL_SRAM_DMA_XferCpltCallback(hmdma);\n#endif \n}\nstatic void SRAM_DMACpltProt(MDMA_HandleTypeDef *hmdma)\n{\n  SRAM_HandleTypeDef *hsram = (SRAM_HandleTypeDef *)(hmdma->Parent);\n  __HAL_MDMA_DISABLE(hmdma);\n  hsram->State = HAL_SRAM_STATE_PROTECTED;\n#if (USE_HAL_SRAM_REGISTER_CALLBACKS == 1)\n  hsram->DmaXferCpltCallback(hmdma);\n#else\n  HAL_SRAM_DMA_XferCpltCallback(hmdma);\n#endif \n}\nstatic void SRAM_DMAError(MDMA_HandleTypeDef *hmdma)\n{\n  SRAM_HandleTypeDef *hsram = (SRAM_HandleTypeDef *)(hmdma->Parent);\n  __HAL_MDMA_DISABLE(hmdma);\n  hsram->State = HAL_SRAM_STATE_ERROR;\n#if (USE_HAL_SRAM_REGISTER_CALLBACKS == 1)\n  hsram->DmaXferErrorCallback(hmdma);\n#else\n  HAL_SRAM_DMA_XferErrorCallback(hmdma);\n#endif \n}\n#endif '"
"""Prompt: Assume you are developing a memory management unit (MMU) for a microcontroller. Please provide a sample array of memory map entries in the format mmu_sect_map_t. Each entry should specify the physical and virtual memory addresses, size in bytes, and cache configuration. . Technical Scenario: You are responsible for configuring the memory mappings for different regions of the microcontroller's memory. The memory map entries should include details such as the base physical and virtual addresses, the size of each memory region in bytes, and the cache configuration for optimal performance. With this information, you need to create an array of mmu_sect_map_t structures to represent these memory map entries.","mmu_sect_map_t mem_map[] = {\n    {0x30000000, 0x00000000,   1,   MMU_CACHE_NONE},     \n    {0x30000000, 0x30000000,   32,  MMU_CACHE_WTHROUGH}, \n    {0x32000000, 0x32000000,   32,  MMU_CACHE_NONE},     \n    {0x48000000, 0x48000000,   256, MMU_CACHE_NONE},     \n    {0x50000000, 0x50000000,   256, MMU_CACHE_NONE},     \n    {0x00000000, 0x00000000,   0,    0}                  \n};'"
'Prompt: You are working on a graphics library and need to implement functions to draw and fill polygons. The `hagl_draw_polygon` function draws a polygon specified by an array of vertices with a specified color. The `hagl_fill_polygon` function fills the polygon with the specified color using scanline fill algorithm. Can you provide the code for these functions in C?,"void\nhagl_draw_polygon(void const *surface, int16_t amount, int16_t *vertices, hagl_color_t color)\n{\n    for(int16_t i = 0; i < amount - 1; i++) {\n        hagl_draw_line(\n            surface,\n            vertices[(i << 1 ) + 0],\n            vertices[(i << 1 ) + 1],\n            vertices[(i << 1 ) + 2],\n            vertices[(i << 1 ) + 3],\n            color\n        );\n    }\n    hagl_draw_line(\n        surface,\n        vertices[0],\n        vertices[1],\n        vertices[(amount << 1 ) - 2],\n        vertices[(amount << 1 ) - 1],\n        color\n    );\n}\nvoid\nhagl_fill_polygon(void const *_surface, int16_t amount, int16_t *vertices, hagl_color_t color)\n{\n    const hagl_surface_t *surface = _surface;\n    uint16_t nodes[64];\n    int16_t y;\n    float x0;\n    float y0;\n    float x1;\n    float y1;\n    int16_t miny = surface->height;\n    int16_t maxy = 0;\n    for (uint8_t i = 0; i < amount; i++) {\n        if (miny > vertices[(i << 1) + 1]) {\n            miny = vertices[(i << 1) + 1];\n        }\n        if (maxy < vertices[(i << 1) + 1]) {\n            maxy = vertices[(i << 1) + 1];\n        }\n    }\n    for (y = miny; y < maxy; y++) {\n        int16_t count = 0;\n        int16_t j = amount - 1;\n        for (int16_t i = 0; i < amount; i++) {\n            x0 = vertices[(i << 1) + 0];\n            y0 = vertices[(i << 1) + 1];\n            x1 = vertices[(j << 1) + 0];\n            y1 = vertices[(j << 1) + 1];\n            if (\n                (y0 < (float)y && y1 >= (float)y) ||\n                (y1 < (float)y && y0 >= (float)y)\n            ) {\n                nodes[count] = (int16_t)(x0 + (y - y0) / (y1 - y0) * (x1 - x0));\n                count++;\n            }\n            j = i;\n        }\n        int16_t i = 0;\n        while (i < count - 1) {\n            if (nodes[i] > nodes[i + 1]) {\n                int16_t swap = nodes[i];\n                nodes[i] = nodes[i + 1];\n                nodes[i + 1] = swap;\n                if (i) {\n                    i--;\n                }\n            } else {\n                i++;\n            }\n        }\n        for (int16_t i = 0; i < count; i += 2) {\n            int16_t width = nodes[i + 1] - nodes[i];\n            hagl_draw_hline(surface, nodes[i], y, width, color);\n        }\n    }\n}'"
"('You could have prompted me with: ""Create a function that simulates the synchronization process of a communication system using quadrature pilot symbols. The function should take as input parameters the modulation scheme, payload length, pilot spacing, carrier frequency offset (dphi), initial carrier phase offset (phi), channel gain (gamma), and signal-to-noise ratio (SNRdB). The function should generate random payload symbols, modulate them, add pilot symbols, simulate transmission over a noisy channel, demodulate received symbols, and calculate synchronization metrics such as carrier frequency offset estimation, carrier phase offset estimation, channel gain estimation, and error vector magnitude. The function should also print verbose results and perform automated tests. Lastly, include optional debug and logging functionalities. Additionally, create an automated test function for a specific set of parameters (LIQUID_MODEM_QPSK, payload length of 500, pilot spacing of 32, carrier frequency offset of 0.07, initial carrier phase offset of 1","//...\nvoid qpilotsync_test(modulation_scheme _ms,\n                     unsigned int      _payload_len,\n                     unsigned int      _pilot_spacing,\n                     float             _dphi,\n                     float             _phi,\n                     float             _gamma,\n                     float             _SNRdB)\n{\n    unsigned int i;\n    float nstd = powf(10.0f, -_SNRdB/20.0f);\n    qpilotgen  pg = qpilotgen_create( _payload_len, _pilot_spacing);\n    qpilotsync ps = qpilotsync_create(_payload_len, _pilot_spacing);\n    unsigned int frame_len = qpilotgen_get_frame_len(pg);\n    CONTEND_EQUALITY(frame_len, qpilotsync_get_frame_len(ps));\n    unsigned char payload_sym_tx[_payload_len]; \n    float complex payload_tx    [_payload_len]; \n    float complex frame_tx      [frame_len];    \n    float complex frame_rx      [frame_len];    \n    float complex payload_rx    [_payload_len]; \n    unsigned char payload_sym_rx[_payload_len]; \n    modemcf mod = modemcf_create(_ms);\n    modemcf dem = modemcf_create(_ms);\n    for (i=0; i<_payload_len; i++) {\n        payload_sym_tx[i] = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod, payload_sym_tx[i], &payload_tx[i]);\n    }\n    qpilotgen_execute(pg, payload_tx, frame_tx);\n    for (i=0; i<frame_len; i++) {\n        frame_rx[i]  = frame_tx[i] * cexpf(_Complex_I*_dphi*i + _Complex_I*_phi);\n        frame_rx[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n        frame_rx[i] *= _gamma;\n    }\n    qpilotsync_execute(ps, frame_rx, payload_rx);\n    for (i=0; i<_payload_len; i++) {\n        unsigned int sym_demod;\n        modemcf_demodulate(dem, payload_rx[i], &sym_demod);\n        payload_sym_rx[i] = (unsigned char)sym_demod;\n    }\n    unsigned int bit_errors = 0;\n    for (i=0; i<_payload_len; i++)\n        bit_errors += count_bit_errors(payload_sym_rx[i], payload_sym_tx[i]);\n    float dphi_hat  = qpilotsync_get_dphi(ps);\n    float phi_hat   = qpilotsync_get_phi (ps);\n    float gamma_hat = qpilotsync_get_gain(ps);\n    float evm_hat   = qpilotsync_get_evm (ps);\n    if (liquid_autotest_verbose) {\n        qpilotgen_print(pg);\n        printf(""  received bit errors : %u / %u\\n"", bit_errors, _payload_len * modemcf_get_bps(mod));\n        printf(""  dphi (carrier freq.): %12.8f (expected %12.8f, error=%12.8f)\\n"", dphi_hat,  _dphi, _dphi-dphi_hat);\n        printf(""  phi  (carrier phase): %12.8f (expected %12.8f, error=%12.8f)\\n"", phi_hat,   _phi, _phi-phi_hat);\n        printf(""  gamma (channel gain): %12.8f (expected %12.8f, error=%12.8f)\\n"", gamma_hat, _gamma, _gamma-gamma_hat);\n        printf(""  error vector mag.   : %12.8f (expected %12.8f, error=%12.8f)\\n"", evm_hat,   -_SNRdB,_SNRdB+evm_hat);\n    }\n    CONTEND_DELTA   (   dphi_hat,  _dphi, 0.010f );\n    CONTEND_DELTA   (    phi_hat,   _phi, 0.087f );  \n    CONTEND_DELTA   (  gamma_hat, _gamma, 0.010f );\n    CONTEND_EQUALITY( bit_errors, 0 );\n    qpilotgen_destroy(pg);\n    qpilotsync_destroy(ps);\n    modemcf_destroy(mod);\n    modemcf_destroy(dem);\n#if 0\n    FILE * fp = fopen(""qpilotsync_errors.txt"", ""a"");\n    fprintf(fp,""%12.4e %12.4e %12.4e %12.4e\\n"",dphi_hat-_dphi,phi_hat-_phi,gamma_hat-_gamma,evm_hat+_SNRdB);\n    fclose(fp);\n#endif\n#if 0 \n    char filename[256];\n    sprintf(filename,""autotest/logs/qpilotsync_autotest_%u_%u_debug.m"", _payload_len, _pilot_spacing);\n    FILE * fid = fopen(filename,""w"");\n    if (!fid) {\n        liquid_error(LIQUID_EIO,""could not open \'%s\' for writing"", filename);\n        return;\n    }\n    fprintf(fid,""%% %s : auto-generated file\\n"", filename);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""payload_len = %u;\\n"", _payload_len);\n    fprintf(fid,""frame_len   = %u;\\n"", frame_len);\n    fprintf(fid,""frame_tx   = zeros(1,frame_len);\\n"");\n    fprintf(fid,""payload_rx = zeros(1,payload_len);\\n"");\n    for (i=0; i<frame_len; i++)\n        fprintf(fid,""frame_rx(%6u) = %12.4e + 1i*%12.4e;\\n"", i+1, crealf(frame_rx[i]), cimagf(frame_rx[i]));\n    for (i=0; i<_payload_len; i++)\n        fprintf(fid,""payload_rx(%6u) = %12.4e + 1i*%12.4e;\\n"", i+1, crealf(payload_rx[i]), cimagf(payload_rx[i]));\n    fprintf(fid,""figure(\'Color\',\'white\',\'position\',[100 100 950 400]);\\n"");\n    fprintf(fid,""subplot(1,2,1);\\n"");\n    fprintf(fid,""  plot(real(frame_rx),  imag(frame_rx),  \'x\',\'MarkerSize\',3);\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.5);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'real\');\\n"");\n    fprintf(fid,""  ylabel(\'imag\');\\n"");\n    fprintf(fid,""  title(\'received\');\\n"");\n    fprintf(fid,""subplot(1,2,2);\\n"");\n    fprintf(fid,""  plot(real(payload_rx),imag(payload_rx),\'x\',\'MarkerSize\',3);\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.5);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'real\');\\n"");\n    fprintf(fid,""  ylabel(\'imag\');\\n"");\n    fprintf(fid,""  title(\'recovered\');\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", filename);\n#endif\n}\nvoid autotest_qpilotsync_500_32() { qpilotsync_test(LIQUID_MODEM_QPSK, 500, 32, 0.07f, 1.2f, 0.7f, 40.0f); }\n//...')
"
"('Prompt: You need a function that creates a copy of a modem with a specified modulation scheme and runs some tests on it. The function should modulate and demodulate signals using the original and copied modems, comparing the results for equality. The tests should be run for various modulation schemes like PSK, DPSK, ASK, QAM, APSK, BPSK, QPSK, OOK, SQAM, V29, and various arbitrary optimized and vectored modulations. The function should output the modulation scheme names before and after copying for comparison. The copied modem should perform modulate/demodulate operations correctly compared to the original.","void modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_psk2()      { modemcf_test_copy(LIQUID_MODEM_PSK2);      }\nvoid autotest_modem_copy_psk4()      { modemcf_test_copy(LIQUID_MODEM_PSK4);      }\nvoid autotest_modem_copy_psk8()      { modemcf_test_copy(LIQUID_MODEM_PSK8);      }\nvoid autotest_modem_copy_psk16()     { modemcf_test_copy(LIQUID_MODEM_PSK16);     }\nvoid autotest_modem_copy_psk32()     { modemcf_test_copy(LIQUID_MODEM_PSK32);     }\nvoid autotest_modem_copy_psk64()     { modemcf_test_copy(LIQUID_MODEM_PSK64);     }\nvoid autotest_modem_copy_psk128()    { modemcf_test_copy(LIQUID_MODEM_PSK128);    }\nvoid autotest_modem_copy_psk256()    { modemcf_test_copy(LIQUID_MODEM_PSK256);    }\nvoid autotest_modem_copy_dpsk2()     { modemcf_test_copy(LIQUID_MODEM_DPSK2);     }\nvoid autotest_modem_copy_dpsk4()     { modemcf_test_copy(LIQUID_MODEM_DPSK4);     }\nvoid autotest_modem_copy_dpsk8()     { modemcf_test_copy(LIQUID_MODEM_DPSK8);     }\nvoid autotest_modem_copy_dpsk16()    { modemcf_test_copy(LIQUID_MODEM_DPSK16);    }\nvoid autotest_modem_copy_dpsk32()    { modemcf_test_copy(LIQUID_MODEM_DPSK32);    }\nvoid autotest_modem_copy_dpsk64()    { modemcf_test_copy(LIQUID_MODEM_DPSK64);    }\nvoid autotest_modem_copy_dpsk128()   { modemcf_test_copy(LIQUID_MODEM_DPSK128);   }\nvoid autotest_modem_copy_dpsk256()   { modemcf_test_copy(LIQUID_MODEM_DPSK256);   }\nvoid autotest_modem_copy_ask2()      { modemcf_test_copy(LIQUID_MODEM_ASK2);      }\nvoid autotest_modem_copy_ask4()      { modemcf_test_copy(LIQUID_MODEM_ASK4);      }\nvoid autotest_modem_copy_ask8()      { modemcf_test_copy(LIQUID_MODEM_ASK8);      }\nvoid autotest_modem_copy_ask16()     { modemcf_test_copy(LIQUID_MODEM_ASK16);     }\nvoid autotest_modem_copy_ask32()     { modemcf_test_copy(LIQUID_MODEM_ASK32);     }\nvoid autotest_modem_copy_ask64()     { modemcf_test_copy(LIQUID_MODEM_ASK64);     }\nvoid autotest_modem_copy_ask128()    { modemcf_test_copy(LIQUID_MODEM_ASK128);    }\nvoid autotest_modem_copy_ask256()    { modemcf_test_copy(LIQUID_MODEM_ASK256);    }\nvoid autotest_modem_copy_qam4()      { modemcf_test_copy(LIQUID_MODEM_QAM4);      }\nvoid autotest_modem_copy_qam8()      { modemcf_test_copy(LIQUID_MODEM_QAM8);      }\nvoid autotest_modem_copy_qam16()     { modemcf_test_copy(LIQUID_MODEM_QAM16);     }\nvoid autotest_modem_copy_qam32()     { modemcf_test_copy(LIQUID_MODEM_QAM32);     }\nvoid autotest_modem_copy_qam64()     { modemcf_test_copy(LIQUID_MODEM_QAM64);     }\nvoid autotest_modem_copy_qam128()    { modemcf_test_copy(LIQUID_MODEM_QAM128);    }\nvoid autotest_modem_copy_qam256()    { modemcf_test_copy(LIQUID_MODEM_QAM256);    }\nvoid autotest_modem_copy_apsk4()     { modemcf_test_copy(LIQUID_MODEM_APSK4);     }\nvoid autotest_modem_copy_apsk8()     { modemcf_test_copy(LIQUID_MODEM_APSK8);     }\nvoid autotest_modem_copy_apsk16()    { modemcf_test_copy(LIQUID_MODEM_APSK16);    }\nvoid autotest_modem_copy_apsk32()    { modemcf_test_copy(LIQUID_MODEM_APSK32);    }\nvoid autotest_modem_copy_apsk64()    { modemcf_test_copy(LIQUID_MODEM_APSK64);    }\nvoid autotest_modem_copy_apsk128()   { modemcf_test_copy(LIQUID_MODEM_APSK128);   }\nvoid autotest_modem_copy_apsk256()   { modemcf_test_copy(LIQUID_MODEM_APSK256);   }\nvoid autotest_modem_copy_bpsk()      { modemcf_test_copy(LIQUID_MODEM_BPSK);      }\nvoid autotest_modem_copy_qpsk()      { modemcf_test_copy(LIQUID_MODEM_QPSK);      }\nvoid autotest_modem_copy_ook()       { modemcf_test_copy(LIQUID_MODEM_OOK);       }\nvoid autotest_modem_copy_sqam32()    { modemcf_test_copy(LIQUID_MODEM_SQAM32);    }\nvoid autotest_modem_copy_sqam128()   { modemcf_test_copy(LIQUID_MODEM_SQAM128);   }\nvoid autotest_modem_copy_V29()       { modemcf_test_copy(LIQUID_MODEM_V29);       }\nvoid autotest_modem_copy_arb16opt()  { modemcf_test_copy(LIQUID_MODEM_ARB16OPT);  }\nvoid autotest_modem_copy_arb32opt()  { modemcf_test_copy(LIQUID_MODEM_ARB32OPT);  }\nvoid autotest_modem_copy_arb64opt()  { modemcf_test_copy(LIQUID_MODEM_ARB64OPT);  }\nvoid autotest_modem_copy_arb128opt() { modemcf_test_copy(LIQUID_MODEM_ARB128OPT); }\nvoid autotest_modem_copy_arb256opt() { modemcf_test_copy(LIQUID_MODEM_ARB256OPT); }\nvoid autotest_modem_copy_arb64vt()   { modemcf_test_copy(LIQUID_MODEM_ARB64VT);   }\nvoid autotest_modem_copy_pi4dqpsk()  { modemcf_test_copy(LIQUID_MODEM_PI4DQPSK);  }')
"
"('Prompt: Your task is to write a C function that takes a floating-point value, a unit character pointer, and a scale pointer as arguments. The function should determine the appropriate scale factor and unit prefix to represent the value in engineering notation. The function should set the scale factor and unit prefix based on the magnitude of the input value according to the following criteria: p (10^-12) for values less than 1e-9, n (10^-9) for values less than 1e-6, u (10^-6) for values less than 1e-3, m (10^-3) for values less than 1e0, k (10^3) for values less than 1e6, M (10^6) for values less than 1e9, G (10^9) for values less than 1e12, T (10^12) for values less than 1e15, and P (10^","//...\nint liquid_get_scale(float   _val,\n                     char *  _unit,\n                     float * _scale)\n{\n    float v = fabsf(_val);\n    if      (v < 1e-9) { *_scale = 1e12;  *_unit = 'p'; }\n    else if (v < 1e-6) { *_scale = 1e9 ;  *_unit = 'n'; }\n    else if (v < 1e-3) { *_scale = 1e6 ;  *_unit = 'u'; }\n    else if (v < 1e+0) { *_scale = 1e3 ;  *_unit = 'm'; }\n    else if (v < 1e3)  { *_scale = 1e0 ;  *_unit = ' '; }\n    else if (v < 1e6)  { *_scale = 1e-3;  *_unit = 'k'; }\n    else if (v < 1e9)  { *_scale = 1e-6;  *_unit = 'M'; }\n    else if (v < 1e12) { *_scale = 1e-9;  *_unit = 'G'; }\n    else if (v < 1e15) { *_scale = 1e-12; *_unit = 'T'; }\n    else               { *_scale = 1e-15; *_unit = 'P'; }\n    return LIQUID_OK;\n}\n//..."")
"
('Prompt: You are working on a flight simulation software that includes a function to reset the pilot generator. Please provide code for the function qpilotgen_reset that takes a qpilotgen object and returns LIQUID_OK when the reset is successful.,"//...\nint qpilotgen_reset(qpilotgen _q)\n{\n    return LIQUID_OK;\n}\n//...')
"
('Write a code snippet that tests whether different forward error correction (FEC) schemes are convolutional or not. The code should use the `fec_scheme_is_convolutional` function to check this for various FEC schemes. The output of the test should indicate whether each scheme is convolutional (1) or not (0).,"//...\nvoid autotest_fec_is_convolutional()\n{\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_NONE),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_REP3),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_REP5),        0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_HAMMING74),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_HAMMING84),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_HAMMING128),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_GOLAY2412),   0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_SECDED2216),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_SECDED3932),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_SECDED7264),  0 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27),    1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29),    1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V39),    1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V615),   1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P23), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P34), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P45), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P56), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P67), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V27P78), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P23), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P34), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P45), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P56), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P67), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_CONV_V29P78), 1 );\n    CONTEND_EQUALITY( fec_scheme_is_convolutional(LIQUID_FEC_RS_M8),       0 );\n}\n//...')
"
('Please provide a prompt for creating a test scenario for a function that performs a sum of squares calculation on a set of numbers. Include details such as the input parameters and expected output values.,"//...\nfloat sumsqf_test_x3[3];    float sumsqf_test_y3;\nfloat sumsqf_test_y7 = 0.545767182598435;\nvoid sumsqf_runtest(float *      _x,\n                    unsigned int _n,\n                    float        _y)\n{\n    float tol = 1e-6;   \n    float y = liquid_sumsqf(_x, _n);\n    CONTEND_DELTA( y, _y, tol );\n}\nvoid autotest_sumsqf_7()    {   sumsqf_runtest( sumsqf_test_x7,  7,  sumsqf_test_y7  ); }\n//...')
"
"'Provide a prompt to generate code for handling CSI driver fragments in a technical scenario where a CSI driver is used to capture images from a camera module connected to a microcontroller:. . ""Generate code for handling CSI driver fragments in a scenario where a CSI driver is used to capture images from a camera module connected to a microcontroller. Include functions for initializing, deinitializing, creating handles, transferring image data, aborting image capture, and handling interrupts for CSI driver fragments.""","#if CSI_DRIVER_FRAG_MODE\n#endif\n#if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET\n#endif\n#if (!defined(CSI_CR3_TWO_8BIT_SENSOR_MASK) && defined(CSI_CR3_SENSOR_16BITS_MASK))\n#define CSI_CR3_TWO_8BIT_SENSOR_MASK CSI_CR3_SENSOR_16BITS_MASK\n#endif\n#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.csi""\n#endif\n#define CSI_MAX_ACTIVE_FRAME_NUM 2U\n#define CSI_FRAG_INPUT_BYTES_PER_PIXEL 2U\n#if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET\n#define CSI_ADDR_CPU_2_IP(addr) (MEMORY_ConvertMemoryMapAddress((uint32_t)(addr), kMEMORY_Local2DMA))\n#define CSI_ADDR_IP_2_CPU(addr) (MEMORY_ConvertMemoryMapAddress((uint32_t)(addr), kMEMORY_DMA2Local))\n#else\n#define CSI_ADDR_CPU_2_IP(addr) (addr)\n#define CSI_ADDR_IP_2_CPU(addr) (addr)\n#endif \ntypedef union pvoid_to_u32\n{\n    void *pvoid;\n    uint32_t u32;\n} pvoid_to_u32_t;\nstatic uint32_t CSI_GetInstance(CSI_Type *base);\n#if !CSI_DRIVER_FRAG_MODE\nstatic uint8_t CSI_TransferGetQueueDelta(uint8_t startIdx, uint8_t endIdx);\nstatic uint8_t CSI_TransferIncreaseQueueIdx(uint8_t idx);\nstatic uint32_t CSI_TransferGetEmptyBufferCount(csi_handle_t *handle);\nstatic uint32_t CSI_TransferGetEmptyBuffer(csi_handle_t *handle);\nstatic void CSI_TransferPutEmptyBuffer(csi_handle_t *handle, uint32_t buffer);\nstatic uint32_t CSI_GetRxBufferAddr(CSI_Type *base, uint8_t index);\ntypedef void (*csi_isr_t)(CSI_Type *base, csi_handle_t *handle);\n#else\ntypedef void (*csi_isr_t)(CSI_Type *base, csi_frag_handle_t *handle);\n#endif \nstatic CSI_Type *const s_csiBases[] = CSI_BASE_PTRS;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_csiClocks[] = CSI_CLOCKS;\n#endif \n#if !CSI_DRIVER_FRAG_MODE\nstatic csi_handle_t *s_csiHandle[ARRAY_SIZE(s_csiBases)];\n#else\nstatic csi_frag_handle_t *s_csiHandle[ARRAY_SIZE(s_csiBases)];\n#endif\nstatic const IRQn_Type s_csiIRQ[] = CSI_IRQS;\n#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)\nstatic csi_isr_t s_csiIsr = (csi_isr_t)DefaultISR;\n#else\nstatic csi_isr_t s_csiIsr;\n#endif\nstatic uint32_t CSI_GetInstance(CSI_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_csiBases); instance++)\n    {\n        if (s_csiBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_csiBases));\n    return instance;\n}\n#if !CSI_DRIVER_FRAG_MODE\nstatic uint8_t CSI_TransferGetQueueDelta(uint8_t startIdx, uint8_t endIdx)\n{\n    uint8_t ret;\n    if (endIdx >= startIdx)\n    {\n        ret = endIdx - startIdx;\n    }\n    else\n    {\n        ret = (uint8_t)(endIdx + CSI_DRIVER_ACTUAL_QUEUE_SIZE - startIdx);\n    }\n    return ret;\n}\nstatic uint8_t CSI_TransferIncreaseQueueIdx(uint8_t idx)\n{\n    uint8_t ret;\n    ret = idx + 1U;\n    if (ret >= CSI_DRIVER_ACTUAL_QUEUE_SIZE)\n    {\n        ret = 0U;\n    }\n    return ret;\n}\nstatic uint32_t CSI_TransferGetEmptyBufferCount(csi_handle_t *handle)\n{\n    return handle->emptyBufferCnt;\n}\nstatic uint32_t CSI_TransferGetEmptyBuffer(csi_handle_t *handle)\n{\n    pvoid_to_u32_t buf;\n    buf.pvoid = handle->emptyBuffer;\n    handle->emptyBufferCnt--;\n    handle->emptyBuffer = *(void **)(buf.pvoid);\n    return buf.u32;\n}\nstatic void CSI_TransferPutEmptyBuffer(csi_handle_t *handle, uint32_t buffer)\n{\n    pvoid_to_u32_t buf;\n    buf.u32 = buffer;\n    *(void **)(buf.pvoid) = handle->emptyBuffer;\n    handle->emptyBuffer   = buf.pvoid;\n    handle->emptyBufferCnt++;\n}\nstatic uint32_t CSI_GetRxBufferAddr(CSI_Type *base, uint8_t index)\n{\n    uint32_t addr;\n    if (index != 0U)\n    {\n        addr = CSI_REG_DMASA_FB2(base);\n    }\n    else\n    {\n        addr = CSI_REG_DMASA_FB1(base);\n    }\n    return CSI_ADDR_IP_2_CPU(addr);\n}\n#endif \nstatus_t CSI_Init(CSI_Type *base, const csi_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t reg;\n    uint32_t imgWidth_Bytes;\n    uint8_t busCyclePerPixel;\n    imgWidth_Bytes = (uint32_t)config->width * (uint32_t)config->bytesPerPixel;\n    if ((0U != (imgWidth_Bytes & 0x07U)) || (0U != ((uint32_t)config->linePitch_Bytes & 0x07U)))\n    {\n        return kStatus_InvalidArgument;\n    }\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    uint32_t instance = CSI_GetInstance(base);\n    CLOCK_EnableClock(s_csiClocks[instance]);\n#endif\n    CSI_Reset(base);\n    reg = ((uint32_t)config->workMode) | config->polarityFlags | CSI_CR1_FCC_MASK;\n    if (config->useExtVsync)\n    {\n        reg |= CSI_CR1_EXT_VSYNC_MASK;\n    }\n    CSI_REG_CR1(base) = reg;\n    if ((kCSI_DataBus8Bit == config->dataBus) && (2U == config->bytesPerPixel))\n    {\n        busCyclePerPixel = 2U;\n    }\n    else\n    {\n        busCyclePerPixel = 1U;\n    }\n    if (4U == config->bytesPerPixel)\n    {\n        CSI_REG_CR18(base) |= CSI_CR18_PARALLEL24_EN_MASK;\n    }\n    if (kCSI_DataBus16Bit == config->dataBus)\n    {\n        CSI_REG_CR3(base) |= CSI_CR3_TWO_8BIT_SENSOR_MASK;\n    }\n    CSI_REG_IMAG_PARA(base) =\n        (((uint32_t)config->width * (uint32_t)busCyclePerPixel) << CSI_IMAG_PARA_IMAGE_WIDTH_SHIFT) |\n        ((uint32_t)(config->height) << CSI_IMAG_PARA_IMAGE_HEIGHT_SHIFT);\n    CSI_REG_FBUF_PARA(base) = (uint32_t)((config->linePitch_Bytes - imgWidth_Bytes) / 8U)\n                              << CSI_FBUF_PARA_FBUF_STRIDE_SHIFT;\n    CSI_REG_CR3(base) |= CSI_CR3_ECC_AUTO_EN_MASK;\n    if (0U == (imgWidth_Bytes % (8U * 16U)))\n    {\n        CSI_REG_CR2(base) = CSI_CR2_DMA_BURST_TYPE_RFF(3U);\n        CSI_REG_CR3(base) = (CSI_REG_CR3(base) & ~CSI_CR3_RxFF_LEVEL_MASK) | ((2U << CSI_CR3_RxFF_LEVEL_SHIFT));\n    }\n    else if (0U == (imgWidth_Bytes % (8U * 8U)))\n    {\n        CSI_REG_CR2(base) = CSI_CR2_DMA_BURST_TYPE_RFF(2U);\n        CSI_REG_CR3(base) = (CSI_REG_CR3(base) & ~CSI_CR3_RxFF_LEVEL_MASK) | ((1U << CSI_CR3_RxFF_LEVEL_SHIFT));\n    }\n    else\n    {\n        CSI_REG_CR2(base) = CSI_CR2_DMA_BURST_TYPE_RFF(1U);\n        CSI_REG_CR3(base) = (CSI_REG_CR3(base) & ~CSI_CR3_RxFF_LEVEL_MASK) | ((0U << CSI_CR3_RxFF_LEVEL_SHIFT));\n    }\n    CSI_ReflashFifoDma(base, kCSI_RxFifo);\n    return kStatus_Success;\n}\nvoid CSI_Deinit(CSI_Type *base)\n{\n    CSI_Stop(base);\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    uint32_t instance = CSI_GetInstance(base);\n    CLOCK_DisableClock(s_csiClocks[instance]);\n#endif\n}\nvoid CSI_Reset(CSI_Type *base)\n{\n    uint32_t csisr;\n    CSI_Stop(base);\n    CSI_REG_CR3(base) = 0U;\n    CSI_REG_CR3(base) |= CSI_CR3_FRMCNT_RST_MASK;\n    while (0U != (CSI_REG_CR3(base) & CSI_CR3_FRMCNT_RST_MASK))\n    {\n    }\n    CSI_ClearFifo(base, kCSI_AllFifo);\n    CSI_ReflashFifoDma(base, kCSI_AllFifo);\n    csisr            = CSI_REG_SR(base);\n    CSI_REG_SR(base) = csisr;\n    CSI_REG_CR1(base) = CSI_CR1_HSYNC_POL_MASK | CSI_CR1_EXT_VSYNC_MASK;\n    CSI_REG_CR2(base) = 0U;\n    CSI_REG_CR3(base) = 0U;\n#if defined(CSI_CR18_CSI_LCDIF_BUFFER_LINES)\n    CSI_REG_CR18(base) = CSI_CR18_AHB_HPROT(0x0DU) | CSI_CR18_CSI_LCDIF_BUFFER_LINES(0x02U);\n#else\n    CSI_REG_CR18(base) = CSI_CR18_AHB_HPROT(0x0DU);\n#endif\n    CSI_REG_FBUF_PARA(base) = 0U;\n    CSI_REG_IMAG_PARA(base) = 0U;\n}\nvoid CSI_GetDefaultConfig(csi_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n    config->width           = 320U;\n    config->height          = 240U;\n    config->polarityFlags   = (uint32_t)kCSI_HsyncActiveHigh | (uint32_t)kCSI_DataLatchOnRisingEdge;\n    config->bytesPerPixel   = 2U;\n    config->linePitch_Bytes = 320U * 2U;\n    config->workMode        = kCSI_GatedClockMode;\n    config->dataBus         = kCSI_DataBus8Bit;\n    config->useExtVsync     = true;\n}\nvoid CSI_SetRxBufferAddr(CSI_Type *base, uint8_t index, uint32_t addr)\n{\n    addr = CSI_ADDR_CPU_2_IP(addr);\n    if (0U != index)\n    {\n        CSI_REG_DMASA_FB2(base) = addr;\n    }\n    else\n    {\n        CSI_REG_DMASA_FB1(base) = addr;\n    }\n}\nvoid CSI_ClearFifo(CSI_Type *base, csi_fifo_t fifo)\n{\n    uint32_t cr1;\n    uint32_t mask = 0U;\n    cr1               = CSI_REG_CR1(base);\n    CSI_REG_CR1(base) = (cr1 & ~CSI_CR1_FCC_MASK);\n    if (0U != ((uint32_t)fifo & (uint32_t)kCSI_RxFifo))\n    {\n        mask |= CSI_CR1_CLR_RXFIFO_MASK;\n    }\n    if (0U != ((uint32_t)fifo & (uint32_t)kCSI_StatFifo))\n    {\n        mask |= CSI_CR1_CLR_STATFIFO_MASK;\n    }\n    CSI_REG_CR1(base) = (cr1 & ~CSI_CR1_FCC_MASK) | mask;\n    while (0U != (CSI_REG_CR1(base) & mask))\n    {\n    }\n    CSI_REG_CR1(base) = cr1;\n}\nvoid CSI_ReflashFifoDma(CSI_Type *base, csi_fifo_t fifo)\n{\n    uint32_t cr3 = 0U;\n    if (0U != ((uint32_t)fifo & (uint32_t)kCSI_RxFifo))\n    {\n        cr3 |= CSI_CR3_DMA_REFLASH_RFF_MASK;\n    }\n    if (0U != ((uint32_t)fifo & (uint32_t)kCSI_StatFifo))\n    {\n        cr3 |= CSI_CR3_DMA_REFLASH_SFF_MASK;\n    }\n    CSI_REG_CR3(base) |= cr3;\n    while (0U != (CSI_REG_CR3(base) & cr3))\n    {\n    }\n}\nvoid CSI_EnableFifoDmaRequest(CSI_Type *base, csi_fifo_t fifo, bool enable)\n{\n    uint32_t cr3 = 0U;\n    if (0U != ((uint32_t)fifo & (uint32_t)kCSI_RxFifo))\n    {\n        cr3 |= CSI_CR3_DMA_REQ_EN_RFF_MASK;\n    }\n    if (0U != ((uint32_t)fifo & (uint32_t)kCSI_StatFifo))\n    {\n        cr3 |= CSI_CR3_DMA_REQ_EN_SFF_MASK;\n    }\n    if (enable)\n    {\n        CSI_REG_CR3(base) |= cr3;\n    }\n    else\n    {\n        CSI_REG_CR3(base) &= ~cr3;\n    }\n}\nvoid CSI_EnableInterrupts(CSI_Type *base, uint32_t mask)\n{\n    CSI_REG_CR1(base) |= (mask & CSI_CR1_INT_EN_MASK);\n    CSI_REG_CR3(base) |= (mask & CSI_CR3_INT_EN_MASK);\n    CSI_REG_CR18(base) |= ((mask & CSI_CR18_INT_EN_MASK) >> 6U);\n}\nvoid CSI_DisableInterrupts(CSI_Type *base, uint32_t mask)\n{\n    CSI_REG_CR1(base) &= ~(mask & CSI_CR1_INT_EN_MASK);\n    CSI_REG_CR3(base) &= ~(mask & CSI_CR3_INT_EN_MASK);\n    CSI_REG_CR18(base) &= ~((mask & CSI_CR18_INT_EN_MASK) >> 6U);\n}\n#if !CSI_DRIVER_FRAG_MODE\nstatus_t CSI_TransferCreateHandle(CSI_Type *base,\n                                  csi_handle_t *handle,\n                                  csi_transfer_callback_t callback,\n                                  void *userData)\n{\n    assert(NULL != handle);\n    uint32_t instance;\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->callback = callback;\n    handle->userData = userData;\n    instance = CSI_GetInstance(base);\n    s_csiHandle[instance] = handle;\n    s_csiIsr = CSI_TransferHandleIRQ;\n    (void)EnableIRQ(s_csiIRQ[instance]);\n    return kStatus_Success;\n}\nstatus_t CSI_TransferStart(CSI_Type *base, csi_handle_t *handle)\n{\n    assert(NULL != handle);\n    uint32_t emptyBufferCount;\n    emptyBufferCount = CSI_TransferGetEmptyBufferCount(handle);\n    if (emptyBufferCount < 2U)\n    {\n        return kStatus_CSI_NoEmptyBuffer;\n    }\n    CSI_REG_CR18(base) = (CSI_REG_CR18(base) & ~CSI_CR18_MASK_OPTION_MASK) | CSI_CR18_MASK_OPTION(0) |\n                         CSI_CR18_BASEADDR_SWITCH_SEL_MASK | CSI_CR18_BASEADDR_SWITCH_EN_MASK;\n    CSI_REG_DMASA_FB1(base) = CSI_ADDR_CPU_2_IP(CSI_TransferGetEmptyBuffer(handle));\n    CSI_REG_DMASA_FB2(base) = CSI_ADDR_CPU_2_IP(CSI_TransferGetEmptyBuffer(handle));\n    handle->activeBufferNum = CSI_MAX_ACTIVE_FRAME_NUM;\n    CSI_ReflashFifoDma(base, kCSI_RxFifo);\n    handle->transferStarted = true;\n    CSI_EnableInterrupts(\n        base, (uint32_t)kCSI_RxBuffer1DmaDoneInterruptEnable | (uint32_t)kCSI_RxBuffer0DmaDoneInterruptEnable);\n    CSI_Start(base);\n    return kStatus_Success;\n}\nstatus_t CSI_TransferStop(CSI_Type *base, csi_handle_t *handle)\n{\n    assert(NULL != handle);\n    uint8_t activeBufferNum;\n    uint8_t bufIdx;\n    CSI_Stop(base);\n    CSI_DisableInterrupts(\n        base, (uint32_t)kCSI_RxBuffer1DmaDoneInterruptEnable | (uint32_t)kCSI_RxBuffer0DmaDoneInterruptEnable);\n    activeBufferNum = handle->activeBufferNum;\n    handle->transferStarted = false;\n    handle->activeBufferNum = 0;\n    for (bufIdx = 0; bufIdx < activeBufferNum; bufIdx++)\n    {\n        CSI_TransferPutEmptyBuffer(handle, CSI_GetRxBufferAddr(base, bufIdx));\n    }\n    return kStatus_Success;\n}\nstatus_t CSI_TransferSubmitEmptyBuffer(CSI_Type *base, csi_handle_t *handle, uint32_t frameBuffer)\n{\n    uint32_t csicr1;\n    csicr1 = CSI_REG_CR1(base);\n    CSI_REG_CR1(base) = (csicr1 & ~(CSI_CR1_FB2_DMA_DONE_INTEN_MASK | CSI_CR1_FB1_DMA_DONE_INTEN_MASK));\n    CSI_TransferPutEmptyBuffer(handle, frameBuffer);\n    CSI_REG_CR1(base) = csicr1;\n    return kStatus_Success;\n}\nstatus_t CSI_TransferGetFullBuffer(CSI_Type *base, csi_handle_t *handle, uint32_t *frameBuffer)\n{\n    uint32_t csicr1;\n    status_t status;\n    uint8_t queueReadIdx;\n    uint8_t queueWriteIdx;\n    queueReadIdx  = handle->queueReadIdx;\n    queueWriteIdx = handle->queueWriteIdx;\n    if (queueReadIdx == queueWriteIdx)\n    {\n        status = kStatus_CSI_NoFullBuffer;\n    }\n    else\n    {\n        csicr1 = CSI_REG_CR1(base);\n        CSI_REG_CR1(base) = (csicr1 & ~(CSI_CR1_FB2_DMA_DONE_INTEN_MASK | CSI_CR1_FB1_DMA_DONE_INTEN_MASK));\n        *frameBuffer = handle->frameBufferQueue[handle->queueReadIdx];\n        handle->queueReadIdx = CSI_TransferIncreaseQueueIdx(handle->queueReadIdx);\n        CSI_REG_CR1(base) = csicr1;\n        status = kStatus_Success;\n    }\n    return status;\n}\nvoid CSI_TransferHandleIRQ(CSI_Type *base, csi_handle_t *handle)\n{\n    uint8_t queueWriteIdx;\n    uint8_t queueReadIdx;\n    uint8_t dmaDoneBufferIdx;\n    uint32_t frameBuffer;\n    uint32_t csisr = CSI_REG_SR(base);\n    CSI_REG_SR(base) = csisr;\n    if ((csisr & (CSI_SR_DMA_TSF_DONE_FB2_MASK | CSI_SR_DMA_TSF_DONE_FB1_MASK)) ==\n        (CSI_SR_DMA_TSF_DONE_FB2_MASK | CSI_SR_DMA_TSF_DONE_FB1_MASK))\n    {\n        ; \n    }\n    else if (0U != (csisr & (CSI_SR_DMA_TSF_DONE_FB2_MASK | CSI_SR_DMA_TSF_DONE_FB1_MASK)))\n    {\n        if (0U != (csisr & CSI_SR_DMA_TSF_DONE_FB2_MASK))\n        {\n            dmaDoneBufferIdx = 1;\n        }\n        else\n        {\n            dmaDoneBufferIdx = 0;\n        }\n        if (handle->activeBufferNum == CSI_MAX_ACTIVE_FRAME_NUM)\n        {\n            queueWriteIdx = handle->queueWriteIdx;\n            queueReadIdx  = handle->queueReadIdx;\n            if (CSI_TransferGetQueueDelta(queueReadIdx, queueWriteIdx) < CSI_DRIVER_QUEUE_SIZE)\n            {\n                frameBuffer                             = CSI_GetRxBufferAddr(base, dmaDoneBufferIdx);\n                handle->frameBufferQueue[queueWriteIdx] = frameBuffer;\n                handle->queueWriteIdx = CSI_TransferIncreaseQueueIdx(queueWriteIdx);\n                handle->activeBufferNum--;\n                if (NULL != handle->callback)\n                {\n                    handle->callback(base, handle, kStatus_CSI_FrameDone, handle->userData);\n                }\n            }\n            else\n            {\n            }\n        }\n        if (handle->activeBufferNum < CSI_MAX_ACTIVE_FRAME_NUM)\n        {\n            if (CSI_TransferGetEmptyBufferCount(handle) > 0U)\n            {\n                CSI_SetRxBufferAddr(base, dmaDoneBufferIdx, CSI_TransferGetEmptyBuffer(handle));\n                handle->activeBufferNum++;\n            }\n            else\n            {\n                frameBuffer = CSI_GetRxBufferAddr(base, dmaDoneBufferIdx ^ 1U);\n                CSI_SetRxBufferAddr(base, dmaDoneBufferIdx, frameBuffer);\n            }\n        }\n    }\n    else\n    {\n    }\n}\n#else \n#if defined(__CC_ARM)\n__asm void CSI_ExtractYFromYUYV(void *datBase, const void *dmaBase, size_t count)\n{\n    push    {r4-r7, lr}\n10\n    LDMIA    R1!, {r3-r6}\n    bfi      r7, r3, #0, #8  \n    bfi      ip, r5, #0, #8  \n    lsr      r3, r3, #16\n    lsr      r5, r5, #16\n    bfi      r7, r3, #8, #8  \n    bfi      ip, r5, #8, #8  \n    bfi      r7, r4, #16, #8 \n    bfi      ip, r6, #16, #8 \n    lsr      r4, r4, #16\n    lsr      r6, r6, #16\n    bfi      r7, r4, #24, #8 \n    bfi      ip, r6, #24, #8 \n    STMIA    r0!, {r7, ip}\n    subs     r2, #8\n    bne      %b10\n    pop      {r4-r7, pc}\n}\n__asm void CSI_ExtractYFromUYVY(void *datBase, const void *dmaBase, size_t count)\n{\n    push    {r4-r7, lr}\n10\n    LDMIA    R1!, {r3-r6}\n    lsr      r3, r3, #8\n    lsr      r5, r5, #8\n    bfi      r7, r3, #0, #8  \n    bfi      ip, r5, #0, #8  \n    lsr      r3, r3, #16\n    lsr      r5, r5, #16\n    bfi      r7, r3, #8, #8  \n    bfi      ip, r5, #8, #8  \n    lsr      r4, r4, #8\n    lsr      r6, r6, #8\n    bfi      r7, r4, #16, #8 \n    bfi      ip, r6, #16, #8 \n    lsr      r4, r4, #16\n    lsr      r6, r6, #16\n    bfi      r7, r4, #24, #8 \n    bfi      ip, r6, #24, #8 \n    STMIA    r0!, {r7, ip}\n    subs     r2, #8\n    bne      %b10\n    pop      {r4-r7, pc}\n}\n#elif (defined(__GNUC__) || defined(__ICCARM__)) || defined(__ARMCC_VERSION)\n#if defined(__ICCARM__)\n#pragma diag_suppress = Pe940\n#endif\n__attribute__((naked)) void CSI_ExtractYFromYUYV(void *datBase, const void *dmaBase, size_t count);\nvoid CSI_ExtractYFromYUYV(void *datBase, const void *dmaBase, size_t count)\n{\n    __asm volatile(\n        ""    push    {r1-r7, r12, lr}  \\n""\n        ""loop0:                        \\n""\n        ""    ldmia   r1!, {r3-r6}      \\n""\n        ""    bfi     r7, r3, #0, #8    \\n"" \n        ""    bfi     r12, r5, #0, #8   \\n"" \n        ""    lsr     r3, r3, #16       \\n""\n        ""    lsr     r5, r5, #16       \\n""\n        ""    bfi     r7, r3, #8, #8    \\n"" \n        ""    bfi     r12, r5, #8, #8   \\n"" \n        ""    bfi     r7, r4, #16, #8   \\n"" \n        ""    bfi     r12, r6, #16, #8  \\n"" \n        ""    lsr     r4, r4, #16       \\n""\n        ""    lsr     r6, r6, #16       \\n""\n        ""    bfi     r7, r4, #24, #8   \\n"" \n        ""    bfi     r12, r6, #24, #8  \\n"" \n        ""    stmia   r0!, {r7, r12}    \\n""\n        ""    subs    r2, #8            \\n""\n        ""    bne     loop0             \\n""\n        ""    pop     {r1-r7, r12, pc}  \\n"");\n}\n__attribute__((naked)) void CSI_ExtractYFromUYVY(void *datBase, const void *dmaBase, size_t count);\nvoid CSI_ExtractYFromUYVY(void *datBase, const void *dmaBase, size_t count)\n{\n    __asm volatile(\n        ""    push    {r1-r7, r12, lr}  \\n""\n        ""loop1:                        \\n""\n        ""    ldmia   r1!, {r3-r6}      \\n""\n        ""    lsr     r3, r3, #8        \\n""\n        ""    lsr     r5, r5, #8        \\n""\n        ""    bfi     r7, r3, #0, #8    \\n"" \n        ""    bfi     r12, r5, #0, #8   \\n"" \n        ""    lsr     r3, r3, #16       \\n""\n        ""    lsr     r5, r5, #16       \\n""\n        ""    bfi     r7, r3, #8, #8    \\n"" \n        ""    bfi     r12, r5, #8, #8   \\n"" \n        ""    lsr     r4, r4, #8        \\n""\n        ""    lsr     r6, r6, #8        \\n""\n        ""    bfi     r7, r4, #16, #8   \\n"" \n        ""    bfi     r12, r6, #16, #8  \\n"" \n        ""    lsr     r4, r4, #16       \\n""\n        ""    lsr     r6, r6, #16       \\n""\n        ""    bfi     r7, r4, #24, #8   \\n"" \n        ""    bfi     r12, r6, #24, #8  \\n"" \n        ""    stmia   r0!, {r7, r12}    \\n""\n        ""    subs    r2, #8            \\n""\n        ""    bne     loop1             \\n""\n        ""    pop     {r1-r7, r12, pc}  \\n"");\n}\n#if defined(__ICCARM__)\n#pragma diag_default = Pe940\n#endif\n#else\n#error Toolchain not supported.\n#endif\nstatic void CSI_MemCopy(void *pDest, const void *pSrc, size_t cnt)\n{\n    (void)memcpy(pDest, pSrc, cnt);\n}\nvoid CSI_FragModeInit(CSI_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    uint32_t instance = CSI_GetInstance(base);\n    CLOCK_EnableClock(s_csiClocks[instance]);\n#endif\n    CSI_Reset(base);\n}\nvoid CSI_FragModeDeinit(CSI_Type *base)\n{\n    CSI_Deinit(base);\n}\nstatus_t CSI_FragModeCreateHandle(CSI_Type *base,\n                                  csi_frag_handle_t *handle,\n                                  const csi_frag_config_t *config,\n                                  csi_frag_transfer_callback_t callback,\n                                  void *userData)\n{\n    assert(NULL != config);\n    uint32_t reg;\n    uint32_t instance;\n    uint32_t imgWidth_Bytes;\n    if (config->dataBus != kCSI_DataBus8Bit)\n    {\n        return kStatus_InvalidArgument;\n    }\n    imgWidth_Bytes = (uint32_t)config->width * CSI_FRAG_INPUT_BYTES_PER_PIXEL;\n    if ((imgWidth_Bytes & 0x07U) != 0U)\n    {\n        return kStatus_InvalidArgument;\n    }\n    if (config->height % config->dmaBufferLine != 0U)\n    {\n        return kStatus_InvalidArgument;\n    }\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->callback            = callback;\n    handle->userData            = userData;\n    handle->height              = config->height;\n    handle->width               = config->width;\n    handle->maxLinePerFrag      = config->dmaBufferLine;\n    handle->dmaBytePerLine      = config->width * CSI_FRAG_INPUT_BYTES_PER_PIXEL;\n    handle->isDmaBufferCachable = config->isDmaBufferCachable;\n    instance = CSI_GetInstance(base);\n    s_csiHandle[instance] = handle;\n    s_csiIsr = CSI_FragModeTransferHandleIRQ;\n    (void)EnableIRQ(s_csiIRQ[instance]);\n    reg = ((uint32_t)config->workMode) | config->polarityFlags | CSI_CR1_FCC_MASK;\n    if (config->useExtVsync)\n    {\n        reg |= CSI_CR1_EXT_VSYNC_MASK;\n    }\n    CSI_REG_CR1(base) = reg;\n    CSI_REG_FBUF_PARA(base) = 0;\n    CSI_REG_CR3(base) |= CSI_CR3_ECC_AUTO_EN_MASK;\n    if (0U == (imgWidth_Bytes % (8U * 16U)))\n    {\n        CSI_REG_CR2(base) = CSI_CR2_DMA_BURST_TYPE_RFF(3U);\n        CSI_REG_CR3(base) = (CSI_REG_CR3(base) & ~CSI_CR3_RxFF_LEVEL_MASK) | ((2U << CSI_CR3_RxFF_LEVEL_SHIFT));\n    }\n    else if (0U == (imgWidth_Bytes % (8U * 8U)))\n    {\n        CSI_REG_CR2(base) = CSI_CR2_DMA_BURST_TYPE_RFF(2U);\n        CSI_REG_CR3(base) = (CSI_REG_CR3(base) & ~CSI_CR3_RxFF_LEVEL_MASK) | ((1U << CSI_CR3_RxFF_LEVEL_SHIFT));\n    }\n    else\n    {\n        CSI_REG_CR2(base) = CSI_CR2_DMA_BURST_TYPE_RFF(1U);\n        CSI_REG_CR3(base) = (CSI_REG_CR3(base) & ~CSI_CR3_RxFF_LEVEL_MASK) | ((0U << CSI_CR3_RxFF_LEVEL_SHIFT));\n    }\n    CSI_REG_DMASA_FB1(base) = CSI_ADDR_CPU_2_IP(config->dmaBufferAddr0);\n    CSI_REG_DMASA_FB2(base) = CSI_ADDR_CPU_2_IP(config->dmaBufferAddr1);\n    if (handle->isDmaBufferCachable)\n    {\n        DCACHE_CleanInvalidateByRange(\n            config->dmaBufferAddr0,\n            (uint32_t)config->dmaBufferLine * (uint32_t)config->width * CSI_FRAG_INPUT_BYTES_PER_PIXEL);\n        DCACHE_CleanInvalidateByRange(\n            config->dmaBufferAddr1,\n            (uint32_t)config->dmaBufferLine * (uint32_t)config->width * CSI_FRAG_INPUT_BYTES_PER_PIXEL);\n    }\n    return kStatus_Success;\n}\nstatus_t CSI_FragModeTransferCaptureImage(CSI_Type *base,\n                                          csi_frag_handle_t *handle,\n                                          const csi_frag_capture_config_t *config)\n{\n    assert(NULL != config);\n    uint16_t windowWidth;\n    if (config->window != NULL)\n    {\n        handle->windowULX   = config->window->windowULX;\n        handle->windowULY   = config->window->windowULY;\n        handle->windowLRX   = config->window->windowLRX;\n        handle->windowLRY   = config->window->windowLRY;\n        handle->linePerFrag = 1;\n    }\n    else\n    {\n        handle->windowULX   = 0;\n        handle->windowULY   = 0;\n        handle->windowLRX   = handle->width - 1U;\n        handle->windowLRY   = handle->height - 1U;\n        handle->linePerFrag = handle->maxLinePerFrag;\n    }\n    windowWidth = handle->windowLRX - handle->windowULX + 1U;\n    if (config->outputGrayScale)\n    {\n        if (windowWidth % 8U != 0U)\n        {\n            return kStatus_InvalidArgument;\n        }\n        handle->datBytePerLine = windowWidth;\n        if (handle->inputFormat == kCSI_FragInputYUYV)\n        {\n            handle->copyFunc = CSI_ExtractYFromYUYV;\n        }\n        else\n        {\n            handle->copyFunc = CSI_ExtractYFromUYVY;\n        }\n    }\n    else\n    {\n        handle->datBytePerLine = windowWidth * CSI_FRAG_INPUT_BYTES_PER_PIXEL;\n        handle->copyFunc       = CSI_MemCopy;\n    }\n    handle->dmaCurLine      = 0;\n    handle->outputBuffer    = (uint32_t)config->buffer;\n    handle->datCurWriteAddr = (uint32_t)config->buffer;\n    CSI_REG_IMAG_PARA(base) =\n        (((uint32_t)handle->width * CSI_FRAG_INPUT_BYTES_PER_PIXEL) << CSI_IMAG_PARA_IMAGE_WIDTH_SHIFT) |\n        ((uint32_t)(handle->linePerFrag) << CSI_IMAG_PARA_IMAGE_HEIGHT_SHIFT);\n    CSI_REG_CR18(base) = (CSI_REG_CR18(base) & ~CSI_CR18_MASK_OPTION_MASK) | CSI_CR18_MASK_OPTION(0);\n    CSI_EnableInterrupts(base, (uint32_t)kCSI_StartOfFrameInterruptEnable |\n                                   (uint32_t)kCSI_RxBuffer1DmaDoneInterruptEnable |\n                                   (uint32_t)kCSI_RxBuffer0DmaDoneInterruptEnable);\n    return kStatus_Success;\n}\nvoid CSI_FragModeTransferAbortCaptureImage(CSI_Type *base, csi_frag_handle_t *handle)\n{\n    CSI_Stop(base);\n    CSI_DisableInterrupts(base, (uint32_t)kCSI_StartOfFrameInterruptEnable |\n                                    (uint32_t)kCSI_RxBuffer1DmaDoneInterruptEnable |\n                                    (uint32_t)kCSI_RxBuffer0DmaDoneInterruptEnable);\n}\nvoid CSI_FragModeTransferHandleIRQ(CSI_Type *base, csi_frag_handle_t *handle)\n{\n    uint32_t csisr = CSI_REG_SR(base);\n    uint32_t dmaBufAddr;\n    uint16_t line;\n    pvoid_to_u32_t memSrc;\n    pvoid_to_u32_t memDest;\n    CSI_REG_SR(base) = csisr;\n    if (0U != (csisr & (uint32_t)kCSI_StartOfFrameFlag))\n    {\n        CSI_REG_CR3(base) |= (CSI_CR3_DMA_REFLASH_RFF_MASK | CSI_CR3_DMA_REQ_EN_RFF_MASK);\n        CSI_Start(base);\n        handle->dmaCurLine      = 0;\n        handle->datCurWriteAddr = handle->outputBuffer;\n    }\n    else if ((csisr & (CSI_SR_DMA_TSF_DONE_FB2_MASK | CSI_SR_DMA_TSF_DONE_FB1_MASK)) != 0U)\n    {\n        if ((csisr & CSI_SR_DMA_TSF_DONE_FB1_MASK) == CSI_SR_DMA_TSF_DONE_FB1_MASK)\n        {\n            dmaBufAddr = CSI_REG_DMASA_FB1(base);\n        }\n        else\n        {\n            dmaBufAddr = CSI_REG_DMASA_FB2(base);\n        }\n        dmaBufAddr = CSI_ADDR_IP_2_CPU(dmaBufAddr);\n        if (handle->isDmaBufferCachable)\n        {\n            DCACHE_InvalidateByRange(dmaBufAddr, (uint32_t)handle->dmaBytePerLine * (uint32_t)handle->linePerFrag);\n        }\n        dmaBufAddr += ((uint32_t)handle->windowULX * CSI_FRAG_INPUT_BYTES_PER_PIXEL);\n        for (line = 0; line < handle->linePerFrag; line++)\n        {\n            if (handle->dmaCurLine + line > handle->windowLRY)\n            {\n                break;\n            }\n            else if (handle->dmaCurLine + line >= handle->windowULY)\n            {\n                memDest.u32 = handle->datCurWriteAddr;\n                memSrc.u32  = dmaBufAddr;\n                handle->copyFunc(memDest.pvoid, memSrc.pvoid, handle->datBytePerLine);\n                handle->datCurWriteAddr += handle->datBytePerLine;\n                dmaBufAddr += handle->dmaBytePerLine;\n            }\n            else\n            {\n                ; \n            }\n        }\n        handle->dmaCurLine += handle->linePerFrag;\n        if (handle->dmaCurLine >= handle->height)\n        {\n            CSI_Stop(base);\n            CSI_DisableInterrupts(base, (uint32_t)kCSI_StartOfFrameInterruptEnable |\n                                            (uint32_t)kCSI_RxBuffer1DmaDoneInterruptEnable |\n                                            (uint32_t)kCSI_RxBuffer0DmaDoneInterruptEnable);\n            if (NULL != handle->callback)\n            {\n                handle->callback(base, handle, kStatus_CSI_FrameDone, handle->userData);\n            }\n        }\n    }\n    else\n    {\n    }\n}\n#endif \n#if defined(CSI)\nvoid CSI_DriverIRQHandler(void);\nvoid CSI_DriverIRQHandler(void)\n{\n    s_csiIsr(CSI, s_csiHandle[0]);\n    SDK_ISR_EXIT_BARRIER;\n}\n#endif\n#if defined(CSI0)\nvoid CSI0_DriverIRQHandler(void);\nvoid CSI0_DriverIRQHandler(void)\n{\n    s_csiIsr(CSI, s_csiHandle[0]);\n    SDK_ISR_EXIT_BARRIER;\n}\n#endif'"
"('Prompt: You are working on a project where you need to implement a function for modem symbol constellation mapping. You want to create a function that will search for the nearest neighbors to a reference point in the constellation. The function should take in the complex symbol array, the constellation size, the reference point array, the number of points to search for, an index array to store the results, and the step size for the search. Additionally, you need a function to count the number of unassigned constellation points. Can you provide me with the C code for these functions?","//...\nvoid modemcf_arbref_search(float complex * _c,\n                         unsigned int _M,\n                         float complex * _cref,\n                         unsigned int _p,\n                         unsigned char * _index,\n                         unsigned int _s)\n{\n    if (_M < 2) {\n        fprintf(stderr,""error: modemcf_arbref_search(), input constellation size too small\\n"");\n        exit(1);\n    } else if (_s > _M) {\n        fprintf(stderr,""error: modemcf_arbref_search(), index size exceeds constellation size\\n"");\n        exit(1);\n    }\n    unsigned int i;\n    for (i=0; i<_p; i++)\n        modemcf_arbref_search_point(_c, _M, _cref[i], &_index[_s*i], _s);\n}\nvoid modemcf_arbref_search_point(float complex * _c,\n                               unsigned int _M,\n                               float complex _cref,\n                               unsigned char * _index,\n                               unsigned int _s)\n{\n#if DEBUG\n    printf(""searching neighbors to (%8.3f,%8.3f)\\n"", crealf(_cref), cimagf(_cref));\n#endif\n    unsigned char selected[_M];\n    memset(selected, 0x00, _M);\n    unsigned int i;\n    unsigned int n;\n    for (n=0; n<_s; n++) {\n        int min_found = 0;\n        float d;\n        float dmin = 0.0f;\n        unsigned int index_min = 0;\n        for (i=0; i<_M; i++) {\n            if (selected[i]==1)\n                continue;\n            d = crealf( (_c[i]-_cref)*conjf(_c[i]-_cref) );\n            if ( d < dmin || !min_found ) {\n                dmin = d;\n                index_min = i;\n                min_found = 1;\n            }\n        }\n        _index[n] = index_min;\n        selected[index_min] = 1;\n#if DEBUG\n        printf(""%6u (%8.3f,%8.3f)\\n"", index_min, crealf(_c[index_min]), cimagf(_c[index_min]));\n#endif\n    }\n}\nunsigned int modemcf_arbref_search_unassigned(unsigned char * _index,\n                                            unsigned int _M,\n                                            unsigned int _p,\n                                            unsigned int _s,\n                                            unsigned char * _assigned)\n{\n    unsigned int num_unassigned = 0;\n    unsigned int i;\n    for (i=0; i<_M; i++) {\n        _assigned[i] = 0;\n        unsigned int j;\n        for (j=0; j<_p; j++) {\n            unsigned int k;\n            for (k=0; k<_s; k++) {\n                if (_index[j*_s+k] == i)\n                    _assigned[i] = 1;\n            }\n        }\n        if (!_assigned[i])\n            num_unassigned++;\n    }\n    return num_unassigned;\n}\n//...')
"
'Please provide the technical scenario or requirements for which you need the code implementation.,"//...\nstatic mqtt_msg pubmsg;\n    char* host;         \n    int port;\n    opts.mqtt_version = MQTTVERSION_3_1_1;\n#define LOGA_DEBUG 0\nint tests = 0;\n    return failures;\nFILE* xml;\n    global_start_time = start_clock();\n#define LOGA_DEBUG 0\n    return 1;\n    fprintf(xml, ""<testcase classname=\\""test1\\"" name=\\""connectionLost and binary will messages\\"""");\n    opts2.keepAliveInterval = 20;\n    opts.cleansession = 1;\n    opts.will = &wopts;\n    opts.will->message = test6_will_message;\n    opts.will->qos = 1;\n    opts.will->retained = 0;\n    opts.will->topicName = test6_will_topic;\n    assert(""Good rc from unsubscribe"", rc == MQTTCLIENT_SUCCESS, ""rc was %d"", rc);\n            goto exit;\n    opts.will->payload.data = test6_will_message;\n    opts.will->payload.len = strlen(test6_will_message) + 1;\nSTART_TIME_TYPE start_clock(void)\n{\n    struct timeval start_time;\n    gettimeofday(&start_time, NULL);\n    return start_time;\n}\nint check_subs_exist(mqtt_client* c, const char* test_topic, int which)\n{\n    int rc = MQTT_FAILURE;\n    int wait_seconds = 0;\n    memset(&pubmsg, \'\\0\', sizeof(pubmsg));\n    pubmsg.payload = (void*)""a much longer message that we can shorten to the extent that we need to payload up to 11"";\n    pubmsg.payloadlen = 11;\n    pubmsg.qos = MQTT_QOS2;\n    pubmsg.retained = 0;\n    pubmsg.dup = 0;\n    test1_message_data = test2_message_data = NULL;\n    rc = mqtt_publish(c, test_topic, &pubmsg);\n    assert(""Good rc from publish"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    wait_seconds = 10;\n    while (wait_seconds-- > 0)\n    {\n        mqtt_yield(c, 100);\n    }\n    rc = (((which == 1 || which == 3) && test1_message_data) ||\n         (which == 2 && test1_message_data == NULL)) ? MQTT_SUCCESS : MQTT_FAILURE;\n    assert(""test1 subscription"", rc == MQTT_SUCCESS, ""test1_message_data %p\\n"",\n            test1_message_data);\n    rc = (((which == 2 || which == 3) && test2_message_data) ||\n         (which == 1 && test2_message_data == NULL)) ? MQTT_SUCCESS : MQTT_FAILURE;\n    assert(""test2 subscription"", rc == MQTT_SUCCESS, ""test2_message_data %p\\n"",\n             test2_message_data);\n    return rc;\n}\nvoid write_test_result(void)\n{\n    uint64_t duration = time_elapsed_ms(&g_start_time);\n    fprintf(xml, "" time=\\""%ld.%.3ld\\"" >\\n"", duration / 1000, duration % 1000);\n    if (cur_output != output) {\n        fprintf(xml, ""%s"", output);\n        cur_output = output;\n    }\n    fprintf(xml, ""</testcase>\\n"");\n}\nvoid messageArrived(MessageData* md)\n{\n    test1_message_data = md;\n    mqtt_msg* m = md->message;\n    assert(""Good message lengths"", pubmsg.payloadlen == m->payloadlen,\n                    ""payloadlen was %d"", m->payloadlen);\n    if (pubmsg.payloadlen == m->payloadlen)\n            assert(""Good message contents"", memcmp(m->payload, pubmsg.payload, m->payloadlen) == 0,\n                            ""payload was %s"", m->payload);\n}\nvoid messageArrived2(MessageData* md)\n{\n    test2_message_data = md;\n    mqtt_msg *m = md->message;\n    assert(""Good message lengths"", pubmsg.payloadlen == m->payloadlen,\n         ""payloadlen was %d"", m->payloadlen);\n    if (pubmsg.payloadlen == m->payloadlen)\n        assert(""Good message contents"", memcmp(m->payload, pubmsg.payload, m->payloadlen) == 0,\n          ""payload was %s"", m->payload);\n}\nint test2(struct Options options)\n{\n    int subsqos = 2;\n    mqtt_client c;\n    int rc = 0;\n    char* test_topic = ""C client test2"";\n    mqtt_connack_data connack;\n    mqtt_suback_data suback;\n    fprintf(xml, ""<testcase classname=\\""test2\\"" name=\\""connack return data\\"""");\n    global_start_time = start_clock();\n    failures = 0;\n    MyLog(LOGA_INFO, ""Starting test 2 - connack return data"");\n    mqtt_client_init(&c, options.host, options.port);\n    mqtt_connack_data tmp_data;\n    mqtt_pkt_conn_data data = mqtt_pkt_conn_data_initializer;\n    data.willFlag = 1;\n    data.mqtt_version = options.mqtt_version;\n    data.clientID.cstring = ""connack-return-data"";\n    data.username.cstring = ""testuser"";\n    data.password.cstring = ""testpassword"";\n    data.keepAliveInterval = 20;\n    data.cleansession = 1;\n    data.will.message.cstring = ""will message"";\n    data.will.qos = 1;\n    data.will.retained = 0;\n    data.will.topicName.cstring = ""will topic"";\n    MyLog(LOGA_DEBUG, ""Connecting"");\n    rc = mqtt_connect(&c, &data, &tmp_data);\n    assert(""Good rc from connect"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    if (rc != MQTT_SUCCESS)\n            goto exit;\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    data.cleansession = 0;\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Good rc from connect"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 0"", connack.sessionPresent == 0,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived, &suback);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good granted QoS"", suback.grantedQoS == subsqos,\n                    ""granted QoS was %d"", suback.grantedQoS);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 1"", connack.sessionPresent == 1,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    data.cleansession = 1;\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 0"", connack.sessionPresent == 0,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\nexit:\n    MyLog(LOGA_INFO, ""TEST1: test %s. %d tests run, %d failures."",\n                    (failures == 0) ? ""passed"" : ""failed"", tests, failures);\n    write_test_result();\n    return failures;\n}\nvoid MyLog(int LOGA_level, char* format, ...)\n{\n    static char msg_buf[256];\n    va_list args;\n    struct timeb ts;\n    struct tm *timeinfo;\n    ftime(&ts);\n    timeinfo = localtime(&ts.time);\n    strftime(msg_buf, 80, ""%Y%m%d %H%M%S"", timeinfo);\n    sprintf(&msg_buf[strlen(msg_buf)], "".%.3hu "", ts.millitm);\n    va_start(args, format);\n    vsnprintf(&msg_buf[strlen(msg_buf)], sizeof(msg_buf) - strlen(msg_buf), format, args);\n    va_end(args);\n    printf(""%s\\n"", msg_buf);\n    fflush(stdout);\n}\nint test1(struct Options options)\n{\n    int subsqos = 2;\n    mqtt_client c;\n    int rc = 0;\n    char* test_topic = ""C client test1"";\n    fprintf(xml, ""<testcase classname=\\""test1\\"" name=\\""single threaded client using receive\\"""");\n    gettimeofday(&g_start_time, NULL);\n    failures = 0;\n    MyLog(LOGA_INFO, ""Starting test 1 - single threaded client using receive"");\n    mqtt_client_init(&c, options.host, options.port);\n    mqtt_suback_data tmp_subback_data;\n    mqtt_connack_data tmp_data;\n    mqtt_pkt_conn_data data = mqtt_pkt_conn_data_initializer;\n    data.willFlag = 1;\n    data.mqtt_version = options.mqtt_version;\n    data.clientID.cstring = ""single-threaded-test"";\n    data.username.cstring = ""testuser"";\n    data.password.cstring = ""testpassword"";\n    data.keepAliveInterval = 20;\n    data.cleansession = 1;\n    data.will.message.cstring = ""will message"";\n    data.will.qos = 1;\n    data.will.retained = 0;\n    data.will.topicName.cstring = ""will topic"";\n    MyLog(LOGA_DEBUG, ""Connecting"");\n    rc = mqtt_connect(&c, &data, &tmp_data);\n    assert(""Good rc from connect"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    if (rc != MQTT_SUCCESS)\n        goto exit;\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived, &tmp_subback_data);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    test1_sendAndReceive(&c, 0, test_topic);\n    test1_sendAndReceive(&c, 1, test_topic);\n    test1_sendAndReceive(&c, 2, test_topic);\n    MyLog(LOGA_DEBUG, ""Stopping\\n"");\n    rc = mqtt_unsubscribe(&c, test_topic);\n    assert(""Unsubscribe successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n#if 0\n    rc = mqtt_connect(&c, &data, &tmp_data);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n#endif\nexit:\n    MyLog(LOGA_INFO, ""TEST1: test %s. %d tests run, %d failures."",\n                    (failures == 0) ? ""passed"" : ""failed"", tests, failures);\n    write_test_result();\n    mqtt_client_deinit(&c);\n    return failures;\n}\nlong elapsed(START_TIME_TYPE start_time)\n{\n    struct timeval now, res;\n    gettimeofday(&now, NULL);\n    timersub(&now, &start_time, &res);\n    return (res.tv_sec)*1000 + (res.tv_usec)/1000;\n}\nvoid test1_sendAndReceive(mqtt_client* c, int qos, char* test_topic)\n{\n    int i = 0;\n    int iterations = 5;\n    int rc;\n    int wait_seconds;\n    MyLog(LOGA_DEBUG, ""%d messages at QoS %d"", iterations, qos);\n    memset(&pubmsg, \'\\0\', sizeof(pubmsg));\n    pubmsg.payload = ""a much longer message that we can shorten to the extent that we need to payload up to 11"";\n    pubmsg.payloadlen = 11;\n    pubmsg.qos = qos;\n    pubmsg.retained = 0;\n    pubmsg.dup = 0;\n    for (i = 0; i < iterations; ++i) {\n        test1_message_data = NULL;\n        rc = mqtt_publish(c, test_topic, &pubmsg);\n        assert(""Good rc from publish"", rc == MQTT_SUCCESS, ""rc was %d\\n"", rc);\n        wait_seconds = 10;\n        while ((test1_message_data == NULL) && (wait_seconds-- > 0)) {\n            mqtt_yield(c, 100);\n        }\n        assert(""Message Arrived"", wait_seconds > 0, ""Time out waiting for message %d\\n"", i);\n        if (!test1_message_data)\n            printf(""No message received within timeout period\\n"");\n    }\n    wait_seconds = 2;\n    while (wait_seconds-- > 0) {\n        mqtt_yield(c, 1000);\n    }\n}\nint test3(struct Options options)\n{\n    enum mqtt_qos subsqos = MQTT_QOS2;\n    mqtt_client c;\n    int rc;\n    const char* test_topic = ""C client test3"";\n    int wait_seconds = 0;\n    mqtt_connack_data connack;\n    mqtt_suback_data suback;\n    fprintf(xml, ""<testcase classname=\\""test3\\"" name=\\""session state\\"""");\n    global_start_time = start_clock();\n    failures = 0;\n    MyLog(LOGA_INFO, ""Starting test 3 - session state"");\n    mqtt_client_init(&c, options.host, options.port);\n    mqtt_pkt_conn_data data = mqtt_pkt_conn_data_initializer;\n    data.willFlag = 1;\n    data.mqtt_version = options.mqtt_version;\n    data.clientID.cstring = (char*)""connack-session-state"";\n    data.username.cstring = (char*)""testuser"";\n    data.password.cstring = (char*)""testpassword"";\n    data.keepAliveInterval = 10;\n    data.cleansession = 1;\n    data.will.message.cstring = (char*)""will message"";\n    data.will.qos = 1;\n    data.will.retained = 0;\n    data.will.topicName.cstring = (char*)""will topic"";\n    assert(""Not connected"", mqtt_is_connected(&c) == 0,\n                    ""isconnected was %d"", mqtt_is_connected(&c));\n    MyLog(LOGA_DEBUG, ""Connecting"");\n#if 0\n    rc = NetworkConnect(&c.ipstack, options.host, options.port);\n    assert(""Good rc from TCP connect"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    if (rc != MQTT_SUCCESS)\n            goto exit;\n#endif\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Good rc from connect"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    if (rc != MQTT_SUCCESS)\n            goto exit;\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 0"", connack.sessionPresent == 0,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    assert(""Good rc in connack"", mqtt_is_connected(&c) == 1,\n                    ""isconnected was %d"", mqtt_is_connected(&c));\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    data.cleansession = 0;\n    assert(""TCP connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 0"", connack.sessionPresent == 0,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived, &suback);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Granted QoS rc from subscribe"", suback.grantedQoS == MQTT_QOS2,\n                    ""rc was %d"", suback.grantedQoS);\n    check_subs_exist(&c, test_topic, 1);\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived2, &suback);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Granted QoS rc from subscribe"", suback.grantedQoS == MQTT_QOS2,\n                    ""rc was %d"", suback.grantedQoS);\n    check_subs_exist(&c, test_topic, 2);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    data.cleansession = 0;\n    assert(""TCP connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 1"", connack.sessionPresent == 1,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    check_subs_exist(&c, test_topic, 2);\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived, &suback);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Granted QoS rc from subscribe"", suback.grantedQoS == MQTT_QOS2,\n                    ""rc was %d"", suback.grantedQoS);\n    check_subs_exist(&c, test_topic, 1);\n    memset(&pubmsg, \'\\0\', sizeof(pubmsg));\n    pubmsg.payload = (void*)""TERMINATE"";\n    pubmsg.payloadlen = strlen((char*)pubmsg.payload);\n    pubmsg.qos = MQTT_QOS0;\n    pubmsg.retained = 0;\n    pubmsg.dup = 0;\n    rc = mqtt_publish(&c, ""MQTTSAS topic"", &pubmsg);\n    assert(""Good rc from publish"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    wait_seconds = 20;\n    while (mqtt_is_connected(&c) && (wait_seconds-- > 0))\n    {\n            mqtt_yield(&c, 1000);\n    }\n    assert(""Disconnected"", !mqtt_is_connected(&c), ""isConnected was %d"",\n                    mqtt_is_connected(&c));\n    rc = mqtt_disconnect(&c);\n    data.cleansession = 0;\n    assert(""TCP connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 1"", connack.sessionPresent == 1,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    check_subs_exist(&c, test_topic, 1);\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived2, &suback);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Granted QoS rc from subscribe"", suback.grantedQoS == MQTT_QOS2,\n                    ""rc was %d"", suback.grantedQoS);\n    check_subs_exist(&c, test_topic, 2);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    data.cleansession = 1;\n    assert(""TCP connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_connect(&c, &data, &connack);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Good rc in connack"", connack.rc == 0, ""rc was %d"", connack.rc);\n    assert(""Session present is 0"", connack.sessionPresent == 0,\n                    ""sessionPresent was %d"", connack.sessionPresent);\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived2, &suback);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    assert(""Granted QoS rc from subscribe"", suback.grantedQoS == MQTT_QOS2,\n                    ""rc was %d"", suback.grantedQoS);\n    check_subs_exist(&c, test_topic, 2);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\nexit:\n    MyLog(LOGA_INFO, ""TEST2: test %s. %d tests run, %d failures."",\n                    (failures == 0) ? ""passed"" : ""failed"", tests, failures);\n    write_test_result();\n    return failures;\n}\n//...'"
"('Prompt: You need to create a callback function for a specific scenario. The function should calculate the desired value and weight based on a given frequency. If the frequency is less than 0.39, the desired value should be calculated as the exponential function of 20 times the absolute value of the frequency, and the weight should be calculated as the exponential function of -10 times the frequency. Otherwise, both the desired value and weight should be set to 0. Additionally, you need to write a function that will use this callback function to create a filter with specific parameters and then validate the filter response against predefined regions. Can you provide the code for this scenario?","//...\nint callback_firdespm_autotest(double   _frequency,\n                               void   * _userdata,\n                               double * _desired,\n                               double * _weight)\n{\n    *_desired = _frequency < 0.39 ? exp(20*fabs(_frequency)) : 0;\n    *_weight  = _frequency < 0.39 ? exp(-10*_frequency) : 1;\n    return 0;\n}\nvoid autotest_firdespm_callback()\n{\n    unsigned int h_len = 81;    \n    liquid_firdespm_btype btype = LIQUID_FIRDESPM_BANDPASS;\n    unsigned int num_bands = 2;\n    float        bands[4]  = {0.0, 0.35, 0.4, 0.5};\n    float h[h_len];\n    firdespm q = firdespm_create_callback(h_len,num_bands,bands,btype,\n            callback_firdespm_autotest,NULL);\n    firdespm_execute(q,h);\n    firdespm_destroy(q);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.50,  .fmax=-0.40,  .pmin= 0, .pmax=-20, .test_lo=0, .test_hi=1},\n      {.fmin=-0.36,  .fmax=-0.30,  .pmin=52, .pmax= 62, .test_lo=1, .test_hi=1},\n      {.fmin=-0.30,  .fmax=-0.20,  .pmin=34, .pmax= 53, .test_lo=1, .test_hi=1},\n      {.fmin=-0.20,  .fmax=-0.10,  .pmin=15, .pmax= 36, .test_lo=1, .test_hi=1},\n      {.fmin=-0.10,  .fmax=+0.10,  .pmin= 0, .pmax= 19, .test_lo=1, .test_hi=1},\n      {.fmin= 0.10,  .fmax= 0.20,  .pmin=15, .pmax= 36, .test_lo=1, .test_hi=1},\n      {.fmin= 0.20,  .fmax= 0.30,  .pmin=34, .pmax= 53, .test_lo=1, .test_hi=1},\n      {.fmin= 0.30,  .fmax= 0.36,  .pmin=52, .pmax= 62, .test_lo=1, .test_hi=1},\n      {.fmin= 0.40,  .fmax= 0.50,  .pmin= 0, .pmax=-20, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signalf(h, h_len, regions, 9,\n        liquid_autotest_verbose ? ""autotest/logs/firdespm_callback.m"" : NULL);\n}\n//...')
"
"('Prompt: In a scenario where you are working on testing error correction capabilities in a communication system, can you provide code that demonstrates testing the Hamming (7,4) error correction code using both hard and soft decoding methods? The code should include encoding a message, introducing a bit flip in the encoded message, decoding the message using the error correction code, and verifying the correctness of the decoded message.","void autotest_hamming74_codec()\n{\n    unsigned int n=4;\n    unsigned char msg[] = {0x25, 0x62, 0x3F, 0x52};\n    fec_scheme fs = LIQUID_FEC_HAMMING74;\n    unsigned int n_enc = fec_get_enc_msg_length(fs,n);\n    unsigned char msg_dec[n];\n    unsigned char msg_enc[n_enc];\n    fec q = fec_create(fs,NULL);\n    if (liquid_autotest_verbose)\n        fec_print(q);\n    fec_encode(q, n, msg, msg_enc);\n    msg_enc[0] ^= 0x04; \n#if 0\n    msg_enc[1] ^= 0x04; \n    msg_enc[2] ^= 0x02; \n    msg_enc[3] ^= 0x01; \n    msg_enc[4] ^= 0x80; \n    msg_enc[5] ^= 0x40; \n    msg_enc[6] ^= 0x20; \n#endif\n    fec_decode(q, n, msg_enc, msg_dec);\n    CONTEND_SAME_DATA(msg, msg_dec, n);\n    fec_destroy(q);\n}\nvoid autotest_hamming74_codec_soft()\n{\n    unsigned char s;            \n    unsigned char c;            \n    unsigned char c_soft[7];    \n    unsigned char s_hat;        \n    for (s=0; s<16; s++) {\n        c = hamming74_enc_gentab[s];\n        c_soft[0] = (c & 0x40) ? 255 : 0;\n        c_soft[1] = (c & 0x20) ? 255 : 0;\n        c_soft[2] = (c & 0x10) ? 255 : 0;\n        c_soft[3] = (c & 0x08) ? 255 : 0;\n        c_soft[4] = (c & 0x04) ? 255 : 0;\n        c_soft[5] = (c & 0x02) ? 255 : 0;\n        c_soft[6] = (c & 0x01) ? 255 : 0;\n        s_hat = fecsoft_hamming74_decode(c_soft);\n        CONTEND_EQUALITY(s, s_hat);\n    }\n}')
"
"('Prompt: You are working on a software project that involves designing a Phase-Locked Loop (PLL) system for a communication system. You have two different design options for the PLL loop filter: one uses an active lag-lead design and the other uses an active Proportional-Integral (PI) design. You need to implement the functions `iirdes_pll_active_lag` and `iirdes_pll_active_PI` in C to calculate the coefficients for the IIR (Infinite Impulse Response) filter based on the given parameters: bandwidth (_w), damping factor (_zeta), and gain (_K). The functions should return the filter coefficients in the arrays _b and _a. If any of the input parameters (_w, _zeta, _K) are less than or equal to 0, the functions should return an error message using the `liquid_error` function.","void iirdes_pll_active_lag(float _w,\n                           float _zeta,\n                           float _K,\n                           float * _b,\n                           float * _a)\n{\n    if (_w <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_lag(), bandwidth must be greater than 0"");\n        return;\n    } else if (_zeta <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_lag(), damping factor must be greater than 0"");\n        return;\n    } else if (_K <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_lag(), gain must be greater than 0"");\n        return;\n    }\n    float wn = _w;                  \n    float t1 = _K/(wn*wn);          \n    float t2 = 2*_zeta/wn - 1/_K;   \n    _b[0] = 2*_K*(1.+t2/2.0f);\n    _b[1] = 2*_K*2.;\n    _b[2] = 2*_K*(1.-t2/2.0f);\n    _a[0] =  1 + t1/2.0f;\n    _a[1] = -t1;\n    _a[2] = -1 + t1/2.0f;\n}\nvoid iirdes_pll_active_PI(float _w,\n                          float _zeta,\n                          float _K,\n                          float * _b,\n                          float * _a)\n{\n    if (_w <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_PI(), bandwidth must be greater than 0"");\n        return;\n    } else if (_zeta <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_PI(), damping factor must be greater than 0"");\n        return;\n    } else if (_K <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_PI(), gain must be greater than 0"");\n        return;\n    }\n    float wn = _w;          \n    float t1 = _K/(wn*wn);  \n    float t2 = 2*_zeta/wn;  \n    _b[0] = 2*_K*(1.+t2/2.0f);\n    _b[1] = 2*_K*2.;\n    _b[2] = 2*_K*(1.-t2/2.0f);\n    _a[0] =  t1/2.0f;\n    _a[1] = -t1;\n    _a[2] =  t1/2.0f;\n}')
"
"('Please provide the prompt that describes the requirement for a frequency demodulation module implementation in C. This module should include functions for creating and destroying a frequency demodulator object, printing its properties, resetting it, and demodulating a single sample or a block of samples. The demodulation process involves calculating the phase difference between consecutive input samples and converting it to the corresponding message signal value using a modulation factor.","struct FREQDEM(_s) {\n    float kf;   \n    T     ref;  \n    TC r_prime; \n};\nFREQDEM() FREQDEM(_create)(float _kf)\n{\n    if (_kf <= 0.0f)\n        return liquid_error_config(""freqdem%s_create(), modulation factor %12.4e must be greater than 0"", EXTENSION, _kf);\n    FREQDEM() q = (freqdem) malloc(sizeof(struct FREQDEM(_s)));\n    q->kf = _kf;\n    q->ref = 1.0f / (2*M_PI*q->kf);\n    FREQDEM(_reset)(q);\n    return q;\n}\nint FREQDEM(_destroy)(FREQDEM() _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\nint FREQDEM(_print)(FREQDEM() _q)\n{\n    printf(""freqdem:\\n"");\n    printf(""    mod. factor :   %8.4f\\n"", _q->kf);\n    return LIQUID_OK;\n}\nint FREQDEM(_reset)(FREQDEM() _q)\n{\n    _q->r_prime = 0;\n    return LIQUID_OK;\n}\nint FREQDEM(_demodulate)(FREQDEM() _q,\n                         TC        _r,\n                         T *       _m)\n{\n    *_m = cargf( conjf(_q->r_prime)*_r ) * _q->ref;\n    _q->r_prime = _r;\n    return LIQUID_OK;\n}\nint FREQDEM(_demodulate_block)(FREQDEM()    _q,\n                               TC *         _r,\n                               unsigned int _n,\n                               T *          _m)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        FREQDEM(_demodulate)(_q, _r[i], &_m[i]);\n    return LIQUID_OK;\n}')
"
"('Prompt: You are working on testing a Signal Processing library function that computes a spectrogram of a signal in C. The function takes in multiple parameters such as the FFT size, window length, delay, window type, and noise floor level. Write a testbench function that generates a spectrogram with noise for a specific set of parameters. The function should create the spectrogram, push noise samples into it, verify the number of samples, calculate the power spectral density, and check the values against the noise floor level with a tolerance of 0.5. Lastly, the spectrogram should be destroyed after the test is complete. . . ```c. void testbench_spgramcf_noise(unsigned int _nfft,.                               unsigned int _wlen,.                               unsigned int _delay,.                               int          _wtype,.                               float        _noise_floor). {.     unsigned int num_samples = 2000*_nfft;  .     float        nstd        = powf(10.0f,_noise","//...\nvoid testbench_spgramcf_noise(unsigned int _nfft,\n                              unsigned int _wlen,\n                              unsigned int _delay,\n                              int          _wtype,\n                              float        _noise_floor)\n{\n    unsigned int num_samples = 2000*_nfft;  \n    float        nstd        = powf(10.0f,_noise_floor/20.0f); \n    float        tol         = 0.5f; \n    if (liquid_autotest_verbose) {\n        printf(""  spgramcf test  (noise): nfft=%6u, wtype=%24s, noise floor=%6.1f\\n"",\n                _nfft, liquid_window_str[_wtype][1], _noise_floor);\n    }\n    spgramcf q = NULL;\n    if (_wlen==0 || _delay==0 || _wtype==LIQUID_WINDOW_UNKNOWN)\n        q = spgramcf_create_default(_nfft);\n    else\n        q = spgramcf_create(_nfft, _wtype, _wlen, _delay);\n    unsigned int i;\n    for (i=0; i<num_samples; i++)\n        spgramcf_push(q, nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2);\n    CONTEND_EQUALITY(spgramcf_get_num_samples(q),       num_samples);\n    CONTEND_EQUALITY(spgramcf_get_num_samples_total(q), num_samples);\n    float psd[_nfft];\n    spgramcf_get_psd(q, psd);\n    for (i=0; i<_nfft; i++)\n        CONTEND_DELTA(psd[i], _noise_floor, tol)\n    spgramcf_destroy(q);\n}\nvoid autotest_spgramcf_noise_hann           () { testbench_spgramcf_noise(800, 0, 0, LIQUID_WINDOW_HANN,           -80.0); }\n//...')
"
"'Prompt: You are working on a project that requires implementing a custom keyboard interface in an embedded system using LVGL. The keyboard should have a specific layout with custom characters and symbols arranged in a grid. Your task is to create a function that initializes and sets up this custom keyboard interface. The function should create a keyboard object, set the keyboard map and controls, set the mode to user-defined, create a textarea object for text input, align it to the top center of the screen, and link it to the keyboard for input. The keyboard layout should include letters, symbols, and special keys like backspace, new line, close, and OK. Based on this description, please provide the implementation code for the custom keyboard interface.","#if LV_USE_KEYBOARD && LV_BUILD_EXAMPLES\nvoid lv_example_keyboard_2(void)\n{\n    static const char * kb_map[] = {""A"", ""Z"", ""E"", ""R"", ""T"", ""Y"", ""U"", ""I"", ""O"", ""P"", LV_SYMBOL_BACKSPACE, ""\\n"",\n                                    ""Q"", ""S"", ""D"", ""F"", ""G"", ""J"", ""K"", ""L"", ""M"",  LV_SYMBOL_NEW_LINE, ""\\n"",\n                                    ""W"", ""X"", ""C"", ""V"", ""B"", ""N"", "","", ""."", "":"", ""!"", ""?"", ""\\n"",\n                                    LV_SYMBOL_CLOSE, "" "",  "" "", "" "", LV_SYMBOL_OK, NULL\n                                   };\n    static const lv_buttonmatrix_ctrl_t kb_ctrl[] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6,\n                                                     4, 4, 4, 4, 4, 4, 4, 4, 4, 6,\n                                                     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n                                                     2, LV_BUTTONMATRIX_CTRL_HIDDEN | 2, 6, LV_BUTTONMATRIX_CTRL_HIDDEN | 2, 2\n                                                    };\n    lv_obj_t * kb = lv_keyboard_create(lv_screen_active());\n    lv_keyboard_set_map(kb, LV_KEYBOARD_MODE_USER_1, kb_map, kb_ctrl);\n    lv_keyboard_set_mode(kb, LV_KEYBOARD_MODE_USER_1);\n    lv_obj_t * ta;\n    ta = lv_textarea_create(lv_screen_active());\n    lv_obj_align(ta, LV_ALIGN_TOP_MID, 0, 10);\n    lv_obj_set_size(ta, lv_pct(90), 80);\n    lv_obj_add_state(ta, LV_STATE_FOCUSED);\n    lv_keyboard_set_textarea(kb, ta);\n}\n#endif'"
"'Please provide a code snippet for initializing a pthread barrier in C that takes into account the possibility of configuration settings being loaded from a header file. The code should initialize the pthread barrier based on the provided count and attributes, setting the initial and current barrier height, using a semaphore to handle synchronization, and returning appropriate error codes if the initialization fails.","#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_barrier_init (pthread_barrier_t * barrier,\n\t\t      const pthread_barrierattr_t * attr, unsigned int count)\n{\n  pthread_barrier_t b;\n  if (barrier == NULL || count == 0)\n    {\n      return EINVAL;\n    }\n  if (NULL != (b = (pthread_barrier_t) calloc (1, sizeof (*b))))\n    {\n      b->pshared = (attr != NULL && *attr != NULL\n\t\t    ? (*attr)->pshared : PTHREAD_PROCESS_PRIVATE);\n      b->nCurrentBarrierHeight = b->nInitialBarrierHeight = count;\n      b->lock = 0;\n      if (0 == sem_init (&(b->semBarrierBreeched), b->pshared, 0))\n\t    {\n\t      *barrier = b;\n\t      return 0;\n\t    }\n      (void) free (b);\n    }\n  return ENOMEM;\n}'"
('Prompt: Imagine you are testing a function that computes the squared magnitude of a complex sequence of numbers and comparing the result with a predefined value within a specific tolerance. What function is called inside `sumsqcf_runtest` to calculate the squared magnitude of the provided complex sequence? How does the `autotest_sumsqcf_7` function use `sumsqcf_runtest` to test the function at a sequence length of 7 with a predefined value of 0.179790025178960?,"//...\nfloat complex sumsqcf_test_x3[3];   float sumsqcf_test_y3;\nfloat sumsqcf_test_y7 = 0.179790025178960;\nvoid sumsqcf_runtest(float complex * _x,\n                     unsigned int    _n,\n                     float           _y)\n{\n    float tol = 1e-6;   \n    float y = liquid_sumsqcf(_x, _n);\n    CONTEND_DELTA( y, _y, tol );\n}\nvoid autotest_sumsqcf_7()   {   sumsqcf_runtest( sumsqcf_test_x7,  7,  sumsqcf_test_y7  );  }\n//...')
"
"('Prompt: You are working on a digital signal processing project and need to test the function that creates a prototype IIR filter. Write a testbench function that creates an IIR filter prototype using the elliptic design, lowpass filter type, and the given format. It should then generate random input samples, execute the filter, create a copy of the filter, execute both filters with the same input samples, and check that the output of both filters is equal. Finally, destroy both filters. Provide two auto-test functions that call the testbench function with different formats: LIQUID_IIRDES_TF and LIQUID_IIRDES_SOS.","void testbench_iirfilt_copy(liquid_iirdes_format _format)\n{\n    iirfilt_crcf q0 = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_ELLIP, LIQUID_IIRDES_LOWPASS, _format,\n        9,0.2f,0.0f,0.1f,60.0f);\n    unsigned int i, num_samples = 80;\n    float complex y0, y1;\n    for (i=0; i<num_samples; i++) {\n        float complex v = randnf() + _Complex_I*randnf();\n        iirfilt_crcf_execute(q0, v, &y0);\n    }\n    iirfilt_crcf q1 = iirfilt_crcf_copy(q0);\n    for (i=0; i<num_samples; i++) {\n        float complex v = randnf() + _Complex_I*randnf();\n        iirfilt_crcf_execute(q0, v, &y0);\n        iirfilt_crcf_execute(q1, v, &y1);\n        CONTEND_EQUALITY(y0, y1);\n    }\n    iirfilt_crcf_destroy(q0);\n    iirfilt_crcf_destroy(q1);\n}\nvoid autotest_iirfilt_copy_tf () { testbench_iirfilt_copy(LIQUID_IIRDES_TF ); }\nvoid autotest_iirfilt_copy_sos() { testbench_iirfilt_copy(LIQUID_IIRDES_SOS); }')
"
('Please provide a prompt where you need to compare the performance of a filterbank channelizer against a traditional channelizer in a communication system. Would you be able to demonstrate this by coding a program that implements both channelizers and calculates the root mean square error (RMSE) between their outputs for a given input signal?,"#define DEBUG 1\nint main() {\n    unsigned int num_channels=4;    \n    unsigned int m=5;               \n    unsigned int num_symbols=12;    \n    unsigned int num_samples = num_channels * num_symbols;\n    unsigned int i;\n    unsigned int j;\n    unsigned int h_len = 2*m*num_channels;\n    float h[h_len];\n    for (i=0; i<h_len; i++) h[i] = randnf();\n    dotprod_crcf dp[num_channels];  \n    windowcf w[num_channels];       \n#if DEBUG\n    printf(""h_prototype:\\n"");\n    for (i=0; i<h_len; i++)\n        printf(""  h[%3u] = %12.8f\\n"", i, h[i]);\n#endif\n    unsigned int h_sub_len = 2*m;\n    float h_sub[h_sub_len];\n    for (i=0; i<num_channels; i++) {\n#if 0\n        for (j=0; j<h_sub_len; j++)\n            h_sub[j] = h[j*num_channels+i];\n#else\n        for (j=0; j<h_sub_len; j++)\n            h_sub[h_sub_len-j-1] = h[j*num_channels+i];\n#endif\n        dp[i] = dotprod_crcf_create(h_sub, h_sub_len);\n        w[i]  = windowcf_create(h_sub_len);\n#if DEBUG\n        printf(""h_sub[%u] : \\n"", i);\n        for (j=0; j<h_sub_len; j++)\n            printf(""  h[%3u] = %12.8f\\n"", j, h_sub[j]);\n#endif\n    }\n    float complex x[num_channels];  \n    float complex X[num_channels];  \n#if 0\n    fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);\n#else\n    fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_FORWARD, 0);\n#endif\n    firfilt_crcf f = firfilt_crcf_create(h, h_len);\n    float complex y[num_samples];                   \n    float complex Y0[num_symbols][num_channels];    \n    float complex Y1[num_symbols][num_channels];    \n    for (i=0; i<num_samples; i++)\n        y[i] = randnf() * cexpf(_Complex_I*randf()*2*M_PI);\n#if 0\n    unsigned int filter_index = 0;\n#else\n    unsigned int filter_index = num_channels-1;\n#endif\n    float complex y_hat;    \n    float complex * r;      \n    for (i=0; i<num_symbols; i++) {\n        for (j=0; j<num_channels; j++) {\n            y_hat = y[i*num_channels + j];\n            windowcf_push(w[filter_index], y_hat);\n            filter_index = (filter_index + num_channels - 1) % num_channels;\n        }\n        for (j=0; j<num_channels; j++) {\n            windowcf_read(w[j], &r);\n            dotprod_crcf_execute(dp[j], r, &X[num_channels-j-1]);\n        }\n        fft_execute(fft);\n        for (j=0; j<num_channels; j++)\n            Y0[i][j] = x[j];\n    }\n    float dphi; \n    unsigned int n=0;\n    for (i=0; i<num_channels; i++) {\n        firfilt_crcf_reset(f);\n        dphi = 2.0f * M_PI * (float)i / (float)num_channels;\n        n=0;\n        for (j=0; j<num_samples; j++) {\n            firfilt_crcf_push(f, y[j]*cexpf(-_Complex_I*j*dphi));\n            assert(n<num_symbols);\n            if ( ((j+1)%num_channels)==0 ) {\n                firfilt_crcf_execute(f, &Y1[n][i]);\n                n++;\n            }\n        }\n        assert(n==num_symbols);\n    }\n    for (i=0; i<num_channels; i++) {\n        dotprod_crcf_destroy(dp[i]);\n        windowcf_destroy(w[i]);\n    }\n    fft_destroy_plan(fft);\n    firfilt_crcf_destroy(f);\n    printf(""\\n"");\n    printf(""filterbank channelizer:\\n"");\n    for (i=0; i<num_symbols; i++) {\n        printf(""%3u: "", i);\n        for (j=0; j<num_channels; j++) {\n            printf(""  %8.5f+j%8.5f, "", crealf(Y0[i][j]), cimagf(Y0[i][j]));\n        }\n        printf(""\\n"");\n    }\n    printf(""\\n"");\n    printf(""traditional channelizer:\\n"");\n    for (i=0; i<num_symbols; i++) {\n        printf(""%3u: "", i);\n        for (j=0; j<num_channels; j++) {\n            printf(""  %8.5f+j%8.5f, "", crealf(Y1[i][j]), cimagf(Y1[i][j]));\n        }\n        printf(""\\n"");\n    }\n    float mse[num_channels];\n    float complex d;\n    for (i=0; i<num_channels; i++) {\n        mse[i] = 0.0f;\n        for (j=0; j<num_symbols; j++) {\n            d = Y0[j][i] - Y1[j][i];\n            mse[i] += crealf(d*conjf(d));\n        }\n        mse[i] /= num_symbols;\n    }\n    printf(""\\n"");\n    printf(""rmse: "");\n    for (i=0; i<num_channels; i++)\n        printf(""%12.4e          "", sqrt(mse[i]));\n    printf(""\\n"");\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: You are developing a packetizer module in C that needs to dynamically reallocate memory buffers to accommodate varying packet sizes. Please provide a code snippet for a function that reallocates the buffers in the packetizer module, taking in the packetizer object and the new length as parameters. The function should update the buffer lengths and perform memory reallocation for both buffer_0 and buffer_1.","//...\nint packetizer_realloc_buffers(packetizer   _p,\n                               unsigned int _len)\n{\n    _p->buffer_len = _len;\n    _p->buffer_0 = (unsigned char*) realloc(_p->buffer_0, _p->buffer_len);\n    _p->buffer_1 = (unsigned char*) realloc(_p->buffer_1, _p->buffer_len);\n    return LIQUID_OK;\n}\n//...')
"
"('Please provide code for a FEC (Forward Error Correction) scheme using three repetitions (FEC_REP3). The scheme should include functions for encoding, decoding, and soft decoding. The encoding function should repeat each message symbol three times, and the decoding function should use a simple voting mechanism (majority vote) to reconstruct the original symbols. The soft decoding function should use a weighted average of the three symbol values to estimate the original symbol with erasure correction capability.","//...\nint fec_rep3_decode_soft(fec             _q,\n                         unsigned int    _dec_msg_len,\n                         unsigned char * _msg_enc,\n                         unsigned char * _msg_dec)\n{\n    unsigned char s0, s1, s2;\n    unsigned int i;\n    unsigned int j;\n    unsigned int s_hat;\n    for (i=0; i<_dec_msg_len; i++) {\n        _msg_dec[i] = 0x00;\n        for (j=0; j<8; j++) {\n            s0 = _msg_enc[8*i                    + j];\n            s1 = _msg_enc[8*(i +   _dec_msg_len) + j];\n            s2 = _msg_enc[8*(i + 2*_dec_msg_len) + j];\n            s_hat = (s0 + s1 + s2)/3;\n            _msg_dec[i] |= (s_hat > LIQUID_SOFTBIT_ERASURE) ? (1 << (8-j-1)) : 0x00;\n        }\n    }\n    return LIQUID_OK;\n}\nint fec_rep3_encode(fec             _q,\n                    unsigned int    _dec_msg_len,\n                    unsigned char * _msg_dec,\n                    unsigned char * _msg_enc)\n{\n    unsigned int i;\n    for (i=0; i<3; i++) {\n        memcpy(&_msg_enc[i*_dec_msg_len], _msg_dec, _dec_msg_len);\n    }\n    return LIQUID_OK;\n}\nint fec_rep3_decode(fec             _q,\n                    unsigned int    _dec_msg_len,\n                    unsigned char * _msg_enc,\n                    unsigned char * _msg_dec)\n{\n    unsigned char s0, s1, s2;\n    unsigned int i;\n    for (i=0; i<_dec_msg_len; i++) {\n        s0 = _msg_enc[i];\n        s1 = _msg_enc[i +   _dec_msg_len];\n        s2 = _msg_enc[i + 2*_dec_msg_len];\n        _msg_dec[i] = (s0 & s1) | (s0 & s2) | (s1 & s2);\n    }\n    return LIQUID_OK;\n}\nfec fec_rep3_create(void * _opts)\n{\n    fec q = (fec) malloc(sizeof(struct fec_s));\n    q->scheme = LIQUID_FEC_REP3;\n    q->rate = fec_get_rate(q->scheme);\n    q->encode_func      = &fec_rep3_encode;\n    q->decode_func      = &fec_rep3_decode;\n    q->decode_soft_func = &fec_rep3_decode_soft;\n    return q;\n}\n//...')
"
"('Prompt: ""Imagine you are tasked with testing error correction capabilities in a communication system. Write a function that tests a Forward Error Correction (FEC) codec with a specific scheme and parameters. The function should encode a random message, introduce an error into the encoded message, decode it, and verify that the original message is recovered correctly. Also, provide a helper function for testing the Hamming(7,4) FEC scheme with a message length of 64. Keep in mind that some FEC schemes might not be available without a specific library installed.""","//...\nvoid fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    fec q = fec_create(_fs,_opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,_n);\n    unsigned char msg[_n];          \n    unsigned char msg_enc[n_enc];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg[i] = rand() & 0xff;\n        msg_dec[i] = 0;\n    }\n    fec_encode(q,_n,msg,msg_enc);\n    msg_enc[0] ^= 0x01;\n    fec_decode(q,_n,msg_enc,msg_dec);\n    CONTEND_SAME_DATA(msg,msg_dec,_n);\n    fec_destroy(q);\n}\nvoid autotest_fec_h74()     { fec_test_codec(LIQUID_FEC_HAMMING74,     64, NULL); }\n//...')
"
"('Prompt: You are working on a software project that involves testing a demodulation function for different modulation schemes in a communication system. Write a function that creates two modem objects, one for modulation and one for demodulation with the specified modulation scheme. The function should iterate through all possible symbols for the given modulation scheme, modulate each symbol, then demodulate it back using the demodulator. Confirm that the received symbol matches the transmitted one and convert the received soft bits back to symbol values, ensuring they match the transmitted value. Finally, destroy the modem objects. Implement an auto test function specifically for APSK4 modulation scheme.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_apsk4()     { modemcf_test_demodsoft(LIQUID_MODEM_APSK4);     }\n//...')
"
"'Prompt: You are working on a project where you need to create a graphical user interface with a bar element that displays a temperature range. The bar should have a gradient color effect from red to blue and animate smoothly between temperature values. Can you provide a code snippet that initializes the bar element with the specified style and animation parameters?. . Response:. ```c. #if LV_USE_BAR && LV_BUILD_EXAMPLES. static void set_temp(void * bar, int32_t temp). {.     lv_bar_set_value(bar, temp, LV_ANIM_ON);. }. void lv_example_bar_3(void). {.     static lv_style_t style_indic;.     lv_style_init(&style_indic);.     lv_style_set_bg_opa(&style_indic, LV_OPA_COVER);.     lv_style_set_bg_color(&style_indic, lv_palette_main(LV_PALETTE_RED));.     lv_style_set_bg_grad_color(&style_indic, lv_palette_main(LV_PALETTE_BLUE));.     lv_style_set","#if LV_USE_BAR && LV_BUILD_EXAMPLES\nstatic void set_temp(void * bar, int32_t temp)\n{\n    lv_bar_set_value(bar, temp, LV_ANIM_ON);\n}\nvoid lv_example_bar_3(void)\n{\n    static lv_style_t style_indic;\n    lv_style_init(&style_indic);\n    lv_style_set_bg_opa(&style_indic, LV_OPA_COVER);\n    lv_style_set_bg_color(&style_indic, lv_palette_main(LV_PALETTE_RED));\n    lv_style_set_bg_grad_color(&style_indic, lv_palette_main(LV_PALETTE_BLUE));\n    lv_style_set_bg_grad_dir(&style_indic, LV_GRAD_DIR_VER);\n    lv_obj_t * bar = lv_bar_create(lv_screen_active());\n    lv_obj_add_style(bar, &style_indic, LV_PART_INDICATOR);\n    lv_obj_set_size(bar, 20, 200);\n    lv_obj_center(bar);\n    lv_bar_set_range(bar, -20, 40);\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_exec_cb(&a, set_temp);\n    lv_anim_set_duration(&a, 3000);\n    lv_anim_set_playback_duration(&a, 3000);\n    lv_anim_set_var(&a, bar);\n    lv_anim_set_values(&a, -20, 40);\n    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n    lv_anim_start(&a);\n}\n#endif'"
"'Prompt: You need to create a function that creates a symbolic link between two directories on a Windows system. The function should be able to handle both wide character strings and multibyte character strings. Additionally, you need to handle creating a symbolic link between directories specifically. How would you implement this functionality?. . Response:. ```c. #define _CRT_SECURE_NO_WARNINGS 1 . #define _UTF8_LIB_SOURCE . #ifdef _WIN32. int symlinkdW(const WCHAR *targetName, const WCHAR *linkName) {.   BOOL done;.   int err;.   DEBUG_CODE(.   char *pszLink8;.   char *pszTarget8;.   ).   DEBUG_WSTR2NEWUTF8(linkName, pszLink8);.   DEBUG_WSTR2NEWUTF8(targetName, pszTarget8);.   DEBUG_ENTER((""symlinkd(\\""%s\\"", \\""%s\\"");\\n"", pszTarget8, pszLink8));.   DEBUG_FREEUTF8(pszTarget8);.   DEBUG_FREE","#define _CRT_SECURE_NO_WARNINGS 1 \n#define _UTF8_LIB_SOURCE \n#ifdef _WIN32\nint junctionW(const WCHAR *targetName, const WCHAR *junctionName) {\n  WCHAR *wszReparseBuffer = NULL;\n  WCHAR  wszVolumeName[] = L""X:\\\\"";\n  WCHAR *wszJunctionFullName = NULL;\n  WCHAR *wszFileSystem = NULL;\n  WCHAR *wszTargetTempName = NULL;\n  WCHAR *wszTargetFullName = NULL;\n  WCHAR *wszTargetNativeName = NULL;\n  WCHAR *wszRemoteName = NULL;\n  WCHAR *pwszFilePart;\n  size_t lNativeName;\n  HANDLE hFile;\n  DWORD  dwReturnedLength;\n  PMOUNTPOINT_WRITE_BUFFER reparseInfo;\n  DEBUG_CODE(\n  char *pszJunction8;\n  char *pszTarget8;\n  char *pszTemp8;\n  )\n  UINT uiDriveType;\n  DWORD dwFileSystemFlags;\n  int iRet = -1;\t\n  DEBUG_WSTR2NEWUTF8(junctionName, pszJunction8);\n  DEBUG_WSTR2NEWUTF8(targetName, pszTarget8);\n  DEBUG_ENTER((""junction(\\""%s\\"", \\""%s\\"");\\n"", pszTarget8, pszJunction8));\n  DEBUG_FREEUTF8(pszJunction8);\n  wszReparseBuffer = malloc(sizeof(WCHAR)*PATH_MAX*3);\n  if (!wszReparseBuffer) goto junctionW_exit;\n  reparseInfo = (PMOUNTPOINT_WRITE_BUFFER)wszReparseBuffer;\n  wszJunctionFullName = malloc(sizeof(WCHAR)*PATH_MAX);\n  if (!wszJunctionFullName) goto junctionW_exit;\n#define SIZEOF_wszFileSystem (sizeof(WCHAR)*PATH_MAX)\n  wszFileSystem = malloc(SIZEOF_wszFileSystem);\n  if (!wszFileSystem) goto junctionW_exit;\n  wszTargetTempName = malloc(sizeof(WCHAR)*PATH_MAX);\n  if (!wszTargetTempName) goto junctionW_exit;\n  wszTargetFullName = malloc(sizeof(WCHAR)*PATH_MAX);\n  if (!wszTargetFullName) goto junctionW_exit;\n  wszTargetNativeName = malloc(sizeof(WCHAR)*PATH_MAX);\n  if (!wszTargetNativeName) goto junctionW_exit;\n  if (!GetFullPathNameW(junctionName, PATH_MAX, wszJunctionFullName, &pwszFilePart)) {\n    errno = Win32ErrorToErrno();\n    DEBUG_LEAVE((""return -1; \n    goto junctionW_exit;\n  }\n  if ((targetName[0] != \'\\\\\') && (targetName[1] != \':\')) {\n    size_t lTempName = PATH_MAX;\n    lstrcpyW(wszTargetTempName, wszJunctionFullName);\n    lTempName -= lstrlenW(wszJunctionFullName);\n    if (lTempName < (size_t)(lstrlenW(targetName) + 5)) {\n      errno = ENAMETOOLONG;\n      DEBUG_LEAVE((""return -1; \n      goto junctionW_exit;\n    }\n    lstrcatW(wszTargetTempName, L""\\\\..\\\\"");\n    lstrcatW(wszTargetTempName, targetName);\n    if (!GetFullPathNameW(wszTargetTempName, PATH_MAX, wszTargetFullName, &pwszFilePart)) {\n      errno = Win32ErrorToErrno();\n      DEBUG_LEAVE((""return -1; \n      goto junctionW_exit;\n    }\n    DEBUG_WSTR2NEWUTF8(wszTargetFullName, pszTemp8);\n    XDEBUG_PRINTF((""wszTargetFullName = \\""%s\\""; \n    DEBUG_FREEUTF8(pszTemp8);\n  } else { \n    if (!GetFullPathNameW(targetName, PATH_MAX, wszTargetFullName, &pwszFilePart)) {\n      errno = Win32ErrorToErrno();\n      DEBUG_LEAVE((""return -1; \n      goto junctionW_exit;\n    }\n    DEBUG_WSTR2NEWUTF8(wszTargetFullName, pszTemp8);\n    XDEBUG_PRINTF((""wszTargetFullName = \\""%s\\""; \n    DEBUG_FREEUTF8(pszTemp8);\n  }\n#pragma warning(disable:4305) \n#pragma warning(disable:4306) \n  wszTargetFullName[0] = (WCHAR)CharUpperW((WCHAR *)(wszTargetFullName[0]));\n#pragma warning(default:4706)\n#pragma warning(default:4705)\n  DEBUG_FREEUTF8(pszTarget8);\n  wszVolumeName[0] = wszJunctionFullName[0];\n  wszFileSystem[0] = L\'\\0\'; \n  GetVolumeInformationW(wszVolumeName, NULL, 0, NULL, NULL, &dwFileSystemFlags, wszFileSystem, SIZEOF_wszFileSystem/sizeof(WCHAR));\n  if (!(dwFileSystemFlags & FILE_SUPPORTS_REPARSE_POINTS)) {\n    errno = EDOM;\n    DEBUG_WSTR2NEWUTF8(wszFileSystem, pszTemp8);\n    DEBUG_LEAVE((""return -1; \n    DEBUG_FREEUTF8(pszTemp8);\n    goto junctionW_exit;\n  }\n  uiDriveType = GetDriveTypeW(wszVolumeName);\n  DEBUG_WSTR2NEWUTF8(wszVolumeName, pszTemp8);\n  XDEBUG_PRINTF((""GetDriveType(\\""%s\\"") = %d \n  if (uiDriveType == DRIVE_REMOTE) {\n    WCHAR  wszLocalName[] = L""X:"";\n    DWORD dwErr;\n    DWORD dwLength = PATH_MAX;\n    wszRemoteName = malloc(sizeof(WCHAR)*PATH_MAX);\n    if (!wszRemoteName) goto junctionW_exit;\n    wszLocalName[0] = wszJunctionFullName[0];\n    dwErr = WNetGetConnectionW(wszLocalName, wszRemoteName, &dwLength);\n    if (dwErr == NO_ERROR) {\n      WCHAR *pwsz;\n      DEBUG_CODE(\n      char *pszRemote8;\n      )\n      DEBUG_WSTR2NEWUTF8(wszRemoteName, pszRemote8);\n      XDEBUG_PRINTF((""net use %c: %s\\n"", (char)(wszLocalName[0]), pszRemote8));\n      DEBUG_FREEUTF8(pszRemote8);\n      if ((wszRemoteName[0] == L\'\\\\\') && (wszRemoteName[1] == L\'\\\\\')) {\n\tpwsz = wcschr(wszRemoteName+2, L\'\\\\\');\n\tif (pwsz) {\n\t  if ((pwsz[2] == L\'$\') && !pwsz[3]) { \n\t    wszTargetFullName[0] = pwsz[1];\t\n\t  } else { \n\t    int lTempName = PATH_MAX;\n\t    wszTargetTempName[0] = L\'C\';\t\n\t    wszTargetTempName[1] = L\':\';\n\t    lstrcpyW(wszTargetTempName+2, pwsz);\n\t    lTempName -= lstrlenW(wszTargetTempName);\n\t    if (lTempName > lstrlenW(wszTargetFullName+2)) {\n\t      lstrcatW(wszTargetTempName, wszTargetFullName+2);\n\t      lstrcpyW(wszTargetFullName, wszTargetTempName);\n\t    }\n\t  }\n\t}\n      }\n    } else {\n      XDEBUG_PRINTF((""WNetGetConnection(\\""%s\\"") failed: Error %d\\n"", pszTemp8, dwErr));\n    }\n  }\n  DEBUG_FREEUTF8(pszTemp8);\n  lNativeName = wsprintfW(wszTargetNativeName, L""\\\\??\\\\%s"", wszTargetFullName );\n  if ( (wszTargetNativeName[lNativeName-1] == L\'\\\\\') &&\n       (wszTargetNativeName[lNativeName-2] != L\':\')) {\n    wszTargetNativeName[lNativeName-1] = L\'\\0\';\n    lNativeName -= 1;\n  }\n  DEBUG_WSTR2NEWUTF8(wszJunctionFullName, pszJunction8);\n  DEBUG_WSTR2NEWUTF8(wszTargetNativeName, pszTarget8);\n  DEBUG_PRINTF((""\n  CreateDirectoryW(junctionName, NULL);\n  hFile = CreateFileW(junctionName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\n\t\t      FILE_FLAG_OPEN_REPARSE_POINT|FILE_FLAG_BACKUP_SEMANTICS, NULL );\n  if (hFile == INVALID_HANDLE_VALUE) {\n    errno = Win32ErrorToErrno();\n    DEBUG_LEAVE((""return -1; \n    goto junctionW_exit;\n  }\n  ZeroMemory(reparseInfo, sizeof( *reparseInfo ));\n  reparseInfo->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n  reparseInfo->ReparseTargetLength = (WORD)(lNativeName * sizeof(WCHAR));\n  reparseInfo->ReparseTargetMaximumLength = reparseInfo->ReparseTargetLength + sizeof(WCHAR);\n  reparseInfo->ReparseDataLength          = reparseInfo->ReparseTargetLength + MOUNTPOINT_WRITE_BUFFER_HEADER_SIZE - 4;\n  lstrcpynW(reparseInfo->ReparseTarget, wszTargetNativeName, PATH_MAX);\n  if (!DeviceIoControl(hFile, FSCTL_SET_REPARSE_POINT, reparseInfo,\n\t\t       reparseInfo->ReparseDataLength + 8,\n\t\t       NULL, 0, &dwReturnedLength, NULL )) {\n    errno = Win32ErrorToErrno();\n    CloseHandle(hFile);\n    RemoveDirectoryW(junctionName);\n    DEBUG_LEAVE((""return -1; \n    goto junctionW_exit;\n  }\n  CloseHandle(hFile);\n  DEBUG_LEAVE((""return 0; \n  iRet = 0; \njunctionW_exit:\n  DEBUG_FREEUTF8(pszJunction8);\n  DEBUG_FREEUTF8(pszTarget8);\n  free(wszReparseBuffer);\n  free(wszJunctionFullName);\n  free(wszFileSystem);\n  free(wszTargetTempName);\n  free(wszTargetFullName);\n  free(wszTargetNativeName);\n  free(wszRemoteName);\n  return iRet;\n}\nint junctionM(const char *targetName, const char *junctionName, UINT cp) {\n  WCHAR *pwszJunction;\n  WCHAR *pwszTarget;\n  int iRet;\n  pwszJunction = MultiByteToNewWidePath(cp,\t\t\n\t\t\t\t\tjunctionName\t\n\t\t\t\t\t);\n  if (!pwszJunction) {\n    return -1;\n  }\n  pwszTarget = MultiByteToNewWidePath(cp,\t\t\n    \t\t\t\t      targetName\t\n    \t\t\t\t      );\n  if (!pwszTarget) {\n    free(pwszJunction);\n    return -1;\n  }\n  iRet = junctionW(pwszTarget, pwszJunction);\n  free(pwszJunction);\n  free(pwszTarget);\n  return iRet;\n}\n#if WINVER < 0x600 \ntypedef BOOLEAN (WINAPI *LPCREATESYMBOLICLINK)(LPCWSTR lpSymlinkName, LPCWSTR lpTargetName, DWORD dwFlags);\n#pragma warning(disable:4100) \nBOOLEAN WINAPI DefaultCreateSymbolicLinkW(LPCWSTR lpSymlinkName, LPCWSTR lpTargetName, DWORD dwFlags) {\n  DWORD dwAttr = GetFileAttributesW(lpTargetName);\n  if (dwAttr != INVALID_FILE_ATTRIBUTES) { \n    if (dwAttr & FILE_ATTRIBUTE_DIRECTORY) { \n      int iRet = junctionW(lpTargetName, lpSymlinkName);\t\n      return (BOOLEAN)(iRet + 1);\t\t\t\t\n    }\n  }\n  SetLastError(ERROR_NOT_SUPPORTED);\n  return FALSE;\n}\n#pragma warning(default:4105)\nBOOLEAN WINAPI InitCreateSymbolicLink(LPCWSTR lpSymlinkName, LPCWSTR lpTargetName, DWORD dwFlags) {\n  extern LPCREATESYMBOLICLINK lpCreateSymbolicLinkW;\n  lpCreateSymbolicLinkW = (LPCREATESYMBOLICLINK) GetProcAddress(\n    GetModuleHandle(TEXT(""kernel32.dll"")), ""CreateSymbolicLinkW"");\n  if (!lpCreateSymbolicLinkW) { \n    lpCreateSymbolicLinkW = DefaultCreateSymbolicLinkW;\n  }\n  return (*lpCreateSymbolicLinkW)(lpSymlinkName, lpTargetName, dwFlags);\n}\nLPCREATESYMBOLICLINK lpCreateSymbolicLinkW = InitCreateSymbolicLink;\n#undef CreateSymbolicLinkW\n#define CreateSymbolicLinkW (*lpCreateSymbolicLinkW)\n#endif \nint symlinkW(const WCHAR *targetName, const WCHAR *linkName) {\n  DWORD dwAttr;\n  BOOL done;\n  DWORD dwFlags;\n  int err;\n  DEBUG_CODE(\n  char *pszLink8;\n  char *pszTarget8;\n  )\n  DEBUG_WSTR2NEWUTF8(linkName, pszLink8);\n  DEBUG_WSTR2NEWUTF8(targetName, pszTarget8);\n  DEBUG_ENTER((""symlink(\\""%s\\"", \\""%s\\"");\\n"", pszTarget8, pszLink8));\n  DEBUG_FREEUTF8(pszTarget8);\n  DEBUG_FREEUTF8(pszLink8);\n  dwAttr = GetFileAttributesW(targetName);\n  DEBUG_PRINTF((""GetFileAttributes() = 0x%lX\\n"", dwAttr));\n  dwFlags = 0;\n  if (dwAttr != INVALID_FILE_ATTRIBUTES) {\t\n    if (dwAttr & FILE_ATTRIBUTE_DIRECTORY) dwFlags |= SYMBOLIC_LINK_FLAG_DIRECTORY;\n  } else { \n    size_t len = lstrlenW(targetName);\n    if (len) {\n      WCHAR c = targetName[len-1];\n      if ((c == L\'/\') || (c == L\'\\\\\')) dwFlags |= SYMBOLIC_LINK_FLAG_DIRECTORY;\n    }\n  }\n  done = CreateSymbolicLinkW(linkName, targetName, dwFlags);\n  if (done) {\n    err = 0;\n  } else {\n    errno = Win32ErrorToErrno();\n    err = -1;\n  }\n  RETURN_INT_COMMENT(err, (""%s\\n"", err?""Failed to create link"":""Created link successfully""));\n}\nint symlinkM(const char *targetName, const char *linkName, UINT cp) {\n  WCHAR *pwszLink;\n  WCHAR *pwszTarget;\n  int iRet;\n  pwszLink = MultiByteToNewWidePath(cp,\t\t\n\t\t\t\t    linkName\t\n\t\t\t\t    );\n  if (!pwszLink) {\n    return -1;\n  }\n  pwszTarget = MultiByteToNewWidePath(cp,\t\t\n\t\t\t\t      targetName\t\n\t\t\t\t      );\n  if (!pwszTarget) {\n    free(pwszLink);\n    return -1;\n  }\n  iRet = symlinkW(pwszTarget, pwszLink);\n  free(pwszLink);\n  free(pwszTarget);\n  return iRet;  \n}\nint symlinkdW(const WCHAR *targetName, const WCHAR *linkName) {\n  BOOL done;\n  int err;\n  DEBUG_CODE(\n  char *pszLink8;\n  char *pszTarget8;\n  )\n  DEBUG_WSTR2NEWUTF8(linkName, pszLink8);\n  DEBUG_WSTR2NEWUTF8(targetName, pszTarget8);\n  DEBUG_ENTER((""symlinkd(\\""%s\\"", \\""%s\\"");\\n"", pszTarget8, pszLink8));\n  DEBUG_FREEUTF8(pszTarget8);\n  DEBUG_FREEUTF8(pszLink8);\n  done = CreateSymbolicLinkW(linkName, targetName, SYMBOLIC_LINK_FLAG_DIRECTORY);\n  if (done) {\n    err = 0;\n  } else {\n    errno = Win32ErrorToErrno();\n    err = -1;\n  }\n  RETURN_INT_COMMENT(err, (""%s\\n"", err?""Failed to create link"":""Created link successfully""));\n}\nint symlinkdM(const char *targetName, const char *linkName, UINT cp) {\n  WCHAR *pwszLink;\n  WCHAR *pwszTarget;\n  int iRet;\n  pwszLink = MultiByteToNewWidePath(cp,\t\t\n\t\t\t\t    linkName\t\n\t\t\t\t    );\n  if (!pwszLink) {\n    return -1;\n  }\n  pwszTarget = MultiByteToNewWidePath(cp,\t\t\n\t\t\t\t      targetName\t\n\t\t\t\t      );\n  if (!pwszTarget) {\n    free(pwszLink);\n    return -1;\n  }\n  iRet = symlinkdW(pwszTarget, pwszLink);\n  free(pwszLink);\n  free(pwszTarget);\n  return iRet;\n}\n#endif'"
"('Prompt: You are developing a program that involves forward error correction (FEC) using various schemes. The program utilizes the libfec library to implement convolutional and Reed-Solomon codes. However, there is a condition where libfec is not enabled in the system. In this scenario, you need to create a function that tests the FEC codec using different schemes. The function should generate random messages, encode and decode them using the specified FEC scheme, and compare the original message with the decoded message. If libfec is not enabled, the function should warn the user and return. Additionally, you need to create specific test functions for the V27 and V27P45 FEC schemes. Write the code for the FEC testing function and the test functions for V27 and V27P45 FEC schemes.","//...\nvoid fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    fec q = fec_create(_fs,_opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,_n);\n    unsigned char msg[_n];          \n    unsigned char msg_enc[n_enc];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg[i] = rand() & 0xff;\n        msg_dec[i] = 0;\n    }\n    fec_encode(q,_n,msg,msg_enc);\n    msg_enc[0] ^= 0x01;\n    fec_decode(q,_n,msg_enc,msg_dec);\n    CONTEND_SAME_DATA(msg,msg_dec,_n);\n    fec_destroy(q);\n}\nvoid autotest_fec_v27()     { fec_test_codec(LIQUID_FEC_CONV_V27,      64, NULL); }\nvoid autotest_fec_v27p45()  { fec_test_codec(LIQUID_FEC_CONV_V27P45,   64, NULL); }\n//...')
"
"(""Prompt: You are tasked with writing a function in C that tests error correction capabilities using Forward Error Correction (FEC) for a specific set of FEC schemes. The function should encode a random message, introduce an error in the encoded message, decode it, and verify that the original message is recovered. Additionally, if the 'libfec' library is not enabled, the function should output a warning message indicating unavailability of convolutional and Reed-Solomon codes. Finally, you need to write a specific test function for the LIQUID_FEC_CONV_V27 scheme with message length 64.. Code Response:. ```c. void fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts). {. #if !LIBFEC_ENABLED.     switch (_fs) {.     case LIQUID_FEC_CONV_V27:.     case LIQUID_FEC_CONV_V29:.     case LIQUID_FEC_CONV_V39:.     case LIQUID_FEC","//...\nvoid fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    fec q = fec_create(_fs,_opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,_n);\n    unsigned char msg[_n];          \n    unsigned char msg_enc[n_enc];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg[i] = rand() & 0xff;\n        msg_dec[i] = 0;\n    }\n    fec_encode(q,_n,msg,msg_enc);\n    msg_enc[0] ^= 0x01;\n    fec_decode(q,_n,msg_enc,msg_dec);\n    CONTEND_SAME_DATA(msg,msg_dec,_n);\n    fec_destroy(q);\n}\nvoid autotest_fec_v27()     { fec_test_codec(LIQUID_FEC_CONV_V27,      64, NULL); }\n//...')
"
"('Prompt: You are tasked with writing a function in C that sets the payload soft value in a given OFDM flexframe sync object. The function should take in the OFDM flexframe sync object and an integer value, and should return LIQUID_OK upon successful completion.","//...\n    unsigned char * p;      \n    int payload_soft;                   \nint ofdmflexframesync_decode_payload_soft(ofdmflexframesync _q,\n                                          int _soft)\n{\n    _q->payload_soft = _soft;\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on a program that requires creating a histogram and logging the results. Write a C function that takes in an array of floats representing the histogram bins, the number of bins, the minimum value, and the maximum value, and prints out a visualization of the histogram. The visualization should consist of characters representing the frequency of each bin relative to the maximum frequency. The histogram bars should be a maximum of 72 characters long.","//...\nvoid _support_histogram_log(float *      _bins,\n                            unsigned int _num_bins,\n                            float        _vmin,\n                            float        _vmax)\n{\n    unsigned int i;\n    float hist_max = 0;\n    for (i=0; i<_num_bins; i++)\n        hist_max = _bins[i] > hist_max ? _bins[i] : hist_max;\n    unsigned int num_chars = 72;\n    float _vstep = (_vmax - _vmin) / (float)(_num_bins-1);\n    printf(""%8s : [%12s]\\n"", ""v"", ""bin value"");\n    for (i=0; i<_num_bins; i++) {\n        printf(""%8.2f : [%12g]"", _vmin + i*_vstep, _bins[i]);\n        unsigned int k;\n        unsigned int n = round(num_chars * _bins[i] / hist_max);\n        for (k=0; k<n; k++)\n            printf(""-"");\n        printf(""+"");\n        printf(""\\n"");\n    }\n}\n//...')
"
"('Prompt: You are working on a project that involves implementing forward error correction (FEC) for different code rates in a communication system. You need to define matrices for FEC convolutional codes with rates 1/2, 3/4, 4/5, 5/6, 6/7, and 7/8 for both constraint lengths 7 and 9. Can you provide the C code defining the matrices for each of these FEC convolutional codes?","int fec_conv27p23_matrix[4] = {\n    1, 1,\n    1, 0\n};\nint fec_conv27p34_matrix[6] = {\n    1, 1, 0,\n    1, 0, 1\n};\nint fec_conv27p45_matrix[8] = {\n    1, 1, 1, 1,\n    1, 0, 0, 0\n};\nint fec_conv27p56_matrix[10] = {\n    1, 1, 0, 1, 0,\n    1, 0, 1, 0, 1\n};\nint fec_conv27p67_matrix[12] = {\n    1, 1, 1, 0, 1, 0,\n    1, 0, 0, 1, 0, 1\n};\nint fec_conv27p78_matrix[14] = {\n    1, 1, 1, 1, 0, 1, 0,\n    1, 0, 0, 0, 1, 0, 1\n};\nint fec_conv29p23_matrix[4] = {\n    1, 1,\n    1, 0\n};\nint fec_conv29p34_matrix[6] = {\n    1, 1, 1,\n    1, 0, 0\n};\nint fec_conv29p45_matrix[8] = {\n    1, 1, 0, 1,\n    1, 0, 1, 0\n};\nint fec_conv29p56_matrix[10] = {\n    1, 0, 1, 1, 0,\n    1, 1, 0, 0, 1\n};\nint fec_conv29p67_matrix[12] = {\n    1, 1, 0, 1, 1, 0,\n    1, 0, 1, 0, 0, 1\n};\nint fec_conv29p78_matrix[14] = {\n    1, 1, 0, 1, 0, 1, 1,\n    1, 0, 1, 0, 1, 0, 0\n};')
"
"(""Prompt: Given a scenario where you have a set of polynomial coefficients stored in an array `_p` of length `_k` and you need to find the roots of the polynomial. Write a function `poly_findroots` that takes the polynomial coefficients `_p`, the length of the array `_k`, and an array `_roots` to store the roots in. The function should use the Bairstow's method to find the roots and then sort the roots in ascending order using the `qsort` function. Finally, the function should return `LIQUID_OK` to indicate successful execution.","//...\nint poly_findroots(double *         _p,\n                   unsigned int     _k,\n                   double complex * _roots)\n{\n    liquid_poly_findroots_bairstow(_p,_k,_roots);\n    qsort(_roots, _k-1, sizeof(double complex), &liquid_poly_sort_roots_compare);\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: In a scenario where you are working on a LVGL project that includes examples and uses image functionality, demonstrate how to create a new style (style 12) for an object with a green background color and a light green border color with a border width of 3. Additionally, set the background color of the object to orange and position it in the center of the screen.","#if LV_BUILD_EXAMPLES && LV_USE_IMAGE\nvoid lv_example_style_12(void)\n{\n    static lv_style_t style;\n    lv_style_init(&style);\n    lv_style_set_bg_color(&style, lv_palette_main(LV_PALETTE_GREEN));\n    lv_style_set_border_color(&style, lv_palette_lighten(LV_PALETTE_GREEN, 3));\n    lv_style_set_border_width(&style, 3);\n    lv_obj_t * obj = lv_obj_create(lv_screen_active());\n    lv_obj_add_style(obj, &style, 0);\n    lv_obj_set_style_bg_color(obj, lv_palette_main(LV_PALETTE_ORANGE), LV_PART_MAIN);\n    lv_obj_center(obj);\n}\n#endif'"
"('You are working on optimizing a complex dot product implementation in C using SIMD instructions. The code you provided translates the dot product calculation to SSE and SSE4 instructions for improved performance. You first define functions for SSE and SSE4 execution, then choose the appropriate function based on the dimensionality of the inputs. . . Prompt: ""Can you provide an optimized complex dot product implementation in C using SIMD instructions, specifically targeting SSE and SSE4 for improved performance?""","//...\nint dotprod_cccf_execute_sse(dotprod_cccf    _q,\n                             float complex * _x,\n                             float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    __m128 v;   \n    __m128 hi;  \n    __m128 hq;  \n    __m128 ci;  \n    __m128 cq;  \n    float w[4] __attribute__((aligned(16))) = {0,0,0,0};\n#if HAVE_SSE3\n    __m128 s;   \n    __m128 sum = _mm_setzero_ps(); \n#else\n    float wi[4] __attribute__((aligned(16)));\n    float wq[4] __attribute__((aligned(16)));\n#endif\n    unsigned int t = (n >> 2) << 2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        v = _mm_loadu_ps(&x[i]);\n        hi = _mm_load_ps(&_q->hi[i]);\n        hq = _mm_load_ps(&_q->hq[i]);\n        ci = _mm_mul_ps(v, hi);\n        cq = _mm_mul_ps(v, hq);\n        cq = _mm_shuffle_ps( cq, cq, _MM_SHUFFLE(2,3,0,1) );\n#if HAVE_SSE3\n        s = _mm_addsub_ps( ci, cq );\n        sum = _mm_add_ps(sum, s);\n#else\n        _mm_store_ps(wi, ci);\n        _mm_store_ps(wq, cq);\n        w[0] += wi[0] - wq[0];\n        w[1] += wi[1] + wq[1];\n        w[2] += wi[2] - wq[2];\n        w[3] += wi[3] + wq[3];\n#endif\n    }\n#if HAVE_SSE3\n    _mm_store_ps(w, sum);\n#endif\n    w[0] += w[2];   \n    w[1] += w[3];   \n    float complex total = w[0] + w[1] * _Complex_I;\n    for (i=t/2; i<_q->n; i++)\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    *_y = total;\n    return LIQUID_OK;\n}\nint dotprod_cccf_execute_sse4(dotprod_cccf    _q,\n                              float complex * _x,\n                              float complex * _y)\n{\n    float * x = (float*) _x;\n    unsigned int n = 2*_q->n;\n    __m128 v0,  v1,  v2,  v3;   \n    __m128 hi0, hi1, hi2, hi3;  \n    __m128 hq0, hq1, hq2, hq3;  \n    __m128 ci0, ci1, ci2, ci3;  \n    __m128 cq0, cq1, cq2, cq3;  \n    __m128 sumi = _mm_setzero_ps();\n    __m128 sumq = _mm_setzero_ps();\n    unsigned int r = (n >> 4) << 2;\n    unsigned int i;\n    for (i=0; i<r; i+=4) {\n        v0 = _mm_loadu_ps(&x[4*i+0]);\n        v1 = _mm_loadu_ps(&x[4*i+4]);\n        v2 = _mm_loadu_ps(&x[4*i+8]);\n        v3 = _mm_loadu_ps(&x[4*i+12]);\n        hi0 = _mm_load_ps(&_q->hi[4*i+0]);\n        hi1 = _mm_load_ps(&_q->hi[4*i+4]);\n        hi2 = _mm_load_ps(&_q->hi[4*i+8]);\n        hi3 = _mm_load_ps(&_q->hi[4*i+12]);\n        hq0 = _mm_load_ps(&_q->hq[4*i+0]);\n        hq1 = _mm_load_ps(&_q->hq[4*i+4]);\n        hq2 = _mm_load_ps(&_q->hq[4*i+8]);\n        hq3 = _mm_load_ps(&_q->hq[4*i+12]);\n        ci0 = _mm_mul_ps(v0, hi0);\n        ci1 = _mm_mul_ps(v1, hi1);\n        ci2 = _mm_mul_ps(v2, hi2);\n        ci3 = _mm_mul_ps(v3, hi3);\n        cq0 = _mm_mul_ps(v0, hq0);\n        cq1 = _mm_mul_ps(v1, hq1);\n        cq2 = _mm_mul_ps(v2, hq2);\n        cq3 = _mm_mul_ps(v3, hq3);\n        sumi = _mm_add_ps(sumi, ci0);   sumq = _mm_add_ps(sumq, cq0);\n        sumi = _mm_add_ps(sumi, ci1);   sumq = _mm_add_ps(sumq, cq1);\n        sumi = _mm_add_ps(sumi, ci2);   sumq = _mm_add_ps(sumq, cq2);\n        sumi = _mm_add_ps(sumi, ci3);   sumq = _mm_add_ps(sumq, cq3);\n    }\n    sumq = _mm_shuffle_ps( sumq, sumq, _MM_SHUFFLE(2,3,0,1) );\n    float wi[4] __attribute__((aligned(16)));\n    float wq[4] __attribute__((aligned(16)));\n    _mm_store_ps(wi, sumi);\n    _mm_store_ps(wq, sumq);\n    float complex total = \n        ((wi[0] - wq[0]) + (wi[2] - wq[2])) +\n        ((wi[1] + wq[1]) + (wi[3] + wq[3])) * _Complex_I;\n    for (i=2*r; i<_q->n; i++) {\n        total += _x[i] * ( _q->hi[2*i] + _q->hq[2*i]*_Complex_I );\n    }\n    *_y = total;\n    return LIQUID_OK;\n}\nint dotprod_cccf_execute(dotprod_cccf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 32) {\n        return dotprod_cccf_execute_sse(_q, _x, _y);\n    }\n    return dotprod_cccf_execute_sse4(_q, _x, _y);\n}\nint dotprod_cccf_execute(dotprod_cccf    _q,\n                         float complex * _x,\n                         float complex * _y)\n{\n    if (_q->n < 32) {\n        return dotprod_cccf_execute_sse(_q, _x, _y);\n    }\n    return dotprod_cccf_execute_sse4(_q, _x, _y);\n}\n//...')
"
"'Please provide me with a technical scenario in which you need to perform operations related to Flash memory in your embedded system, such as mass erasing, enabling/disabling write protection, configuring secure areas, and boot address options.","#ifdef HAL_FLASH_MODULE_ENABLED\n#define FLASH_TIMEOUT_VALUE       50000U \nstatic void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks);\nstatic void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks);\nstatic void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Bank);\nstatic void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank);\nstatic void FLASH_OB_RDPConfig(uint32_t RDPLevel);\nstatic uint32_t FLASH_OB_GetRDP(void);\nstatic void FLASH_OB_PCROPConfig(uint32_t PCROConfigRDP, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks);\nstatic void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr,uint32_t *PCROPEndAddr, uint32_t Bank);\nstatic void FLASH_OB_BOR_LevelConfig(uint32_t Level);\nstatic uint32_t FLASH_OB_GetBOR(void);\nstatic void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig);\nstatic uint32_t FLASH_OB_GetUser(void);\nstatic void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1);\nstatic void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1);\nstatic void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks);\nstatic void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank);\nstatic void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank);\nstatic void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank);\n#if defined (DUAL_CORE)\nstatic void FLASH_OB_CM4BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1);\nstatic void FLASH_OB_GetCM4BootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1);\n#endif \n#if defined (FLASH_OTPBL_LOCKBL)\nstatic void FLASH_OB_OTP_LockConfig(uint32_t OTP_Block);\nstatic uint32_t FLASH_OB_OTP_GetLock(void);\n#endif \n#if defined (FLASH_OPTSR2_TCM_AXI_SHARED)\nstatic void FLASH_OB_SharedRAM_Config(uint32_t SharedRamConfig);\nstatic uint32_t FLASH_OB_SharedRAM_GetConfig(void);\n#endif \n#if defined (FLASH_OPTSR2_CPUFREQ_BOOST)\nstatic void FLASH_OB_CPUFreq_BoostConfig(uint32_t FreqBoost);\nstatic uint32_t FLASH_OB_CPUFreq_GetBoost(void);\n#endif \nHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t sector_index;\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\n  assert_param(IS_FLASH_BANK(pEraseInit->Banks));\n  __HAL_LOCK(&pFlash);\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\n  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n  }\n#if defined (DUAL_BANK)\n  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n  }\n#endif \n  if(status == HAL_OK)\n  {\n    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\n    {\n      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);\n      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\n      {\n        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\n        {\n          status = HAL_ERROR;\n        }\n        FLASH->CR1 &= (~FLASH_CR_BER);\n      }\n#if defined (DUAL_BANK)\n      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\n      {\n        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\n        {\n          status = HAL_ERROR;\n        }\n        FLASH->CR2 &= (~FLASH_CR_BER);\n      }\n#endif \n    }\n    else\n    {\n      *SectorError = 0xFFFFFFFFU;\n      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)\n      {\n        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);\n        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\n        {\n          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);\n          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));\n        }\n#if defined (DUAL_BANK)\n        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\n        {\n          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);\n          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));\n        }\n#endif \n        if(status != HAL_OK)\n        {\n          *SectorError = sector_index;\n          break;\n        }\n      }\n    }\n  }\n  __HAL_UNLOCK(&pFlash);\n  return status;\n}\nHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\n  assert_param(IS_FLASH_BANK(pEraseInit->Banks));\n  __HAL_LOCK(&pFlash);\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\n  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n  }\n#if defined (DUAL_BANK)\n  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\n    {\n      status = HAL_ERROR;\n    }\n  }\n#endif \n  if (status != HAL_OK)\n  {\n    __HAL_UNLOCK(&pFlash);\n  }\n  else\n  {\n    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\n    {\n#if defined (FLASH_CR_OPERRIE)\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);\n#else\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);\n#endif \n    }\n#if defined (DUAL_BANK)\n    if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\n    {\n#if defined (FLASH_CR_OPERRIE)\n      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\n                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2 | FLASH_IT_OPERR_BANK2);\n#else\n      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\n                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);\n#endif \n    }\n#endif \n    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\n    {\n      if(pEraseInit->Banks == FLASH_BANK_1)\n      {\n        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;\n      }\n#if defined (DUAL_BANK)\n      else if(pEraseInit->Banks == FLASH_BANK_2)\n      {\n        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;\n      }\n#endif \n      else\n      {\n        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;\n      }\n      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);\n    }\n    else\n    {\n#if defined (DUAL_BANK)\n      if(pEraseInit->Banks == FLASH_BANK_1)\n      {\n        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;\n      }\n      else\n      {\n        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;\n      }\n#else\n      pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;\n#endif \n      pFlash.NbSectorsToErase = pEraseInit->NbSectors;\n      pFlash.Sector = pEraseInit->Sector;\n      pFlash.VoltageForErase = pEraseInit->VoltageRange;\n      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);\n    }\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)\n{\n  HAL_StatusTypeDef status;\n  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));\n  __HAL_LOCK(&pFlash);\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\n  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\n  {\n    status = HAL_ERROR;\n  }\n#if defined (DUAL_BANK)\n  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\n  {\n    status = HAL_ERROR;\n  }\n#endif \n  else\n  {\n    status = HAL_OK;\n  }\n  if(status == HAL_OK)\n  {\n    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)\n    {\n      assert_param(IS_WRPSTATE(pOBInit->WRPState));\n      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)\n      {\n        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);\n      }\n      else\n      {\n        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);\n      }\n    }\n    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)\n    {\n      FLASH_OB_RDPConfig(pOBInit->RDPLevel);\n    }\n    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)\n    {\n      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);\n    }\n    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)\n    {\n      assert_param(IS_FLASH_BANK(pOBInit->Banks));\n      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);\n    }\n    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)\n    {\n      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);\n    }\n#if defined(DUAL_CORE)\n    if((pOBInit->OptionType & OPTIONBYTE_CM7_BOOTADD) == OPTIONBYTE_CM7_BOOTADD)\n    {\n      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);\n    }\n    if((pOBInit->OptionType & OPTIONBYTE_CM4_BOOTADD) == OPTIONBYTE_CM4_BOOTADD)\n    {\n      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);\n    }\n#else \n    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)\n    {\n      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);\n    }\n#endif \n    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)\n    {\n      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);\n    }\n#if defined(FLASH_OTPBL_LOCKBL)\n    if((pOBInit->OptionType & OPTIONBYTE_OTP_LOCK) == OPTIONBYTE_OTP_LOCK)\n    {\n      FLASH_OB_OTP_LockConfig(pOBInit->OTPBlockLock);\n    }\n#endif \n#if defined(FLASH_OPTSR2_TCM_AXI_SHARED)\n    if((pOBInit->OptionType & OPTIONBYTE_SHARED_RAM) == OPTIONBYTE_SHARED_RAM)\n    {\n      FLASH_OB_SharedRAM_Config(pOBInit->SharedRamConfig);\n    }\n#endif \n#if defined(FLASH_OPTSR2_CPUFREQ_BOOST)\n    if((pOBInit->OptionType & OPTIONBYTE_FREQ_BOOST) == OPTIONBYTE_FREQ_BOOST)\n    {\n      FLASH_OB_CPUFreq_BoostConfig(pOBInit->FreqBoostState);\n    }\n#endif \n  }\n  __HAL_UNLOCK(&pFlash);\n  return status;\n}\nvoid HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)\n{\n  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);\n  pOBInit->RDPLevel = FLASH_OB_GetRDP();\n  pOBInit->USERConfig = FLASH_OB_GetUser();\n  pOBInit->BORLevel = FLASH_OB_GetBOR();\n#if defined (DUAL_BANK)\n  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))\n#else\n  if (pOBInit->Banks == FLASH_BANK_1)\n#endif \n  {\n    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);\n    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);\n    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);\n    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);\n  }\n  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));\n#if defined(DUAL_CORE)\n  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;\n  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));\n#else\n  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;\n#endif \n#if defined (FLASH_OTPBL_LOCKBL)\n  pOBInit->OptionType |= OPTIONBYTE_OTP_LOCK;\n  pOBInit->OTPBlockLock = FLASH_OB_OTP_GetLock();\n#endif \n#if defined (FLASH_OPTSR2_TCM_AXI_SHARED)\n  pOBInit->OptionType |= OPTIONBYTE_SHARED_RAM;\n  pOBInit->SharedRamConfig = FLASH_OB_SharedRAM_GetConfig();\n#endif \n#if defined (FLASH_OPTSR2_CPUFREQ_BOOST)\n  pOBInit->OptionType |= OPTIONBYTE_FREQ_BOOST;\n  pOBInit->FreqBoostState = FLASH_OB_CPUFreq_GetBoost();\n#endif \n}\nHAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)\n{\n  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)\n  {\n    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);\n    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);\n    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)\n    {\n      return HAL_ERROR;\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)\n{\n  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);\n  return HAL_OK;\n}\n#if defined (DUAL_BANK)\nHAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank2(void)\n{\n  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)\n  {\n    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);\n    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);\n    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)\n    {\n      return HAL_ERROR;\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_FLASHEx_Lock_Bank2(void)\n{\n  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);\n  return HAL_OK;\n}\n#endif \nHAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)\n{\n  HAL_StatusTypeDef status;\n  uint32_t sector_index;\n  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));\n  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));\n  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\n  if (status == HAL_OK)\n  {\n    if (pCRCInit->Bank == FLASH_BANK_1)\n    {\n      FLASH->CR1 |= FLASH_CR_CRC_EN;\n      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);\n      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;\n      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)\n      {\n        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;\n        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)\n        {\n          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);\n        }\n      }\n      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)\n      {\n        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;\n      }\n      else\n      {\n        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);\n      }\n      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;\n      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);\n      (*CRC_Result) = FLASH->CRCDATA;\n      FLASH->CR1 &= (~FLASH_CR_CRC_EN);\n      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);\n    }\n#if defined (DUAL_BANK)\n    else\n    {\n      FLASH->CR2 |= FLASH_CR_CRC_EN;\n      FLASH->CCR2 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);\n      FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;\n      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)\n      {\n        FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_SECT;\n        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)\n        {\n          FLASH_CRC_AddSector(sector_index, FLASH_BANK_2);\n        }\n      }\n      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)\n      {\n        FLASH->CRCCR2 |= FLASH_CRCCR_ALL_BANK;\n      }\n      else\n      {\n        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_2);\n      }\n      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;\n      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);\n      (*CRC_Result) = FLASH->CRCDATA;\n      FLASH->CR2 &= (~FLASH_CR_CRC_EN);\n      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);\n    }\n#endif \n  }\n  return status;\n}\nstatic void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)\n{\n#if defined (FLASH_CR_PSIZE)\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\n#else\n  UNUSED(VoltageRange);\n#endif \n  assert_param(IS_FLASH_BANK(Banks));\n#if defined (DUAL_BANK)\n  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)\n  {\n#if defined (FLASH_CR_PSIZE)\n    FLASH->CR1 &= (~FLASH_CR_PSIZE);\n    FLASH->CR2 &= (~FLASH_CR_PSIZE);\n    FLASH->CR1 |= VoltageRange;\n    FLASH->CR2 |= VoltageRange;\n#endif \n    FLASH->OPTCR |= FLASH_OPTCR_MER;\n  }\n  else\n#endif \n  {\n    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\n    {\n#if defined (FLASH_CR_PSIZE)\n      FLASH->CR1 &= (~FLASH_CR_PSIZE);\n      FLASH->CR1 |=  VoltageRange;\n#endif \n      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);\n    }\n#if defined (DUAL_BANK)\n    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\n    {\n#if defined (FLASH_CR_PSIZE)\n      FLASH->CR2 &= (~FLASH_CR_PSIZE);\n      FLASH->CR2 |= VoltageRange;\n#endif \n      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);\n    }\n#endif \n  }\n}\nvoid FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)\n{\n  assert_param(IS_FLASH_SECTOR(Sector));\n  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));\n#if defined (FLASH_CR_PSIZE)\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\n#else\n  UNUSED(VoltageRange);\n#endif \n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n#if defined (FLASH_CR_PSIZE)\n    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);\n    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\n#else\n    FLASH->CR1 &= ~(FLASH_CR_SNB);\n    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\n#endif \n  }\n#if defined (DUAL_BANK)\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n#if defined (FLASH_CR_PSIZE)\n    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);\n    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\n#else\n    FLASH->CR2 &= ~(FLASH_CR_SNB);\n    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\n#endif \n  }\n#endif \n}\nstatic void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)\n{\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\n  assert_param(IS_FLASH_BANK(Banks));\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));\n  }\n#if defined (DUAL_BANK)\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));\n  }\n#endif \n}\nstatic void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)\n{\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\n  assert_param(IS_FLASH_BANK(Banks));\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);\n  }\n#if defined (DUAL_BANK)\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);\n  }\n#endif \n}\nstatic void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)\n{\n  uint32_t regvalue = 0U;\n  if(Bank == FLASH_BANK_1)\n  {\n    regvalue = FLASH->WPSN_CUR1;\n  }\n#if defined (DUAL_BANK)\n  if(Bank == FLASH_BANK_2)\n  {\n    regvalue = FLASH->WPSN_CUR2;\n  }\n#endif \n  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;\n  if(*WRPSector == 0U)\n  {\n    (*WRPState) = OB_WRPSTATE_DISABLE;\n  }\n  else\n  {\n    (*WRPState) = OB_WRPSTATE_ENABLE;\n  }\n}\nstatic void FLASH_OB_RDPConfig(uint32_t RDPLevel)\n{\n  assert_param(IS_OB_RDP_LEVEL(RDPLevel));\n  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);\n}\nstatic uint32_t FLASH_OB_GetRDP(void)\n{\n  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);\n  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))\n  {\n    return (OB_RDP_LEVEL_1);\n  }\n  else\n  {\n    return rdp_level;\n  }\n}\n#if defined(DUAL_CORE)\n#else\n#endif \nstatic void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)\n{\n  uint32_t optr_reg_val = 0;\n  uint32_t optr_reg_mask = 0;\n  assert_param(IS_OB_USER_TYPE(UserType));\n  if((UserType & OB_USER_IWDG1_SW) != 0U)\n  {\n    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);\n    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;\n  }\n#if defined(DUAL_CORE)\n  if((UserType & OB_USER_IWDG2_SW) != 0U)\n  {\n    assert_param(IS_OB_IWDG2_SOURCE(UserConfig & FLASH_OPTSR_IWDG2_SW));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);\n    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;\n  }\n#endif \n  if((UserType & OB_USER_NRST_STOP_D1) != 0U)\n  {\n    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);\n    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;\n  }\n  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)\n  {\n    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);\n    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;\n  }\n  if((UserType & OB_USER_IWDG_STOP) != 0U)\n  {\n    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);\n    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;\n  }\n  if((UserType & OB_USER_IWDG_STDBY) != 0U)\n  {\n    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);\n    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;\n  }\n  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)\n  {\n    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);\n    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;\n  }\n  if((UserType & OB_USER_SECURITY) != 0U)\n  {\n    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);\n    optr_reg_mask |= FLASH_OPTSR_SECURITY;\n  }\n#if defined(DUAL_CORE)\n  if((UserType & OB_USER_BCM4) != 0U)\n  {\n    assert_param(IS_OB_USER_BCM4(UserConfig & FLASH_OPTSR_BCM4));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_BCM4);\n    optr_reg_mask |= FLASH_OPTSR_BCM4;\n  }\n  if((UserType & OB_USER_BCM7) != 0U)\n  {\n    assert_param(IS_OB_USER_BCM7(UserConfig & FLASH_OPTSR_BCM7));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_BCM7);\n    optr_reg_mask |= FLASH_OPTSR_BCM7;\n  }\n#endif \n#if defined (FLASH_OPTSR_NRST_STOP_D2)\n  if((UserType & OB_USER_NRST_STOP_D2) != 0U)\n  {\n    assert_param(IS_OB_STOP_D2_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D2));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D2);\n    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D2;\n  }\n  if((UserType & OB_USER_NRST_STDBY_D2) != 0U)\n  {\n    assert_param(IS_OB_STDBY_D2_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D2));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D2);\n    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;\n  }\n#endif \n#if defined (DUAL_BANK)\n  if((UserType & OB_USER_SWAP_BANK) != 0U)\n  {\n    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);\n    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;\n  }\n#endif \n  if((UserType & OB_USER_IOHSLV) != 0U)\n  {\n    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);\n    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;\n  }\n#if defined (FLASH_OPTSR_VDDMMC_HSLV)\n  if((UserType & OB_USER_VDDMMC_HSLV) != 0U)\n  {\n    assert_param(IS_OB_USER_VDDMMC_HSLV(UserConfig & FLASH_OPTSR_VDDMMC_HSLV));\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_VDDMMC_HSLV);\n    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;\n  }\n#endif \n  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);\n}\n#if defined(DUAL_CORE)\n#else\n#endif \nstatic uint32_t FLASH_OB_GetUser(void)\n{\n  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);\n  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));\n  return userConfig;\n}\nstatic void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)\n{\n  assert_param(IS_FLASH_BANK(Banks));\n  assert_param(IS_OB_PCROP_RDP(PCROPConfig));\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));\n    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \\\n                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \\\n                       PCROPConfig;\n  }\n#if defined (DUAL_BANK)\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));\n    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \\\n                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \\\n                       PCROPConfig;\n  }\n#endif \n}\nstatic void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)\n{\n  uint32_t regvalue = 0;\n  uint32_t bankBase = 0;\n  if(Bank == FLASH_BANK_1)\n  {\n    regvalue = FLASH->PRAR_CUR1;\n    bankBase = FLASH_BANK1_BASE;\n  }\n#if defined (DUAL_BANK)\n  if(Bank == FLASH_BANK_2)\n  {\n    regvalue = FLASH->PRAR_CUR2;\n    bankBase = FLASH_BANK2_BASE;\n  }\n#endif \n  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);\n  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;\n  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;\n  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;\n}\nstatic void FLASH_OB_BOR_LevelConfig(uint32_t Level)\n{\n  assert_param(IS_OB_BOR_LEVEL(Level));\n  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);\n}\nstatic uint32_t FLASH_OB_GetBOR(void)\n{\n  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);\n}\nstatic void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)\n{\n  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));\n  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)\n  {\n    assert_param(IS_BOOT_ADDRESS(BootAddress0));\n#if defined(DUAL_CORE)\n    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));\n#else \n    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));\n#endif \n  }\n  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)\n  {\n    assert_param(IS_BOOT_ADDRESS(BootAddress1));\n#if defined(DUAL_CORE)\n    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);\n#else \n    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);\n#endif \n  }\n}\nstatic void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)\n{\n  uint32_t regvalue;\n#if defined(DUAL_CORE)\n  regvalue = FLASH->BOOT7_CUR;\n  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;\n  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);\n#else \n  regvalue = FLASH->BOOT_CUR;\n  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;\n  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);\n#endif \n}\n#if defined(DUAL_CORE)\nstatic void FLASH_OB_CM4BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)\n{\n  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));\n  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)\n  {\n    assert_param(IS_BOOT_ADDRESS(BootAddress0));\n    MODIFY_REG(FLASH->BOOT4_PRG, FLASH_BOOT4_BCM4_ADD0, (BootAddress0 >> 16));\n  }\n  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)\n  {\n    assert_param(IS_BOOT_ADDRESS(BootAddress1));\n    MODIFY_REG(FLASH->BOOT4_PRG, FLASH_BOOT4_BCM4_ADD1, BootAddress1);\n  }\n}\nstatic void FLASH_OB_GetCM4BootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)\n{\n  uint32_t regvalue;\n  regvalue = FLASH->BOOT4_CUR;\n  (*BootAddress0) = (regvalue & FLASH_BOOT4_BCM4_ADD0) << 16;\n  (*BootAddress1) = (regvalue & FLASH_BOOT4_BCM4_ADD1);\n}\n#endif \nstatic void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)\n{\n  assert_param(IS_FLASH_BANK(Banks));\n  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\n  {\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));\n    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \\\n                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \\\n                       (SecureAreaConfig & FLASH_SCAR_DMES);\n  }\n#if defined (DUAL_BANK)\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\n  {\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));\n    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \\\n                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \\\n                       (SecureAreaConfig & FLASH_SCAR_DMES);\n  }\n#endif \n}\nstatic void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)\n{\n  uint32_t regvalue = 0;\n  uint32_t bankBase = 0;\n  if(Bank == FLASH_BANK_1)\n  {\n    regvalue = FLASH->SCAR_CUR1;\n    bankBase = FLASH_BANK1_BASE;\n  }\n#if defined (DUAL_BANK)\n  if(Bank == FLASH_BANK_2)\n  {\n    regvalue = FLASH->SCAR_CUR2;\n    bankBase = FLASH_BANK2_BASE;\n  }\n#endif \n  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);\n  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;\n  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;\n  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;\n}\nstatic void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)\n{\n  assert_param(IS_FLASH_SECTOR(Sector));\n  if (Bank == FLASH_BANK_1)\n  {\n    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);\n    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;\n  }\n#if defined (DUAL_BANK)\n  else\n  {\n    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);\n    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;\n  }\n#endif \n}\nstatic void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)\n{\n  if (Bank == FLASH_BANK_1)\n  {\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));\n    FLASH->CRCSADD1 = CRCStartAddr;\n    FLASH->CRCEADD1 = CRCEndAddr;\n  }\n#if defined (DUAL_BANK)\n  else\n  {\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCStartAddr));\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCEndAddr));\n    FLASH->CRCSADD2 = CRCStartAddr;\n    FLASH->CRCEADD2 = CRCEndAddr;\n  }\n#endif \n}\n#if defined (FLASH_OTPBL_LOCKBL)\nstatic void FLASH_OB_OTP_LockConfig(uint32_t OTP_Block)\n{\n  assert_param(IS_OTP_BLOCK(OTP_Block));\n  FLASH->OTPBL_PRG |= (OTP_Block & FLASH_OTPBL_LOCKBL);\n}\nstatic uint32_t FLASH_OB_OTP_GetLock(void)\n{\n  return (FLASH->OTPBL_CUR);\n}\n#endif \n#if defined (FLASH_OPTSR2_TCM_AXI_SHARED)\nstatic void FLASH_OB_SharedRAM_Config(uint32_t SharedRamConfig)\n{\n  assert_param(IS_OB_USER_TCM_AXI_SHARED(SharedRamConfig));\n  MODIFY_REG(FLASH->OPTSR2_PRG, FLASH_OPTSR2_TCM_AXI_SHARED, SharedRamConfig);\n}\nstatic uint32_t FLASH_OB_SharedRAM_GetConfig(void)\n{\n  return (FLASH->OPTSR2_CUR & FLASH_OPTSR2_TCM_AXI_SHARED);\n}\n#endif \n#if defined (FLASH_OPTSR2_CPUFREQ_BOOST)\nstatic void FLASH_OB_CPUFreq_BoostConfig(uint32_t FreqBoost)\n{\n  assert_param(IS_OB_USER_CPUFREQ_BOOST(FreqBoost));\n  MODIFY_REG(FLASH->OPTSR2_PRG, FLASH_OPTSR2_CPUFREQ_BOOST, FreqBoost);\n}\nstatic uint32_t FLASH_OB_CPUFreq_GetBoost(void)\n{\n  return (FLASH->OPTSR2_CUR & FLASH_OPTSR2_CPUFREQ_BOOST);\n}\n#endif \n#endif '"
('Please provide the prompt for which you would like the corresponding code as a response.,"typedef struct {\n    int             id;\n    float complex * buf;\n    unsigned int    buf_len;\n    unsigned int    count;\n} autotest_qdsync_s;\nint autotest_qdsync_callback(float complex * _buf,\n                             unsigned int    _buf_len,\n                             void *          _context)\n{\n    autotest_qdsync_s * q = (autotest_qdsync_s *) _context;\n    if (liquid_autotest_verbose)\n        printf(""[%d] qdsync callback got %u samples\\n"", q->id, _buf_len);\n    unsigned int i;\n    for (i=0; i<_buf_len; i++) {\n        if (q->count == q->buf_len)\n            return 1; \n        q->buf[q->count++] = _buf[i];\n    }\n    return 0;\n}\nvoid testbench_qdsync_linear(unsigned int _k,\n                             unsigned int _m,\n                             float        _beta)\n{\n    unsigned int seq_len      = 1200;   \n    unsigned int k            =   _k;   \n    unsigned int m            =   _m;   \n    float        beta         = _beta;  \n    int          ftype        = LIQUID_FIRFILT_ARKAISER;\n    float        nstd         = 0.001f;\n    float        tau          = 0.400f; \n    float complex seq_tx[seq_len];  \n    float complex seq_rx[seq_len];  \n    unsigned int i;\n    for (i=0; i<seq_len ; i++) {\n        seq_tx[i] = (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 +\n                    (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 * _Complex_I;\n    }\n    autotest_qdsync_s obj = {.id=0, .buf=seq_rx, .buf_len=seq_len, .count=0};\n    qdsync_cccf q = qdsync_cccf_create_linear(seq_tx, 240, ftype, k, m, beta,\n            autotest_qdsync_callback, (void*)&obj);\n    qdsync_cccf_set_range(q, 0.001f);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(ftype,k,m,beta,0);\n    fdelay_crcf delay = fdelay_crcf_create_default(100);\n    fdelay_crcf_set_delay(delay, 10*k + tau);\n    float complex buf[k];\n    for (i=0; i<4*seq_len + 2*m + 50; i++) {\n        float complex s = (i < seq_len) ? seq_tx[i] : 0;\n        firinterp_crcf_execute(interp, s, buf);\n        fdelay_crcf_execute_block(delay, buf, k, buf);\n        unsigned int j;\n        for (j=0; j<k; j++)\n            buf[j] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n        qdsync_cccf_execute(q, buf, k);\n    }\n    float rxy_hat  = qdsync_cccf_get_rxy  (q);\n    float tau_hat  = qdsync_cccf_get_tau  (q);\n    float gamma_hat= qdsync_cccf_get_gamma(q);\n    float dphi_hat = qdsync_cccf_get_dphi (q);\n    float phi_hat  = qdsync_cccf_get_phi  (q);\n    float rmse = 0.0f;\n    for (i=0; i<seq_len; i++) {\n        float e = cabsf(seq_rx[i]) - 1.0f;\n        rmse += e*e;\n    }\n    rmse = 10*log10f( rmse / (float)seq_len );\n    if (liquid_autotest_verbose) {\n        printf(""qdsync: rxy:%5.3f, tau:%5.2f, gamma:%5.3f, dphi:%12.4e, phi:%8.5f, rmse:%5.2f\\n"",\n                rxy_hat, tau_hat, gamma_hat, dphi_hat, phi_hat, rmse);\n    }\n    CONTEND_LESS_THAN   ( rmse,              -30.0f )\n    CONTEND_GREATER_THAN( rxy_hat,            0.75f )\n    CONTEND_LESS_THAN   ( fabsf(tau_hat-tau), 0.10f )\n    CONTEND_GREATER_THAN( gamma_hat,          0.75f )\n    CONTEND_LESS_THAN   ( fabsf(dphi_hat),    1e-3f )\n    CONTEND_LESS_THAN   ( fabsf( phi_hat),    0.4f  )\n    qdsync_cccf_destroy(q);\n    firinterp_crcf_destroy(interp);\n    fdelay_crcf_destroy(delay);\n#if 0\n    FILE * fid = fopen(""autotest/logs/qdsync_cccf_autotest.m"",""w"");\n    fprintf(fid,""clear all; close all;\\n"");\n    for (i=0; i<seq_len; i++) {\n        fprintf(fid,""s(%4u)=%12.4e+%12.4ej; r(%4u)=%12.4e+%12.4ej;\\n"",\n            i+1, crealf(seq_tx[i]), cimagf(seq_tx[i]),\n            i+1, crealf(seq_rx[i]), cimagf(seq_rx[i]));\n    }\n    fprintf(fid,""figure(\'color\',\'white\',\'position\',[100 100 800 400]);\\n"");\n    fprintf(fid,""subplot(1,2,1), plot(s,\'.\',\'MarkerSize\',6); grid on; axis square;\\n"");\n    fprintf(fid,""axis([-1 1 -1 1]*1.5); xlabel(\'I\'); ylabel(\'Q\'); title(\'tx\');\\n"");\n    fprintf(fid,""subplot(1,2,2), plot(r,\'.\',\'MarkerSize\',6); grid on; axis square;\\n"");\n    fprintf(fid,""axis([-1 1 -1 1]*1.5); xlabel(\'I\'); ylabel(\'Q\'); title(\'rx\');\\n"");\n    fclose(fid);\n#endif\n}\nvoid autotest_qdsync_cccf_k2() { testbench_qdsync_linear(2, 7, 0.3f); }\nvoid autotest_qdsync_cccf_k3() { testbench_qdsync_linear(3, 7, 0.3f); }\nvoid autotest_qdsync_cccf_k4() { testbench_qdsync_linear(4, 7, 0.3f); }\nvoid autotest_qdsync_set_buf_len()\n{\n    unsigned int seq_len      = 2400;   \n    unsigned int k            =    2;   \n    unsigned int m            =   12;   \n    float        beta         = 0.3f;   \n    int          ftype        = LIQUID_FIRFILT_ARKAISER;\n    float complex seq_tx[seq_len];  \n    float complex seq_rx[seq_len];  \n    unsigned int i;\n    for (i=0; i<seq_len ; i++)\n        seq_tx[i] = cexpf(_Complex_I*2*M_PI*randf());\n    autotest_qdsync_s obj = {.id=0, .buf=seq_rx, .buf_len=seq_len, .count=0};\n    qdsync_cccf q = qdsync_cccf_create_linear(seq_tx, 120, ftype, k, m, beta,\n            autotest_qdsync_callback, (void*)&obj);\n    qdsync_cccf_set_range(q, 0.001f);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(ftype,k,m,beta,0);\n    float complex buf[k];\n    for (i=0; i<seq_len + 20*m + 200; i++) {\n        firinterp_crcf_execute(interp, (i < seq_len) ? seq_tx[i] : 0, buf);\n        qdsync_cccf_execute(q, buf, k);\n        if ( (i % 7)==0 )\n            qdsync_cccf_set_buf_len(q, 13 + 17*(i % 11));\n    }\n    float rmse = 0.0f;\n    for (i=0; i<seq_len; i++) {\n        float e = cabsf(seq_rx[i]) - 1.0f;\n        rmse += e*e;\n    }\n    rmse = 10*log10f( rmse / (float)seq_len );\n    if (liquid_autotest_verbose)\n        printf(""qdsync: rmse: %12.3f\\n"", rmse);\n    CONTEND_LESS_THAN( rmse, -30.0f )\n    qdsync_cccf_destroy(q);\n    firinterp_crcf_destroy(interp);\n}\nvoid autotest_qdsync_cccf_copy()\n{\n    unsigned int seq_len= 2400; \n    unsigned int split  = 1033; \n    unsigned int k      =    2; \n    unsigned int m      =   12; \n    float        beta   = 0.25; \n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        nstd   = 0.001f;\n    unsigned int i;\n    float complex seq_tx     [seq_len];  \n    float complex seq_rx_orig[seq_len];  \n    float complex seq_rx_copy[seq_len];  \n    for (i=0; i<seq_len ; i++) {\n        seq_tx[i] = (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 +\n                    (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 * _Complex_I;\n    }\n    autotest_qdsync_s c_orig = {.id=0, .buf=seq_rx_orig, .buf_len=seq_len, .count=0};\n    qdsync_cccf q_orig = qdsync_cccf_create_linear(seq_tx, 240, ftype, k, m, beta,\n            autotest_qdsync_callback, (void*)&c_orig);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(ftype,k,m,beta,0);\n    float complex buf[k];\n    for (i=0; i<split; i++) {\n        firinterp_crcf_execute(interp, (i < seq_len) ? seq_tx[i] : 0, buf);\n        unsigned int j;\n        for (j=0; j<k; j++)\n            buf[j] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n        qdsync_cccf_execute(q_orig, buf, k);\n    }\n    autotest_qdsync_s c_copy = {.id=1, .buf=seq_rx_copy, .buf_len=seq_len, .count=c_orig.count};\n    memmove(c_copy.buf, c_orig.buf, c_orig.count*sizeof(float complex)); \n    qdsync_cccf q_copy = qdsync_cccf_copy(q_orig);\n    qdsync_cccf_set_context(q_copy, (void*)&c_copy);\n    for (i=split; i<seq_len + 20*m * 40; i++) {\n        firinterp_crcf_execute(interp, (i < seq_len) ? seq_tx[i] : 0, buf);\n        unsigned int j;\n        for (j=0; j<k; j++)\n            buf[j] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n        qdsync_cccf_execute(q_orig, buf, k);\n        qdsync_cccf_execute(q_copy, buf, k);\n    }\n    CONTEND_EQUALITY(c_orig.count, seq_len);\n    CONTEND_EQUALITY(c_copy.count, seq_len);\n    CONTEND_SAME_DATA(c_orig.buf, c_copy.buf, seq_len*sizeof(float complex));\n    qdsync_cccf_destroy(q_orig);\n    qdsync_cccf_destroy(q_copy);\n}\nvoid autotest_qdsync_cccf_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping qdsync_cccf config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(qdsync_cccf_copy(NULL));\n    CONTEND_ISNULL(qdsync_cccf_create_linear(NULL,0,LIQUID_FIRFILT_ARKAISER,4,12,0.25f,NULL,NULL));\n    float complex seq[] = {+1,-1,+1,-1,-1,+1,-1,+1,-1,+1,-1,+1,+1,+1,-1,+1,-1,-1,-1,-1,};\n    qdsync_cccf q = qdsync_cccf_create_linear(seq,20,LIQUID_FIRFILT_ARKAISER,4,12,0.25f,NULL,NULL);\n    CONTEND_EQUALITY(LIQUID_OK, qdsync_cccf_print(q))\n    CONTEND_EQUALITY(LIQUID_OK, qdsync_cccf_set_callback(q,autotest_qdsync_callback))\n    CONTEND_EQUALITY(LIQUID_OK, qdsync_cccf_set_context(q,NULL))\n    CONTEND_EQUALITY(LIQUID_OK, qdsync_cccf_set_threshold(q,0.654321f))\n    CONTEND_EQUALITY(0.654321f, qdsync_cccf_get_threshold(q))\n    CONTEND_INEQUALITY(LIQUID_OK, qdsync_cccf_set_buf_len(q,0))\n    CONTEND_EQUALITY(0, qdsync_cccf_is_open(q))\n    qdsync_cccf_destroy(q);\n}')
"
"('You could have prompted me with the following technical scenario: ""You are working on a software-defined radio project where you have implemented a flexible frame synchronization algorithm. You need a code snippet to reset the frame data statistics and perform various initializations for the synchronization algorithm. Can you provide a function that resets the frame data statistics and sync state for the flexible frame sync object?""","//...\n    framedatastats_s    framedatastats; \n    unsigned int    m;                  \nint flexframesync_reset(flexframesync _q)\n{\n    qdetector_cccf_reset(_q->detector);\n    nco_crcf_reset(_q->mixer);\n    nco_crcf_reset(_q->pll);\n    firpfb_crcf_reset(_q->mf);\n    _q->state           = FLEXFRAMESYNC_STATE_DETECTFRAME;\n    _q->preamble_counter= 0;\n    _q->symbol_counter  = 0;\n    _q->framesyncstats.evm = 0.0f;\n    return LIQUID_OK;\n}\nint flexframesync_reset_framedatastats(flexframesync _q)\n{\n    return framedatastats_reset(&_q->framedatastats);\n}\n//...')
"
"('Prompt: You are working on implementing a GMSK frame synchronization algorithm for a digital communication system. You need to provide a function that resets the internal state of the frame synchronizer to its initial values. The state includes variables such as counters for detecting different parts of the frame (preamble, header, payload), filter objects for pre-processing, and a detection module. Your function should set all counters to 0, reset the buffers, reset the detector, initialize the NCO (Numerically Controlled Oscillator) to zero frequency, and clear the filter objects. Your task is to implement the `gmskframesync_reset` function that handles these requirements.","//...\n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int m;                 \n    float complex x_prime;          \n    float fi_hat;                   \n    firpfb_rrrf mf;                 \n    firpfb_rrrf dmf;                \n    float pfb_q;                    \n    detector_cccf frame_detector;   \n    windowcf buffer;                \n    nco_crcf nco_coarse;            \n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int preamble_counter;  \n    unsigned int header_counter;    \n    unsigned int payload_counter;   \nint gmskframesync_reset(gmskframesync _q)\n{\n    _q->state = STATE_DETECTFRAME;\n    _q->preamble_counter = 0;\n    _q->header_counter   = 0;\n    _q->payload_counter  = 0;\n    windowcf_reset(_q->buffer);\n    detector_cccf_reset(_q->frame_detector);\n    nco_crcf_reset(_q->nco_coarse);\n    _q->x_prime = 0.0f;\n    _q->fi_hat  = 0.0f;\n    firpfb_rrrf_reset(_q->mf);\n    firpfb_rrrf_reset(_q->dmf);\n    _q->pfb_q = 0.0f;   \n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: Write a test case for an autotest function that tests the functionality of copying and interpolating data using a high-pass FIR Hilbert transformer. The test case should involve creating a FIR Hilbert transformer with a length of 12 taps and a cutoff frequency of 120.0 Hz. Random complex numbers should be generated as input for interpolation, and the interpolated output should be compared between the original and copied instances of the filter. The test case should verify that the output values are equal for both instances. Additionally, enable verbose output to display the input complex numbers and corresponding interpolated output values.","//...\nvoid autotest_firhilbf_copy_interp()\n{\n    firhilbf q0 = firhilbf_create(12,120.0f);\n    unsigned int i;\n    float y0[2], y1[2];\n    for (i=0; i<80; i++) {\n        float complex x = randnf() + _Complex_I*randnf();\n        firhilbf_interp_execute(q0, x, y0);\n    }\n    firhilbf q1 = firhilbf_copy(q0);\n    for (i=0; i<80; i++) {\n        float complex x = randnf() + _Complex_I*randnf();\n        firhilbf_interp_execute(q0, x, y0);\n        firhilbf_interp_execute(q1, x, y1);\n        if (liquid_autotest_verbose) {\n            printf(""%3u : %12.8f +j%12.8f > {%12.8f, %12.8f}, {%12.8f, %12.8f}\\n"",\n                    i, crealf(x), cimagf(x), y0[0], y0[1], y1[0], y1[1]);\n        }\n        CONTEND_EQUALITY(y0[0], y1[0]);\n        CONTEND_EQUALITY(y0[1], y1[1]);\n    }\n    firhilbf_destroy(q0);\n    firhilbf_destroy(q1);\n}\n//...')
"
'Please provide a prompt related to configuring SAI (serial audio interface) transfers using EDMA (enhanced direct memory access) in a microcontroller application.,"#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.sai_edma""\n#endif\n#define STCD_ADDR(address) (edma_tcd_t *)(((uint32_t)(address) + 32UL) & ~0x1FU)\nstatic I2S_Type *const s_saiBases[] = I2S_BASE_PTRS;\n#define SAI_CHANNEL_MAP_MODULO(channel) (channel == 2U ? kEDMA_Modulo8bytes : kEDMA_Modulo16bytes)\ntypedef struct sai_edma_private_handle\n{\n    I2S_Type *base;\n    sai_edma_handle_t *handle;\n} sai_edma_private_handle_t;\nenum\n{\n    kSAI_Busy = 0x0U,      \n    kSAI_BusyLoopTransfer, \n    kSAI_Idle,             \n};\nstatic sai_edma_private_handle_t s_edmaPrivateHandle[ARRAY_SIZE(s_saiBases)][2];\nstatic uint32_t SAI_GetInstance(I2S_Type *base);\nstatic void SAI_TxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds);\nstatic void SAI_RxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds);\nstatic uint32_t SAI_GetInstance(I2S_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_saiBases); instance++)\n    {\n        if (s_saiBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_saiBases));\n    return instance;\n}\nstatic void SAI_TxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds)\n{\n    sai_edma_private_handle_t *privHandle = (sai_edma_private_handle_t *)userData;\n    sai_edma_handle_t *saiHandle          = privHandle->handle;\n    status_t status                       = kStatus_SAI_TxBusy;\n    if (saiHandle->state != (uint32_t)kSAI_BusyLoopTransfer)\n    {\n        if (saiHandle->queueDriver + tcds > (uint32_t)SAI_XFER_QUEUE_SIZE)\n        {\n            (void)memset(&saiHandle->saiQueue[saiHandle->queueDriver], 0,\n                         sizeof(sai_transfer_t) * ((uint32_t)SAI_XFER_QUEUE_SIZE - saiHandle->queueDriver));\n            (void)memset(&saiHandle->saiQueue[0U], 0,\n                         sizeof(sai_transfer_t) * (saiHandle->queueDriver + tcds - (uint32_t)SAI_XFER_QUEUE_SIZE));\n        }\n        else\n        {\n            (void)memset(&saiHandle->saiQueue[saiHandle->queueDriver], 0, sizeof(sai_transfer_t) * tcds);\n        }\n        saiHandle->queueDriver = (uint8_t)((saiHandle->queueDriver + tcds) % (uint32_t)SAI_XFER_QUEUE_SIZE);\n        if (saiHandle->saiQueue[saiHandle->queueDriver].data == NULL)\n        {\n            SAI_TxEnableDMA(privHandle->base, kSAI_FIFORequestDMAEnable, false);\n            EDMA_AbortTransfer(handle);\n            status = kStatus_SAI_TxIdle;\n        }\n    }\n    if (saiHandle->callback != NULL)\n    {\n        (saiHandle->callback)(privHandle->base, saiHandle, status, saiHandle->userData);\n    }\n}\nstatic void SAI_RxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds)\n{\n    sai_edma_private_handle_t *privHandle = (sai_edma_private_handle_t *)userData;\n    sai_edma_handle_t *saiHandle          = privHandle->handle;\n    status_t status                       = kStatus_SAI_RxBusy;\n    if (saiHandle->state != (uint32_t)kSAI_BusyLoopTransfer)\n    {\n        if (saiHandle->queueDriver + tcds > (uint32_t)SAI_XFER_QUEUE_SIZE)\n        {\n            (void)memset(&saiHandle->saiQueue[saiHandle->queueDriver], 0,\n                         sizeof(sai_transfer_t) * ((uint32_t)SAI_XFER_QUEUE_SIZE - saiHandle->queueDriver));\n            (void)memset(&saiHandle->saiQueue[0U], 0,\n                         sizeof(sai_transfer_t) * (saiHandle->queueDriver + tcds - (uint32_t)SAI_XFER_QUEUE_SIZE));\n        }\n        else\n        {\n            (void)memset(&saiHandle->saiQueue[saiHandle->queueDriver], 0, sizeof(sai_transfer_t) * tcds);\n        }\n        saiHandle->queueDriver = (uint8_t)((saiHandle->queueDriver + tcds) % (uint32_t)SAI_XFER_QUEUE_SIZE);\n        if (saiHandle->saiQueue[saiHandle->queueDriver].data == NULL)\n        {\n            SAI_RxEnableDMA(privHandle->base, kSAI_FIFORequestDMAEnable, false);\n            EDMA_AbortTransfer(handle);\n            status = kStatus_SAI_RxIdle;\n        }\n    }\n    if (saiHandle->callback != NULL)\n    {\n        (saiHandle->callback)(privHandle->base, saiHandle, status, saiHandle->userData);\n    }\n}\nvoid SAI_TransferTxCreateHandleEDMA(\n    I2S_Type *base, sai_edma_handle_t *handle, sai_edma_callback_t callback, void *userData, edma_handle_t *txDmaHandle)\n{\n    assert((handle != NULL) && (txDmaHandle != NULL));\n    uint32_t instance = SAI_GetInstance(base);\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->dmaHandle = txDmaHandle;\n    handle->callback  = callback;\n    handle->userData  = userData;\n    handle->state = (uint32_t)kSAI_Idle;\n    s_edmaPrivateHandle[instance][0].base   = base;\n    s_edmaPrivateHandle[instance][0].handle = handle;\n    EDMA_InstallTCDMemory(txDmaHandle, (edma_tcd_t *)(STCD_ADDR(handle->tcd)), SAI_XFER_QUEUE_SIZE);\n    EDMA_SetCallback(txDmaHandle, SAI_TxEDMACallback, &s_edmaPrivateHandle[instance][0]);\n}\nvoid SAI_TransferRxCreateHandleEDMA(\n    I2S_Type *base, sai_edma_handle_t *handle, sai_edma_callback_t callback, void *userData, edma_handle_t *rxDmaHandle)\n{\n    assert((handle != NULL) && (rxDmaHandle != NULL));\n    uint32_t instance = SAI_GetInstance(base);\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->dmaHandle = rxDmaHandle;\n    handle->callback  = callback;\n    handle->userData  = userData;\n    handle->state = (uint32_t)kSAI_Idle;\n    s_edmaPrivateHandle[instance][1].base   = base;\n    s_edmaPrivateHandle[instance][1].handle = handle;\n    EDMA_InstallTCDMemory(rxDmaHandle, STCD_ADDR(handle->tcd), SAI_XFER_QUEUE_SIZE);\n    EDMA_SetCallback(rxDmaHandle, SAI_RxEDMACallback, &s_edmaPrivateHandle[instance][1]);\n}\nvoid SAI_TransferTxSetFormatEDMA(I2S_Type *base,\n                                 sai_edma_handle_t *handle,\n                                 sai_transfer_format_t *format,\n                                 uint32_t mclkSourceClockHz,\n                                 uint32_t bclkSourceClockHz)\n{\n    assert((handle != NULL) && (format != NULL));\n    SAI_TxSetFormat(base, format, mclkSourceClockHz, bclkSourceClockHz);\n    if (format->bitWidth == 24U)\n    {\n        handle->bytesPerFrame = 4U;\n    }\n    else\n    {\n        handle->bytesPerFrame = (uint8_t)(format->bitWidth / 8U);\n    }\n    handle->channel = format->channel;\n    base->TCR3 &= ~I2S_TCR3_TCE_MASK;\n#if defined(FSL_FEATURE_SAI_HAS_FIFO) && (FSL_FEATURE_SAI_HAS_FIFO)\n    handle->count = (uint8_t)((uint32_t)FSL_FEATURE_SAI_FIFO_COUNTn(base) - format->watermark);\n#else\n    handle->count = 1U;\n#endif \n}\nvoid SAI_TransferTxSetConfigEDMA(I2S_Type *base, sai_edma_handle_t *handle, sai_transceiver_t *saiConfig)\n{\n    assert((handle != NULL) && (saiConfig != NULL));\n    SAI_TxSetConfig(base, saiConfig);\n#if defined(FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE) && FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE\n    assert(\n        (saiConfig->channelNums <= 1U) ||\n        ((saiConfig->channelNums > 1U) && ((saiConfig->fifo.fifoCombine == kSAI_FifoCombineModeEnabledOnWrite) ||\n                                           (saiConfig->fifo.fifoCombine == kSAI_FifoCombineModeEnabledOnReadWrite))));\n#endif\n    if (saiConfig->serialData.dataWordLength == 24U)\n    {\n        handle->bytesPerFrame = 4U;\n    }\n    else\n    {\n        handle->bytesPerFrame = saiConfig->serialData.dataWordLength / 8U;\n    }\n    handle->channel     = saiConfig->startChannel;\n    handle->channelMask = saiConfig->channelMask;\n    handle->channelNums = saiConfig->channelNums;\n    base->TCR3 &= ~I2S_TCR3_TCE_MASK;\n#if defined(FSL_FEATURE_SAI_HAS_FIFO) && (FSL_FEATURE_SAI_HAS_FIFO)\n    handle->count = (uint8_t)((uint32_t)FSL_FEATURE_SAI_FIFO_COUNTn(base) - saiConfig->fifo.fifoWatermark);\n#else\n    handle->count = 1U;\n#endif \n}\nvoid SAI_TransferRxSetFormatEDMA(I2S_Type *base,\n                                 sai_edma_handle_t *handle,\n                                 sai_transfer_format_t *format,\n                                 uint32_t mclkSourceClockHz,\n                                 uint32_t bclkSourceClockHz)\n{\n    assert((handle != NULL) && (format != NULL));\n    SAI_RxSetFormat(base, format, mclkSourceClockHz, bclkSourceClockHz);\n    if (format->bitWidth == 24U)\n    {\n        handle->bytesPerFrame = 4U;\n    }\n    else\n    {\n        handle->bytesPerFrame = (uint8_t)(format->bitWidth / 8U);\n    }\n    handle->channel = format->channel;\n    base->RCR3 &= ~I2S_RCR3_RCE_MASK;\n#if defined(FSL_FEATURE_SAI_HAS_FIFO) && (FSL_FEATURE_SAI_HAS_FIFO)\n    handle->count = format->watermark;\n#else\n    handle->count = 1U;\n#endif \n}\nvoid SAI_TransferRxSetConfigEDMA(I2S_Type *base, sai_edma_handle_t *handle, sai_transceiver_t *saiConfig)\n{\n    assert((handle != NULL) && (saiConfig != NULL));\n    SAI_RxSetConfig(base, saiConfig);\n#if defined(FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE) && FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE\n    assert(\n        (saiConfig->channelNums <= 1U) ||\n        ((saiConfig->channelNums > 1U) && ((saiConfig->fifo.fifoCombine == kSAI_FifoCombineModeEnabledOnRead) ||\n                                           (saiConfig->fifo.fifoCombine == kSAI_FifoCombineModeEnabledOnReadWrite))));\n#endif\n    if (saiConfig->serialData.dataWordLength == 24U)\n    {\n        handle->bytesPerFrame = 4U;\n    }\n    else\n    {\n        handle->bytesPerFrame = saiConfig->serialData.dataWordLength / 8U;\n    }\n    handle->channel     = saiConfig->startChannel;\n    handle->channelMask = saiConfig->channelMask;\n    handle->channelNums = saiConfig->channelNums;\n    base->RCR3 &= ~I2S_RCR3_RCE_MASK;\n#if defined(FSL_FEATURE_SAI_HAS_FIFO) && (FSL_FEATURE_SAI_HAS_FIFO)\n    handle->count = saiConfig->fifo.fifoWatermark;\n#else\n    handle->count = 1U;\n#endif \n}\nstatus_t SAI_TransferSendEDMA(I2S_Type *base, sai_edma_handle_t *handle, sai_transfer_t *xfer)\n{\n    assert((handle != NULL) && (xfer != NULL));\n    edma_transfer_config_t config = {0};\n    uint32_t destAddr             = SAI_TxGetDataRegisterAddress(base, handle->channel);\n    uint32_t destOffset           = 0U;\n    if ((xfer->data == NULL) || (xfer->dataSize == 0U))\n    {\n        return kStatus_InvalidArgument;\n    }\n    if (handle->saiQueue[handle->queueUser].data != NULL)\n    {\n        return kStatus_SAI_QueueFull;\n    }\n    handle->state = (uint32_t)kSAI_Busy;\n    handle->transferSize[handle->queueUser]      = xfer->dataSize;\n    handle->saiQueue[handle->queueUser].data     = xfer->data;\n    handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;\n    handle->queueUser                            = (handle->queueUser + 1U) % (uint8_t)SAI_XFER_QUEUE_SIZE;\n#if !(defined(FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE) && FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE)\n    if (handle->channelNums > 1U)\n    {\n        destOffset = sizeof(uint32_t);\n    }\n#endif\n    EDMA_PrepareTransferConfig(&config, xfer->data, (uint32_t)handle->bytesPerFrame, (int16_t)handle->bytesPerFrame,\n                               (uint32_t *)destAddr, (uint32_t)handle->bytesPerFrame, (int16_t)destOffset,\n                               (uint32_t)handle->count * handle->bytesPerFrame, xfer->dataSize);\n    handle->nbytes = handle->count * handle->bytesPerFrame;\n    if (EDMA_SubmitTransfer(handle->dmaHandle, &config) != kStatus_Success)\n    {\n        return kStatus_SAI_QueueFull;\n    }\n#if !(defined(FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE) && FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE)\n    if (handle->channelNums > 1U)\n    {\n        if ((handle->channelNums % 2U) != 0U)\n        {\n            return kStatus_InvalidArgument;\n        }\n        EDMA_SetModulo(handle->dmaHandle->base, handle->dmaHandle->channel, kEDMA_ModuloDisable,\n                       SAI_CHANNEL_MAP_MODULO(handle->channelNums));\n    }\n#endif\n    EDMA_StartTransfer(handle->dmaHandle);\n    SAI_TxEnableDMA(base, kSAI_FIFORequestDMAEnable, true);\n    SAI_TxEnable(base, true);\n    base->TCR3 |= I2S_TCR3_TCE(handle->channelMask);\n    return kStatus_Success;\n}\nstatus_t SAI_TransferReceiveEDMA(I2S_Type *base, sai_edma_handle_t *handle, sai_transfer_t *xfer)\n{\n    assert((handle != NULL) && (xfer != NULL));\n    edma_transfer_config_t config = {0};\n    uint32_t srcAddr              = SAI_RxGetDataRegisterAddress(base, handle->channel);\n    uint32_t srcOffset            = 0U;\n    if ((xfer->data == NULL) || (xfer->dataSize == 0U))\n    {\n        return kStatus_InvalidArgument;\n    }\n    if (handle->saiQueue[handle->queueUser].data != NULL)\n    {\n        return kStatus_SAI_QueueFull;\n    }\n    handle->state = (uint32_t)kSAI_Busy;\n    handle->transferSize[handle->queueUser]      = xfer->dataSize;\n    handle->saiQueue[handle->queueUser].data     = xfer->data;\n    handle->saiQueue[handle->queueUser].dataSize = xfer->dataSize;\n    handle->queueUser                            = (handle->queueUser + 1U) % (uint8_t)SAI_XFER_QUEUE_SIZE;\n#if !(defined(FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE) && FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE)\n    if (handle->channelNums > 1U)\n    {\n        srcOffset = sizeof(uint32_t);\n    }\n#endif\n    EDMA_PrepareTransferConfig(&config, (uint32_t *)srcAddr, (uint32_t)handle->bytesPerFrame, (int16_t)srcOffset,\n                               xfer->data, (uint32_t)handle->bytesPerFrame, (int16_t)handle->bytesPerFrame,\n                               (uint32_t)handle->count * handle->bytesPerFrame, xfer->dataSize);\n    handle->nbytes = handle->count * handle->bytesPerFrame;\n    if (EDMA_SubmitTransfer(handle->dmaHandle, &config) != kStatus_Success)\n    {\n        return kStatus_SAI_QueueFull;\n    }\n#if !(defined(FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE) && FSL_FEATURE_SAI_HAS_FIFO_COMBINE_MODE)\n    if (handle->channelNums > 1U)\n    {\n        if ((handle->channelNums % 2U) != 0U)\n        {\n            return kStatus_InvalidArgument;\n        }\n        EDMA_SetModulo(handle->dmaHandle->base, handle->dmaHandle->channel, SAI_CHANNEL_MAP_MODULO(handle->channelNums),\n                       kEDMA_ModuloDisable);\n    }\n#endif\n    EDMA_StartTransfer(handle->dmaHandle);\n    SAI_RxEnableDMA(base, kSAI_FIFORequestDMAEnable, true);\n    base->RCR3 |= I2S_RCR3_RCE(handle->channelMask);\n    SAI_RxEnable(base, true);\n    return kStatus_Success;\n}\nstatus_t SAI_TransferSendLoopEDMA(I2S_Type *base,\n                                  sai_edma_handle_t *handle,\n                                  sai_transfer_t *xfer,\n                                  uint32_t loopTransferCount)\n{\n    assert((handle != NULL) && (xfer != NULL));\n    edma_transfer_config_t config = {0};\n    uint32_t destAddr             = SAI_TxGetDataRegisterAddress(base, handle->channel);\n    sai_transfer_t *transfer      = xfer;\n    edma_tcd_t *currentTCD        = STCD_ADDR(handle->tcd);\n    uint32_t tcdIndex             = 0U;\n    handle->state = (uint32_t)kSAI_Busy;\n    for (uint32_t i = 0U; i < loopTransferCount; i++)\n    {\n        transfer = &xfer[i];\n        if ((transfer->data == NULL) || (transfer->dataSize == 0U) || (tcdIndex >= (uint32_t)SAI_XFER_QUEUE_SIZE))\n        {\n            return kStatus_InvalidArgument;\n        }\n        handle->transferSize[tcdIndex]      = transfer->dataSize;\n        handle->saiQueue[tcdIndex].data     = transfer->data;\n        handle->saiQueue[tcdIndex].dataSize = transfer->dataSize;\n        EDMA_PrepareTransfer(&config, transfer->data, handle->bytesPerFrame, (uint32_t *)destAddr,\n                             handle->bytesPerFrame, (uint32_t)handle->count * handle->bytesPerFrame, transfer->dataSize,\n                             kEDMA_MemoryToPeripheral);\n        if (i == (loopTransferCount - 1U))\n        {\n            EDMA_TcdSetTransferConfig(&currentTCD[tcdIndex], &config, &currentTCD[0U]);\n            EDMA_TcdEnableInterrupts(&currentTCD[tcdIndex], (uint32_t)kEDMA_MajorInterruptEnable);\n            handle->state = (uint32_t)kSAI_BusyLoopTransfer;\n            break;\n        }\n        else\n        {\n            EDMA_TcdSetTransferConfig(&currentTCD[tcdIndex], &config, &currentTCD[tcdIndex + 1U]);\n            EDMA_TcdEnableInterrupts(&currentTCD[tcdIndex], (uint32_t)kEDMA_MajorInterruptEnable);\n        }\n        tcdIndex = tcdIndex + 1U;\n    }\n    EDMA_InstallTCD(handle->dmaHandle->base, handle->dmaHandle->channel, &currentTCD[0]);\n    EDMA_StartTransfer(handle->dmaHandle);\n    SAI_TxEnableDMA(base, kSAI_FIFORequestDMAEnable, true);\n    SAI_TxEnable(base, true);\n    base->TCR3 |= I2S_TCR3_TCE(1UL << handle->channel);\n    return kStatus_Success;\n}\nstatus_t SAI_TransferReceiveLoopEDMA(I2S_Type *base,\n                                     sai_edma_handle_t *handle,\n                                     sai_transfer_t *xfer,\n                                     uint32_t loopTransferCount)\n{\n    assert((handle != NULL) && (xfer != NULL));\n    edma_transfer_config_t config = {0};\n    uint32_t srcAddr              = SAI_RxGetDataRegisterAddress(base, handle->channel);\n    sai_transfer_t *transfer      = xfer;\n    edma_tcd_t *currentTCD        = STCD_ADDR(handle->tcd);\n    uint32_t tcdIndex             = 0U;\n    handle->state = (uint32_t)kSAI_Busy;\n    for (uint32_t i = 0U; i < loopTransferCount; i++)\n    {\n        transfer = &xfer[i];\n        if ((tcdIndex >= (uint32_t)SAI_XFER_QUEUE_SIZE) || (xfer->data == NULL) || (xfer->dataSize == 0U))\n        {\n            return kStatus_InvalidArgument;\n        }\n        handle->transferSize[tcdIndex]      = transfer->dataSize;\n        handle->saiQueue[tcdIndex].data     = transfer->data;\n        handle->saiQueue[tcdIndex].dataSize = transfer->dataSize;\n        EDMA_PrepareTransfer(&config, (uint32_t *)srcAddr, handle->bytesPerFrame, transfer->data, handle->bytesPerFrame,\n                             (uint32_t)handle->count * handle->bytesPerFrame, transfer->dataSize,\n                             kEDMA_PeripheralToMemory);\n        if (i == (loopTransferCount - 1U))\n        {\n            EDMA_TcdSetTransferConfig(&currentTCD[tcdIndex], &config, &currentTCD[0U]);\n            EDMA_TcdEnableInterrupts(&currentTCD[tcdIndex], (uint32_t)kEDMA_MajorInterruptEnable);\n            handle->state = (uint32_t)kSAI_BusyLoopTransfer;\n            break;\n        }\n        else\n        {\n            EDMA_TcdSetTransferConfig(&currentTCD[tcdIndex], &config, &currentTCD[tcdIndex + 1U]);\n            EDMA_TcdEnableInterrupts(&currentTCD[tcdIndex], (uint32_t)kEDMA_MajorInterruptEnable);\n        }\n        tcdIndex = tcdIndex + 1U;\n    }\n    EDMA_InstallTCD(handle->dmaHandle->base, handle->dmaHandle->channel, &currentTCD[0]);\n    EDMA_StartTransfer(handle->dmaHandle);\n    SAI_RxEnableDMA(base, kSAI_FIFORequestDMAEnable, true);\n    base->RCR3 |= I2S_RCR3_RCE(1UL << handle->channel);\n    SAI_RxEnable(base, true);\n    return kStatus_Success;\n}\nvoid SAI_TransferAbortSendEDMA(I2S_Type *base, sai_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    EDMA_AbortTransfer(handle->dmaHandle);\n    base->TCR3 &= ~I2S_TCR3_TCE_MASK;\n    SAI_TxEnableDMA(base, kSAI_FIFORequestDMAEnable, false);\n    SAI_TxEnable(base, false);\n    if ((base->TCSR & I2S_TCSR_TE_MASK) == 0UL)\n    {\n        base->TCSR |= (I2S_TCSR_FR_MASK | I2S_TCSR_SR_MASK);\n        base->TCSR &= ~I2S_TCSR_SR_MASK;\n    }\n    (void)memset(&handle->saiQueue[handle->queueDriver], 0, sizeof(sai_transfer_t));\n    handle->queueDriver = (handle->queueDriver + 1U) % (uint8_t)SAI_XFER_QUEUE_SIZE;\n    handle->state = (uint32_t)kSAI_Idle;\n}\nvoid SAI_TransferAbortReceiveEDMA(I2S_Type *base, sai_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    EDMA_AbortTransfer(handle->dmaHandle);\n    base->RCR3 &= ~I2S_RCR3_RCE_MASK;\n    SAI_RxEnableDMA(base, kSAI_FIFORequestDMAEnable, false);\n    SAI_RxEnable(base, false);\n    if ((base->RCSR & I2S_RCSR_RE_MASK) == 0UL)\n    {\n        base->RCSR |= (I2S_RCSR_FR_MASK | I2S_RCSR_SR_MASK);\n        base->RCSR &= ~I2S_RCSR_SR_MASK;\n    }\n    (void)memset(&handle->saiQueue[handle->queueDriver], 0, sizeof(sai_transfer_t));\n    handle->queueDriver = (handle->queueDriver + 1U) % (uint8_t)SAI_XFER_QUEUE_SIZE;\n    handle->state = (uint32_t)kSAI_Idle;\n}\nvoid SAI_TransferTerminateSendEDMA(I2S_Type *base, sai_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    SAI_TransferAbortSendEDMA(base, handle);\n    (void)memset(handle->tcd, 0, sizeof(handle->tcd));\n    (void)memset(handle->saiQueue, 0, sizeof(handle->saiQueue));\n    (void)memset(handle->transferSize, 0, sizeof(handle->transferSize));\n    handle->queueUser   = 0U;\n    handle->queueDriver = 0U;\n}\nvoid SAI_TransferTerminateReceiveEDMA(I2S_Type *base, sai_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    SAI_TransferAbortReceiveEDMA(base, handle);\n    (void)memset(handle->tcd, 0, sizeof(handle->tcd));\n    (void)memset(handle->saiQueue, 0, sizeof(handle->saiQueue));\n    (void)memset(handle->transferSize, 0, sizeof(handle->transferSize));\n    handle->queueUser   = 0U;\n    handle->queueDriver = 0U;\n}\nstatus_t SAI_TransferGetSendCountEDMA(I2S_Type *base, sai_edma_handle_t *handle, size_t *count)\n{\n    assert(handle != NULL);\n    status_t status = kStatus_Success;\n    if (handle->state != (uint32_t)kSAI_Busy)\n    {\n        status = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        *count = (handle->transferSize[handle->queueDriver] -\n                  (uint32_t)handle->nbytes *\n                      EDMA_GetRemainingMajorLoopCount(handle->dmaHandle->base, handle->dmaHandle->channel));\n    }\n    return status;\n}\nstatus_t SAI_TransferGetReceiveCountEDMA(I2S_Type *base, sai_edma_handle_t *handle, size_t *count)\n{\n    assert(handle != NULL);\n    status_t status = kStatus_Success;\n    if (handle->state != (uint32_t)kSAI_Busy)\n    {\n        status = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        *count = (handle->transferSize[handle->queueDriver] -\n                  (uint32_t)handle->nbytes *\n                      EDMA_GetRemainingMajorLoopCount(handle->dmaHandle->base, handle->dmaHandle->channel));\n    }\n    return status;\n}\nuint32_t SAI_TransferGetValidTransferSlotsEDMA(I2S_Type *base, sai_edma_handle_t *handle)\n{\n    uint32_t validSlot = 0U;\n    for (uint32_t i = 0U; i < (uint32_t)SAI_XFER_QUEUE_SIZE; i++)\n    {\n        if (handle->saiQueue[i].data == NULL)\n        {\n            validSlot++;\n        }\n    }\n    return validSlot;\n}'"
('Prompt: You need to optimize a function that calculates the sum of squares of elements in an array using AVX instructions. The function should take a pointer to the array and the size of the array as inputs. The optimization should involve using AVX instructions to compute the sum of squares faster. Please provide the optimized code for this function.,"//...\nfloat liquid_sumsqf_avxu(float *      _v,\n                         unsigned int _n)\n{\n    __m256 v0, v1, v2, v3;   \n    __m256 s0, s1, s2, s3;   \n    __m256 sum = _mm256_setzero_ps(); \n    unsigned int t = (_n >> 5) << 3;\n    unsigned int i;\n    for (i=0; i<t; i+=8) {\n        v0 = _mm256_loadu_ps(&_v[4*i+ 0]);\n        v1 = _mm256_loadu_ps(&_v[4*i+ 8]);\n        v2 = _mm256_loadu_ps(&_v[4*i+16]);\n        v3 = _mm256_loadu_ps(&_v[4*i+24]);\n        s0 = _mm256_mul_ps(v0, v0);\n        s1 = _mm256_mul_ps(v1, v1);\n        s2 = _mm256_mul_ps(v2, v2);\n        s3 = _mm256_mul_ps(v3, v3);\n        sum = _mm256_add_ps( sum, s0 );\n        sum = _mm256_add_ps( sum, s1 );\n        sum = _mm256_add_ps( sum, s2 );\n        sum = _mm256_add_ps( sum, s3 );\n    }\n    __m256 z = _mm256_setzero_ps();\n    sum = _mm256_hadd_ps(sum, z);\n    sum = _mm256_hadd_ps(sum, z);\n    float w[8] __attribute__((aligned(32)));\n    _mm256_store_ps(w, sum);\n    float total = w[0] + w[4];\n    for (i=4*t; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf_avx(float *      _v,\n                        unsigned int _n)\n{\n    __m256 v;   \n    __m256 s;   \n    __m256 sum = _mm256_setzero_ps(); \n    unsigned int t = (_n >> 3) << 3;\n    unsigned int i;\n    for (i=0; i<t; i+=8) {\n        v = _mm256_loadu_ps(&_v[i]);\n        s = _mm256_mul_ps(v, v);\n        sum = _mm256_add_ps( sum, s );\n    }\n    __m256 z = _mm256_setzero_ps();\n    sum = _mm256_hadd_ps(sum, z);\n    sum = _mm256_hadd_ps(sum, z);\n    float w[8] __attribute__((aligned(32)));\n    _mm256_store_ps(w, sum);\n    float total = w[0] + w[4];\n    for (; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    if (_n < 32) {\n        return liquid_sumsqf_avx(_v, _n);\n    }\n    return liquid_sumsqf_avxu(_v, _n);\n}\nfloat liquid_sumsqf_avxu(float *      _v,\n                         unsigned int _n)\n{\n    __m256 v0, v1, v2, v3;   \n    __m256 s0, s1, s2, s3;   \n    __m256 sum = _mm256_setzero_ps(); \n    unsigned int t = (_n >> 5) << 3;\n    unsigned int i;\n    for (i=0; i<t; i+=8) {\n        v0 = _mm256_loadu_ps(&_v[4*i+ 0]);\n        v1 = _mm256_loadu_ps(&_v[4*i+ 8]);\n        v2 = _mm256_loadu_ps(&_v[4*i+16]);\n        v3 = _mm256_loadu_ps(&_v[4*i+24]);\n        s0 = _mm256_mul_ps(v0, v0);\n        s1 = _mm256_mul_ps(v1, v1);\n        s2 = _mm256_mul_ps(v2, v2);\n        s3 = _mm256_mul_ps(v3, v3);\n        sum = _mm256_add_ps( sum, s0 );\n        sum = _mm256_add_ps( sum, s1 );\n        sum = _mm256_add_ps( sum, s2 );\n        sum = _mm256_add_ps( sum, s3 );\n    }\n    __m256 z = _mm256_setzero_ps();\n    sum = _mm256_hadd_ps(sum, z);\n    sum = _mm256_hadd_ps(sum, z);\n    float w[8] __attribute__((aligned(32)));\n    _mm256_store_ps(w, sum);\n    float total = w[0] + w[4];\n    for (i=4*t; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\n//...')
"
('Prompt: You are working on a program that involves complex number dot products and cyclic redundancy checks. Your project requires the implementation of a function to destroy a custom data structure `dotprod_crcf`. Write a code snippet in C that shows how to properly free memory allocated to the structure and return a specific value upon successful destruction.,"//...\nint dotprod_crcf_destroy(dotprod_crcf _q)\n{\n    _mm_free(_q->h);\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
'Prompt: I need a code snippet for an LVGL example function that creates a scrollable object with a label displaying Persian and Hebrew text using the DejaVu 16 font. The text should describe what a microcontroller is in Persian. The function should set the base direction of the object to right-to-left and center it on the screen.,"#if LV_BUILD_EXAMPLES && LV_FONT_DEJAVU_16_PERSIAN_HEBREW\nvoid lv_example_scroll_5(void)\n{\n    lv_obj_t * obj = lv_obj_create(lv_screen_active());\n    lv_obj_set_style_base_dir(obj, LV_BASE_DIR_RTL, 0);\n    lv_obj_set_size(obj, 200, 100);\n    lv_obj_center(obj);\n    lv_obj_t * label = lv_label_create(obj);\n    lv_label_set_text(label,\n                      "" ( : Microcontroller) \u200c        (RAM)   \u200c (ROM)  \u200c    (I/O)    (Serial Port  )      \u200c       .             CPU       \u200c          \u200c."");\n    lv_obj_set_width(label, 400);\n    lv_obj_set_style_text_font(label, &lv_font_dejavu_16_persian_hebrew, 0);\n}\n#endif'"
('Prompt: You are designing a software-defined radio (SDR) system that requires efficient computation of the dot product between two complex vectors. Can you provide me with optimized C code functions for calculating the dot product of two complex vectors using direct computation and utilizing SIMD-like operations for better performance?,"//...\nint dotprod_cccf_run(float complex * _h,\n                     float complex * _x,\n                     unsigned int    _n,\n                     float complex * _y)\n{\n    float complex r = 0;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\nint dotprod_cccf_run4(float complex * _h,\n                      float complex * _x,\n                      unsigned int    _n,\n                      float complex * _y)\n{\n    float complex r = 0;\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        r += _h[i]   * _x[i];\n        r += _h[i+1] * _x[i+1];\n        r += _h[i+2] * _x[i+2];\n        r += _h[i+3] * _x[i+3];\n    }\n    for ( ; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\n//...')
"
"('Please provide me with a prompt to test functions related to prime numbers, factors, and totient function.","void autotest_prime_small()\n{\n    const int is_prime_array[2500] = {\n\t\t0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,\n\t\t0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,\n\t\t0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,\n\t\t0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,\n\t\t0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n\t\t0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,\n\t\t0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,\n\t\t0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,\n\t\t0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,\n\t\t0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,\n\t\t0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,\n\t\t0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,\n\t\t0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,\n\t\t0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n\t\t0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,\n\t\t0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,\n\t\t0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,\n\t\t0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,\n\t\t0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,\n\t\t0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,\n\t\t0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n\t\t0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,\n\t\t0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,\n\t\t0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,\n\t\t0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n\t\t0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,\n\t\t0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,\n\t\t0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n\t\t0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n\t\t0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,\n\t\t0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n\t\t0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,\n\t\t0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,\n\t\t0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,\n\t\t0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,\n\t\t0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,\n\t\t0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,\n\t\t0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,\n\t\t0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};\n\tunsigned int n;\n    for (n=0; n<2500; n++)\n        CONTEND_EQUALITY(is_prime_array[n], liquid_is_prime(n));\n}\nvoid autotest_factors()\n{\n    const unsigned int factors_280[5] = {2,2,2,5,7};\n    const unsigned int factors_280_unique[3] = {2,5,7};\n    unsigned int factors[LIQUID_MAX_FACTORS];\n    unsigned int num_factors = 0;\n    unsigned int i;\n    CONTEND_EQUALITY(liquid_factor(280,factors,&num_factors), LIQUID_OK);\n    CONTEND_EQUALITY(num_factors, 5);\n    for (i=0; i<5; i++)\n        CONTEND_EQUALITY(factors_280[i], factors[i]);\n    CONTEND_EQUALITY(liquid_unique_factor(280,factors,&num_factors), LIQUID_OK);\n    CONTEND_EQUALITY(num_factors, 3);\n    for (i=0; i<3; i++)\n        CONTEND_EQUALITY(factors_280_unique[i], factors[i]);\n}\nvoid autotest_totient()\n{\n    CONTEND_EQUALITY(liquid_totient(   9),   6)\n    CONTEND_EQUALITY(liquid_totient(  20),   8)\n    CONTEND_EQUALITY(liquid_totient( 100),  40)\n    CONTEND_EQUALITY(liquid_totient(1200), 320)\n    CONTEND_EQUALITY(liquid_totient(1201),1200)\n}')
"
"('Please provide a prompt for testing the impulse response of a Finite Impulse Response (FIR) Polyphase Filterbank using a specific set of coefficients and input data. The test should involve pushing noise samples through the filterbank and comparing the output against expected values within a specified tolerance level. The function should create the filterbank, push noise samples, execute the filterbank for each output index, and then destroy the filterbank to clean up resources.","//...\nvoid autotest_firpfb_impulse_response()\n{\n    float tol=1e-4f;\n    float h[48] = {\n     -0.033116,  -0.024181,  -0.006284,   0.018261, \n      0.045016,   0.068033,   0.080919,   0.078177, \n      0.056597,   0.016403,  -0.038106,  -0.098610, \n     -0.153600,  -0.189940,  -0.194900,  -0.158390, \n     -0.075002,   0.054511,   0.222690,   0.415800, \n      0.615340,   0.800390,   0.950380,   1.048100, \n      1.082000,   1.048100,   0.950380,   0.800390, \n      0.615340,   0.415800,   0.222690,   0.054511, \n     -0.075002,  -0.158390,  -0.194900,  -0.189940, \n     -0.153600,  -0.098610,  -0.038106,   0.016403, \n      0.056597,   0.078177,   0.080919,   0.068033, \n      0.045016,   0.018261,  -0.006284,  -0.024181\n    };\n    float noise[12] = {\n      0.438310,   1.001900,   0.200600,   0.790040, \n      1.134200,   1.592200,  -0.702980,  -0.937560, \n     -0.511270,  -1.684700,   0.328940,  -0.387780\n    };\n    float test[4] = {\n        2.05558467194397f,\n        1.56922189602661f,\n        0.998479744645138,\n        0.386125857849177\n    };\n    firpfb_rrrf f = firpfb_rrrf_create(4, h, 48);\n    unsigned int i;\n    for (i=0; i<12; i++)\n        firpfb_rrrf_push(f,noise[i]);\n    float y;\n    for (i=0; i<4; i++) {\n        firpfb_rrrf_execute(f,i,&y);\n        CONTEND_DELTA(test[i],y,tol);\n    }\n    firpfb_rrrf_destroy(f);\n}\n//...')
"
"('Prompt: You are working on a digital spread spectrum communication system that utilizes direct sequence spread spectrum (DSSS) modulation technique. You need to implement a function that processes each incoming complex sample using DSSS frame synchronization. Provide a code snippet that includes a struct definition for the DSSS frame synchronization object and a function `dsssframesync_step` that takes in the object, an incoming complex sample, and outputs a processed sample. The function should mix down the input sample, push it through a multi-rate filter bank, and return a processed sample if enough samples are available for processing.","//...\nstruct dsssframesync_s {\n    framesync_callback  callback;\n    void *              userdata;\n    framesyncstats_s    framesyncstats;\n    framedatastats_s    framedatastats;\n    unsigned int        k;\n    unsigned int        m;\n    float               beta;\n    qdetector_cccf      detector;\n    float               tau_hat;\n    float               dphi_hat;\n    float               phi_hat;\n    float               gamma_hat;\n    nco_crcf            mixer;\n    nco_crcf            pll;\n    firpfb_crcf         mf;\n    unsigned int        npfb;\n    int                 mf_counter;\n    unsigned int        pfb_index;\n    float complex *     preamble_pn;\n    float complex *     preamble_rx;\n    synth_crcf          header_synth;\n    synth_crcf          payload_synth;\n    int                 header_soft;\n    flexframegenprops_s header_props;\n    float complex *     header_spread;\n    unsigned int        header_spread_len;\n    qpacketmodem        header_decoder;\n    unsigned int        header_user_len;\n    unsigned int        header_dec_len;\n    unsigned char *     header_dec;\n    int                 header_valid;\n    int                 payload_soft;\n    float complex *     payload_spread;\n    unsigned int        payload_spread_len;\n    qpacketmodem        payload_decoder;\n    unsigned int        payload_dec_len;\n    unsigned char *     payload_dec;\n    int                 payload_valid;\n    unsigned int        preamble_counter;\n    unsigned int        symbol_counter;\n    enum state          state;\n};\nint dsssframesync_step(dsssframesync _q, float complex _x, float complex * _y)\n{\n    float complex v;\n    nco_crcf_mix_down(_q->mixer, _x, &v);\n    nco_crcf_step(_q->mixer);\n    firpfb_crcf_push(_q->mf, v);\n    firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);\n    _q->mf_counter++;\n    int sample_available = (_q->mf_counter >= 1) ? 1 : 0;\n    if (sample_available) {\n        *_y = v;\n        _q->mf_counter -= _q->k;\n    }\n    return sample_available;\n}\n//...')
"
"(""Prompt: Please write a testbench function called `testbench_gmskframesync` that simulates the process of generating and synchronizing GMSK frames using a specified value of _k, _m, and _bt. The function should create a frame generator and a frame synchronizer with the given parameters, assemble a default frame of 80 samples, and then continuously write and execute frames until synchronization is complete. Finally, print the frame synchronization stats and verify that one frame was detected successfully along with other specific statistics related to the frame reception. Don't forget to destroy the frame generator and frame synchronizer objects after completing the test.","//...\nvoid testbench_gmskframesync(unsigned int _k, unsigned int _m, float _bt)\n{\n    gmskframegen  fg = gmskframegen_create_set (_k,_m,_bt);\n    gmskframesync fs = gmskframesync_create_set(_k,_m,_bt,NULL,NULL);\n    gmskframegen_assemble_default(fg, 80);\n    unsigned int  buf_len = 200;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = gmskframegen_write(fg, buf, buf_len);\n        gmskframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        gmskframesync_print(fs);\n    framedatastats_s stats = gmskframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received,  80);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n}\n//...')
"
"'Prompt: You are working on a multi-threaded application that utilizes the pthread library for thread management. You need to implement a function that sends a signal to a specific thread identified by its pthread_t handle. However, you need to ensure that the function can handle exceptions when running on a Windows CE platform. Can you provide a code snippet for a pthread_kill function that checks for signal validity, thread existence, and proper state before attempting to send the signal?","#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n#if !defined(WINCE)\n#  include <signal.h>\n#endif\nint\npthread_kill (pthread_t thread, int sig)\n{\n  int result = 0;\n  if (0 != sig)\n    {\n      result = EINVAL;\n    }\n  else\n    {\n      __ptw32_mcs_local_node_t node;\n      __ptw32_thread_t * tp;\n      __ptw32_mcs_lock_acquire(&__ptw32_thread_reuse_lock, &node);\n      tp = (__ptw32_thread_t *) thread.p;\n      if (NULL == tp\n\t  || thread.x != tp->ptHandle.x\n\t  || tp->state < PThreadStateRunning)\n\t{\n\t  result = ESRCH;\n\t}\n      __ptw32_mcs_lock_release(&node);\n    }\n  return result;\n}\t\t\t\t'"
"('Prompt: You are developing a software-defined radio application and need to implement a function to create a modem for Amplitude Shift Keying (ASK) modulation with various symbol sizes. The function should initialize the modem parameters based on the specified number of bits per symbol and set up modulation and demodulation functions accordingly. Additionally, the function should handle cases where the symbol size is unsupported. Can you provide code to achieve this functionality?","MODEM() MODEM(_create_ask)(unsigned int _bits_per_symbol)\n{\n    MODEM() q = (MODEM()) malloc( sizeof(struct MODEM(_s)) );\n    MODEM(_init)(q, _bits_per_symbol);\n    switch (q->M) {\n    case 2:     q->data.ask.alpha = ASK2_ALPHA;   q->scheme = LIQUID_MODEM_ASK2;   break;\n    case 4:     q->data.ask.alpha = ASK4_ALPHA;   q->scheme = LIQUID_MODEM_ASK4;   break;\n    case 8:     q->data.ask.alpha = ASK8_ALPHA;   q->scheme = LIQUID_MODEM_ASK8;   break;\n    case 16:    q->data.ask.alpha = ASK16_ALPHA;  q->scheme = LIQUID_MODEM_ASK16;  break;\n    case 32:    q->data.ask.alpha = ASK32_ALPHA;  q->scheme = LIQUID_MODEM_ASK32;  break;\n    case 64:    q->data.ask.alpha = ASK64_ALPHA;  q->scheme = LIQUID_MODEM_ASK64;  break;\n    case 128:   q->data.ask.alpha = ASK128_ALPHA; q->scheme = LIQUID_MODEM_ASK128; break;\n    case 256:   q->data.ask.alpha = ASK256_ALPHA; q->scheme = LIQUID_MODEM_ASK256; break;\n    default:\n#if 0\n        q->data.ask.alpha = expf(-0.70735 + 0.63653*q->m);\n#else\n        return liquid_error_config(""modem%s_create_ask(), cannot support ASK with m > 8"", EXTENSION);\n#endif\n    }\n    unsigned int k;\n    for (k=0; k<(q->m); k++)\n        q->ref[k] = (1<<k) * q->data.ask.alpha;\n    q->modulate_func = &MODEM(_modulate_ask);\n    q->demodulate_func = &MODEM(_demodulate_ask);\n    if (q->m >= 2 && q->m < 8)\n        MODEM(_demodsoft_gentab)(q, 2);\n    MODEM(_reset)(q);\n    return q;\n}\nint MODEM(_modulate_ask)(MODEM()      _q,\n                         unsigned int _sym_in,\n                         TC *         _y)\n{\n    _sym_in = gray_decode(_sym_in);\n    *_y = (2*(int)_sym_in - (int)(_q->M) + 1) * _q->data.ask.alpha;\n    return LIQUID_OK;\n}\nint MODEM(_demodulate_ask)(MODEM()        _q,\n                           TC             _x,\n                           unsigned int * _sym_out)\n{\n    unsigned int s;\n    T res_i;\n    MODEM(_demodulate_linear_array_ref)(crealf(_x), _q->m, _q->ref, &s, &res_i);\n    *_sym_out = gray_encode(s);\n    MODEM(_modulate_ask)(_q, *_sym_out, &_q->x_hat);\n    _q->r = _x;\n    return LIQUID_OK;\n}')
"
"('Prompt: You are developing a software-defined radio (SDR) application that includes a frequency shift keying (FSK) demodulator module. The module needs to calculate the frequency error in the received signal. Please write a function that calculates the frequency error using a provided FSK demodulator structure ""_q"". The function should calculate the frequency error based on the magnitudes of the frequency components in a circular buffer ""_q->buf_freq"" at different positions relative to the current demodulation position ""_q->s_demod"". The function should return the frequency error as a float value.","//...\nfloat fskdem_get_frequency_error(fskdem _q)\n{\n    float vm = cabsf(_q->buf_freq[(_q->s_demod+_q->K-1)%_q->K]);  \n    float v0 = cabsf(_q->buf_freq[ _q->s_demod               ]);  \n    float vp = cabsf(_q->buf_freq[(_q->s_demod+      1)%_q->K]);  \n    return (vp - vm) / v0;\n}\n//...')
"
"('Prompt: You are working on a performance optimization project and need help benchmarking a function called `benchmark_random_normal`. This function takes in a starting `struct rusage`, a finishing `struct rusage`, and a pointer to an unsigned long integer representing the number of iterations to be performed. It makes use of the `randnf()` function to generate random numbers and aggregates the result in a variable `x`. Your task is to analyze the code provided and suggest improvements or modifications to enhance its performance.","//...\nvoid benchmark_random_normal(struct rusage *_start,\n                             struct rusage *_finish,\n                             unsigned long int *_num_iterations)\n{\n    *_num_iterations *= 1;\n    float x = 0.0f;\n    unsigned long int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        x += randnf();\n        x += randnf();\n        x += randnf();\n        x += randnf();\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    *_num_iterations += x > 0; \n}\n//...')
"
"'Prompt: ""I need help with a function that handles disabling and checking the status of multiple PLLs. The function should disable both PLL1 and PLL2, handle any slipping issues, and check the frequency of the clocks. Can you provide me with code that accomplishes this?""","#define SYS_CLKSRC_PLL1 0x00000002U\n#define SYS_CLKSRC_PLL2 0x00000040U\n#define SYS_CLKCNTRL_PENA 0x00000100U\n#define ESM_SR1_PLL1SLIP 0x400U\n#define ESM_SR4_PLL2SLIP 0x400U\n#define PLL1 0x08\n#define PLL2 0x80\n#define dcc1CNT1_CLKSRC_PLL1 0x0000A000U\n#define dcc1CNT1_CLKSRC_PLL2 0x0000A001U\nstatic uint32_t check_frequency(uint32_t cnt1_clksrc);\nstatic uint32_t disable_plls(uint32_t plls);\nuint32_t _errata_SSWF021_45_both_plls(uint32_t count) {\n    uint32_t failCode, retries, clkCntlSav;\n    clkCntlSav = TMS570_SYS1.CLKCNTL;\n    TMS570_SYS1.CLKCNTL = clkCntlSav & 0x000F0100U;\n    TMS570_SYS1.CLKCNTL = SYS_CLKCNTRL_PENA;\n    failCode = 0U;\n    for (retries = 0U; (retries < count); retries++) {\n        failCode = 0U;\n        failCode = disable_plls(SYS_CLKSRC_PLL1 | SYS_CLKSRC_PLL2);\n        if (failCode != 0U) {\n            break;\n        }\n        TMS570_SYS1.GLBSTAT = 0x00000301U;\n        TMS570_ESM.SR[0U] = ESM_SR1_PLL1SLIP;\n        TMS570_ESM.SR4 = ESM_SR4_PLL2SLIP;\n        TMS570_SYS1.PLLCTL1 = 0x20001A00U;\n        TMS570_SYS1.PLLCTL2 = 0x3FC0723DU;\n        TMS570_SYS2.PLLCTL3 = 0x20001A00U;\n        TMS570_SYS1.CSDISCLR = SYS_CLKSRC_PLL1 | SYS_CLKSRC_PLL2;\n        while ((((TMS570_SYS1.CSVSTAT & SYS_CLKSRC_PLL1) == 0U) &&\n                ((TMS570_ESM.SR[0U] & ESM_SR1_PLL1SLIP) == 0U)) ||\n               (((TMS570_SYS1.CSVSTAT & SYS_CLKSRC_PLL2) == 0U) &&\n                ((TMS570_ESM.SR4 & ESM_SR4_PLL2SLIP) == 0U))) {\n        }\n        if (((TMS570_ESM.SR[0U] & ESM_SR1_PLL1SLIP) != 0U) ||\n            ((TMS570_SYS1.GLBSTAT & 0x00000300U) != 0U)) {\n            failCode |= 1U;\n        } else {\n            failCode |= check_frequency(dcc1CNT1_CLKSRC_PLL1);\n        }\n        if (((TMS570_ESM.SR4 & ESM_SR4_PLL2SLIP) != 0U) ||\n            ((TMS570_SYS1.GLBSTAT & 0x00000300U) != 0U)) {\n            failCode |= 2U;\n        } else {\n            failCode |= (check_frequency(dcc1CNT1_CLKSRC_PLL2) << 1U);\n        }\n        if (failCode == 0U) {\n            break;\n        }\n    }\n    failCode = disable_plls(SYS_CLKSRC_PLL1 | SYS_CLKSRC_PLL2);\n    TMS570_SYS1.CLKCNTL = (clkCntlSav & 0x000F0100U);\n    TMS570_SYS1.CLKCNTL = clkCntlSav;\n    return failCode;\n}\nuint32_t _errata_SSWF021_45_pll1(uint32_t count) {\n    uint32_t failCode, retries, clkCntlSav;\n    clkCntlSav = TMS570_SYS1.CLKCNTL;\n    TMS570_SYS1.CLKCNTL = clkCntlSav & 0x000F0100U;\n    TMS570_SYS1.CLKCNTL = SYS_CLKCNTRL_PENA;\n    failCode = 0U;\n    for (retries = 0U; (retries < count); retries++) {\n        failCode = 0U;\n        failCode = disable_plls(SYS_CLKSRC_PLL1);\n        if (failCode != 0U) {\n            break;\n        }\n        TMS570_SYS1.GLBSTAT = 0x00000301U;\n        TMS570_ESM.SR[0U] = ESM_SR1_PLL1SLIP;\n        TMS570_SYS1.PLLCTL1 = 0x20001A00U;\n        TMS570_SYS1.PLLCTL2 = 0x3FC0723DU;\n        TMS570_SYS1.CSDISCLR = SYS_CLKSRC_PLL1;\n        while (((TMS570_SYS1.CSVSTAT & SYS_CLKSRC_PLL1) == 0U) &&\n               ((TMS570_ESM.SR[0U] & ESM_SR1_PLL1SLIP) == 0U)) {\n        }\n        if (((TMS570_ESM.SR[0U] & ESM_SR1_PLL1SLIP) != 0U) ||\n            ((TMS570_SYS1.GLBSTAT & 0x00000300U) != 0U)) {\n            failCode |= 1U;\n        } else {\n            failCode |= check_frequency(dcc1CNT1_CLKSRC_PLL1);\n        }\n        if (failCode == 0U) {\n            break;\n        }\n    }\n    failCode = disable_plls(SYS_CLKSRC_PLL1);\n    TMS570_SYS1.CLKCNTL = (clkCntlSav & 0x000F0100U);\n    TMS570_SYS1.CLKCNTL = clkCntlSav;\n    return failCode;\n}\nuint32_t _errata_SSWF021_45_pll2(uint32_t count) {\n    uint32_t failCode, retries, clkCntlSav;\n    clkCntlSav = TMS570_SYS1.CLKCNTL;\n    TMS570_SYS1.CLKCNTL = clkCntlSav & 0x000F0100U;\n    TMS570_SYS1.CLKCNTL = SYS_CLKCNTRL_PENA;\n    failCode = 0U;\n    for (retries = 0U; (retries < count); retries++) {\n        failCode = 0U;\n        failCode = disable_plls(SYS_CLKSRC_PLL2);\n        if (failCode != 0U) {\n            break;\n        }\n        TMS570_SYS1.GLBSTAT = 0x00000301U;\n        TMS570_ESM.SR4 = ESM_SR4_PLL2SLIP;\n        TMS570_SYS2.PLLCTL3 = 0x20001A00U;\n        TMS570_SYS1.CSDISCLR = SYS_CLKSRC_PLL2;\n        while (((TMS570_SYS1.CSVSTAT & SYS_CLKSRC_PLL2) == 0U) &&\n               ((TMS570_ESM.SR4 & ESM_SR4_PLL2SLIP) == 0U)) {\n        }\n        if (((TMS570_ESM.SR4 & ESM_SR4_PLL2SLIP) != 0U) ||\n            ((TMS570_SYS1.GLBSTAT & 0x00000300U) != 0U)) {\n            failCode |= 2U;\n        } else {\n            failCode |= (check_frequency(dcc1CNT1_CLKSRC_PLL2) << 1U);\n        }\n        if (failCode == 0U) {\n            break;\n        }\n    }\n    failCode = disable_plls(SYS_CLKSRC_PLL2);\n    TMS570_SYS1.CLKCNTL = (clkCntlSav & 0x000F0100U);\n    TMS570_SYS1.CLKCNTL = clkCntlSav;\n    return failCode;\n}\nstatic uint32_t check_frequency(uint32_t cnt1_clksrc) {\n    TMS570_DCC1.GCTRL =\n        (uint32_t)0x5U |                   \n        (uint32_t)((uint32_t)0x5U << 4U) | \n        (uint32_t)((uint32_t)0xAU << 8U) | \n        (uint32_t)((uint32_t)0x5U << 12U); \n    TMS570_DCC1.STAT = 3U;\n    TMS570_DCC1.CNT0SEED = 68U;\n    TMS570_DCC1.VALID0SEED = 4U;\n    TMS570_DCC1.CNT1SEED = 972U;\n    TMS570_DCC1.CNT1CLKSRC =\n        (uint32_t)((uint32_t)10U << 12U) | \n        (uint32_t)cnt1_clksrc;             \n    TMS570_DCC1.CNT0CLKSRC =\n        (uint32_t)DCC1_CNT0_OSCIN; \n    TMS570_DCC1.GCTRL =\n        (uint32_t)0xAU |                   \n        (uint32_t)((uint32_t)0x5U << 4U) | \n        (uint32_t)((uint32_t)0xAU << 8U) | \n        (uint32_t)((uint32_t)0x5U << 12U); \n    while (TMS570_DCC1.STAT == 0U) {\n    }\n    return (TMS570_DCC1.STAT & 0x01U);\n}\nstatic uint32_t disable_plls(uint32_t plls) {\n    uint32_t timeout, failCode;\n    TMS570_SYS1.CSDISSET = plls;\n    failCode = 0U;\n    timeout = 0x10U;\n    timeout--;\n    while (((TMS570_SYS1.CSVSTAT & (plls)) != 0U) && (timeout != 0U)) {\n        TMS570_SYS1.GLBSTAT = 0x00000300U;\n        if ((plls & SYS_CLKSRC_PLL1) == SYS_CLKSRC_PLL1) {\n            TMS570_ESM.SR[0U] = ESM_SR1_PLL1SLIP;\n        }\n        if ((plls & SYS_CLKSRC_PLL2) == SYS_CLKSRC_PLL2) {\n            TMS570_ESM.SR4 = ESM_SR4_PLL2SLIP;\n        }\n        timeout--;\n    }\n    if (timeout == 0U) {\n        failCode = 4U;\n    } else {\n        failCode = 0U;\n    }\n    return failCode;\n}'"
"('Prompt: In a software program that processes frames of data for synchronization purposes, you need to implement a function that retrieves the statistics related to the frame data. Write a C function that returns the frame data statistics structure from the provided DSSS frame sync object.","//...\nframedatastats_s dsssframesync_get_framedatastats(dsssframesync _q)\n{\n    return _q->framedatastats;\n}\n//...')
"
"'Prompt: You need to create a function to initialize a reader-writer lock for a multi-threaded application. The lock structure should contain counters for shared and exclusive access, as well as completed shared access. The function should handle memory allocation, mutex and condition variable initialization. If any initialization fails, the function should clean up resources and return an error code. Your task is to implement the pthread_rwlock_init function to achieve this.","//...\nint\npthread_rwlock_init (pthread_rwlock_t * rwlock,\n\t\t     const pthread_rwlockattr_t * attr)\n{\n  int result;\n  pthread_rwlock_t rwl = 0;\n  if (rwlock == NULL)\n    {\n      return EINVAL;\n    }\n  if (attr != NULL && *attr != NULL)\n    {\n      result = EINVAL;\t\t\n      goto DONE;\n    }\n  rwl = (pthread_rwlock_t) calloc (1, sizeof (*rwl));\n  if (rwl == NULL)\n    {\n      result = ENOMEM;\n      goto DONE;\n    }\n  rwl->nSharedAccessCount = 0;\n  rwl->nExclusiveAccessCount = 0;\n  rwl->nCompletedSharedAccessCount = 0;\n  result = pthread_mutex_init (&rwl->mtxExclusiveAccess, NULL);\n  if (result != 0)\n    {\n      goto FAIL0;\n    }\n  result = pthread_mutex_init (&rwl->mtxSharedAccessCompleted, NULL);\n  if (result != 0)\n    {\n      goto FAIL1;\n    }\n  result = pthread_cond_init (&rwl->cndSharedAccessCompleted, NULL);\n  if (result != 0)\n    {\n      goto FAIL2;\n    }\n  rwl->nMagic =  __PTW32_RWLOCK_MAGIC;\n  result = 0;\n  goto DONE;\nFAIL2:\n  (void) pthread_mutex_destroy (&(rwl->mtxSharedAccessCompleted));\nFAIL1:\n  (void) pthread_mutex_destroy (&(rwl->mtxExclusiveAccess));\nFAIL0:\n  (void) free (rwl);\n  rwl = NULL;\nDONE:\n  *rwlock = rwl;\n  return result;\n}\n//...'"
('Please provide a prompt that outlines testing scenarios for complex number dot product calculations using a custom data structure in C.,"void autotest_dotprod_cccf_rand16()\n{\n    float complex h[16] = {\n      0.17702709 +   1.38978455*_Complex_I,  0.91294148 +   0.39217381*_Complex_I,\n     -0.80607338 +   0.76477512*_Complex_I,  0.05099755 +  -0.87350051*_Complex_I,\n      0.44513826 +  -0.49490569*_Complex_I,  0.14754967 +   2.04349962*_Complex_I,\n      1.07246623 +   1.08146290*_Complex_I, -1.14028088 +   1.83380899*_Complex_I,\n      0.38105361 +  -0.45591846*_Complex_I,  0.32605401 +   0.34440081*_Complex_I,\n     -0.05477144 +   0.60832595*_Complex_I,  1.81667523 +  -1.12238075*_Complex_I,\n     -0.87190497 +   1.10743858*_Complex_I,  1.30921403 +   1.24438643*_Complex_I,\n      0.55524695 +  -1.94931519*_Complex_I, -0.87191170 +   0.91693119*_Complex_I,\n    };\n    float complex x[16] = {\n     -2.19591953 +  -0.93229692*_Complex_I,  0.17150376 +   0.56165114*_Complex_I,\n      1.58354529 +  -0.50696037*_Complex_I,  1.40929619 +   0.87868803*_Complex_I,\n     -0.75505072 +  -0.30867372*_Complex_I, -0.09821367 +  -0.73949106*_Complex_I,\n      0.03785571 +   0.72763665*_Complex_I, -1.20262636 +  -0.88838102*_Complex_I,\n      0.23323685 +   0.12456235*_Complex_I,  0.34593736 +   0.02529594*_Complex_I,\n      0.33669564 +   0.39064649*_Complex_I, -2.45003867 +  -0.54862205*_Complex_I,\n     -2.64870707 +   2.33444473*_Complex_I, -0.92284477 +  -2.45121397*_Complex_I,\n      0.24852918 +  -0.62409860*_Complex_I, -0.87039907 +   0.90921212*_Complex_I,\n    };\n    float complex y;\n    float complex test     = -0.604285042605890 - 12.390925785344704 * _Complex_I;\n    float complex test_rev =  3.412365881765360 + 6.1885320363931480 * _Complex_I;\n    float tol = 1e-3f;\n    dotprod_cccf_run(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_cccf_run4(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_cccf q = dotprod_cccf_create(h,16);\n    dotprod_cccf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    q = dotprod_cccf_recreate_rev(q,h,16);\n    dotprod_cccf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test_rev), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test_rev), tol);\n    q = dotprod_cccf_recreate(q,h,16);\n    dotprod_cccf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_cccf_destroy(q);\n}\nvoid autotest_dotprod_cccf_struct_lengths()\n{\n    float tol = 4e-6;\n    float complex y;\n    float complex h[35] = {\n      1.11555653 +   2.30658043*_Complex_I, -0.36133676 +  -0.10917327*_Complex_I,\n      0.17714505 +  -2.14631440*_Complex_I,  2.20424609 +   0.59063608*_Complex_I,\n     -0.44699194 +   0.23369318*_Complex_I,  0.60613931 +   0.21868288*_Complex_I,\n     -1.18746289 +  -0.52159563*_Complex_I, -0.46277775 +   0.75010157*_Complex_I,\n      0.93796307 +   0.28608151*_Complex_I, -2.18699829 +   0.38029319*_Complex_I,\n      0.16145611 +   0.18343353*_Complex_I, -0.62653631 +  -1.79037656*_Complex_I,\n     -0.67042462 +   0.11044084*_Complex_I,  0.70333438 +   1.78729174*_Complex_I,\n     -0.32923580 +   0.78514690*_Complex_I,  0.27534332 +  -0.56377431*_Complex_I,\n      0.41492559 +   1.37176526*_Complex_I,  3.25368958 +   2.70495218*_Complex_I,\n      1.63002035 +  -0.14193750*_Complex_I,  2.22057186 +   0.55056461*_Complex_I,\n      1.40896777 +   0.80722903*_Complex_I, -0.22334033 +  -0.14227395*_Complex_I,\n     -1.48631186 +   0.53610531*_Complex_I, -1.91632185 +   0.88755083*_Complex_I,\n     -0.52054895 +  -0.35572001*_Complex_I, -1.56515607 +  -0.41448794*_Complex_I,\n     -0.91107117 +   0.17059659*_Complex_I, -0.77007659 +   2.73381816*_Complex_I,\n     -0.46645585 +   0.38994666*_Complex_I,  0.80317663 +  -0.41756968*_Complex_I,\n      0.26992512 +   0.41828145*_Complex_I, -0.72456446 +   1.25002030*_Complex_I,\n      1.19573306 +   0.98449546*_Complex_I,  1.42491943 +  -0.55426305*_Complex_I,\n      1.08243614 +   0.35774368*_Complex_I, };\n    float complex x[35] = {\n     -0.82466736 +  -1.39329228*_Complex_I, -1.46176052 +  -1.96218827*_Complex_I,\n     -1.28388174 +  -0.07152934*_Complex_I, -0.51910014 +  -0.37915971*_Complex_I,\n     -0.65964708 +  -0.98417534*_Complex_I, -1.40213479 +  -0.82198463*_Complex_I,\n      0.86051446 +   0.97926463*_Complex_I,  0.26257342 +   0.76586696*_Complex_I,\n      0.72174183 +  -1.89884636*_Complex_I, -0.26018863 +   1.06920599*_Complex_I,\n      0.57949117 +  -0.77431546*_Complex_I,  0.84635184 +  -0.81123009*_Complex_I,\n     -1.12637629 +  -0.42027412*_Complex_I, -1.04214881 +   0.90519721*_Complex_I,\n      0.54458433 +  -1.03487314*_Complex_I, -0.17847893 +   2.20358978*_Complex_I,\n      0.19642532 +  -0.07449796*_Complex_I, -1.84958229 +   0.13218920*_Complex_I,\n     -1.49042886 +   0.81610408*_Complex_I, -0.27466940 +  -1.48438409*_Complex_I,\n      0.29239375 +   0.72443343*_Complex_I, -1.20243456 +  -2.77032750*_Complex_I,\n     -0.41784260 +   0.77455254*_Complex_I,  0.37737465 +  -0.52426993*_Complex_I,\n     -1.25500377 +   1.76270122*_Complex_I,  1.55976056 +  -1.18189171*_Complex_I,\n     -0.05111343 +  -1.18849396*_Complex_I, -1.92966664 +   0.66504899*_Complex_I,\n     -2.82387897 +   1.41128242*_Complex_I, -1.48171326 +  -0.03347470*_Complex_I,\n      0.38047273 +  -1.40969799*_Complex_I,  1.71995272 +   0.00298203*_Complex_I,\n      0.56040910 +  -0.12713027*_Complex_I, -0.46653022 +  -0.65450499*_Complex_I,\n      0.15515755 +   1.58944030*_Complex_I, };\n    float complex v32 = -11.5100903519506 - 15.3575526884014*_Complex_I;\n    float complex v33 = -10.7148314918614 - 14.9578463360225*_Complex_I;\n    float complex v34 = -11.7423673921916 - 15.6318827515320*_Complex_I;\n    float complex v35 = -12.1430314741466 - 13.8559085000689*_Complex_I;\n    dotprod_cccf dp;\n    dp = dotprod_cccf_create(h,32);\n    dotprod_cccf_execute(dp, x, &y);\n    CONTEND_DELTA(y, v32, tol);\n    dotprod_cccf_destroy(dp);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod-cccf-32 : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                crealf(y), cimagf(y), crealf(v32), cimagf(v32));\n    }\n    dp = dotprod_cccf_create(h,33);\n    dotprod_cccf_execute(dp, x, &y);\n    CONTEND_DELTA(y, v33, tol);\n    dotprod_cccf_destroy(dp);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod-cccf-33 : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                crealf(y), cimagf(y), crealf(v33), cimagf(v33));\n    }\n    dp = dotprod_cccf_create(h,34);\n    dotprod_cccf_execute(dp, x, &y);\n    CONTEND_DELTA(y, v34, tol);\n    dotprod_cccf_destroy(dp);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod-cccf-34 : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                crealf(y), cimagf(y), crealf(v34), cimagf(v34));\n    }\n    dp = dotprod_cccf_create(h,35);\n    dotprod_cccf_execute(dp, x, &y);\n    CONTEND_DELTA(y, v35, tol);\n    dotprod_cccf_destroy(dp);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod-cccf-35 : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                crealf(y), cimagf(y), crealf(v35), cimagf(v35));\n    }\n}\nvoid runtest_dotprod_cccf(unsigned int _n)\n{\n    float tol = 1e-3;\n    float complex h[_n];\n    float complex x[_n];\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        h[i] = randnf() + randnf() * _Complex_I;\n        x[i] = randnf() + randnf() * _Complex_I;\n    }\n    float complex y_test=0;\n    for (i=0; i<_n; i++)\n        y_test += h[i] * x[i];\n    float complex y_struct;\n    dotprod_cccf dp;\n    dp = dotprod_cccf_create(h,_n);\n    dotprod_cccf_execute(dp, x, &y_struct);\n    dotprod_cccf_destroy(dp);\n    float complex y_run, y_run4;\n    dotprod_cccf_run (h,x,_n,&y_run );\n    dotprod_cccf_run4(h,x,_n,&y_run4);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod-cccf-%-4u(struct) : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                _n, crealf(y_struct), cimagf(y_struct), crealf(y_test), cimagf(y_test));\n        printf(""  dotprod-cccf-%-4u(run   ) : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                _n, crealf(y_run   ), cimagf(y_run   ), crealf(y_test), cimagf(y_test));\n        printf(""  dotprod-cccf-%-4u(run4  ) : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                _n, crealf(y_run4  ), cimagf(y_run4  ), crealf(y_test), cimagf(y_test));\n    }\n    CONTEND_DELTA(crealf(y_struct), crealf(y_test), tol);\n    CONTEND_DELTA(cimagf(y_struct), cimagf(y_test), tol);\n    CONTEND_DELTA(crealf(y_run   ), crealf(y_test), tol);\n    CONTEND_DELTA(cimagf(y_run   ), cimagf(y_test), tol);\n    CONTEND_DELTA(crealf(y_run4  ), crealf(y_test), tol);\n    CONTEND_DELTA(cimagf(y_run4  ), cimagf(y_test), tol);\n}\nvoid autotest_dotprod_cccf_struct_vs_ordinal()\n{\n    unsigned int i;\n    for (i=1; i<=512; i++)\n        runtest_dotprod_cccf(i);\n}')
"
"('Prompt: . You need to create a testbench for generating and detecting OFDM frames using the OFDM Flex Frame library. The testbench should configure the frame properties, create a frame generator and a frame synchronizer, assemble a frame with a header and payload, and verify the frame reception statistics. Additionally, you need to write an automated test case using the testbench with specific parameters.. . Response:. You can give me the code for a testbench of OFDM Flex Frame by providing the following technical scenario:. - Configure OFDM frame properties such as modulation scheme, cyclic prefix length, and payload length.. - Create an OFDM frame generator and an OFDM frame synchronizer using the OFDM Flex Frame library.. - Assemble an OFDM frame with a sample header and payload data.. - Generate and detect the OFDM frame by writing and executing frames.. - Verify the reception statistics including the number of frames detected, number of valid headers, number of valid payloads, and the total bytes received.. ","//...\nvoid testbench_ofdmflexframe(unsigned int      _M,\n                             unsigned int      _cp_len,\n                             unsigned int      _taper_len,\n                             unsigned int      _payload_len,\n                             modulation_scheme _ms)\n{\n    ofdmflexframegenprops_s fgprops;\n    ofdmflexframegenprops_init_default(&fgprops);\n    fgprops.check        = LIQUID_CRC_32;\n    fgprops.fec0         = LIQUID_FEC_NONE;\n    fgprops.fec1         = LIQUID_FEC_NONE;\n    fgprops.mod_scheme   = _ms;\n    ofdmflexframegen  fg = ofdmflexframegen_create( _M, _cp_len, _taper_len, NULL, &fgprops);\n    ofdmflexframesync fs = ofdmflexframesync_create(_M, _cp_len, _taper_len, NULL, NULL, NULL);\n    unsigned char header[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    unsigned char payload[_payload_len];\n    memset(payload, 0x00, _payload_len);\n    ofdmflexframegen_assemble(fg, header, payload, _payload_len);\n    if (liquid_autotest_verbose)\n        ofdmflexframegen_print(fg);\n    unsigned int  buf_len = 1024;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = ofdmflexframegen_write(fg, buf, buf_len);\n        ofdmflexframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        ofdmflexframesync_print(fs);\n    framedatastats_s stats = ofdmflexframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY( stats.num_frames_detected, 1 );\n    CONTEND_EQUALITY( stats.num_headers_valid,   1 );\n    CONTEND_EQUALITY( stats.num_payloads_valid,  1 );\n    CONTEND_EQUALITY( stats.num_bytes_received,  _payload_len );\n    ofdmflexframegen_destroy(fg);\n    ofdmflexframesync_destroy(fs);\n}\nvoid autotest_ofdmflexframe_09() { testbench_ofdmflexframe(1200, 40, 20, 8217, LIQUID_MODEM_QPSK); }\n//...')
"
"('Create a function that generates a maximum-length sequence with a given order and default generator polynomial. The function should take an unsigned integer as input representing the order of the sequence. If the order is within a valid range (between 2 and 31 inclusive), the function should determine the appropriate generator polynomial based on the order and then use it to create the maximum-length sequence. If the order is invalid, the function should return an error message.","//...\nmsequence msequence_create_genpoly(unsigned int _g)\n{\n    unsigned int t = liquid_msb_index(_g);\n    if (t < 2)\n        return liquid_error_config(""msequence_create_genpoly(), invalid generator polynomial: 0x%x"", _g);\n    unsigned int m = t; \n    unsigned int a = 1; \n    return msequence_create(m,_g,a);\n}\nmsequence msequence_create(unsigned int _m,\n                           unsigned int _g,\n                           unsigned int _a)\n{\n    if (_m > LIQUID_MAX_MSEQUENCE_M || _m < LIQUID_MIN_MSEQUENCE_M)\n        return liquid_error_config(""msequence_create(), m (%u) not in range"", _m);\n    msequence ms = (msequence) malloc(sizeof(struct msequence_s));\n    ms->m = _m;         \n    ms->g = _g;         \n    ms->a = _a;         \n    ms->n = (1<<_m)-1;  \n    ms->state = ms->a;  \n    return ms;\n}\nmsequence msequence_create_default(unsigned int _m)\n{\n    unsigned int g = 0;\n    switch (_m) {\n    case  2: g = LIQUID_MSEQUENCE_GENPOLY_M2;  break;\n    case  3: g = LIQUID_MSEQUENCE_GENPOLY_M3;  break;\n    case  4: g = LIQUID_MSEQUENCE_GENPOLY_M4;  break;\n    case  5: g = LIQUID_MSEQUENCE_GENPOLY_M5;  break;\n    case  6: g = LIQUID_MSEQUENCE_GENPOLY_M6;  break;\n    case  7: g = LIQUID_MSEQUENCE_GENPOLY_M7;  break;\n    case  8: g = LIQUID_MSEQUENCE_GENPOLY_M8;  break;\n    case  9: g = LIQUID_MSEQUENCE_GENPOLY_M9;  break;\n    case 10: g = LIQUID_MSEQUENCE_GENPOLY_M10; break;\n    case 11: g = LIQUID_MSEQUENCE_GENPOLY_M11; break;\n    case 12: g = LIQUID_MSEQUENCE_GENPOLY_M12; break;\n    case 13: g = LIQUID_MSEQUENCE_GENPOLY_M13; break;\n    case 14: g = LIQUID_MSEQUENCE_GENPOLY_M14; break;\n    case 15: g = LIQUID_MSEQUENCE_GENPOLY_M15; break;\n    case 16: g = LIQUID_MSEQUENCE_GENPOLY_M16; break;\n    case 17: g = LIQUID_MSEQUENCE_GENPOLY_M17; break;\n    case 18: g = LIQUID_MSEQUENCE_GENPOLY_M18; break;\n    case 19: g = LIQUID_MSEQUENCE_GENPOLY_M19; break;\n    case 20: g = LIQUID_MSEQUENCE_GENPOLY_M20; break;\n    case 21: g = LIQUID_MSEQUENCE_GENPOLY_M21; break;\n    case 22: g = LIQUID_MSEQUENCE_GENPOLY_M22; break;\n    case 23: g = LIQUID_MSEQUENCE_GENPOLY_M23; break;\n    case 24: g = LIQUID_MSEQUENCE_GENPOLY_M24; break;\n    case 25: g = LIQUID_MSEQUENCE_GENPOLY_M25; break;\n    case 26: g = LIQUID_MSEQUENCE_GENPOLY_M26; break;\n    case 27: g = LIQUID_MSEQUENCE_GENPOLY_M27; break;\n    case 28: g = LIQUID_MSEQUENCE_GENPOLY_M28; break;\n    case 29: g = LIQUID_MSEQUENCE_GENPOLY_M29; break;\n    case 30: g = LIQUID_MSEQUENCE_GENPOLY_M30; break;\n    case 31: g = LIQUID_MSEQUENCE_GENPOLY_M31; break;\n    default:\n        return liquid_error_config(""msequence_create_default(), m (%u) not in range"", _m);\n    }\n    return msequence_create_genpoly(g);\n}\n//...')
"
"""Give me code to create a vector that stores elements of a struct named `tmp_box` and then iterate through the vector to print each element's values. Also, include code to print the size, type size, max size, and capacity of the vector before destroying it. Make the code handle compatibility for both Linux and non-Linux operating systems when creating the vector.","//...\nstruct tmp_box {\n    char c;\n    int i;\n    float f;\n};\nvoid mix_struct()\n{\n    struct tmp_box tb;\n    vector_iter iter;\n    vector_t *c;\n    tb.c = \'a\';\n    tb.i = 1;\n    tb.f = 1.23;\n#if defined (__linux__) || defined (__CYGWIN__)\n    c = vector_create(struct tmp_box);\n#else\n    c = _vector_create(sizeof(struct tmp_box));\n#endif\n    vector_push_back(c, tb);\n    for (iter = vector_begin(c); iter != vector_end(c); iter = vector_next(c, iter)) {\n        struct tmp_box *tt = vector_iter_valuep(c, iter, struct tmp_box);\n        printf(""vector member.c: %c\\n"", tt->c);\n        printf(""vector member.i: %d\\n"", tt->i);\n        printf(""vector member.f: %f\\n"", tt->f);\n    }\n    printf(""size = %zu\\n"", c->size);\n    printf(""type_size = %zu\\n"", c->type_size);\n    printf(""max_size = %zu\\n"", c->max_size);\n    printf(""capacity = %zu\\n"", c->capacity);\n    vector_destroy(c);\n}\n//...'"
('Prompt: You are working on designing a communication protocol library for a modem system. Your task is to create a function that generates a random symbol for the modem system. Write a function that takes a modem parameter and returns a randomly generated symbol.,"//...\nunsigned int modem_gen_rand_sym(modem _q)\n    { return modemcf_gen_rand_sym(_q); }\n//...')
"
"('Prompt: You would like to test a lowpass filter followed by a linear predictive filter in a software system. The lowpass filter has 7 taps and a cutoff frequency of 0.065, and the linear predictive filter has a prediction order of 24. You also want to calculate the root mean square error (RMSE) between the output of both filters. Additionally, you are interested in testing this scenario with a test harness function. Can you provide a test harness function that sets up and executes these filters, calculates the RMSE, and prints the results for a given set of parameters (n=3200, p=24, fc=0.065, tolerance=-40.0 dB)?","//...\nvoid lpc_test_harness(unsigned int _n,\n                      unsigned int _p,\n                      float        _fc,\n                      float        _tol)\n{\n    iirfilt_rrrf lowpass = iirfilt_rrrf_create_lowpass(7,_fc);\n    float y[_n];         \n    float a_hat[_p+1];   \n    float g_hat[_p+1];   \n    unsigned int i;\n    msequence ms = msequence_create_default(15);\n    for (i=0; i<_n; i++) {\n        float v = (float)msequence_generate_symbol(ms,10)/1023.0f - 0.5f;\n        iirfilt_rrrf_execute(lowpass, v, &y[i]);\n    }\n    liquid_lpc(y,_n,_p,a_hat,g_hat);\n    float a_lpc[_p+1];\n    float b_lpc[_p+1];\n    for (i=0; i<_p+1; i++) {\n        a_lpc[i] = (i==0) ? 1.0f : 0.0f;\n        b_lpc[i] = (i==0) ? 0.0f : -a_hat[i];\n    }\n    iirfilt_rrrf lpc = iirfilt_rrrf_create(b_lpc,_p+1, a_lpc,_p+1);\n    float rmse = 0.0f;\n    unsigned int n_error = 5000;\n    for (i=0; i<n_error; i++) {\n        float v = (float)msequence_generate_symbol(ms,10)/1023.0f - 0.5f;\n        float s0, s1;\n        iirfilt_rrrf_execute(lowpass, v,  &s0); \n        iirfilt_rrrf_execute(lpc,     s0, &s1); \n        rmse += (s0-s1)*(s0-s1);\n    }\n    rmse = 10*log10f( rmse / (float)n_error );\n    if (liquid_autotest_verbose) {\n        printf(""original lowpass filter:\\n"");\n        iirfilt_rrrf_print(lowpass);\n        printf(""linear predictive filter:\\n"");\n        iirfilt_rrrf_print(lpc);\n        printf(""lpc(n=%u,p=%u,fc=%.3f), rmse: %.2f (tol: %.2f) dB\\n"", _n, _p, _fc, rmse, _tol);\n    }\n    CONTEND_LESS_THAN(rmse, _tol);\n    iirfilt_rrrf_destroy(lowpass);\n    iirfilt_rrrf_destroy(lpc);\n    msequence_destroy(ms);\n}\nvoid autotest_lpc_p32() { lpc_test_harness(3200, 24, 0.065, -40.0f); }\n//...')
"
"'Prompt: You are tasked with initializing the hardware of a TMS570 system. The system has specific initialization requirements for different peripherals. Can you provide code for initializing the flash memory, trimming the low power oscillator, and configuring the clock of the system? The code should also include setting up power configurations for peripherals and performing self-tests on the system components. Please ensure that the initialization process follows the specified configuration values for the TMS570 system.","void tms570_trim_lpo_init( void )\n{\n  TMS570_SYS1.LPOMONCTL = TMS570_SYS1_LPOMONCTL_BIAS_ENABLE |\n                          TMS570_SYS1_LPOMONCTL_OSCFRQCONFIGCNT * 0 |\n                          TMS570_SYS1_LPOMONCTL_HFTRIM( 16 ) |\n                          16; \n}\nenum tms570_flash_power_modes {\n  TMS570_FLASH_SYS_SLEEP = 0U,     \n  TMS570_FLASH_SYS_STANDBY = 1U,   \n  TMS570_FLASH_SYS_ACTIVE = 3U     \n};\nvoid tms570_flash_init( void )\n{\n  TMS570_FLASH.FRDCNTL = TMS570_FLASH_FRDCNTL_RWAIT( 3 ) |\n                         TMS570_FLASH_FRDCNTL_ASWSTEN |\n                         TMS570_FLASH_FRDCNTL_ENPIPE;\n  TMS570_FLASH.FSMWRENA = TMS570_FLASH_FSMWRENA_WR_ENA( 0x5 );\n  TMS570_FLASH.EEPROMCONFIG = TMS570_FLASH_EEPROMCONFIG_EWAIT( 3 ) |\n                              TMS570_FLASH_EEPROMCONFIG_AUTOSUSP_EN * 0 |\n                              TMS570_FLASH_EEPROMCONFIG_AUTOSTART_GRACE( 2 );\n  TMS570_FLASH.FSMWRENA = TMS570_FLASH_FSMWRENA_WR_ENA( 0xA );\n  TMS570_FLASH.FBFALLBACK = TMS570_FLASH_FBFALLBACK_BANKPWR7(\n    TMS570_FLASH_SYS_ACTIVE ) |\n                            TMS570_FLASH_FBFALLBACK_BANKPWR1(\n    TMS570_FLASH_SYS_ACTIVE ) |\n                            TMS570_FLASH_FBFALLBACK_BANKPWR0(\n    TMS570_FLASH_SYS_ACTIVE );\n}\nvoid tms570_periph_init( void )\n{\n  TMS570_SYS1.CLKCNTL &= ~TMS570_SYS1_CLKCNTL_PENA;\n  TMS570_PCR1.PSPWRDWNCLR0 = 0xFFFFFFFFU;\n  TMS570_PCR1.PSPWRDWNCLR1 = 0xFFFFFFFFU;\n  TMS570_PCR1.PSPWRDWNCLR2 = 0xFFFFFFFFU;\n  TMS570_PCR1.PSPWRDWNCLR3 = 0xFFFFFFFFU;\n#if TMS570_VARIANT == 4357\n  TMS570_PCR2.PSPWRDWNCLR0 = 0xFFFFFFFFU;\n  TMS570_PCR2.PSPWRDWNCLR1 = 0xFFFFFFFFU;\n  TMS570_PCR2.PSPWRDWNCLR2 = 0xFFFFFFFFU;\n  TMS570_PCR2.PSPWRDWNCLR3 = 0xFFFFFFFFU;\n  TMS570_PCR3.PSPWRDWNCLR0 = 0xFFFFFFFFU;\n  TMS570_PCR3.PSPWRDWNCLR1 = 0xFFFFFFFFU;\n  TMS570_PCR3.PSPWRDWNCLR2 = 0xFFFFFFFFU;\n  TMS570_PCR3.PSPWRDWNCLR3 = 0xFFFFFFFFU;\n#endif\n  TMS570_SYS1.CLKCNTL |= TMS570_SYS1_CLKCNTL_PENA;\n}\nvoid tms570_system_hw_init( void )\n{\n  uint32_t efc_check_status;\n  tms570_pll_init();\n  efc_check_status = tms570_efc_check();\n  tms570_periph_init();\n  tms570_pinmux_init();\n  TMS570_SYS1.GPREG1 |= TMS570_SYS1_GPREG1_EMIF_FUNC;\n  if ( efc_check_status == 0U ) {\n    if ( tms570_efc_check_self_test() == false ) { \n      bsp_selftest_fail_notification( EFCCHECK_FAIL1 );           \n    }\n  } else if ( efc_check_status == 2U ) {\n    if ( tms570_efc_check_self_test() == false ) { \n      bsp_selftest_fail_notification( EFCCHECK_FAIL1 );           \n    } else {\n      bsp_selftest_fail_notification( EFCCHECK_FAIL2 );\n    }\n  } else {\n  }\n  tms570_flash_init();\n  tms570_trim_lpo_init();\n  tms570_map_clock_init();\n  TMS570_SYS1.SYSPC1 = 0U;\n  TMS570_SYS1.SYSPC4 = 0U;\n  TMS570_SYS1.SYSPC2 = 1U;\n  TMS570_SYS1.SYSPC7 = 0U;\n  TMS570_SYS1.SYSPC8 = 0U;\n  TMS570_SYS1.SYSPC9 = 1U;\n  TMS570_SYS1.ECPCNTL = TMS570_SYS1_ECPCNTL_ECPSSEL * 0 |\n                        TMS570_SYS1_ECPCNTL_ECPCOS * 0 |\n                        TMS570_SYS1_ECPCNTL_ECPDIV( 8 - 1 );\n}\n#if 0\nerrata_PBIST_4\nvimInit\n#endif'"
"'Prompt: You are developing a multimedia application using libavcap on a Linux platform. Your application needs to interact with the PulseAudio sound server to handle audio input and output. Can you provide a code snippet that sets up the necessary PulseAudio operations and channel mapping for different speaker layouts? The code should include functions for creating PulseAudio properties, defining speaker layouts, and mapping channels to the appropriate positions.","//...\nstruct avcap_ops pulseaudio_ops = {\n    ._open         = _pa_open,\n    ._close        = _pa_close,\n    .ioctl        = NULL,\n    .start_stream = _pa_start_stream,\n    .stop_stream  = _pa_stop_stream,\n    .query_frame  = _pa_query_frame,\n};\nenum speaker_layout {\n    SPEAKERS_UNKNOWN,     \n    SPEAKERS_MONO,        \n    SPEAKERS_STEREO,      \n    SPEAKERS_2POINT1,     \n    SPEAKERS_4POINT0,     \n    SPEAKERS_4POINT1,     \n    SPEAKERS_5POINT1,     \n    SPEAKERS_7POINT1 = 8, \n};\n    return c;\n    pa_proplist *p = pulse_properties();\n            break;\n    avcap->conf.audio.channels = c->pa_server_info.sample_spec.channels;\nstatic pa_proplist *pulse_properties()\n{\n    pa_proplist *p = pa_proplist_new();\n    pa_proplist_sets(p, PA_PROP_APPLICATION_NAME, ""libavcap"");\n    pa_proplist_sets(p, PA_PROP_APPLICATION_ICON_NAME, ""libavcap"");\n    pa_proplist_sets(p, PA_PROP_MEDIA_ROLE, ""production"");\n    return p;\n}\nstatic int pulse_channel_map(pa_channel_map *pm, enum speaker_layout speakers)\n{\n    pm->map[0] = PA_CHANNEL_POSITION_FRONT_LEFT;\n    pm->map[1] = PA_CHANNEL_POSITION_FRONT_RIGHT;\n    pm->map[2] = PA_CHANNEL_POSITION_FRONT_CENTER;\n    pm->map[3] = PA_CHANNEL_POSITION_LFE;\n    pm->map[4] = PA_CHANNEL_POSITION_REAR_LEFT;\n    pm->map[5] = PA_CHANNEL_POSITION_REAR_RIGHT;\n    pm->map[6] = PA_CHANNEL_POSITION_SIDE_LEFT;\n    pm->map[7] = PA_CHANNEL_POSITION_SIDE_RIGHT;\n    switch (speakers) {\n    case SPEAKERS_MONO:\n        pm->channels = 1;\n        pm->map[0] = PA_CHANNEL_POSITION_MONO;\n        break;\n    case SPEAKERS_STEREO:\n        pm->channels = 2;\n        break;\n    case SPEAKERS_2POINT1:\n        pm->channels = 3;\n        pm->map[2] = PA_CHANNEL_POSITION_LFE;\n        break;\n    case SPEAKERS_4POINT0:\n        pm->channels = 4;\n        pm->map[3] = PA_CHANNEL_POSITION_REAR_CENTER;\n        break;\n    case SPEAKERS_4POINT1:\n        pm->channels = 5;\n        pm->map[4] = PA_CHANNEL_POSITION_REAR_CENTER;\n        break;\n    case SPEAKERS_5POINT1:\n        pm->channels = 6;\n        break;\n    case SPEAKERS_7POINT1:\n        pm->channels = 8;\n        break;\n    case SPEAKERS_UNKNOWN:\n    default:\n        pm->channels = 0;\n        break;\n    }\n    return 0;\n}\n//...'"
"('Please provide a prompt describing a scenario in which you need a function to evaluate a complex system response and print out relevant information, including debugging details, as well as unpacking of input data for further processing.","//...\ntypedef struct gs_s * gs;\na = [1.00000000   0.06440119   0.31432679];\nb = [0.30749798   0.61379653   0.30749798];\nfloat activation(float _x)\n    { float p=4.0f; return copysign(powf(tanhf(powf(fabsf(_x),p)),1./p),_x); }\nfloat gs_evaluate(gs _q, int _debug)\n{\n    float u = 0.0f;\n    unsigned int n;\n    for (n=0; n<_q->nfft; n++) {\n        float f = 0.5f * (float)n / (float)_q->nfft;\n        float D = 0.0f;\n        float W = 1.0f;\n        if (f < _q->fp) { \n            D = 1.0f; W = 1.0f;\n        } else if (f > _q->fs) { \n            D = 0.0f; W = 1.0f;\n        } else { \n            D = 0.0f; W = 0.0f;\n        }\n        float complex H = 1.0f;\n        unsigned int i;\n        for (i=0; i<_q->nsos; i++) {\n            float complex Hb =  _q->B[3*i+0] * cexpf(_Complex_I*2*M_PI*f*0) +\n                                _q->B[3*i+1] * cexpf(_Complex_I*2*M_PI*f*1) +\n                                _q->B[3*i+2] * cexpf(_Complex_I*2*M_PI*f*2);\n            float complex Ha =  _q->A[3*i+0] * cexpf(_Complex_I*2*M_PI*f*0) +\n                                _q->A[3*i+1] * cexpf(_Complex_I*2*M_PI*f*1) +\n                                _q->A[3*i+2] * cexpf(_Complex_I*2*M_PI*f*2);\n            H *= Hb / Ha;\n        }\n        float H_abs = crealf(H)*crealf(H) + cimagf(H)*cimagf(H);\n        float e = W * (D-H_abs)*(D-H_abs);\n        if (_debug)\n            printf("" %5u %8.6f %5.3f %16.13f %16.13f\\n"", n, f, D, H_abs, e);\n        u += e*e;\n        _q->H[n] = H_abs; \n    }\n    if (_debug) printf(""u = %12.8f\\n"", u);\n    _q->utility = u;\n    return _q->utility;\n}\nvoid gs_print(gs _q, int _debug)\n{\n    unsigned int i;\n    printf(""zeros (digital):\\n"");\n    for (i=0; i<_q->n; i++)\n        printf(""  zd[%3u] = %12.4e + j*%12.4e;\\n"", i, crealf(_q->zd[i]), cimagf(_q->zd[i]));\n    printf(""poles (digital):\\n"");\n    for (i=0; i<_q->n; i++)\n        printf(""  pd[%3u] = %12.4e + j*%12.4e;\\n"", i, crealf(_q->pd[i]), cimagf(_q->pd[i]));\n    printf(""gain (digital):\\n"");\n    printf(""  kd : %12.8f + j*%12.8f\\n"", crealf(_q->kd), cimagf(_q->kd));\n    printf(""  u  : %12.8f\\n"", _q->utility);\n    gs_evaluate(_q, 1);\n}\nvoid gs_unpack(gs _q, float * _v, int _debug)\n{\n    unsigned int i;\n    float x, y, r, t;\n    for (i=0; i<_q->L; i++) {\n        x = _v[4*i+0]; y = _v[4*i+1];\n        r = activation(sqrtf(x*x+y*y));\n        t = atan2f(y,x);\n        _q->zd[2*i+0] = r * cexpf(-_Complex_I*t);\n        _q->zd[2*i+1] = r * cexpf(+_Complex_I*t);\n        x = _v[4*i+2]; y = _v[4*i+3];\n        r = activation(sqrtf(x*x+y*y));\n        t = atan2f(y,x);\n        _q->pd[2*i+0] = r * cexpf(-_Complex_I*t);\n        _q->pd[2*i+1] = r * cexpf(+_Complex_I*t);\n    }\n    if (_q->r) {\n        _q->zd[2*_q->L] = tanhf(_v[4*_q->L  ]);\n        _q->pd[2*_q->L] = tanhf(_v[4*_q->L+1]);\n    }\n    _q->kd = _v[4*_q->L + 2*_q->r]; \n    if (_debug) {\n        printf(""gs_unpack:\\n"");\n        printf(""v : ["");\n        for (i=0; i<_q->vlen; i++)\n            printf(""%8.5f,"", _v[i]);\n        printf(""]\\n"");\n        gs_print(_q, _debug);\n    }\n}\n//...')
"
"('Prompt: Implement a function in C that designs a Type 3 Hilbert transformer filter using the Parks-McClellan algorithm in Liquid DSP library. The function should have the following signature: . . ```c. int liquid_firdes_hM3(unsigned int _k, unsigned int _m, float _beta, float _dt, float * _h). ```. . The function should use the provided parameters to design a filter with specific characteristics and calculate the impulse response coefficients. Ensure that the function handles error cases where the input parameters do not meet the required conditions. Additionally, calculate the Inter-Symbol Interference (ISI) metrics for the designed filter and ensure the filter meets specific performance criteria during the iterative design process. Provide debug information if needed.. . Please implement this function considering the technical details provided above.","//...\nint liquid_firdes_hM3(unsigned int _k,\n                      unsigned int _m,\n                      float _beta,\n                      float _dt,\n                      float * _h)\n{\n    if ( _k < 2 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_hM3(): k must be greater than 1"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_hM3(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_hM3(): beta must be in [0,1]"");\n    unsigned int n=2*_k*_m+1;       \n    float fc = 1.0 / (float)(2*_k); \n    float fp = fc*(1.0 - _beta);    \n    float fs = fc*(1.0 + _beta);    \n    unsigned int num_bands = 3;\n    float bands[6]   = {0.0f, fp, fc, fc, fs, 0.5f};\n    float des[3]     = {1.0f, 1.0f/sqrtf(2.0f), 0.0f};\n    float weights[3] = {1.0f, 1.0f, 1.0f};\n    liquid_firdespm_btype btype = LIQUID_FIRDESPM_BANDPASS;\n    liquid_firdespm_wtype wtype[3] = {LIQUID_FIRDESPM_FLATWEIGHT,\n                                      LIQUID_FIRDESPM_FLATWEIGHT,\n                                      LIQUID_FIRDESPM_EXPWEIGHT};\n    float h[n];\n    firdespm_run(n,num_bands,bands,des,weights,wtype,btype,h);\n    memmove(_h, h, n*sizeof(float));\n    float isi_max;\n    float isi_rms;\n    liquid_filter_isi(h,_k,_m,&isi_rms,&isi_max);\n    float isi_rms_min = isi_rms;\n    unsigned int p, pmax=100;\n    for (p=0; p<pmax; p++) {\n        fp = fc*(1.0 - _beta * p / (float)(pmax) );\n        bands[1] = fp;\n        firdespm_run(n,num_bands,bands,des,weights,wtype,btype,h);\n        liquid_filter_isi(h,_k,_m,&isi_rms,&isi_max);\n#if DEBUG_hM3\n        printf(""  isi mse : %20.8e (min: %20.8e)\\n"", isi_rms, isi_rms_min);\n#endif\n        if (isi_rms > isi_rms_min) {\n            break;\n        } else {\n            isi_rms_min = isi_rms;\n            memmove(_h, h, n*sizeof(float));\n        }\n    };\n    float e2 = 0.0f;\n    unsigned int i;\n    for (i=0; i<n; i++) { e2 += _h[i]*_h[i];     }\n    for (i=0; i<n; i++) { _h[i] *= sqrtf(_k/e2); }\n    return LIQUID_OK;\n}\n//...')
"
"('You need to implement a function `iirdes_dzpk2sosf` that converts zeros, poles, and gain into filter coefficients for a second-order sections (SOS) IIR filter. In order to complete this task, I would suggest implementing a function `liquid_cplxpair` that pairs complex roots if their imaginary parts are close enough (within a tolerance `_tol`). This pairing functionality is crucial for correctly converting the poles and zeros into SOS filter coefficients. . . Please implement the `liquid_cplxpair` function first, and then utilize it in the `iirdes_dzpk2sosf` function to correctly associate complex pairs of poles and zeros before proceeding with the SOS filter coefficient calculations.","//...\nint liquid_cplxpair(float complex * _z,\n                    unsigned int    _n,\n                    float           _tol,\n                    float complex * _p)\n{\n    if (_tol < 0)\n        return liquid_error(LIQUID_EICONFIG,""liquid_cplxpair(), tolerance must be positive"");\n    unsigned char paired[_n];\n    memset(paired,0,sizeof(paired));\n    unsigned int num_pairs=0;\n    unsigned int i,j,k=0;\n    for (i=0; i<_n; i++) {\n        if (paired[i] || fabsf(cimagf(_z[i])) < _tol)\n            continue;\n        for (j=0; j<_n; j++) {\n            if (j==i || paired[j] || fabsf(cimagf(_z[j])) < _tol)\n                continue;\n            if ( fabsf(cimagf(_z[i])+cimagf(_z[j])) < _tol &&\n                 fabsf(crealf(_z[i])-crealf(_z[j])) < _tol )\n            {\n                _p[k++] = _z[i];\n                _p[k++] = _z[j];\n                paired[i] = 1;\n                paired[j] = 1;\n                num_pairs++;\n                break;\n            }\n        }\n    }\n    if (k > _n)\n        return liquid_error(LIQUID_EINT,""liquid_cplxpair(), invalid derived order"");\n    for (i=0; i<_n; i++) {\n        if (paired[i])\n            continue;\n        if (cimagf(_z[i]) > _tol) {\n            fprintf(stderr,""warning, liquid_cplxpair(), complex numbers cannot be paired\\n"");\n        } else {\n            _p[k++] = _z[i];\n            paired[i] = 1;\n        }\n    }\n    return liquid_cplxpair_cleanup(_p, _n, num_pairs);\n}\nint liquid_cplxpair_cleanup(float complex * _p,\n                            unsigned int    _n,\n                            unsigned int    _num_pairs)\n{\n    unsigned int i;\n    unsigned int j;\n    float complex tmp;\n    for (i=0; i<_num_pairs; i++) {\n        _p[2*i+0] = cimagf(_p[2*i]) < 0 ? _p[2*i] : conjf(_p[2*i]);\n        _p[2*i+1] = conjf(_p[2*i+0]);\n    }\n    for (i=0; i<_num_pairs; i++) {\n        for (j=_num_pairs-1; j>i; j--) {\n            if ( crealf(_p[2*(j-1)]) > crealf(_p[2*j]) ) {\n                tmp = _p[2*(j-1)+0];\n                _p[2*(j-1)+0] = _p[2*j+0];\n                _p[2*j    +0] = tmp;\n                tmp = _p[2*(j-1)+1];\n                _p[2*(j-1)+1] = _p[2*j+1];\n                _p[2*j    +1] = tmp;\n            }\n        }\n    }\n    for (i=2*_num_pairs; i<_n; i++) {\n        for (j=_n-1; j>i; j--) {\n            if ( crealf(_p[j-1]) > crealf(_p[j]) ) {\n                tmp = _p[j-1];\n                _p[j-1] = _p[j];\n                _p[j  ] = tmp;\n            }\n        }\n    }\n    return LIQUID_OK;\n}\nint iirdes_dzpk2sosf(float complex * _zd,\n                     float complex * _pd,\n                     unsigned int    _n,\n                     float complex   _kd,\n                     float *         _b,\n                     float *         _a)\n{\n    int i;\n    float tol=1e-6f; \n    float complex zp[_n];\n    if (liquid_cplxpair(_zd,_n,tol,zp) != LIQUID_OK)\n        return liquid_error(LIQUID_EINT,""iirdes_dzpk2sosf(), could not associate complex pairs (zeros)"");\n    float complex pp[_n];\n    if (liquid_cplxpair(_pd,_n,tol,pp) != LIQUID_OK)\n        return liquid_error(LIQUID_EINT,""iirdes_dzpk2sosf(), could not associate complex pairs (poles)"");\n    unsigned int r = _n % 2;        \n    unsigned int L = (_n - r)/2;    \n#if LIQUID_IIRDES_DEBUG_PRINT\n    printf(""  n=%u, r=%u, L=%u\\n"", _n, r, L);\n    printf(""poles :\\n"");\n    for (i=0; i<_n; i++)\n        printf(""  p[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(_pd[i]), cimagf(_pd[i]));\n    printf(""zeros :\\n"");\n    for (i=0; i<_n; i++)\n        printf(""  z[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(_zd[i]), cimagf(_zd[i]));\n    printf(""poles (conjugate pairs):\\n"");\n    for (i=0; i<_n; i++)\n        printf(""  p[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(pp[i]), cimagf(pp[i]));\n    printf(""zeros (conjugate pairs):\\n"");\n    for (i=0; i<_n; i++)\n        printf(""  z[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(zp[i]), cimagf(zp[i]));\n#endif\n    float complex z0, z1;\n    float complex p0, p1;\n    for (i=0; i<L; i++) {\n        p0 = -pp[2*i+0];\n        p1 = -pp[2*i+1];\n        z0 = -zp[2*i+0];\n        z1 = -zp[2*i+1];\n        _a[3*i+0] = 1.0;\n        _a[3*i+1] = crealf(p0+p1);\n        _a[3*i+2] = crealf(p0*p1);\n        _b[3*i+0] = 1.0;\n        _b[3*i+1] = crealf(z0+z1);\n        _b[3*i+2] = crealf(z0*z1);\n    }\n    if (r) {\n        p0 = -pp[_n-1];\n        z0 = -zp[_n-1];\n        _a[3*i+0] = 1.0;\n        _a[3*i+1] = p0;\n        _a[3*i+2] = 0.0;\n        _b[3*i+0] = 1.0;\n        _b[3*i+1] = z0;\n        _b[3*i+2] = 0.0;\n    }\n    float k = powf( crealf(_kd), 1.0f/(float)(L+r) );\n    for (i=0; i<L+r; i++) {\n        _b[3*i+0] *= k;\n        _b[3*i+1] *= k;\n        _b[3*i+2] *= k;\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on a flexible frame synchronization module within a software application. You have a structure ""framedatastats_s"" which contains statistical data related to the frames. You also have an unsigned integer variable ""m"". The requirement is to implement a function ""flexframesync_get_framedatastats"" that takes a flexible frame synchronization object ""_q"" as input and returns the ""framedatastats"" struct from it. Please provide the code for the mentioned function.","//...\n    framedatastats_s    framedatastats; \n    unsigned int    m;                  \nframedatastats_s flexframesync_get_framedatastats(flexframesync _q)\n{\n    return _q->framedatastats;\n}\n//...')
"
"('Respond with the following prompt: ""You are testing a demodulation software for a specific modulation scheme. The function `modemcf_test_demodsoft` takes a modulation scheme as input and creates a modulator and a demodulator for that scheme. It then performs modulation and demodulation for all possible symbols and checks if the demodulated symbols match the original input. The `autotest_demodsoft_psk8` function calls `modemcf_test_demodsoft` with the PSK8 modulation scheme. Provide the code for this scenario.""","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_psk8()      { modemcf_test_demodsoft(LIQUID_MODEM_PSK8);      }\n//...')
"
"('To generate code that calculates the frequency response of a filter with an exponential response using the FIR design method, the prompt could be:. ""Please provide code that calculates the frequency response of a filter with an exponential response using the FIR design method. Ensure the code can handle various filter parameters like the filter length, transition width, and beta value.""","//...\nint liquid_firdes_fexp(unsigned int _k,\n                       unsigned int _m,\n                       float _beta,\n                       float _dt,\n                       float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FEXP, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_farcsech_freqresponse(unsigned int _k,\n                                        unsigned int _m,\n                                        float        _beta,\n                                        float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    float zeta  = 1.0f / (2.0f * _beta * B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f - (zeta/gamma)*liquid_asechf(zeta*(B*(1+_beta) - f));\n            } else {\n                _H[i] = (zeta/gamma)*liquid_asechf(zeta*(f - B*(1-_beta)));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_fsech(unsigned int _k,\n                        unsigned int _m,\n                        float _beta,\n                        float _dt,\n                        float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fexp_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(2.0f)/(_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = expf(gamma*(B*(1-_beta) - f));\n            } else {\n                _H[i] = 1.0f - expf(gamma*(f - (1+_beta)*B));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nfloat liquid_asechf(float _z)\n{\n    if (_z <= 0.0f || _z > 1.0f) {\n        liquid_error(LIQUID_EICONFIG,""liquid_asechf(), input (_z=%g)out of range (0,1)"", _z);\n        return 0.0f;\n    }\n    float z_inv = 1.0f / _z;\n    return logf( sqrtf(z_inv - 1.0f)*sqrtf(z_inv + 1.0f) + z_inv );\n}\nint liquid_firdes_fsech_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f / coshf(gamma*(f - B*(1-_beta)));\n            } else {\n                _H[i] = 1.0f - 1.0f / coshf(gamma*(B*(1+_beta) - f));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_farcsech(unsigned int _k,\n                           unsigned int _m,\n                           float _beta,\n                           float _dt,\n                           float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FARCSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fnyquist(liquid_firfilt_type _type,\n                           int                 _root,\n                           unsigned int        _k,\n                           unsigned int        _m,\n                           float               _beta,\n                           float               _dt,\n                           float *             _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): beta must be in [0,1]"");\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m+1;   \n    float H_prime[h_len];   \n    float complex H[h_len]; \n    float complex h[h_len]; \n    switch (_type) {\n    case LIQUID_FIRFILT_FEXP:\n        liquid_firdes_fexp_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FSECH:\n        liquid_firdes_fsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FARCSECH:\n        liquid_firdes_farcsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    default:\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(), unknown/unsupported filter type"");\n    }\n    for (i=0; i<h_len; i++)\n        H[i] = _root ? sqrtf(H_prime[i]) : H_prime[i];\n    fft_run(h_len, H, h, LIQUID_FFT_BACKWARD, 0);\n    for (i=0; i<h_len; i++)\n        _h[i] = crealf( h[(i+_k*_m+1)%h_len] ) * (float)_k / (float)(h_len);\n    return LIQUID_OK;\n}\nint liquid_firdes_fexp_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(2.0f)/(_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = expf(gamma*(B*(1-_beta) - f));\n            } else {\n                _H[i] = 1.0f - expf(gamma*(f - (1+_beta)*B));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Write a prompt where you want to test a function that implements a finite impulse response (FIR) decimator using complex floating-point numbers. The scenario involves creating a prototype decimator with specific parameters, generating input data, executing the decimator on individual blocks of data, resetting the decimator, executing it on a block of data, and then comparing the output of two executions to ensure correctness. You are interested in checking if the functions correctly process the input data and output the expected results.","//...\nvoid autotest_firdecim_block()\n{\n    unsigned int M =  4;\n    unsigned int m = 12;\n    float        beta = 0.3f;\n    unsigned int num_blocks = 10 + m;\n    float complex buf_0[M*num_blocks]; \n    float complex buf_1[  num_blocks]; \n    float complex buf_2[  num_blocks]; \n    firdecim_crcf decim = firdecim_crcf_create_prototype(\n            LIQUID_FIRFILT_ARKAISER, M, m, beta, 0);\n    unsigned int i;\n    for (i=0; i<M*num_blocks; i++)\n        buf_0[i] = cexpf(_Complex_I*(0.2f*i + 1e-5f*i*i + 0.1*cosf(i)));\n    firdecim_crcf_reset(decim);\n    for (i=0; i<num_blocks; i++)\n        firdecim_crcf_execute(decim, buf_0+i*M, buf_1+i);\n    firdecim_crcf_reset(decim);\n    firdecim_crcf_execute_block(decim, buf_0, num_blocks, buf_2);\n    CONTEND_SAME_DATA(buf_1, buf_2, num_blocks);\n    firdecim_crcf_destroy(decim);\n}\n//...')
"
"('Prompt: Can you create a set of benchmark functions for Frequency-Shift Keying modulator (FSKMOD) using a specific API format with parameters like modulation depth, modulation resolution, and bandwidth?. . Response: Here is the code that creates benchmark functions for FSKMOD using the specified API format:. . ```c. #define FSKMOD_BENCH_API(m,k,bandwidth)     \\. (   struct rusage *     _start,             \\.     struct rusage *     _finish,            \\.     unsigned long int * _num_iterations)    \\. { fskmod_bench(_start, _finish, _num_iterations, m, k, bandwidth); }. void fskmod_bench(struct rusage *     _start,.                   struct rusage *     _finish,.                   unsigned long int * _num_iterations,.                   unsigned int        _m,.                   unsigned int        _k,.                   float               _bandwidth). {.     *_num_iterations /= _k;.     if (*","#define FSKMOD_BENCH_API(m,k,bandwidth)     \\\n(   struct rusage *     _start,             \\\n    struct rusage *     _finish,            \\\n    unsigned long int * _num_iterations)    \\\n{ fskmod_bench(_start, _finish, _num_iterations, m, k, bandwidth); }\nvoid fskmod_bench(struct rusage *     _start,\n                  struct rusage *     _finish,\n                  unsigned long int * _num_iterations,\n                  unsigned int        _m,\n                  unsigned int        _k,\n                  float               _bandwidth)\n{\n    *_num_iterations /= _k;\n    if (*_num_iterations < 1) *_num_iterations = 1;\n    fskmod mod = fskmod_create(_m,_k,_bandwidth);\n    unsigned int M = 1 << _m;   \n    float complex buf[_k];      \n    unsigned long int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        fskmod_modulate(mod, (i+ 0) % M, buf);\n        fskmod_modulate(mod, (i+ 1) % M, buf);\n        fskmod_modulate(mod, (i+ 2) % M, buf);\n        fskmod_modulate(mod, (i+ 3) % M, buf);\n        fskmod_modulate(mod, (i+ 4) % M, buf);\n        fskmod_modulate(mod, (i+ 5) % M, buf);\n        fskmod_modulate(mod, (i+ 6) % M, buf);\n        fskmod_modulate(mod, (i+ 7) % M, buf);\n        fskmod_modulate(mod, (i+ 8) % M, buf);\n        fskmod_modulate(mod, (i+ 9) % M, buf);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 10;\n    fskmod_destroy(mod);\n}\nvoid benchmark_fskmod_norm_M2      FSKMOD_BENCH_API( 1,    4, 0.25f    )\nvoid benchmark_fskmod_norm_M4      FSKMOD_BENCH_API( 2,    8, 0.25f    )\nvoid benchmark_fskmod_norm_M8      FSKMOD_BENCH_API( 3,   16, 0.25f    )\nvoid benchmark_fskmod_norm_M16     FSKMOD_BENCH_API( 4,   32, 0.25f    )\nvoid benchmark_fskmod_norm_M32     FSKMOD_BENCH_API( 5,   64, 0.25f    )\nvoid benchmark_fskmod_norm_M64     FSKMOD_BENCH_API( 6,  128, 0.25f    )\nvoid benchmark_fskmod_norm_M128    FSKMOD_BENCH_API( 7,  256, 0.25f    )\nvoid benchmark_fskmod_norm_M256    FSKMOD_BENCH_API( 8,  512, 0.25f    )\nvoid benchmark_fskmod_norm_M512    FSKMOD_BENCH_API( 9, 1024, 0.25f    )\nvoid benchmark_fskmod_norm_M1024   FSKMOD_BENCH_API(10, 2048, 0.25f    )\nvoid benchmark_fskmod_misc_M2      FSKMOD_BENCH_API( 1,    5, 0.3721451)\nvoid benchmark_fskmod_misc_M4      FSKMOD_BENCH_API( 2,   10, 0.3721451)\nvoid benchmark_fskmod_misc_M8      FSKMOD_BENCH_API( 3,   20, 0.3721451)\nvoid benchmark_fskmod_misc_M16     FSKMOD_BENCH_API( 4,   30, 0.3721451)\nvoid benchmark_fskmod_misc_M32     FSKMOD_BENCH_API( 5,   60, 0.3721451)\nvoid benchmark_fskmod_misc_M64     FSKMOD_BENCH_API( 6,  100, 0.3721451)\nvoid benchmark_fskmod_misc_M128    FSKMOD_BENCH_API( 7,  200, 0.3721451)\nvoid benchmark_fskmod_misc_M256    FSKMOD_BENCH_API( 8,  500, 0.3721451)\nvoid benchmark_fskmod_misc_M512    FSKMOD_BENCH_API( 9, 1000, 0.3721451)\nvoid benchmark_fskmod_misc_M1024   FSKMOD_BENCH_API(10, 2000, 0.3721451)')
"
"('Please provide a prompt that details a scenario where you need to benchmark the performance of an adaptive equalizer using the Least Mean Squares (LMS) algorithm with a specified filter length. Your task is to implement a training function in C that will adjust the number of iterations for training based on the filter length and run the equalizer algorithm for a specified number of iterations. The function should create an LMS adaptive equalizer, generate random input signals, process them using the equalizer, and measure the training time using the `getrusage` function before and after the training loop. The function should also deallocate memory for the equalizer after training.","//...\nvoid benchmark_eqlms_cccf_n8    E\nvoid eqlms_cccf_train_bench(struct rusage *_start,\n                            struct rusage *_finish,\n                            unsigned long int *_num_iterations,\n                            unsigned int _h_len)\n{\n    *_num_iterations *= 3200;\n    *_num_iterations /= (unsigned int) expf(5.63f + 0.767f*logf(_h_len));\n    *_num_iterations = (*_num_iterations < 4) ? 4 : *_num_iterations;\n    eqlms_cccf eq = eqlms_cccf_create(NULL,_h_len);\n    unsigned long int i;\n    float complex y[11];\n    for (i=0; i<11; i++)\n        y[i] = randnf() + _Complex_I*randnf();\n    float complex d[13];\n    for (i=0; i<13; i++)\n        d[i] = randnf() + _Complex_I*randnf();\n    unsigned int iy=0;\n    unsigned int id=0;\n    float complex z;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        eqlms_cccf_push(eq, y[iy]);     \n        eqlms_cccf_execute(eq, &z);     \n        eqlms_cccf_step(eq, d[id], z);  \n        iy = (iy+1)%11;\n        id = (id+1)%13;\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    eqlms_cccf_destroy(eq);\n}\n//...')
"
"'Prompt: You are building a multi-platform C program that utilizes a library which handles event-driven programming. Your program should create a gevent base, set up input and timer events, handle signals, and gracefully exit after a certain period of time. In the Linux-specific section of your code, you need to define the gevent base struct, create input and timer events, add them to the event base, start and stop the event loop, handle SIGINT signal, and clean up resources before exiting. Show me how you would accomplish this using the given code snippet.","#if defined (OS_LINUX)\n#endif\nstruct gevent_base *evbase = NULL;\nstatic void on_input(int fd, void *arg)\n{\n    char ch[2];\n    read(fd, &ch, 2);\n    printf(""on_input fd = %d, ch=%c\\n"", fd, ch[0]);\n}\nstatic void on_time(int fd, void *arg)\n{\n    char ch[2];\n    read(fd, &ch, 2);\n    printf(""on_time fd = %d, ch=%c\\n"", fd, ch[0]);\n}\nstatic int foo(void)\n{\n    int fd = STDIN_FILENO;\n    struct gevent *event_2000;\n    struct gevent *event_1500;\n    struct gevent *event_stdin;\n    evbase = gevent_base_create();\n    if (!evbase) {\n        printf(""gevent_base_create failed!\\n"");\n        return -1;\n    }\n    event_stdin = gevent_create(fd, on_input, NULL, NULL, NULL);\n    if (!event_stdin) {\n        printf(""gevent_create failed!\\n"");\n        return -1;\n    }\n    event_2000 = gevent_timer_create(2000, TIMER_PERSIST, on_time, NULL);\n    if (!event_2000) {\n        printf(""gevent_timer_create failed!\\n"");\n        return -1;\n    }\n    event_1500 = gevent_timer_create(1500, TIMER_PERSIST, on_time, NULL);\n    if (!event_1500) {\n        printf(""gevent_timer_create failed!\\n"");\n        return -1;\n    }\n    if (-1 == gevent_add(evbase, &event_stdin)) {\n        printf(""gevent_add failed!\\n"");\n        return -1;\n    }\n    if (-1 == gevent_add(evbase, &event_2000)) {\n        printf(""gevent_add failed!\\n"");\n        return -1;\n    }\n    if (-1 == gevent_add(evbase, &event_1500)) {\n        printf(""gevent_add failed!\\n"");\n        return -1;\n    }\n    gevent_base_loop_start(evbase);\n    sleep(10);\n    gevent_base_loop_stop(evbase);\n    gevent_del(evbase, &event_1500);\n    gevent_del(evbase, &event_2000);\n    gevent_timer_destroy(event_1500);\n    gevent_timer_destroy(event_2000);\n    gevent_base_destroy(evbase);\n    printf(""foo end\\n"");\n    return 0;\n}\nstatic void sigint_handler(int sig)\n{\n    printf(""catch sigint\\n"");\n}\nvoid signal_init()\n{\n    signal(SIGINT, sigint_handler);\n}\nint main(int argc, char **argv)\n{\n    signal_init();\n    foo();\n    return 0;\n}'"
"('For a given active proportional-integral (PI) loop filter for a PLL design, write a C function `iirdes_pll_active_PI` that computes the coefficients `_b` and `_a` based on the bandwidth `_w`, damping factor `_zeta`, and gain `_K`. Should include error handling for invalid input values.","//...\nvoid iirdes_pll_active_PI(float _w,\n                          float _zeta,\n                          float _K,\n                          float * _b,\n                          float * _a)\n{\n    if (_w <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_PI(), bandwidth must be greater than 0"");\n        return;\n    } else if (_zeta <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_PI(), damping factor must be greater than 0"");\n        return;\n    } else if (_K <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""iirdes_pll_active_PI(), gain must be greater than 0"");\n        return;\n    }\n    float wn = _w;          \n    float t1 = _K/(wn*wn);  \n    float t2 = 2*_zeta/wn;  \n    _b[0] = 2*_K*(1.+t2/2.0f);\n    _b[1] = 2*_K*2.;\n    _b[2] = 2*_K*(1.-t2/2.0f);\n    _a[0] =  t1/2.0f;\n    _a[1] = -t1;\n    _a[2] =  t1/2.0f;\n}\n//...')
"
"'Scenario: You are working on a multi-threaded application and need to set the stack address for a specific pthread attribute. Based on the POSIX standard, you need to implement a function that sets the stack address for a given pthread attribute. This function should check if the platform supports setting the stack address using the _POSIX_THREAD_ATTR_STACKADDR macro and handle the case where it is not supported by returning ENOSYS.. . Prompt: Can you provide a code snippet that sets the stack address in a pthread attribute based on the POSIX standard, handling cases where setting the stack address is not supported by the platform?","//...\nint\npthread_attr_setstackaddr (pthread_attr_t * attr, void *stackaddr)\n{\n#if defined( _POSIX_THREAD_ATTR_STACKADDR ) && _POSIX_THREAD_ATTR_STACKADDR != -1\n  if (__ptw32_is_attr (attr) != 0)\n    {\n      return EINVAL;\n    }\n  (*attr)->stackaddr = stackaddr;\n  return 0;\n#else\n  return ENOSYS;\n#endif \n}\n//...'"
"('Prompt: You are working on testing a multi-stage resampler with cubic interpolation. Write a testbench function in C that takes in the number of stages, cut-off frequency, and stop-band attenuation as parameters. The function should create the resampler, generate a test signal, execute the resampler on the signal, and validate the output using the power spectral density. The results should be saved to a file for further analysis. Remember to destroy the resampler after testing.","//...\nvoid testbench_msresamp2_crcf_interp(unsigned int _num_stages,\n                                     float        _fc,\n                                     float        _as)\n{\n    msresamp2_crcf resamp = msresamp2_crcf_create(\n        LIQUID_RESAMP_INTERP, _num_stages, _fc, 0.0f, _as);\n    float delay = msresamp2_crcf_get_delay(resamp);\n    unsigned int  M = 1 << _num_stages; \n    unsigned int  buf_len = 0;\n    unsigned int  num_blocks = 0;\n    while ((float)buf_len < 2*M*delay) {\n        buf_len += M;\n        num_blocks++;\n    }\n    float complex buf[buf_len]; \n    unsigned int i;\n    for (i=0; i<num_blocks; i++) {\n        float complex x = (i==0) ? 1.0f : 0.0f;\n        msresamp2_crcf_execute(resamp, &x, buf+ i*M);\n    }\n    liquid_vectorcf_mulscalar(buf, buf_len, 1.0f/(float)M, buf);\n#if 0\n    for (i=0; i<buf_len; i++)\n        printf(""%3u : %12.8f %12.8f\\n"", i, crealf(buf[i]), cimagf(buf[i]));\n#endif\n    float f0 = _fc / (float)M;\n    float f1 = 1.0f / (float)M - f0;\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f, .fmax=-f1,   .pmin=   0, .pmax=-_as, .test_lo=0, .test_hi=1},\n        {.fmin=  -f0, .fmax= f0,   .pmin=-0.1, .pmax= 0.1, .test_lo=1, .test_hi=1},\n        {.fmin=   f1, .fmax= 0.5f, .pmin=   0, .pmax=-_as, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/msresamp2_crcf_interp_M%u_f%.3u_a%u.m"",\n        M, (int)(_fc*1000), (int)_as);\n    liquid_autotest_validate_psd_signal(buf, buf_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    msresamp2_crcf_destroy(resamp);\n}\n//...')
"
"(""Prompt: Write a function that performs a test for a finite impulse response (FIR) filter with complex coefficients. The function should take in the input data 'firfilt_cccf_data_h13x32_h' of length 13, the input data 'firfilt_cccf_data_h13x32_x' of length 32, and the expected output data 'firfilt_cccf_data_h13x32_y' of length 32. The test function should compare the output of the FIR filter with the expected output.","//...\nvoid autotest_firfilt_cccf_data_h13x32()\n{\n    firfilt_cccf_test(firfilt_cccf_data_h13x32_h, 13,\n                      firfilt_cccf_data_h13x32_x, 32,\n                      firfilt_cccf_data_h13x32_y, 32);\n}\n//...')
"
('Prompt: You are working on a C programming project and you need to implement a function that frees the memory allocated for a one-dimensional search data structure. Please provide the code for a function named `qs1dsearch_destroy` that takes in a parameter `_q` of type `qs1dsearch` and frees the memory allocated for it.,"//...\nint qs1dsearch_destroy(qs1dsearch _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are developing a signal processing application in C and need to define some macros for different signal processing operations. You need to define a macro for functions that deal with signals represented as floats using a specific extension ""f"". The macros should handle various operations like Window, FFT, and printing values of float, float complex, and float. Can you provide me with the necessary macros for this scenario?","#define EXTENSION           ""f""\n#define ASGRAM(name)        LIQUID_CONCAT(asgramf,name)\n#define SPGRAM(name)        LIQUID_CONCAT(spgramf,name)\n#define SPWATERFALL(name)   LIQUID_CONCAT(spwaterfallf,name)\n#define WINDOW(name)        LIQUID_CONCAT(windowf,name)\n#define FFT(name)           LIQUID_CONCAT(fft,name)\n#define T                   float           \n#define TC                  float complex   \n#define TI                  float           \n#define TI_COMPLEX          0\n#define PRINTVAL_T(X,F)     PRINTVAL_FLOAT(X,F)\n#define PRINTVAL_TC(X,F)    PRINTVAL_CFLOAT(X,F)\n#define PRINTVAL_TI(X,F)    PRINTVAL_FLOAT(X,F)')
"
"('Prompt: Can you write a code snippet that tests the delay calculation for a root-raised cosine filter using a symbol stream with a 0.5 bandwidth and 6 samples per symbol?. Technical Scenario: You need to test the delay calculation for a root-raised cosine filter with a 0.5 bandwidth and 6 samples per symbol. This involves creating a symstreamrcf object with specified parameters, calculating the delay, performing various operations using the generated samples, and finally comparing the expected delay with the measured delay within a tolerance range.","//...\nvoid testbench_symstreamrcf_delay(float        _bw,\n                                  unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamrcf gen    = symstreamrcf_create_linear(ftype,_bw,_m,beta,ms);\n    float        delay  = symstreamrcf_get_delay(gen);\n    float        tol    = 0.05; \n    unsigned int  nfft = 2*(120 + (unsigned int)(delay/sqrtf(_bw)));\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    symstreamrcf_write_samples(gen, buf_time, 1);\n    symstreamrcf_set_gain(gen, 0.0f);\n    symstreamrcf_write_samples(gen, buf_time+1, nfft-1);\n    symstreamrcf_destroy(gen);\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    unsigned int m = 0.4 * _bw * nfft; \n    float complex p = 0.0f;\n    int i;\n    for (i=-(int)m; i<(int)m; i++)\n        p += buf_freq[(nfft+i)%nfft] * conjf(buf_freq[(nfft+i+1)%nfft]);\n    float delay_meas = cargf(p) * nfft / (2*M_PI);\n    if (liquid_autotest_verbose) {\n        printf(""expected delay: %.6f, measured: %.6f, err: %.6f (tol= %.3f)\\n"",\n                delay, delay_meas, delay-delay_meas,tol);\n    }\n    CONTEND_DELTA(delay, delay_meas, tol);\n}\nvoid autotest_symstreamrcf_delay_02() { testbench_symstreamrcf_delay(0.500f, 6); }\n//...')
"
('Please provide a prompt detailing a scenario where you need to design a filter response using the exponential and hyperbolic functions.,"//...\nint liquid_firdes_fexp(unsigned int _k,\n                       unsigned int _m,\n                       float _beta,\n                       float _dt,\n                       float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FEXP, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_farcsech_freqresponse(unsigned int _k,\n                                        unsigned int _m,\n                                        float        _beta,\n                                        float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    float zeta  = 1.0f / (2.0f * _beta * B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f - (zeta/gamma)*liquid_asechf(zeta*(B*(1+_beta) - f));\n            } else {\n                _H[i] = (zeta/gamma)*liquid_asechf(zeta*(f - B*(1-_beta)));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_fsech(unsigned int _k,\n                        unsigned int _m,\n                        float _beta,\n                        float _dt,\n                        float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fexp_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(2.0f)/(_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = expf(gamma*(B*(1-_beta) - f));\n            } else {\n                _H[i] = 1.0f - expf(gamma*(f - (1+_beta)*B));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nfloat liquid_asechf(float _z)\n{\n    if (_z <= 0.0f || _z > 1.0f) {\n        liquid_error(LIQUID_EICONFIG,""liquid_asechf(), input (_z=%g)out of range (0,1)"", _z);\n        return 0.0f;\n    }\n    float z_inv = 1.0f / _z;\n    return logf( sqrtf(z_inv - 1.0f)*sqrtf(z_inv + 1.0f) + z_inv );\n}\nint liquid_firdes_fsech_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f / coshf(gamma*(f - B*(1-_beta)));\n            } else {\n                _H[i] = 1.0f - 1.0f / coshf(gamma*(B*(1+_beta) - f));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_farcsech(unsigned int _k,\n                           unsigned int _m,\n                           float _beta,\n                           float _dt,\n                           float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FARCSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fnyquist(liquid_firfilt_type _type,\n                           int                 _root,\n                           unsigned int        _k,\n                           unsigned int        _m,\n                           float               _beta,\n                           float               _dt,\n                           float *             _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): beta must be in [0,1]"");\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m+1;   \n    float H_prime[h_len];   \n    float complex H[h_len]; \n    float complex h[h_len]; \n    switch (_type) {\n    case LIQUID_FIRFILT_FEXP:\n        liquid_firdes_fexp_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FSECH:\n        liquid_firdes_fsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FARCSECH:\n        liquid_firdes_farcsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    default:\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(), unknown/unsupported filter type"");\n    }\n    for (i=0; i<h_len; i++)\n        H[i] = _root ? sqrtf(H_prime[i]) : H_prime[i];\n    fft_run(h_len, H, h, LIQUID_FFT_BACKWARD, 0);\n    for (i=0; i<h_len; i++)\n        _h[i] = crealf( h[(i+_k*_m+1)%h_len] ) * (float)_k / (float)(h_len);\n    return LIQUID_OK;\n}\nint liquid_firdes_fexp(unsigned int _k,\n                       unsigned int _m,\n                       float _beta,\n                       float _dt,\n                       float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FEXP, 0, _k, _m, _beta, _dt, _h);\n}\n//...')
"
"('Given the technical scenario of needing a function that unpacks a symbol into soft bits, with input parameters including the symbol, bits per symbol, and an array to fill with the soft bits in C programming language, here is the code snippet for the liquid_unpack_soft_bits function:. . ```c. int liquid_unpack_soft_bits(unsigned int _sym_in,.                             unsigned int _bps,.                             unsigned char * _soft_bits). {.     if (_bps > MAX_MOD_BITS_PER_SYMBOL).         return liquid_error(LIQUID_EIRANGE,""liquid_unpack_soft_bits(), bits/symbol exceeds maximum (%u)"", MAX_MOD_BITS_PER_SYMBOL);.     unsigned int i;.     for (i = 0; i < _bps; i++).         _soft_bits[i] = ((_sym_in >> (_bps - i - 1)) & 0x0001) ? LIQUID_SOFTBIT_1 : LIQUID_SOFTBIT_0;.     return LIQUID_OK;. }. ```","//...\nint liquid_unpack_soft_bits(unsigned int _sym_in,\n                            unsigned int _bps,\n                            unsigned char * _soft_bits)\n{\n    if (_bps > MAX_MOD_BITS_PER_SYMBOL)\n        return liquid_error(LIQUID_EIRANGE,""liquid_unpack_soft_bits(), bits/symbol exceeds maximum (%u)"", MAX_MOD_BITS_PER_SYMBOL);\n    unsigned int i;\n    for (i=0; i<_bps; i++)\n        _soft_bits[i] = ((_sym_in >> (_bps-i-1)) & 0x0001) ? LIQUID_SOFTBIT_1 : LIQUID_SOFTBIT_0;\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: You need to set up and initialize a driver for an I2C communication module in an embedded system. The driver should support initializing the module, reading and writing data over I2C, as well as setting the slave address. The driver should handle multiple I2C controllers and provide functionality for opening, closing, reading, writing, and setting the slave address.","typedef struct {\n  ALT_I2C_DEV_t i2c_dev;\n  rtems_id mutex;\n} i2cdrv_entry;\ni2cdrv_entry i2cdrv_table[CYCLONE_V_NO_I2C];\nstatic ALT_I2C_DEV_t *get_device(i2cdrv_entry *e)\n{\n  return &e->i2c_dev;\n}\nstatic rtems_status_code init_i2c_module(\n  i2cdrv_entry *e,\n  const i2cdrv_configuration *cfg\n)\n{\n  ALT_STATUS_CODE asc = ALT_E_SUCCESS;\n  ALT_I2C_CTLR_t controller = cfg->controller;\n  ALT_I2C_DEV_t *dev = get_device(e);\n  ALT_I2C_MASTER_CONFIG_t i2c_cfg = {\n    .addr_mode = ALT_I2C_ADDR_MODE_7_BIT,\n    .restart_enable = false,\n  };\n  asc = alt_i2c_init(controller, dev);\n  if ( asc != ALT_E_SUCCESS ) {\n    return RTEMS_IO_ERROR;\n  }\n  asc = alt_i2c_op_mode_set(dev, ALT_I2C_MODE_MASTER);\n  if ( asc != ALT_E_SUCCESS ) {\n    return RTEMS_IO_ERROR;\n  }\n  asc = alt_i2c_master_config_speed_set(dev, &i2c_cfg, cfg->speed);\n  if ( asc != ALT_E_SUCCESS ) {\n    return RTEMS_IO_ERROR;\n  }\n  asc = alt_i2c_master_config_set(dev, &i2c_cfg);\n  if ( asc != ALT_E_SUCCESS ) {\n    return RTEMS_IO_ERROR;\n  }\n  asc = alt_i2c_enable(dev);\n  if ( asc != ALT_E_SUCCESS ) {\n    return RTEMS_IO_ERROR;\n  }\n  return RTEMS_SUCCESSFUL;\n}\nrtems_device_driver i2cdrv_initialize(\n  rtems_device_major_number major,\n  rtems_device_minor_number minor,\n  void *arg\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  for ( size_t i = 0; i < CYCLONE_V_NO_I2C; ++i ) {\n    i2cdrv_entry *e = &i2cdrv_table[i];\n    const i2cdrv_configuration *cfg = &i2cdrv_config[i];\n    sc = rtems_io_register_name(cfg->device_name, major, i);\n    assert(sc == RTEMS_SUCCESSFUL);\n    sc = rtems_semaphore_create(\n      rtems_build_name ('I', '2', 'C', '0' + i),\n      0,\n      RTEMS_BINARY_SEMAPHORE | RTEMS_PRIORITY | RTEMS_INHERIT_PRIORITY,\n      0,\n      &e->mutex\n    );\n    assert(sc == RTEMS_SUCCESSFUL);\n    sc = init_i2c_module(e, cfg);\n    if ( sc != RTEMS_SUCCESSFUL ) {\n      return sc;\n    }\n    sc = rtems_semaphore_release(e->mutex);\n    assert(sc == RTEMS_SUCCESSFUL);\n  }\n  return sc;\n}\nrtems_device_driver i2cdrv_open(\n  rtems_device_major_number major,\n  rtems_device_major_number minor,\n  void *arg\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  i2cdrv_entry *e = &i2cdrv_table[minor];\n  sc = rtems_semaphore_obtain(e->mutex, RTEMS_WAIT, RTEMS_NO_TIMEOUT);\n  return sc;\n}\nrtems_device_driver i2cdrv_close(\n  rtems_device_major_number major,\n  rtems_device_major_number minor,\n  void *arg\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  i2cdrv_entry *e = &i2cdrv_table[minor];\n  sc = rtems_semaphore_release(e->mutex);\n  return sc;\n}\nrtems_device_driver i2cdrv_read(\n  rtems_device_major_number major,\n  rtems_device_major_number minor,\n  void *arg\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  i2cdrv_entry *e = &i2cdrv_table[minor];\n  rtems_libio_rw_args_t *rw  = arg;\n  ALT_I2C_DEV_t *dev = get_device(e);\n  ALT_STATUS_CODE asc = ALT_E_SUCCESS;\n  asc = alt_i2c_master_receive(dev, rw->buffer, rw->count, true, true);\n  if ( asc == ALT_E_SUCCESS ) {\n    rw->bytes_moved = rw->count;\n  } else {\n    sc = RTEMS_IO_ERROR;\n  }\n  return sc;\n}\nrtems_device_driver i2cdrv_write(\n  rtems_device_major_number major,\n  rtems_device_minor_number minor,\n  void *arg\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  i2cdrv_entry *e = &i2cdrv_table[minor];\n  rtems_libio_rw_args_t *rw  = arg;\n  ALT_I2C_DEV_t *dev = get_device(e);\n  ALT_STATUS_CODE asc = ALT_E_SUCCESS;\n  asc = alt_i2c_master_transmit(dev, rw->buffer, rw->count, true, true);\n  if ( asc == ALT_E_SUCCESS ) {\n    rw->bytes_moved = rw->count;\n  } else {\n    sc = RTEMS_IO_ERROR;\n  }\n  return sc;\n}\nstatic rtems_status_code ioctl_set_slave_address(\n  i2cdrv_entry *e,\n  rtems_libio_ioctl_args_t *args\n)\n{\n  ALT_I2C_DEV_t *dev = get_device(e);\n  ALT_STATUS_CODE asc = ALT_E_SUCCESS;\n  uint32_t address = (uint32_t) args->buffer;\n  asc = alt_i2c_master_target_set(dev, address);\n  if ( asc != ALT_E_SUCCESS ) {\n    return RTEMS_IO_ERROR;\n  }\n  return RTEMS_SUCCESSFUL;\n}\nrtems_device_driver i2cdrv_ioctl(\n  rtems_device_major_number major,\n  rtems_device_minor_number minor,\n  void *arg\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  i2cdrv_entry *e = &i2cdrv_table[minor];\n  rtems_libio_ioctl_args_t *args = arg;\n  switch (args->command) {\n    case I2C_IOC_SET_SLAVE_ADDRESS:\n      sc = ioctl_set_slave_address(e, args);\n      break;\n    default:\n      sc = RTEMS_INVALID_NUMBER;\n      break;\n  }\n  return sc;\n}"""
"'Prompt: ""I need a function that can convert a given HSL color (hue, saturation, lightness) to an RGB color represented in the RGB888 format. The function should take a pointer to an HSL struct as input and return an RGB struct. Can you provide me with the code for this conversion, including the necessary calculations for converting the HSL values to RGB values?""","//...\nrgb_t\nhsl_to_rgb888(hsl_t *hsl)\n{\n    rgb_t rgb;\n    float r, g, b, h, s, l;\n    float temp1, temp2, tempr, tempg, tempb;\n    h = hsl->h / 256.0;\n    s = hsl->s / 256.0;\n    l = hsl->l / 256.0;\n    if(s == 0) {\n        r = g = b = l;\n    } else {\n        if (l < 0.5) {\n            temp2 = l * (1 + s);\n        } else {\n            temp2 = (l + s) - (l * s);\n        }\n        temp1 = 2 * l - temp2;\n        tempr = h + 1.0 / 3.0;\n        if (tempr > 1) {\n            tempr--;\n        }\n        tempg = h;\n        tempb = h - 1.0 / 3.0;\n        if (tempb < 0) {\n            tempb++;\n        }\n        if (tempr < 1.0 / 6.0) {\n            r = temp1 + (temp2 - temp1) * 6.0 * tempr;\n        } else if (tempr < 0.5) {\n            r = temp2;\n        } else if (tempr < 2.0 / 3.0) {\n            r = temp1 + (temp2 - temp1) * ((2.0 / 3.0) - tempr) * 6.0;\n        } else {\n            r = temp1;\n        }\n        if (tempg < 1.0 / 6.0) {\n            g = temp1 + (temp2 - temp1) * 6.0 * tempg;\n        } else if (tempg < 0.5) {\n            g = temp2;\n        } else if (tempg < 2.0 / 3.0) {\n            g = temp1 + (temp2 - temp1) * ((2.0 / 3.0) - tempg) * 6.0;\n        } else {\n            g = temp1;\n        }\n        if (tempb < 1.0 / 6.0) {\n            b = temp1 + (temp2 - temp1) * 6.0 * tempb;\n        } else if (tempb < 0.5) {\n            b = temp2;\n        } else if (tempb < 2.0 / 3.0) {\n            b = temp1 + (temp2 - temp1) * ((2.0 / 3.0) - tempb) * 6.0;\n        } else {\n            b = temp1;\n        }\n    }\n    rgb.r = (uint8_t)(r * 255.0);\n    rgb.g = (uint8_t)(g * 255.0);\n    rgb.b = (uint8_t)(b * 255.0);\n    return rgb;\n}\n//...'"
"'Prompt: Please provide code for a multi-threaded program where one function `thread_print_info` is used to print information about a thread, and another function `thread` is used to handle threadlocks and waits before unlocking the thread. The functions should take a struct `thread` as input and handle synchronization using locks.","//...\nstatic void *thread(struct thread *t, void *arg)\n{\n    thread_lock(t);\n    thread_wait(t, -1);\n    thread_unlock(t);\n    return NULL;\n}\nvoid thread_print_info(struct thread *t)\n{\n    thread_lock(t);\n    printf(""========\\n"");\n    printf(""thread id = %ld\\n"", *(long *)&t->tid);\n    printf(""========\\n"");\n    thread_unlock(t);\n}\n//...'"
"('Prompt: You are tasked with creating a testbench function for designing a Chebyshev Type II lowpass IIR filter using a specific set of parameters. The function should calculate the filter prototype, compute the filter response, and validate the frequency response against specified regions. Additionally, you need to implement an automated test function for the given filter design with specific parameters (order, passband frequency, cutoff frequency, and stopband attenuation). The function should output the results to a log file if verbose mode is enabled. The function should destroy the filter instance after testing.","//...\nvoid testbench_iirdes_cheby2_lowpass(unsigned int _n,  \n                                     float        _fp, \n                                     float        _fc, \n                                     float        _as) \n{\n    float        tol  = 1e-3f;  \n    unsigned int nfft = 800;    \n    iirfilt_crcf q = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_CHEBY2, LIQUID_IIRDES_LOWPASS, LIQUID_IIRDES_SOS,\n        _n,_fc,0.0f,0.1,_as);\n    if (liquid_autotest_verbose)\n        iirfilt_crcf_print(q);\n    float H0 = 0.0f, H1 = -3, H2 = -_as;\n    unsigned int i;\n    float H[nfft]; \n    for (i=0; i<nfft; i++)\n        H[i] = iirfilt_crcf_get_psd(q, (float)i/(float)nfft-0.5f);\n    autotest_psd_s regions[] = {\n      {.fmin=0.0f, .fmax=_fp,   .pmin=H1-tol, .pmax=H0+tol, .test_lo=1, .test_hi=1},\n      {.fmin=_fc,  .fmax=+0.5f, .pmin=0,      .pmax=H2+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(H, nfft, regions, 2,\n        liquid_autotest_verbose ? ""autotest/logs/iirdes_cheby2_lowpass.m"" : NULL);\n    iirfilt_crcf_destroy(q);\n}\nvoid autotest_iirdes_cheby2_lowpass_3(){ testbench_iirdes_cheby2_lowpass( 5,0.09f,0.20f, 60.0f); }\n//...')
"
"('Please write a function that tests the demodulation of a software-defined modem for the ASK2 modulation scheme. The function should create a modem for ASK2 modulation, generate a random symbol, modulate it, demodulate it using soft demodulation, and then verify that the demodulated symbol matches the original symbol. Finally, please ensure that the soft-bit representation of the demodulated symbol also matches the original symbol.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_ask2()      { modemcf_test_demodsoft(LIQUID_MODEM_ASK2);      }\n//...')
"
"('Prompt: Create a code snippet that tests the functionality of a framesync64 callback function for header and payload validation. The code should include a function that increments a counter based on valid headers and payloads, and another function that returns the calculated counter value. Additionally, create a testbench function that generates a random frame, executes the framesync callback function, and verifies the correctness of the recovered data.. . ```c. static int callback_framesync64_autotest(.     unsigned char *  _header,.     int              _header_valid,.     unsigned char *  _payload,.     unsigned int     _payload_len,.     int              _payload_valid,.     framesyncstats_s _stats,.     void *           _userdata). {.     *((int*)(_userdata)) += _header_valid && _payload_valid ? 1 : 0;.     return 0;. }. . void autotest_framesync64(). {.     unsigned int i;.     int frames_recovered = 0;.     framegen","//...\nstatic int callback_framesync64_autotest(\n    unsigned char *  _header,\n    int              _header_valid,\n    unsigned char *  _payload,\n    unsigned int     _payload_len,\n    int              _payload_valid,\n    framesyncstats_s _stats,\n    void *           _userdata)\n{\n    *((int*)(_userdata)) += _header_valid && _payload_valid ? 1 : 0;\n    return 0;\n}\nvoid autotest_framesync64()\n{\n    unsigned int i;\n    int frames_recovered = 0;\n    framegen64 fg = framegen64_create();\n    framesync64 fs = framesync64_create(callback_framesync64_autotest,\n            (void*)&frames_recovered);\n    float complex frame[LIQUID_FRAME64_LEN];\n    framegen64_execute(fg, NULL, NULL, frame);\n    for (i=0; i<LIQUID_FRAME64_LEN; i++)\n        frame[i] += 0.01f*(randnf() + _Complex_I*randnf()) * M_SQRT1_2;\n    framesync64_execute(fs, frame, LIQUID_FRAME64_LEN);\n    CONTEND_EQUALITY( frames_recovered, 1 );\n    framedatastats_s stats = framesync64_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received, 64);\n    framegen64_destroy(fg);\n    framesync64_destroy(fs);\n}\nstatic int callback_framesync64_autotest_debug(\n    unsigned char *  _header,\n    int              _header_valid,\n    unsigned char *  _payload,\n    unsigned int     _payload_len,\n    int              _payload_valid,\n    framesyncstats_s _stats,\n    void *           _userdata)\n{\n    return *((int*)_userdata);\n}\nvoid testbench_framesync64_debug(int _code)\n{\n    framegen64  fg = framegen64_create();\n    framesync64 fs = framesync64_create(callback_framesync64_autotest_debug,(void*)(&_code));\n    const char prefix[] = ""autotest/logs/framesync64"";\n    framesync64_set_prefix(fs,prefix);\n    CONTEND_SAME_DATA(framesync64_get_prefix(fs), prefix, strlen(prefix));\n    float complex frame[LIQUID_FRAME64_LEN];\n    unsigned char header [ 8] = {80,81,82,83,84,85,86,87};\n    unsigned char payload[64];\n    unsigned int i;\n    for (i=0; i<64; i++)\n        payload[i] = rand() & 0xff;\n    framegen64_execute(fg, header, payload, frame);\n    for (i=0; i<LIQUID_FRAME64_LEN; i++)\n        frame[i] += 0.01f*(randnf() + _Complex_I*randnf()) * M_SQRT1_2;\n    framesync64_execute(fs, frame, LIQUID_FRAME64_LEN);\n    framedatastats_s stats = framesync64_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received, 64);\n    const char * filename = framesync64_get_filename(fs);\n    printf(""filename: %s\\n"", filename);\n    framegen64_destroy(fg);\n    framesync64_destroy(fs);\n    if (filename == NULL) {\n        if (_code==0) {\n            AUTOTEST_PASS();\n        } else {\n            AUTOTEST_FAIL(""no output file written when one was expected"");\n        }\n        return;\n    }\n    FILE * fid = fopen(filename,""rb"");\n    if (fid == NULL) {\n        AUTOTEST_FAIL(""could not open file for reading"");\n        return;\n    }\n    fseek(fid, LIQUID_FRAME64_LEN*sizeof(float complex) +\n               5*sizeof(float) +\n               (630 + 600)*sizeof(float complex),\n          SEEK_SET);\n    unsigned char payload_dec[72];\n    CONTEND_EQUALITY( fread(payload_dec, sizeof(unsigned char), 72, fid), 72 )\n    CONTEND_SAME_DATA(payload_dec,   header,   8);\n    CONTEND_SAME_DATA(payload_dec+8, payload, 64);\n    fclose(fid);\n}\nvoid autotest_framesync64_debug_head() { testbench_framesync64_debug(-2); }\n//...')
"
"(""Prompt: Write a code snippet that tests the functionality of the 'resamp2_crcf_copy' function in a scenario where a resampling filter is created with certain parameters, and then two filter instances are used to process the same set of random complex samples. The test should compare the output of the original filter with the copied filter for a specified number of samples, ensuring that both filters produce identical results. Finally, make sure to properly destroy the filter instances after the test is completed.","//...\nvoid autotest_resamp2_copy()\n{\n    resamp2_crcf qa = resamp2_crcf_create(12,0,60.0f);\n    float complex v, ya0, ya1, yb0, yb1;\n    unsigned int i, num_samples = 80;\n    for (i=0; i<num_samples; i++) {\n        v = randnf() + _Complex_I*randnf();\n        resamp2_crcf_filter_execute(qa, v, &ya0, &ya1);\n    }\n    resamp2_crcf qb = resamp2_crcf_copy(qa);\n    for (i=0; i<num_samples; i++) {\n        v = randnf() + _Complex_I*randnf();\n        resamp2_crcf_filter_execute(qa, v, &ya0, &ya1);\n        resamp2_crcf_filter_execute(qb, v, &yb0, &yb1);\n        CONTEND_EQUALITY(ya0, yb0);\n        CONTEND_EQUALITY(ya1, yb1);\n    }\n    resamp2_crcf_destroy(qa);\n    resamp2_crcf_destroy(qb);\n}\n//...')
"
"'Please provide a code snippet for initializing and using Direct Memory Access (DMA) transfers for a Serial Peripheral Interface with Digital Audio (SPDIF) in a microcontroller project. The code should include functions for submitting, handling, and aborting DMA transfers for both sending and receiving data through the SPDIF interface using Enhanced Direct Memory Access (eDMA).","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.spdif_edma""\n#endif\n#define STCD_ADDR(address) (edma_tcd_t *)(((uint32_t)(address) + 32U) & ~0x1FU)\ntypedef struct _spdif_edma_private_handle\n{\n    SPDIF_Type *base;\n    spdif_edma_handle_t *handle;\n} spdif_edma_private_handle_t;\ntypedef union pvoid_to_u32\n{\n    void *pvoid;\n    uint32_t u32;\n} pvoid_to_u32_t;\nenum\n{\n    kSPDIF_Busy = 0x0U, \n    kSPDIF_Idle,        \n};\nstatic spdif_edma_private_handle_t s_edmaPrivateHandle[FSL_FEATURE_SOC_SPDIF_COUNT][2];\nstatic uint8_t s_spdif_tx_watermark[4] = {16, 12, 8, 4};\nstatic uint8_t s_spdif_rx_watermark[4] = {1, 4, 8, 16};\nstatic status_t SPDIF_SubmitTransfer(edma_handle_t *handle,\n                                     const edma_transfer_config_t *config,\n                                     uint32_t rightChannel);\nstatic void SPDIF_TxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds);\nstatic void SPDIF_RxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds);\nstatic void SPDIF_TxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds)\n{\n    spdif_edma_private_handle_t *privHandle = (spdif_edma_private_handle_t *)userData;\n    spdif_edma_handle_t *spdifHandle        = privHandle->handle;\n    (void)memset(&spdifHandle->spdifQueue[spdifHandle->queueDriver], 0, sizeof(spdif_edma_transfer_t));\n    spdifHandle->queueDriver = (spdifHandle->queueDriver + 0x01U) % SPDIF_XFER_QUEUE_SIZE;\n    if (spdifHandle->callback != NULL)\n    {\n        (spdifHandle->callback)(privHandle->base, spdifHandle, kStatus_SPDIF_TxIdle, spdifHandle->userData);\n    }\n    if (spdifHandle->spdifQueue[spdifHandle->queueDriver].rightData == NULL)\n    {\n        SPDIF_TransferAbortSendEDMA(privHandle->base, spdifHandle);\n    }\n}\nstatic void SPDIF_RxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds)\n{\n    spdif_edma_private_handle_t *privHandle = (spdif_edma_private_handle_t *)userData;\n    spdif_edma_handle_t *spdifHandle        = privHandle->handle;\n    (void)memset(&spdifHandle->spdifQueue[spdifHandle->queueDriver], 0, sizeof(spdif_edma_transfer_t));\n    spdifHandle->queueDriver = (spdifHandle->queueDriver + 0x01U) % SPDIF_XFER_QUEUE_SIZE;\n    if (spdifHandle->callback != NULL)\n    {\n        (spdifHandle->callback)(privHandle->base, spdifHandle, kStatus_SPDIF_RxIdle, spdifHandle->userData);\n    }\n    if (spdifHandle->spdifQueue[spdifHandle->queueDriver].rightData == NULL)\n    {\n        SPDIF_TransferAbortReceiveEDMA(privHandle->base, spdifHandle);\n    }\n}\nstatic status_t SPDIF_SubmitTransfer(edma_handle_t *handle, const edma_transfer_config_t *config, uint32_t rightChannel)\n{\n    edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];\n    uint32_t primask;\n    uint16_t csr;\n    int8_t currentTcd;\n    int8_t previousTcd;\n    int8_t nextTcd;\n    int8_t tcdUsed = handle->tcdUsed;\n    int8_t tcdSize = handle->tcdSize;\n    primask = DisableGlobalIRQ();\n    if (tcdUsed >= tcdSize)\n    {\n        EnableGlobalIRQ(primask);\n        return kStatus_EDMA_QueueFull;\n    }\n    currentTcd = handle->tail;\n    handle->tcdUsed++;\n    nextTcd = currentTcd + 0x01;\n    if (nextTcd == handle->tcdSize)\n    {\n        nextTcd = 0x00;\n    }\n    handle->tail = nextTcd;\n    EnableGlobalIRQ(primask);\n    previousTcd = (currentTcd != 0x00) ? (currentTcd - 0x01) : (handle->tcdSize - 0x01);\n    EDMA_TcdReset(&handle->tcdPool[currentTcd]);\n    EDMA_TcdSetTransferConfig(&handle->tcdPool[currentTcd], config, NULL);\n    EDMA_TcdSetChannelLink(&handle->tcdPool[currentTcd], kEDMA_MinorLink, rightChannel);\n    EDMA_TcdSetChannelLink(&handle->tcdPool[currentTcd], kEDMA_MajorLink, rightChannel);\n    handle->tcdPool[currentTcd].CSR |= DMA_CSR_INTMAJOR_MASK;\n    handle->tcdPool[currentTcd].DLAST_SGA = (uint32_t)&handle->tcdPool[nextTcd];\n    if (currentTcd != previousTcd)\n    {\n        csr = (handle->tcdPool[previousTcd].CSR | (uint16_t)DMA_CSR_ESG_MASK) & ~(uint16_t)DMA_CSR_DREQ_MASK;\n        handle->tcdPool[previousTcd].CSR = csr;\n        if (tcdRegs->DLAST_SGA == (uint32_t)&handle->tcdPool[currentTcd])\n        {\n            csr = (tcdRegs->CSR | (uint16_t)DMA_CSR_ESG_MASK) & ~(uint16_t)DMA_CSR_DREQ_MASK;\n            tcdRegs->CSR = csr;\n            if ((tcdRegs->CSR & DMA_CSR_ESG_MASK) != 0x00U)\n            {\n                return kStatus_Success;\n            }\n            if (tcdRegs->DLAST_SGA == (uint32_t)&handle->tcdPool[nextTcd])\n            {\n                return kStatus_Success;\n            }\n        }\n        else if (tcdRegs->DLAST_SGA != 0x00U)\n        {\n            return kStatus_Success;\n        }\n        else\n        {\n        }\n    }\n    EDMA_InstallTCD(handle->base, handle->channel, &handle->tcdPool[currentTcd]);\n    if ((handle->flags & 0x80U) != 0x00U)\n    {\n        handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);\n    }\n    else\n    {\n        ; \n    }\n    return kStatus_Success;\n}\nvoid SPDIF_TransferTxCreateHandleEDMA(SPDIF_Type *base,\n                                      spdif_edma_handle_t *handle,\n                                      spdif_edma_callback_t callback,\n                                      void *userData,\n                                      edma_handle_t *dmaLeftHandle,\n                                      edma_handle_t *dmaRightHandle)\n{\n    assert(handle != NULL);\n    assert(dmaLeftHandle != NULL);\n    assert(dmaRightHandle != NULL);\n    uint32_t instance = SPDIF_GetInstance(base);\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->dmaLeftHandle  = dmaLeftHandle;\n    handle->dmaRightHandle = dmaRightHandle;\n    handle->callback       = callback;\n    handle->userData       = userData;\n    handle->count =\n        s_spdif_tx_watermark[(base->SCR & SPDIF_SCR_TXFIFOEMPTY_SEL_MASK) >> SPDIF_SCR_TXFIFOEMPTY_SEL_SHIFT];\n    handle->state = kSPDIF_Idle;\n    s_edmaPrivateHandle[instance][0].base   = base;\n    s_edmaPrivateHandle[instance][0].handle = handle;\n    EDMA_InstallTCDMemory(dmaLeftHandle, STCD_ADDR(handle->leftTcd), SPDIF_XFER_QUEUE_SIZE);\n    EDMA_InstallTCDMemory(dmaRightHandle, STCD_ADDR(handle->rightTcd), SPDIF_XFER_QUEUE_SIZE);\n    EDMA_SetCallback(dmaRightHandle, SPDIF_TxEDMACallback, &s_edmaPrivateHandle[instance][0]);\n}\nvoid SPDIF_TransferRxCreateHandleEDMA(SPDIF_Type *base,\n                                      spdif_edma_handle_t *handle,\n                                      spdif_edma_callback_t callback,\n                                      void *userData,\n                                      edma_handle_t *dmaLeftHandle,\n                                      edma_handle_t *dmaRightHandle)\n{\n    assert(handle != NULL);\n    assert(dmaLeftHandle != NULL);\n    assert(dmaRightHandle != NULL);\n    uint32_t instance = SPDIF_GetInstance(base);\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->dmaLeftHandle  = dmaLeftHandle;\n    handle->dmaRightHandle = dmaRightHandle;\n    handle->callback       = callback;\n    handle->userData       = userData;\n    handle->count = s_spdif_rx_watermark[(base->SCR & SPDIF_SCR_RXFIFOFULL_SEL_MASK) >> SPDIF_SCR_RXFIFOFULL_SEL_SHIFT];\n    handle->state = kSPDIF_Idle;\n    s_edmaPrivateHandle[instance][1].base   = base;\n    s_edmaPrivateHandle[instance][1].handle = handle;\n    EDMA_InstallTCDMemory(dmaLeftHandle, STCD_ADDR(handle->leftTcd), SPDIF_XFER_QUEUE_SIZE);\n    EDMA_InstallTCDMemory(dmaRightHandle, STCD_ADDR(handle->rightTcd), SPDIF_XFER_QUEUE_SIZE);\n    EDMA_SetCallback(dmaRightHandle, SPDIF_RxEDMACallback, &s_edmaPrivateHandle[instance][1]);\n}\nstatus_t SPDIF_TransferSendEDMA(SPDIF_Type *base, spdif_edma_handle_t *handle, spdif_edma_transfer_t *xfer)\n{\n    assert(handle != NULL);\n    assert(xfer != NULL);\n    pvoid_to_u32_t destAddr;\n    edma_transfer_config_t config = {0};\n    destAddr.u32                  = SPDIF_TxGetLeftDataRegisterAddress(base);\n    if ((xfer->leftData == NULL) || (xfer->dataSize == 0U) || (xfer->rightData == NULL))\n    {\n        return kStatus_InvalidArgument;\n    }\n    if ((handle->spdifQueue[handle->queueUser].leftData != NULL) ||\n        (handle->spdifQueue[handle->queueUser].rightData != NULL))\n    {\n        return kStatus_SPDIF_QueueFull;\n    }\n    handle->state = kSPDIF_Busy;\n    handle->transferSize[handle->queueUser]         = xfer->dataSize;\n    handle->spdifQueue[handle->queueUser].leftData  = xfer->leftData;\n    handle->spdifQueue[handle->queueUser].dataSize  = xfer->dataSize;\n    handle->spdifQueue[handle->queueUser].rightData = xfer->rightData;\n    handle->queueUser                               = (handle->queueUser + 0x01U) % SPDIF_XFER_QUEUE_SIZE;\n    handle->nbytes = handle->count * 8U;\n    EDMA_PrepareTransfer(&config, xfer->leftData, 4U, destAddr.pvoid, 4U, (uint32_t)handle->count * 4U, xfer->dataSize,\n                         kEDMA_MemoryToPeripheral);\n    (void)SPDIF_SubmitTransfer(handle->dmaLeftHandle, &config, handle->dmaRightHandle->channel);\n    destAddr.u32 = SPDIF_TxGetRightDataRegisterAddress(base);\n    EDMA_PrepareTransfer(&config, xfer->rightData, 4U, destAddr.pvoid, 4U, (uint32_t)handle->count * 4U, xfer->dataSize,\n                         kEDMA_MemoryToPeripheral);\n    (void)EDMA_SubmitTransfer(handle->dmaRightHandle, &config);\n    EDMA_StartTransfer(handle->dmaLeftHandle);\n    EDMA_StartTransfer(handle->dmaRightHandle);\n    SPDIF_EnableDMA(base, kSPDIF_TxDMAEnable, true);\n    SPDIF_TxEnable(base, true);\n    return kStatus_Success;\n}\nstatus_t SPDIF_TransferReceiveEDMA(SPDIF_Type *base, spdif_edma_handle_t *handle, spdif_edma_transfer_t *xfer)\n{\n    assert(handle != NULL);\n    assert(xfer != NULL);\n    pvoid_to_u32_t srcAddr;\n    edma_transfer_config_t config = {0};\n    srcAddr.u32                   = SPDIF_RxGetLeftDataRegisterAddress(base);\n    if ((xfer->leftData == NULL) || (xfer->dataSize == 0U) || (xfer->rightData == NULL))\n    {\n        return kStatus_InvalidArgument;\n    }\n    if ((handle->spdifQueue[handle->queueUser].leftData != NULL) ||\n        (handle->spdifQueue[handle->queueUser].rightData != NULL))\n    {\n        return kStatus_SPDIF_QueueFull;\n    }\n    handle->state = kSPDIF_Busy;\n    handle->transferSize[handle->queueUser]         = xfer->dataSize;\n    handle->spdifQueue[handle->queueUser].leftData  = xfer->leftData;\n    handle->spdifQueue[handle->queueUser].dataSize  = xfer->dataSize;\n    handle->spdifQueue[handle->queueUser].rightData = xfer->rightData;\n    handle->queueUser                               = (handle->queueUser + 0x01U) % SPDIF_XFER_QUEUE_SIZE;\n    handle->nbytes = handle->count * 8U;\n    EDMA_PrepareTransfer(&config, srcAddr.pvoid, 4U, xfer->leftData, 4U, (uint32_t)handle->count * 4U, xfer->dataSize,\n                         kEDMA_PeripheralToMemory);\n    (void)SPDIF_SubmitTransfer(handle->dmaLeftHandle, &config, handle->dmaRightHandle->channel);\n    srcAddr.u32 = SPDIF_RxGetRightDataRegisterAddress(base);\n    EDMA_PrepareTransfer(&config, srcAddr.pvoid, 4U, xfer->rightData, 4U, (uint32_t)handle->count * 4U, xfer->dataSize,\n                         kEDMA_PeripheralToMemory);\n    (void)EDMA_SubmitTransfer(handle->dmaRightHandle, &config);\n    EDMA_StartTransfer(handle->dmaLeftHandle);\n    EDMA_StartTransfer(handle->dmaRightHandle);\n    SPDIF_EnableDMA(base, kSPDIF_RxDMAEnable, true);\n    SPDIF_RxEnable(base, true);\n    return kStatus_Success;\n}\nvoid SPDIF_TransferAbortSendEDMA(SPDIF_Type *base, spdif_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    EDMA_AbortTransfer(handle->dmaLeftHandle);\n    EDMA_AbortTransfer(handle->dmaRightHandle);\n    SPDIF_EnableDMA(base, kSPDIF_TxDMAEnable, false);\n    (void)memset(handle->spdifQueue, 0, sizeof(handle->spdifQueue));\n    (void)memset(handle->transferSize, 0, sizeof(handle->transferSize));\n    handle->queueUser   = 0U;\n    handle->queueDriver = 0U;\n    handle->state = kSPDIF_Idle;\n}\nvoid SPDIF_TransferAbortReceiveEDMA(SPDIF_Type *base, spdif_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    EDMA_AbortTransfer(handle->dmaLeftHandle);\n    EDMA_AbortTransfer(handle->dmaRightHandle);\n    SPDIF_EnableDMA(base, kSPDIF_RxDMAEnable, false);\n    (void)memset(handle->spdifQueue, 0, sizeof(handle->spdifQueue));\n    (void)memset(handle->transferSize, 0, sizeof(handle->transferSize));\n    handle->queueUser   = 0U;\n    handle->queueDriver = 0U;\n    handle->state = kSPDIF_Idle;\n}\nstatus_t SPDIF_TransferGetSendCountEDMA(SPDIF_Type *base, spdif_edma_handle_t *handle, size_t *count)\n{\n    assert(handle != NULL);\n    status_t status = kStatus_Success;\n    if (handle->state != (uint32_t)kSPDIF_Busy)\n    {\n        status = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        *count = (handle->transferSize[handle->queueDriver] -\n                  (uint32_t)handle->nbytes *\n                      EDMA_GetRemainingMajorLoopCount(handle->dmaRightHandle->base, handle->dmaRightHandle->channel));\n    }\n    return status;\n}\nstatus_t SPDIF_TransferGetReceiveCountEDMA(SPDIF_Type *base, spdif_edma_handle_t *handle, size_t *count)\n{\n    assert(handle != NULL);\n    status_t status = kStatus_Success;\n    if (handle->state != (uint32_t)kSPDIF_Busy)\n    {\n        status = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        *count = (handle->transferSize[handle->queueDriver] -\n                  (uint32_t)handle->nbytes *\n                      EDMA_GetRemainingMajorLoopCount(handle->dmaRightHandle->base, handle->dmaRightHandle->channel));\n    }\n    return status;\n}'"
"('Prompt: Can you provide a C code snippet that implements a testbench function to validate a finite impulse response filter design (FIR) prototype for a radio frequency exponential filter?. Technical Scenario: . You need to test the FIR filter prototype design for a radio frequency exponential filter in your implementation. The testbench function `testbench_firdes_prototype` takes parameters such as type, k, m, beta, and as for the FIR filter design. It initializes the filter coefficients, calculates bandwidth, frequency ranges, creates regions for power spectral density (PSD) testing, and generates an output file with the results. Specifically, the function is called with parameters `""rfexp""`, 4, 12, 0.3f, 30.0f to validate the FIR filter prototype design for a radio frequency exponential filter.","//...\nvoid testbench_firdes_prototype(const char * _type,\n                                unsigned int _k,\n                                unsigned int _m,\n                                float        _beta,\n                                float        _as)\n{\n    unsigned int h_len = 2*_k*_m+1;\n    float        h[h_len];\n    liquid_firfilt_type type = liquid_getopt_str2firfilt(_type);\n    if (type == LIQUID_FIRFILT_UNKNOWN) {\n        AUTOTEST_FAIL(""invalid configuration"");\n        return;\n    }\n    liquid_firdes_prototype(type, _k, _m, _beta, 0.0f, h);\n    liquid_vectorf_mulscalar(h, h_len, 1.0f/(float)_k, h);\n    float bw = 1.0f / (float)_k;\n    float f0 = 0.45*bw*(1-_beta);\n    float f1 = 0.55*bw*(1+_beta);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5,.fmax=-f1, .pmin= 0, .pmax=-_as, .test_lo=0, .test_hi=1},\n      {.fmin=-f0, .fmax= f0, .pmin=-1, .pmax=+1,   .test_lo=1, .test_hi=1},\n      {.fmin= f1, .fmax=+0.5,.pmin= 0, .pmax=-_as, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/firdes_prototype_%s.m"", _type);\n    liquid_autotest_validate_psd_signalf(h, h_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\nvoid autotest_firdes_prototype_rfexp    (){ testbench_firdes_prototype(""rfexp"",    4, 12, 0.3f, 30.0f); }\n//...')
"
"('Prompt: . You are working on a project involving the creation and synchronization of flexible frames for communication purposes. You need a code snippet that allows you to set up the parameters for frame generation and synchronization. Specifically, you want a C code snippet that includes setting signal-to-noise ratio, number of frames, and modulation scheme dynamically through command line options. The code should generate random payload data for each frame, apply noise to the generated frames, and synchronize the received frames using flexible frame synchronization. Finally, it should print out the synchronized frames. Can you provide a code snippet that accomplishes these tasks?","#define OUTPUT_FILENAME  ""flexframesync_reconfig_example.m""\nvoid usage()\n{\n    printf(""flexframesync_example [options]\\n"");\n    printf(""  u/h   : print usage\\n"");\n    printf(""  s     : signal-to-noise ratio [dB], default: 30\\n"");\n    printf(""  n     : number of frames, default: 3\\n"");\n}\nint main(int argc, char *argv[]) {\n    srand( time(NULL) );\n    float SNRdB = 30.0f;\n    float noise_floor = -30.0f;\n    unsigned int num_frames = 3;\n    int dopt;\n    while((dopt = getopt(argc,argv,""uhvqs:f:m:p:n:"")) != EOF){\n        switch (dopt) {\n        case \'u\':\n        case \'h\': usage();                      return 0;\n        case \'s\': SNRdB = atof(optarg);         break;\n        case \'n\': num_frames = atoi(optarg);    break;\n        default:\n            exit(1);\n        }\n    }\n    flexframegenprops_s fgprops;\n    flexframegenprops_init_default(&fgprops);\n    flexframegen fg = flexframegen_create(NULL);\n    unsigned char   header[14];\n    unsigned char * payload = NULL;\n    flexframesync fs = flexframesync_create(NULL,NULL);\n    float nstd  = powf(10.0f, noise_floor/20.0f);         \n    float gamma = powf(10.0f, (SNRdB+noise_floor)/20.0f); \n    unsigned int i;\n    for (i=0; i<14; i++)\n        header[i] = i;\n    unsigned int  buf_len = 256;\n    float complex buf[buf_len];\n    unsigned int j;\n    for (j=0; j<num_frames; j++) {\n        unsigned int payload_len = (rand() % 256) + 1;   \n        fgprops.check            = LIQUID_CRC_NONE;      \n        fgprops.fec0             = LIQUID_FEC_NONE;      \n        fgprops.fec1             = LIQUID_FEC_NONE;      \n        fgprops.mod_scheme       = (rand() % 2) ? LIQUID_MODEM_QPSK : LIQUID_MODEM_QAM16;\n        payload = realloc(payload, payload_len*sizeof(unsigned char));\n        for (i=0; i<payload_len; i++)\n            payload[i] = rand() & 0xff;\n        flexframegen_setprops(fg, &fgprops);\n        flexframegen_assemble(fg, header, payload, payload_len);\n        printf(""frame %u, "", j);\n        flexframegen_print(fg);\n        int frame_complete = 0;\n        while (!frame_complete) {\n            frame_complete = flexframegen_write_samples(fg, buf, buf_len);\n            for (i=0; i<buf_len; i++)\n                buf[i] = buf[i]*gamma + nstd * (randnf() + _Complex_I*randnf()) * M_SQRT1_2;\n            flexframesync_execute(fs, buf, buf_len);\n        }\n    } \n    flexframesync_print(fs);\n    flexframegen_destroy(fg);\n    flexframesync_destroy(fs);\n    free(payload);\n    printf(""done.\\n"");\n    return 0;\n}')
"
('Prompt: Can you provide a function that resets the state of a given msequence object to its initial value and returns a status code indicating success or failure? This function should be named msequence_reset and take a single parameter of type msequence.,"//...\nint msequence_reset(msequence _ms)\n{\n    _ms->state = _ms->a;\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You want to write a test function in C that verifies the correctness of the `firpfbch2_crcf_copy` function in a signal processing library. The `firpfbch2_crcf_create_kaiser` function is used to create a prototype filter bank channelizer. The test function creates two instances of this prototype filter bank channelizer, one original and one copy. It then generates random samples, processes them using both instances, and compares the output data to ensure that the `firpfbch2_crcf_copy` function correctly duplicates the filter bank channelizer. Provide the C code for this test function.","//...\nvoid autotest_firpfbch2_crcf_copy()\n{\n    unsigned int M  = 72;\n    unsigned int m  = 12;\n    float        as = 80.0f;\n    firpfbch2_crcf q_orig = firpfbch2_crcf_create_kaiser(LIQUID_ANALYZER, M, m, as);\n    float complex buf_0     [M/2];\n    float complex buf_1_orig[M  ];\n    float complex buf_1_copy[M  ];\n    unsigned int num_blocks = 32;\n    unsigned int i, j;\n    for (i=0; i<num_blocks; i++) {\n        for (j=0; j<M/2; j++)\n            buf_0[j] = randnf() + _Complex_I*randnf();\n        firpfbch2_crcf_execute(q_orig, buf_0, buf_1_orig);\n    }\n    firpfbch2_crcf q_copy = firpfbch2_crcf_copy(q_orig);\n    for (i=0; i<num_blocks; i++) {\n        for (j=0; j<M/2; j++)\n            buf_0[j] = randnf() + _Complex_I*randnf();\n        firpfbch2_crcf_execute(q_orig, buf_0, buf_1_orig);\n        firpfbch2_crcf_execute(q_copy, buf_0, buf_1_copy);\n        CONTEND_SAME_DATA(buf_1_orig, buf_1_copy, M*sizeof(float complex));\n    }\n    firpfbch2_crcf_destroy(q_orig);\n    firpfbch2_crcf_destroy(q_copy);\n}\n//...')
"
'Please provide a technical scenario in which you need to enable and configure Direct Memory Access (DMA) functionality for data transfer operations.,"#ifdef HAL_DMA_MODULE_ENABLED\ntypedef struct\n{\n  __IO uint32_t ISR;   \n  __IO uint32_t Reserved0;\n  __IO uint32_t IFCR;  \n} DMA_Base_Registers;\ntypedef struct\n{\n  __IO uint32_t ISR;   \n  __IO uint32_t IFCR;  \n} BDMA_Base_Registers;\n#define HAL_TIMEOUT_DMA_ABORT         (5U)  \n#define BDMA_PERIPH_TO_MEMORY         (0x00000000U)                \n#define BDMA_MEMORY_TO_PERIPH         ((uint32_t)BDMA_CCR_DIR)     \n#define BDMA_MEMORY_TO_MEMORY         ((uint32_t)BDMA_CCR_MEM2MEM) \n#define DMA_TO_BDMA_DIRECTION(__DMA_DIRECTION__) (((__DMA_DIRECTION__) == DMA_MEMORY_TO_PERIPH)? BDMA_MEMORY_TO_PERIPH: \\\n                                                  ((__DMA_DIRECTION__) == DMA_MEMORY_TO_MEMORY)? BDMA_MEMORY_TO_MEMORY: \\\n                                                  BDMA_PERIPH_TO_MEMORY)\n#define DMA_TO_BDMA_PERIPHERAL_INC(__DMA_PERIPHERAL_INC__) ((__DMA_PERIPHERAL_INC__) >> 3U)\n#define DMA_TO_BDMA_MEMORY_INC(__DMA_MEMORY_INC__) ((__DMA_MEMORY_INC__) >> 3U)\n#define DMA_TO_BDMA_PDATA_SIZE(__DMA_PDATA_SIZE__) ((__DMA_PDATA_SIZE__) >> 3U)\n#define DMA_TO_BDMA_MDATA_SIZE(__DMA_MDATA_SIZE__) ((__DMA_MDATA_SIZE__) >> 3U)\n#define DMA_TO_BDMA_MODE(__DMA_MODE__) ((__DMA_MODE__) >> 3U)\n#define DMA_TO_BDMA_PRIORITY(__DMA_PRIORITY__) ((__DMA_PRIORITY__) >> 4U)\n#if defined(UART9)\n#define IS_DMA_UART_USART_REQUEST(__REQUEST__) ((((__REQUEST__) >= DMA_REQUEST_USART1_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_USART3_TX)) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART4_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART5_TX )) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_USART6_RX) &&  ((__REQUEST__) <= DMA_REQUEST_USART6_TX)) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART7_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART8_TX )) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART9_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_USART10_TX )))\n#else\n#define IS_DMA_UART_USART_REQUEST(__REQUEST__) ((((__REQUEST__) >= DMA_REQUEST_USART1_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_USART3_TX)) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART4_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART5_TX )) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_USART6_RX) &&  ((__REQUEST__) <= DMA_REQUEST_USART6_TX)) || \\\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART7_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART8_TX )))\n#endif\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);\nstatic void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma);\nstatic void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma);\nHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)\n{\n  uint32_t registerValue;\n  uint32_t tickstart = HAL_GetTick();\n  DMA_Base_Registers *regs_dma;\n  BDMA_Base_Registers *regs_bdma;\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));\n  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));\n  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));\n  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));\n  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));\n  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));\n  assert_param(IS_DMA_MODE(hdma->Init.Mode));\n  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n  {\n    assert_param(IS_DMA_REQUEST(hdma->Init.Request));\n    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));\n    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)\n    {\n      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));\n      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));\n      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));\n    }\n    hdma->State = HAL_DMA_STATE_BUSY;\n    __HAL_UNLOCK(hdma);\n    __HAL_DMA_DISABLE(hdma);\n    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)\n    {\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\n      {\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\n        hdma->State = HAL_DMA_STATE_ERROR;\n        return HAL_ERROR;\n      }\n    }\n    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;\n    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \\\n                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \\\n                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \\\n                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));\n    registerValue |=  hdma->Init.Direction           |\n            hdma->Init.PeriphInc           | hdma->Init.MemInc           |\n            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |\n            hdma->Init.Mode                | hdma->Init.Priority;\n    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\n    {\n      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;\n    }\n#if (STM32H7_DEV_ID == 0x450UL)\n    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)\n    {\n#endif \n      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)\n      {\n        registerValue |= DMA_SxCR_TRBUFF;\n      }\n#if (STM32H7_DEV_ID == 0x450UL)\n    }\n#endif \n    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;\n    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;\n    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);\n    registerValue |= hdma->Init.FIFOMode;\n    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\n    {\n      registerValue |= hdma->Init.FIFOThreshold;\n      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)\n      {\n        if (DMA_CheckFifoParam(hdma) != HAL_OK)\n        {\n          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\n          hdma->State = HAL_DMA_STATE_READY;\n          return HAL_ERROR;\n        }\n      }\n    }\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;\n    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\n    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\n  }\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) \n  {\n    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)\n    {\n      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));\n    }\n    hdma->State = HAL_DMA_STATE_BUSY;\n    __HAL_UNLOCK(hdma);\n    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;\n    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \\\n                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \\\n                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \\\n                                  BDMA_CCR_CT));\n    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |\n                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |\n                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |\n                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |\n                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |\n                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |\n                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;\n    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;\n    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\n    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\n  }\n  else\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\n    hdma->State     = HAL_DMA_STATE_ERROR;\n    return HAL_ERROR;\n  }\n  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n  {\n    DMA_CalcDMAMUXChannelBaseAndMask(hdma);\n    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n    {\n      hdma->Init.Request = DMA_REQUEST_MEM2MEM;\n    }\n    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);\n    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\n    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))\n    {\n      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);\n      hdma->DMAmuxRequestGen->RGCR = 0U;\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\n    }\n    else\n    {\n      hdma->DMAmuxRequestGen = 0U;\n      hdma->DMAmuxRequestGenStatus = 0U;\n      hdma->DMAmuxRequestGenStatusMask = 0U;\n    }\n  }\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n  hdma->State = HAL_DMA_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)\n{\n  DMA_Base_Registers *regs_dma;\n  BDMA_Base_Registers *regs_bdma;\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_DMA_DISABLE(hdma);\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n  {\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;\n    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\n    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\n  }\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) \n  {\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;\n    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\n    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n#if defined (BDMA1) \n  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n#endif \n  {\n    DMA_CalcDMAMUXChannelBaseAndMask(hdma);\n    if(hdma->DMAmuxChannel != 0U)\n    {\n      hdma->DMAmuxChannel->CCR = 0U;\n      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\n    }\n    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))\n    {\n      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);\n      hdma->DMAmuxRequestGen->RGCR = 0U;\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\n    }\n    hdma->DMAmuxRequestGen = 0U;\n    hdma->DMAmuxRequestGenStatus = 0U;\n    hdma->DMAmuxRequestGenStatusMask = 0U;\n  }\n  hdma->XferCpltCallback       = NULL;\n  hdma->XferHalfCpltCallback   = NULL;\n  hdma->XferM1CpltCallback     = NULL;\n  hdma->XferM1HalfCpltCallback = NULL;\n  hdma->XferErrorCallback      = NULL;\n  hdma->XferAbortCallback      = NULL;\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n  hdma->State = HAL_DMA_STATE_RESET;\n  __HAL_UNLOCK(hdma);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hdma);\n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    hdma->State = HAL_DMA_STATE_BUSY;\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n    __HAL_DMA_DISABLE(hdma);\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\n    __HAL_DMA_ENABLE(hdma);\n  }\n  else\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\n    __HAL_UNLOCK(hdma);\n    status = HAL_ERROR;\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hdma);\n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    hdma->State = HAL_DMA_STATE_BUSY;\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n    __HAL_DMA_DISABLE(hdma);\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));\n      if(hdma->XferHalfCpltCallback != NULL)\n      {\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;\n      }\n    }\n    else \n    {\n      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));\n      if(hdma->XferHalfCpltCallback != NULL)\n      {\n        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;\n      }\n    }\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n    {\n      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)\n      {\n        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;\n      }\n      if(hdma->DMAmuxRequestGen != 0U)\n      {\n        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;\n      }\n    }\n    __HAL_DMA_ENABLE(hdma);\n  }\n  else\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\n    __HAL_UNLOCK(hdma);\n    status = HAL_ERROR;\n  }\n  return status;\n}\nHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)\n{\n  DMA_Base_Registers *regs_dma;\n  BDMA_Base_Registers *regs_bdma;\n  const __IO uint32_t *enableRegister;\n  uint32_t tickstart = HAL_GetTick();\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if(hdma->State != HAL_DMA_STATE_BUSY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\n    __HAL_UNLOCK(hdma);\n    return HAL_ERROR;\n  }\n  else\n  {\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);\n      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));\n    }\n    else \n    {\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);\n      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));\n    }\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n    {\n      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;\n    }\n    __HAL_DMA_DISABLE(hdma);\n    while(((*enableRegister) & DMA_SxCR_EN) != 0U)\n    {\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\n      {\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\n        hdma->State = HAL_DMA_STATE_ERROR;\n        __HAL_UNLOCK(hdma);\n        return HAL_ERROR;\n      }\n    }\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\n    }\n    else \n    {\n      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\n      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\n    }\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n    {\n      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\n      if(hdma->DMAmuxRequestGen != 0U)\n      {\n        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;\n        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\n      }\n    }\n    hdma->State = HAL_DMA_STATE_READY;\n    __HAL_UNLOCK(hdma);\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\n{\n  BDMA_Base_Registers *regs_bdma;\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if(hdma->State != HAL_DMA_STATE_BUSY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\n    return HAL_ERROR;\n  }\n  else\n  {\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      hdma->State = HAL_DMA_STATE_ABORT;\n      __HAL_DMA_DISABLE(hdma);\n    }\n    else \n    {\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);\n      __HAL_DMA_DISABLE(hdma);\n      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n      {\n        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;\n        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\n        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\n        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\n        if(hdma->DMAmuxRequestGen != 0U)\n        {\n          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;\n          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\n        }\n      }\n      hdma->State = HAL_DMA_STATE_READY;\n      __HAL_UNLOCK(hdma);\n      if(hdma->XferAbortCallback != NULL)\n      {\n        hdma->XferAbortCallback(hdma);\n      }\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t cpltlevel_mask;\n  uint32_t tickstart = HAL_GetTick();\n  __IO uint32_t *isr_reg;\n  __IO uint32_t *ifcr_reg;\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  if(HAL_DMA_STATE_BUSY != hdma->State)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\n    __HAL_UNLOCK(hdma);\n    return HAL_ERROR;\n  }\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n  {\n    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)\n    {\n      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n      return HAL_ERROR;\n    }\n    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\n    {\n      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);\n    }\n    else\n    {\n      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);\n    }\n    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);\n    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);\n  }\n  else \n  {\n    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)\n    {\n      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n      return HAL_ERROR;\n    }\n    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\n    {\n      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);\n    }\n    else\n    {\n      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);\n    }\n    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);\n    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);\n  }\n  while(((*isr_reg) & cpltlevel_mask) == 0U)\n  {\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n      {\n        hdma->ErrorCode |= HAL_DMA_ERROR_FE;\n        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);\n      }\n      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n      {\n        hdma->ErrorCode |= HAL_DMA_ERROR_DME;\n        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);\n      }\n      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n      {\n        hdma->ErrorCode |= HAL_DMA_ERROR_TE;\n        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);\n        hdma->State = HAL_DMA_STATE_READY;\n        __HAL_UNLOCK(hdma);\n        return HAL_ERROR;\n      }\n    }\n    else \n    {\n      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)\n      {\n        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));\n        hdma->ErrorCode = HAL_DMA_ERROR_TE;\n        hdma->State = HAL_DMA_STATE_READY;\n        __HAL_UNLOCK(hdma);\n        return HAL_ERROR;\n      }\n    }\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))\n      {\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\n        (void) HAL_DMA_Abort(hdma);\n        return HAL_ERROR;\n      }\n    }\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n    {\n      if(hdma->DMAmuxRequestGen != 0U)\n      {\n        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)\n        {\n          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\n          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;\n        }\n      }\n      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)\n      {\n        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\n        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;\n      }\n    }\n  }\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\n  {\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);\n    }\n    else \n    {\n      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));\n    }\n    hdma->State = HAL_DMA_STATE_READY;\n    __HAL_UNLOCK(hdma);\n  }\n  else \n  {\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n    {\n      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);\n    }\n    else \n    {\n      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));\n    }\n  }\n  return status;\n}\nvoid HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)\n{\n  uint32_t tmpisr_dma, tmpisr_bdma;\n  uint32_t ccr_reg;\n  __IO uint32_t count = 0U;\n  uint32_t timeout = SystemCoreClock / 9600U;\n  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\n  tmpisr_dma  = regs_dma->ISR;\n  tmpisr_bdma = regs_bdma->ISR;\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  \n  {\n    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n    {\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)\n      {\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);\n        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);\n        hdma->ErrorCode |= HAL_DMA_ERROR_TE;\n      }\n    }\n    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n    {\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)\n      {\n        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);\n        hdma->ErrorCode |= HAL_DMA_ERROR_FE;\n      }\n    }\n    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n    {\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)\n      {\n        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);\n        hdma->ErrorCode |= HAL_DMA_ERROR_DME;\n      }\n    }\n    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n    {\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)\n      {\n        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);\n        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)\n        {\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)\n          {\n            if(hdma->XferHalfCpltCallback != NULL)\n            {\n              hdma->XferHalfCpltCallback(hdma);\n            }\n          }\n          else\n          {\n            if(hdma->XferM1HalfCpltCallback != NULL)\n            {\n              hdma->XferM1HalfCpltCallback(hdma);\n            }\n          }\n        }\n        else\n        {\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)\n          {\n            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);\n          }\n          if(hdma->XferHalfCpltCallback != NULL)\n          {\n            hdma->XferHalfCpltCallback(hdma);\n          }\n        }\n      }\n    }\n    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\n    {\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)\n      {\n        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);\n        if(HAL_DMA_STATE_ABORT == hdma->State)\n        {\n          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\n          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);\n          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\n          {\n            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);\n          }\n          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\n          hdma->State = HAL_DMA_STATE_READY;\n          __HAL_UNLOCK(hdma);\n          if(hdma->XferAbortCallback != NULL)\n          {\n            hdma->XferAbortCallback(hdma);\n          }\n          return;\n        }\n        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)\n        {\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)\n          {\n            if(hdma->XferM1CpltCallback != NULL)\n            {\n              hdma->XferM1CpltCallback(hdma);\n            }\n          }\n          else\n          {\n            if(hdma->XferCpltCallback != NULL)\n            {\n              hdma->XferCpltCallback(hdma);\n            }\n          }\n        }\n        else\n        {\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)\n          {\n            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);\n            hdma->State = HAL_DMA_STATE_READY;\n            __HAL_UNLOCK(hdma);\n          }\n          if(hdma->XferCpltCallback != NULL)\n          {\n            hdma->XferCpltCallback(hdma);\n          }\n        }\n      }\n    }\n    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\n    {\n      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)\n      {\n        hdma->State = HAL_DMA_STATE_ABORT;\n        __HAL_DMA_DISABLE(hdma);\n        do\n        {\n          if (++count > timeout)\n          {\n            break;\n          }\n        }\n        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);\n        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)\n        {\n          hdma->State = HAL_DMA_STATE_ERROR;\n        }\n        else\n        {\n          hdma->State = HAL_DMA_STATE_READY;\n        }\n        __HAL_UNLOCK(hdma);\n      }\n      if(hdma->XferErrorCallback != NULL)\n      {\n        hdma->XferErrorCallback(hdma);\n      }\n    }\n  }\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  \n  {\n    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);\n    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))\n    {\n      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));\n      if((ccr_reg & BDMA_CCR_DBM) != 0U)\n      {\n        if((ccr_reg & BDMA_CCR_CT) == 0U)\n        {\n          if(hdma->XferM1HalfCpltCallback != NULL)\n          {\n            hdma->XferM1HalfCpltCallback(hdma);\n          }\n        }\n        else\n        {\n          if(hdma->XferHalfCpltCallback != NULL)\n          {\n            hdma->XferHalfCpltCallback(hdma);\n          }\n        }\n      }\n      else\n      {\n        if((ccr_reg & BDMA_CCR_CIRC) == 0U)\n        {\n          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);\n        }\n       if(hdma->XferHalfCpltCallback != NULL)\n        {\n          hdma->XferHalfCpltCallback(hdma);\n        }\n      }\n    }\n    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))\n    {\n      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);\n      if((ccr_reg & BDMA_CCR_DBM) != 0U)\n      {\n        if((ccr_reg & BDMA_CCR_CT) == 0U)\n        {\n          if(hdma->XferM1CpltCallback != NULL)\n          {\n            hdma->XferM1CpltCallback(hdma);\n          }\n        }\n        else\n        {\n          if(hdma->XferCpltCallback != NULL)\n          {\n            hdma->XferCpltCallback(hdma);\n          }\n        }\n      }\n      else\n      {\n        if((ccr_reg & BDMA_CCR_CIRC) == 0U)\n        {\n          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);\n          hdma->State = HAL_DMA_STATE_READY;\n          __HAL_UNLOCK(hdma);\n        }\n        if(hdma->XferCpltCallback != NULL)\n        {\n          hdma->XferCpltCallback(hdma);\n        }\n      }\n    }\n    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))\n    {\n      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));\n      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);\n      hdma->ErrorCode = HAL_DMA_ERROR_TE;\n      hdma->State = HAL_DMA_STATE_READY;\n      __HAL_UNLOCK(hdma);\n      if (hdma->XferErrorCallback != NULL)\n      {\n        hdma->XferErrorCallback(hdma);\n      }\n    }\n    else\n    {\n    }\n  }\n  else\n  {\n  }\n}\nHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hdma);\n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    switch (CallbackID)\n    {\n    case  HAL_DMA_XFER_CPLT_CB_ID:\n      hdma->XferCpltCallback = pCallback;\n      break;\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\n      hdma->XferHalfCpltCallback = pCallback;\n      break;\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\n      hdma->XferM1CpltCallback = pCallback;\n      break;\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\n      hdma->XferM1HalfCpltCallback = pCallback;\n      break;\n    case  HAL_DMA_XFER_ERROR_CB_ID:\n      hdma->XferErrorCallback = pCallback;\n      break;\n    case  HAL_DMA_XFER_ABORT_CB_ID:\n      hdma->XferAbortCallback = pCallback;\n      break;\n    default:\n      status =  HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    status =  HAL_ERROR;\n  }\n  __HAL_UNLOCK(hdma);\n  return status;\n}\nHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if(hdma == NULL)\n  {\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hdma);\n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    switch (CallbackID)\n    {\n    case  HAL_DMA_XFER_CPLT_CB_ID:\n      hdma->XferCpltCallback = NULL;\n      break;\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\n      hdma->XferHalfCpltCallback = NULL;\n      break;\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\n      hdma->XferM1CpltCallback = NULL;\n      break;\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\n      hdma->XferM1HalfCpltCallback = NULL;\n      break;\n    case  HAL_DMA_XFER_ERROR_CB_ID:\n      hdma->XferErrorCallback = NULL;\n      break;\n    case  HAL_DMA_XFER_ABORT_CB_ID:\n      hdma->XferAbortCallback = NULL;\n      break;\n    case   HAL_DMA_XFER_ALL_CB_ID:\n      hdma->XferCpltCallback = NULL;\n      hdma->XferHalfCpltCallback = NULL;\n      hdma->XferM1CpltCallback = NULL;\n      hdma->XferM1HalfCpltCallback = NULL;\n      hdma->XferErrorCallback = NULL;\n      hdma->XferAbortCallback = NULL;\n      break;\n    default:\n      status = HAL_ERROR;\n      break;\n    }\n  }\n  else\n  {\n    status = HAL_ERROR;\n  }\n  __HAL_UNLOCK(hdma);\n  return status;\n}\nHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)\n{\n  return hdma->State;\n}\nuint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)\n{\n  return hdma->ErrorCode;\n}\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{\n  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;\n  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\n  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) \n  {\n    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\n    if(hdma->DMAmuxRequestGen != 0U)\n    {\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\n    }\n  }\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n  {\n    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\n    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);\n    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;\n    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\n    {\n      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;\n      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;\n    }\n    else\n    {\n      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;\n      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;\n    }\n  }\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) \n  {\n    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;\n    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\n    {\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;\n    }\n    else\n    {\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;\n    }\n  }\n  else\n  {\n  }\n}\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)\n{\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) \n  {\n    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;\n    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};\n    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];\n    if (stream_number > 3U)\n    {\n      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);\n    }\n    else\n    {\n      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));\n    }\n  }\n  else \n  {\n    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));\n  }\n  return hdma->StreamBaseAddress;\n}\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)\n  {\n    switch (hdma->Init.FIFOThreshold)\n    {\n      case DMA_FIFO_THRESHOLD_1QUARTERFULL:\n      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\n        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\n        {\n          status = HAL_ERROR;\n        }\n        break;\n      case DMA_FIFO_THRESHOLD_HALFFULL:\n        if (hdma->Init.MemBurst == DMA_MBURST_INC16)\n        {\n          status = HAL_ERROR;\n        }\n        break;\n      case DMA_FIFO_THRESHOLD_FULL:\n        break;\n      default:\n        break;\n    }\n  }\n  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\n  {\n    switch (hdma->Init.FIFOThreshold)\n    {\n      case DMA_FIFO_THRESHOLD_1QUARTERFULL:\n      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\n        status = HAL_ERROR;\n        break;\n      case DMA_FIFO_THRESHOLD_HALFFULL:\n        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\n        {\n          status = HAL_ERROR;\n        }\n        break;\n      case DMA_FIFO_THRESHOLD_FULL:\n        if (hdma->Init.MemBurst == DMA_MBURST_INC16)\n        {\n          status = HAL_ERROR;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  else\n  {\n    switch (hdma->Init.FIFOThreshold)\n    {\n      case DMA_FIFO_THRESHOLD_1QUARTERFULL:\n      case DMA_FIFO_THRESHOLD_HALFFULL:\n      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\n        status = HAL_ERROR;\n        break;\n      case DMA_FIFO_THRESHOLD_FULL:\n        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\n        {\n          status = HAL_ERROR;\n        }\n    break;\n      default:\n        break;\n    }\n  }\n  return status;\n}\nstatic void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)\n{\n  uint32_t stream_number;\n  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);\n  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)\n  {\n    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;\n    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));\n    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;\n    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);\n  }\n  else\n  {\n    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;\n    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \\\n       (stream_baseaddress >= ((uint32_t)DMA2_Stream0)))\n    {\n      stream_number += 8U;\n    }\n    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));\n    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;\n    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);\n  }\n}\nstatic void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)\n{\n  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;\n  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))\n  {\n    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)\n    {\n      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));\n      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;\n    }\n    else\n    {\n      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));\n      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;\n    }\n    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);\n  }\n}\n#endif '"
"'Prompt: Please provide a code snippet that involves setting up a video capture configuration using the AVCAP library. In this scenario, the configuration should be specified to capture video data using the XCB backend. Additionally, include a function named `on_audio` which takes a pointer to an `avcap_ctx` and an `audio_frame` structure. The function should print information about the audio frame such as frame ID, number of frames, total size, and timestamp in milliseconds. Finally, write the audio data to a file using the `file_write` function.","//...\nstruct avcap_config conf = {\n            .type = AVCAP_TYPE_VIDEO,\n            .backend = AVCAP_BACKEND_XCB,\n    };\nstatic struct file *fp;\nstatic int on_audio(struct avcap_ctx *c, struct audio_frame *audio)\n{\n    printf(""audio_frame[%"" PRIu64 ""] cnt=%d size=%"" PRIu64 "", ts=%"" PRIu64 "" ms\\n"",\n           audio->frame_id, audio->frames, audio->total_size, audio->timestamp/1000000);\n    file_write(fp, audio->data[0], audio->total_size);\n    return 0;\n}\n//...'"
"('Scenario: You are testing a GMSK frame synchronization algorithm using specific parameters (k=2, m=5, bt=0.40) to ensure it is working correctly. You have a testbench function that creates a GMSK frame generator and a GMSK frame synchronizer with the given parameters, assembles a default frame, writes data to the buffer until a frame is complete, and then checks various statistics of the received frame. If the test is running in verbose mode, it prints out the frame synchronization details. To trigger this specific test with the parameters provided, you call the autotest function with k=2, m=5, and bt=0.40.","//...\nvoid testbench_gmskframesync(unsigned int _k, unsigned int _m, float _bt)\n{\n    gmskframegen  fg = gmskframegen_create_set (_k,_m,_bt);\n    gmskframesync fs = gmskframesync_create_set(_k,_m,_bt,NULL,NULL);\n    gmskframegen_assemble_default(fg, 80);\n    unsigned int  buf_len = 200;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = gmskframegen_write(fg, buf, buf_len);\n        gmskframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        gmskframesync_print(fs);\n    framedatastats_s stats = gmskframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received,  80);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n}\nvoid autotest_gmskframesync_k02_m05_bt40() { testbench_gmskframesync( 2, 5, 0.40f); }\n//...')
"
"'To receive the code provided as a response, you could have given the following prompt:. . ""Please provide code that includes functions to set, activate, deactivate, and handle events for various features of a Real-Time Clock (RTC) module. The code should include functions for setting time stamps, activating internal time stamps, setting and handling tamper events, setting and handling wake-up timer events, setting calibration output, activating and deactivating reference clock detection, enabling and disabling bypass shadow, and handling alarm B events. The code should also include error handling and timeout mechanisms.""","#ifdef HAL_RTC_MODULE_ENABLED\n#define TAMP_ALL (TAMP_CR1_TAMP1E | TAMP_CR1_TAMP2E | TAMP_CR1_TAMP3E)\nHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)\n{\n  uint32_t tmpreg;\n  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));\n  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));\n  UNUSED(RTC_TimeStampPin);\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));\n  tmpreg |= TimeStampEdge;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  hrtc->Instance->CR = (uint32_t)tmpreg;\n  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)\n{\n  uint32_t tmpreg;\n  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));\n  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));\n  UNUSED(RTC_TimeStampPin);\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));\n  tmpreg |= TimeStampEdge;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  hrtc->Instance->CR = (uint32_t)tmpreg;\n  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);\n  __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc, RTC_IT_TS);\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n  }\n  else\n  {\n    __HAL_RTC_TAMPER_TIMESTAMP_EXTID2_ENABLE_IT();\n  }\n#else \n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n#endif \n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)\n{\n  uint32_t tmpreg;\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);\n  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));\n  hrtc->Instance->CR = (uint32_t)tmpreg;\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetInternalTimeStamp(RTC_HandleTypeDef *hrtc)\n{\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  __HAL_RTC_INTERNAL_TIMESTAMP_ENABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTimeStamp(RTC_HandleTypeDef *hrtc)\n{\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  __HAL_RTC_INTERNAL_TIMESTAMP_DISABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp, RTC_DateTypeDef *sTimeStampDate, uint32_t Format)\n{\n  uint32_t tmptime;\n  uint32_t tmpdate;\n  assert_param(IS_RTC_FORMAT(Format));\n  tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);\n  tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);\n  sTimeStamp->Hours      = (uint8_t)((tmptime & (RTC_TSTR_HT  | RTC_TSTR_HU))  >> RTC_TSTR_HU_Pos);\n  sTimeStamp->Minutes    = (uint8_t)((tmptime & (RTC_TSTR_MNT | RTC_TSTR_MNU)) >> RTC_TSTR_MNU_Pos);\n  sTimeStamp->Seconds    = (uint8_t)((tmptime & (RTC_TSTR_ST  | RTC_TSTR_SU))  >> RTC_TSTR_SU_Pos);\n  sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TSTR_PM))                 >> RTC_TSTR_PM_Pos);\n  sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;\n  sTimeStampDate->Year    = 0U;\n  sTimeStampDate->Month   = (uint8_t)((tmpdate & (RTC_TSDR_MT | RTC_TSDR_MU)) >> RTC_TSDR_MU_Pos);\n  sTimeStampDate->Date    = (uint8_t)((tmpdate & (RTC_TSDR_DT | RTC_TSDR_DU)) >> RTC_TSDR_DU_Pos);\n  sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_TSDR_WDU))              >> RTC_TSDR_WDU_Pos);\n  if (Format == RTC_FORMAT_BIN)\n  {\n    sTimeStamp->Hours   = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);\n    sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);\n    sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);\n    sTimeStampDate->Month   = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);\n    sTimeStampDate->Date    = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);\n    sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);\n  }\n  __HAL_RTC_INTERNAL_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_ITSF);\n  __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);\n  return HAL_OK;\n}\n#if defined(TAMP)\nHAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef * hrtc, RTC_TamperTypeDef * sTamper)\n{\n  uint32_t tmpreg;\n  TAMP_TypeDef *tamp = (TAMP_TypeDef *)((uint32_t)hrtc->Instance + TAMP_OFFSET);\n  assert_param(IS_RTC_TAMPER(sTamper->Tamper));\n  assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));\n  assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));\n  assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));\n  assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));\n  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));\n  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));\n  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));\n  assert_param(IS_RTC_TAMPER_FILTER_CONFIG_CORRECT(sTamper->Filter, sTamper->Trigger));\n  tmpreg = tamp->CR2;\n  tmpreg &= ~((sTamper->Tamper << TAMP_CR2_TAMP1TRG_Pos) | (sTamper->Tamper << TAMP_CR2_TAMP1MSK_Pos) | (sTamper->Tamper << TAMP_CR2_TAMP1NOERASE_Pos));\n  if ((sTamper->Trigger == RTC_TAMPERTRIGGER_HIGHLEVEL) || (sTamper->Trigger == RTC_TAMPERTRIGGER_FALLINGEDGE))\n  {\n    tmpreg |= (sTamper->Tamper << TAMP_CR2_TAMP1TRG_Pos);\n  }\n  if (sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)\n  {\n    tmpreg |= (sTamper->Tamper << TAMP_CR2_TAMP1MSK_Pos);\n  }\n  if (sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)\n  {\n    tmpreg |= (sTamper->Tamper << TAMP_CR2_TAMP1NOERASE_Pos);\n  }\n  tamp->CR2 = tmpreg;\n  tamp->FLTCR = (sTamper->Filter)            | (sTamper->SamplingFrequency) | \\\n                (sTamper->PrechargeDuration) | (sTamper->TamperPullUp);\n  if ((hrtc->Instance->CR & RTC_CR_TAMPTS) != (sTamper->TimeStampOnTamperDetection))\n  {\n    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n    tmpreg = (hrtc->Instance->CR & ~RTC_CR_TAMPTS);\n    hrtc->Instance->CR = (tmpreg | (sTamper->TimeStampOnTamperDetection));\n    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  }\n  tamp->CR1 |= (sTamper->Tamper);\n  return HAL_OK;\n}\n#else\nHAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef * hrtc, RTC_TamperTypeDef * sTamper)\n{\n  uint32_t tmpreg;\n  assert_param(IS_RTC_TAMPER(sTamper->Tamper));\n  assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));\n  assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));\n  assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));\n  assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));\n  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));\n  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));\n  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));\n  assert_param(IS_RTC_TAMPER_FILTER_CONFIG_CORRECT(sTamper->Filter, sTamper->Trigger));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  tmpreg = hrtc->Instance->TAMPCR;\n  tmpreg |= (sTamper->Tamper);\n  if ((sTamper->Trigger == RTC_TAMPERTRIGGER_HIGHLEVEL) || (sTamper->Trigger == RTC_TAMPERTRIGGER_FALLINGEDGE))\n  {\n    tmpreg |= (uint32_t)(sTamper->Tamper << 1U);\n  }\n  else\n  {\n    tmpreg &= (uint32_t)~(sTamper->Tamper << 1U);\n  }\n  if (sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP1NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP2NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP3NOERASE);\n    }\n  }\n  else\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP1NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP2NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP3NOERASE);\n    }\n  }\n  if (sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP1MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP2MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP3MF);\n    }\n  }\n  else\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP1MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP2MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP3MF);\n    }\n  }\n  tmpreg &= ~(RTC_TAMPERFILTER_MASK            | RTC_TAMPERSAMPLINGFREQ_RTCCLK_MASK | \\\n              RTC_TAMPERPRECHARGEDURATION_MASK | RTC_TAMPER_PULLUP_MASK             | \\\n              RTC_TIMESTAMPONTAMPERDETECTION_MASK);\n  tmpreg |= ((uint32_t)sTamper->Filter            | \\\n             (uint32_t)sTamper->SamplingFrequency | \\\n             (uint32_t)sTamper->PrechargeDuration | \\\n             (uint32_t)sTamper->TamperPullUp      | \\\n             (uint32_t)sTamper->TimeStampOnTamperDetection);\n  hrtc->Instance->TAMPCR = tmpreg;\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\n#endif \n#if defined(TAMP)\nHAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef * hrtc, RTC_TamperTypeDef * sTamper)\n{\n  uint32_t tmpreg;\n  TAMP_TypeDef *tamp = (TAMP_TypeDef *)((uint32_t)hrtc->Instance + TAMP_OFFSET);\n  assert_param(IS_RTC_TAMPER(sTamper->Tamper));\n  assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));\n  assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));\n  assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));\n  assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));\n  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));\n  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));\n  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));\n  assert_param(IS_RTC_TAMPER_FILTER_CONFIG_CORRECT(sTamper->Filter, sTamper->Trigger));\n  tmpreg = tamp->CR2;\n  tmpreg &= ~((sTamper->Tamper << TAMP_CR2_TAMP1TRG_Pos) | (sTamper->Tamper << TAMP_CR2_TAMP1MSK_Pos) | (sTamper->Tamper << TAMP_CR2_TAMP1NOERASE_Pos));\n  if ((sTamper->Trigger == RTC_TAMPERTRIGGER_HIGHLEVEL) || (sTamper->Trigger == RTC_TAMPERTRIGGER_FALLINGEDGE))\n  {\n    tmpreg |= (sTamper->Tamper << TAMP_CR2_TAMP1TRG_Pos);\n  }\n  if (sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)\n  {\n    tmpreg |= (sTamper->Tamper << TAMP_CR2_TAMP1MSK_Pos);\n  }\n  if (sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)\n  {\n    tmpreg |= (sTamper->Tamper << TAMP_CR2_TAMP1NOERASE_Pos);\n  }\n  tamp->CR2 = tmpreg;\n  tamp->FLTCR = (sTamper->Filter)            | (sTamper->SamplingFrequency) | \\\n                (sTamper->PrechargeDuration) | (sTamper->TamperPullUp);\n  if ((hrtc->Instance->CR & RTC_CR_TAMPTS) != (sTamper->TimeStampOnTamperDetection))\n  {\n    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n    tmpreg = (hrtc->Instance->CR & ~RTC_CR_TAMPTS);\n    hrtc->Instance->CR = (tmpreg | (sTamper->TimeStampOnTamperDetection));\n    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  }\n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_FALLING_EDGE();\n  tamp->IER |= sTamper->Tamper;\n  tamp->CR1 |= sTamper->Tamper;\n  return HAL_OK;\n}\n#else\nHAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef * hrtc, RTC_TamperTypeDef * sTamper)\n{\n  uint32_t tmpreg;\n  assert_param(IS_RTC_TAMPER(sTamper->Tamper));\n  assert_param(IS_RTC_TAMPER_INTERRUPT(sTamper->Interrupt));\n  assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));\n  assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));\n  assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));\n  assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));\n  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));\n  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));\n  assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));\n  assert_param(IS_RTC_TAMPER_FILTER_CONFIG_CORRECT(sTamper->Filter, sTamper->Trigger));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  tmpreg = hrtc->Instance->TAMPCR;\n  tmpreg |= (sTamper->Tamper);\n  if ((sTamper->Trigger == RTC_TAMPERTRIGGER_HIGHLEVEL) || (sTamper->Trigger == RTC_TAMPERTRIGGER_FALLINGEDGE))\n  {\n    tmpreg |= (uint32_t)(sTamper->Tamper << 1U);\n  }\n  else\n  {\n    tmpreg &= (uint32_t)~(sTamper->Tamper << 1U);\n  }\n  if (sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP1NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP2NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP3NOERASE);\n    }\n  }\n  else\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP1NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP2NOERASE);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP3NOERASE);\n    }\n  }\n  if (sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP1MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP2MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg |= (uint32_t)(RTC_TAMPCR_TAMP3MF);\n    }\n  }\n  else\n  {\n    if ((sTamper->Tamper & RTC_TAMPER_1) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP1MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_2) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP2MF);\n    }\n    if ((sTamper->Tamper & RTC_TAMPER_3) != 0U)\n    {\n      tmpreg &= (uint32_t)~(RTC_TAMPCR_TAMP3MF);\n    }\n  }\n  tmpreg &= ~(RTC_TAMPERFILTER_MASK            | RTC_TAMPERSAMPLINGFREQ_RTCCLK_MASK | \\\n              RTC_TAMPERPRECHARGEDURATION_MASK | RTC_TAMPER_PULLUP_MASK             | \\\n              RTC_TIMESTAMPONTAMPERDETECTION_MASK);\n  tmpreg |= ((uint32_t)sTamper->Filter            | \\\n             (uint32_t)sTamper->SamplingFrequency | \\\n             (uint32_t)sTamper->PrechargeDuration | \\\n             (uint32_t)sTamper->TamperPullUp      | \\\n             (uint32_t)sTamper->TimeStampOnTamperDetection);\n  tmpreg |= (uint32_t)sTamper->Interrupt;\n  hrtc->Instance->TAMPCR = tmpreg;\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n  }\n  else\n  {\n    __HAL_RTC_TAMPER_TIMESTAMP_EXTID2_ENABLE_IT();\n  }\n#else \n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n#endif \n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\n#endif \n#if defined(TAMP)\nHAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef * hrtc, uint32_t Tamper)\n{\n  TAMP_TypeDef *tamp = (TAMP_TypeDef *)((uint32_t)hrtc->Instance + TAMP_OFFSET);\n  assert_param(IS_RTC_TAMPER(Tamper));\n  tamp->CR1 &= ~Tamper;\n  tamp->IER &= ~Tamper;\n  tamp->SCR = Tamper;\n  tamp->CR2 &= ~((Tamper << TAMP_CR2_TAMP1TRG_Pos) | (Tamper << TAMP_CR2_TAMP1MSK_Pos) | (Tamper << TAMP_CR2_TAMP1NOERASE_Pos));\n  return HAL_OK;\n}\n#else\nHAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef * hrtc, uint32_t Tamper)\n{\n  assert_param(IS_RTC_TAMPER(Tamper));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  hrtc->Instance->TAMPCR &= ((uint32_t)~Tamper);\n  if ((Tamper & RTC_TAMPER_1) != 0U)\n  {\n    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP1));\n  }\n  if ((Tamper & RTC_TAMPER_2) != 0U)\n  {\n    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP2));\n  }\n  if ((Tamper & RTC_TAMPER_3) != 0U)\n  {\n    hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP3));\n  }\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\n#endif \n#if defined(TAMP)\nHAL_StatusTypeDef HAL_RTCEx_SetInternalTamper(RTC_HandleTypeDef *hrtc, RTC_InternalTamperTypeDef *sIntTamper)\n{\n  assert_param(IS_RTC_INTERNAL_TAMPER(sIntTamper->IntTamper));\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sIntTamper->TimeStampOnTamperDetection));\n  if (READ_BIT(RTC->CR, RTC_CR_TAMPTS) != sIntTamper->TimeStampOnTamperDetection)\n  {\n    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n    MODIFY_REG(RTC->CR, RTC_CR_TAMPTS, sIntTamper->TimeStampOnTamperDetection);\n    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  }\n  SET_BIT(TAMP->CR1, sIntTamper->IntTamper);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetInternalTamper_IT(RTC_HandleTypeDef *hrtc, RTC_InternalTamperTypeDef *sIntTamper)\n{\n  assert_param(IS_RTC_INTERNAL_TAMPER(sIntTamper->IntTamper));\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sIntTamper->TimeStampOnTamperDetection));\n  if (READ_BIT(RTC->CR, RTC_CR_TAMPTS) != sIntTamper->TimeStampOnTamperDetection)\n  {\n    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n    MODIFY_REG(RTC->CR, RTC_CR_TAMPTS, sIntTamper->TimeStampOnTamperDetection);\n    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  }\n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_FALLING_EDGE();\n  SET_BIT(TAMP->IER, sIntTamper->IntTamper);\n  SET_BIT(TAMP->CR1, sIntTamper->IntTamper);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateInternalTamper(RTC_HandleTypeDef *hrtc, uint32_t IntTamper)\n{\n  UNUSED(hrtc);\n  assert_param(IS_RTC_INTERNAL_TAMPER(IntTamper));\n  CLEAR_BIT(TAMP->CR1, IntTamper);\n  CLEAR_BIT(TAMP->IER, IntTamper);\n  WRITE_REG(TAMP->SCR, IntTamper);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetActiveTampers(RTC_HandleTypeDef *hrtc, RTC_ActiveTampersTypeDef *sAllTamper)\n{\n  uint32_t IER, CR1, CR2, ATCR1, CR, i, tickstart;\n#ifdef  USE_FULL_ASSERT\n  for (i = 0; i < RTC_TAMP_NB; i++)\n  {\n    assert_param(IS_RTC_TAMPER_ERASE_MODE(sAllTamper->TampInput[i].NoErase));\n    assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sAllTamper->TampInput[i].MaskFlag));\n    assert_param(!((sAllTamper->TampInput[i].MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE) && (i > RTC_TAMPER_3)));\n  }\n  assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sAllTamper->TimeStampOnTamperDetection));\n#endif \n  if (READ_BIT(TAMP->ATOR, TAMP_ATOR_INITS) != 0U)\n  {\n    if (HAL_RTCEx_DeactivateActiveTampers(hrtc) != HAL_OK)\n    {\n      return HAL_ERROR;\n    }\n  }\n  CR = READ_REG(RTC->CR);\n  if ((CR & RTC_CR_TAMPTS) != (sAllTamper->TimeStampOnTamperDetection))\n  {\n    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n    MODIFY_REG(RTC->CR, RTC_CR_TAMPTS, sAllTamper->TimeStampOnTamperDetection);\n    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  }\n  CR1 = READ_REG(TAMP->CR1);\n  CR2 = READ_REG(TAMP->CR2);\n  IER = READ_REG(TAMP->IER);\n  ATCR1 = (sAllTamper->ActiveFilter | (sAllTamper->ActiveOutputChangePeriod << TAMP_ATCR1_ATPER_Pos) | sAllTamper->ActiveAsyncPrescaler);\n  for (i = 0; i < RTC_TAMP_NB; i++)\n  {\n    if (sAllTamper->TampInput[i].Enable != RTC_ATAMP_DISABLE)\n    {\n      CR1 |= (TAMP_CR1_TAMP1E << i);\n      ATCR1 |= (TAMP_ATCR1_TAMP1AM << i);\n      if (sAllTamper->TampInput[i].Interrupt != RTC_ATAMP_INTERRUPT_DISABLE)\n      {\n        __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();\n        __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();\n        IER |= (TAMP_IER_TAMP1IE << i);\n      }\n      if (sAllTamper->TampInput[i].MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)\n      {\n        CR2 |= (TAMP_CR2_TAMP1MSK << i);\n      }\n      if (sAllTamper->TampInput[i].NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)\n      {\n        CR2 |= (TAMP_CR2_TAMP1NOERASE << i);\n      }\n      if (sAllTamper->TampInput[i].Output != i)\n      {\n        ATCR1 |= TAMP_ATCR1_ATOSHARE;\n        ATCR1 |= sAllTamper->TampInput[i].Output << ((2u * i) + TAMP_ATCR1_ATOSEL1_Pos);\n      }\n    }\n  }\n  WRITE_REG(TAMP->IER, IER);\n  WRITE_REG(TAMP->IER, IER);\n  WRITE_REG(TAMP->ATCR1, ATCR1);\n#if defined(TAMP_ATCR2_ATOSEL1)\n  WRITE_REG(TAMP->ATCR2, ATCR2);\n#endif \n  WRITE_REG(TAMP->CR2, CR2);\n  WRITE_REG(TAMP->CR1, CR1);\n  for (i = 0; i < RTC_ATAMP_SEED_NB_UINT32; i++)\n  {\n    WRITE_REG(TAMP->ATSEEDR, sAllTamper->Seed[i]);\n  }\n  tickstart = HAL_GetTick();\n  while (READ_BIT(TAMP->ATOR,  TAMP_ATOR_SEEDF) != 0u)\n  {\n    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n    {\n      hrtc->State = HAL_RTC_STATE_TIMEOUT;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetActiveSeed(RTC_HandleTypeDef *hrtc, uint32_t *pSeed)\n{\n  uint32_t i, tickstart;\n  if (READ_BIT(TAMP->ATOR,  TAMP_ATOR_INITS) == 0U)\n  {\n    return HAL_ERROR;\n  }\n  for (i = 0; i < RTC_ATAMP_SEED_NB_UINT32; i++)\n  {\n    WRITE_REG(TAMP->ATSEEDR, pSeed[i]);\n  }\n  tickstart = HAL_GetTick();\n  while (READ_BIT(TAMP->ATOR,  TAMP_ATOR_SEEDF) != 0U)\n  {\n    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n    {\n      hrtc->State = HAL_RTC_STATE_TIMEOUT;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateActiveTampers(RTC_HandleTypeDef *hrtc)\n{\n  uint32_t ATamp_mask = READ_BIT(TAMP->ATCR1, TAMP_ALL);\n  UNUSED(hrtc);\n  CLEAR_BIT(TAMP->CR1, ATamp_mask);\n  CLEAR_BIT(TAMP->CR2, (ATamp_mask | ((ATamp_mask & (TAMP_ATCR1_TAMP1AM | TAMP_ATCR1_TAMP2AM | TAMP_ATCR1_TAMP3AM)) << TAMP_CR2_TAMP1MSK_Pos)));\n  WRITE_REG(TAMP->SCR, ATamp_mask);\n  CLEAR_BIT(TAMP->IER, ATamp_mask);\n  CLEAR_BIT(TAMP->ATCR1, TAMP_ALL | TAMP_ATCR1_ATCKSEL | TAMP_ATCR1_ATPER | \\\n            TAMP_ATCR1_ATOSHARE | TAMP_ATCR1_FLTEN);\n#if defined(TAMP_ATCR2_ATOSEL1)\n  CLEAR_BIT(TAMP->ATCR2, TAMP_ATCR2_ATOSEL1 | TAMP_ATCR2_ATOSEL2 | TAMP_ATCR2_ATOSEL3 | TAMP_ATCR2_ATOSEL4 |\n            TAMP_ATCR2_ATOSEL5 | TAMP_ATCR2_ATOSEL6 | TAMP_ATCR2_ATOSEL7 | TAMP_ATCR2_ATOSEL8);\n#endif \n  return HAL_OK;\n}\n#endif \n#if defined(TAMP)\nvoid HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)\n{\n  TAMP_TypeDef *tamp = (TAMP_TypeDef *)((uint32_t)hrtc->Instance + TAMP_OFFSET);\n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();\n  if ((hrtc->Instance->MISR & RTC_MISR_TSMF) != 0u)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->TimeStampEventCallback(hrtc);\n#else\n    HAL_RTCEx_TimeStampEventCallback(hrtc);\n#endif \n    hrtc->Instance->SCR = RTC_SCR_CTSF;\n  }\n  uint32_t tmp = tamp->MISR;\n  tamp->SCR = tmp;\n  if ((tmp & RTC_TAMPER_1) == RTC_TAMPER_1)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->Tamper1EventCallback(hrtc);\n#else\n    HAL_RTCEx_Tamper1EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_TAMPER_2) == RTC_TAMPER_2)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->Tamper2EventCallback(hrtc);\n#else\n    HAL_RTCEx_Tamper2EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_TAMPER_3) == RTC_TAMPER_3)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->Tamper3EventCallback(hrtc);\n#else\n    HAL_RTCEx_Tamper3EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_1) == RTC_INT_TAMPER_1)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper1EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper1EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_2) == RTC_INT_TAMPER_2)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper2EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper2EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_3) == RTC_INT_TAMPER_3)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper3EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper3EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_4) == RTC_INT_TAMPER_4)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper4EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper4EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_5) == RTC_INT_TAMPER_5)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper5EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper5EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_6) == RTC_INT_TAMPER_6)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper6EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper6EventCallback(hrtc);\n#endif \n  }\n  if ((tmp & RTC_INT_TAMPER_8) == RTC_INT_TAMPER_8)\n  {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->InternalTamper8EventCallback(hrtc);\n#else\n    HAL_RTCEx_InternalTamper8EventCallback(hrtc);\n#endif \n  }\n  hrtc->State = HAL_RTC_STATE_READY;\n}\n#else\nvoid HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)\n{\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();\n  }\n  else\n  {\n    __HAL_RTC_TAMPER_TIMESTAMP_EXTID2_CLEAR_FLAG();\n  }\n#else \n  __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();\n#endif \n  if (__HAL_RTC_TIMESTAMP_GET_IT_SOURCE(hrtc, RTC_IT_TS) != 0U)\n  {\n    if (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) != 0U)\n    {\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n      hrtc->TimeStampEventCallback(hrtc);\n#else  \n      HAL_RTCEx_TimeStampEventCallback(hrtc);\n#endif \n      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);\n    }\n  }\n  if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP1) != 0U)\n  {\n    if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != 0U)\n    {\n      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n      hrtc->Tamper1EventCallback(hrtc);\n#else  \n      HAL_RTCEx_Tamper1EventCallback(hrtc);\n#endif \n    }\n  }\n  if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP2) != 0U)\n  {\n    if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) != 0U)\n    {\n      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n      hrtc->Tamper2EventCallback(hrtc);\n#else  \n      HAL_RTCEx_Tamper2EventCallback(hrtc);\n#endif \n    }\n  }\n  if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP3) != 0U)\n  {\n    if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) != 0U)\n    {\n      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n      hrtc->Tamper3EventCallback(hrtc);\n#else  \n      HAL_RTCEx_Tamper3EventCallback(hrtc);\n#endif \n    }\n  }\n  hrtc->State = HAL_RTC_STATE_READY;\n}\n#endif \n__weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef * hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef * hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef * hrtc)\n{\n  UNUSED(hrtc);\n}\n#if defined(TAMP)\n__weak void HAL_RTCEx_InternalTamper1EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_InternalTamper2EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_InternalTamper3EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_InternalTamper4EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_InternalTamper5EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_InternalTamper6EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n__weak void HAL_RTCEx_InternalTamper8EventCallback(RTC_HandleTypeDef *hrtc)\n{\n  UNUSED(hrtc);\n}\n#endif \nHAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)\n{\n  uint32_t tickstart = HAL_GetTick();\n  while (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == 0U)\n  {\n    if (__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != 0U)\n    {\n      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);\n      hrtc->State = HAL_RTC_STATE_ERROR;\n      return HAL_ERROR;\n    }\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  hrtc->State = HAL_RTC_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef * hrtc, uint32_t Timeout)\n{\n  uint32_t tickstart = HAL_GetTick();\n  while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) == 0U)\n  {\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);\n  hrtc->State = HAL_RTC_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef * hrtc, uint32_t Timeout)\n{\n  uint32_t tickstart = HAL_GetTick();\n  while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == 0U)\n  {\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);\n  hrtc->State = HAL_RTC_STATE_READY;\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef * hrtc, uint32_t Timeout)\n{\n  uint32_t tickstart = HAL_GetTick();\n  while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) == 0U)\n  {\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);\n  hrtc->State = HAL_RTC_STATE_READY;\n  return HAL_OK;\n}\n#if defined(TAMP)\nHAL_StatusTypeDef HAL_RTCEx_PollForInternalTamperEvent(RTC_HandleTypeDef *hrtc, uint32_t IntTamper, uint32_t Timeout)\n{\n  UNUSED(hrtc);\n  assert_param(IS_RTC_INTERNAL_TAMPER(IntTamper));\n  uint32_t tickstart = HAL_GetTick();\n  while (READ_BIT(TAMP->SR, IntTamper) != IntTamper)\n  {\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  WRITE_REG(TAMP->SCR, IntTamper);\n  return HAL_OK;\n}\n#endif \nHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)\n{\n  uint32_t tickstart;\n  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));\n  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  CLEAR_BIT(RTC->CR, RTC_CR_WUTE);\n#if defined(TAMP)\n  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)\n  {\n    tickstart = HAL_GetTick();\n    while (READ_BIT(hrtc->Instance->ICSR, RTC_FLAG_WUTWF) == 0U)\n#else\n  if (READ_BIT(RTC->ISR, RTC_ISR_INITF) == 0U)\n  {\n    tickstart = HAL_GetTick();\n    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)\n#endif \n    {\n      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n      {\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        __HAL_UNLOCK(hrtc);\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  uint32_t CR_tmp = hrtc->Instance->CR;\n  CR_tmp &= (uint32_t)~RTC_CR_WUCKSEL;\n  CR_tmp |= (uint32_t)WakeUpClock;\n  hrtc->Instance->CR = CR_tmp;\n  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;\n  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)\n{\n  uint32_t tickstart;\n  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));\n  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  CLEAR_BIT(RTC->CR, RTC_CR_WUTE);\n#if defined(TAMP)\n  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)\n  {\n    tickstart = HAL_GetTick();\n    while (READ_BIT(hrtc->Instance->ICSR, RTC_FLAG_WUTWF) == 0U)\n#else\n  if (READ_BIT(RTC->ISR, RTC_ISR_INITF) == 0U)\n  {\n    tickstart = HAL_GetTick();\n    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)\n#endif \n    {\n      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n      {\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        __HAL_UNLOCK(hrtc);\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;\n  {\n    uint32_t CR_tmp = hrtc->Instance->CR;\n    CR_tmp &= (uint32_t)~RTC_CR_WUCKSEL;\n    CR_tmp |= (uint32_t)WakeUpClock;\n    hrtc->Instance->CR = CR_tmp;\n  }\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();\n  }\n  else\n  {\n    __HAL_RTC_WAKEUPTIMER_EXTID2_ENABLE_IT();\n  }\n#else \n  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();\n#endif \n  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();\n  __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc, RTC_IT_WUT);\n  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)\n{\n  uint32_t tickstart;\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);\n  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc, RTC_IT_WUT);\n  tickstart = HAL_GetTick();\n#if defined(TAMP)\n  while (READ_BIT(hrtc->Instance->ICSR, RTC_FLAG_WUTWF) == 0U)\n#else\n  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)\n#endif \n  {\n    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n    {\n      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n      hrtc->State = HAL_RTC_STATE_TIMEOUT;\n      __HAL_UNLOCK(hrtc);\n      return HAL_TIMEOUT;\n    }\n  }\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nuint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)\n{\n  return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));\n}\nvoid HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)\n{\n#if defined(DUAL_CORE)\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();\n  }\n  else\n  {\n    __HAL_RTC_WAKEUPTIMER_EXTID2_CLEAR_FLAG();\n  }\n#else \n  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();\n#endif \n#if defined(TAMP)\n  if ((hrtc->Instance->MISR & RTC_MISR_WUTMF) != 0u)\n  {\n    hrtc->Instance->SCR = RTC_SCR_CWUTF;\n  #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->WakeUpTimerEventCallback(hrtc);\n  #else\n    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);\n  #endif \n  }\n#else\n  if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)\n  {\n    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);\n  #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    hrtc->WakeUpTimerEventCallback(hrtc);\n  #else\n    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);\n  #endif \n  }\n#endif \n  hrtc->State = HAL_RTC_STATE_READY;\n}\n__weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef * hrtc)\n{\n  UNUSED(hrtc);\n}\nHAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef * hrtc, uint32_t Timeout)\n{\n  uint32_t tickstart = HAL_GetTick();\n  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == 0U)\n  {\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);\n  hrtc->State = HAL_RTC_STATE_READY;\n  return HAL_OK;\n}\nvoid HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef * hrtc, uint32_t BackupRegister, uint32_t Data)\n{\n  uint32_t tmp;\n  assert_param(IS_RTC_BKP(BackupRegister));\n#if defined(TAMP)\n  tmp = (uint32_t) & (((TAMP_TypeDef *)((uint32_t)hrtc->Instance + TAMP_OFFSET))->BKP0R);\n#else\n  tmp = (uint32_t) & (hrtc->Instance->BKP0R);\n#endif \n  tmp += (BackupRegister * 4U);\n  *(__IO uint32_t *)tmp = (uint32_t)Data;\n}\nuint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef * hrtc, uint32_t BackupRegister)\n{\n  uint32_t tmp;\n  assert_param(IS_RTC_BKP(BackupRegister));\n#if defined(TAMP)\n  tmp = (uint32_t) & (((TAMP_TypeDef *)((uint32_t)hrtc->Instance + TAMP_OFFSET))->BKP0R);\n#else\n  tmp = (uint32_t) & (hrtc->Instance->BKP0R);\n#endif \n  tmp += (BackupRegister * 4U);\n  return (*(__IO uint32_t *)tmp);\n}\nHAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef * hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue)\n{\n  uint32_t tickstart;\n  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));\n  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));\n  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n#if defined(TAMP)\n  if ((hrtc->Instance->ICSR & RTC_ICSR_RECALPF) != 0U)\n  {\n    tickstart = HAL_GetTick();\n    while ((hrtc->Instance->ICSR & RTC_ICSR_RECALPF) != 0U)\n#else\n  if ((hrtc->Instance->ISR  & RTC_ISR_RECALPF)  != 0U)\n  {\n    tickstart = HAL_GetTick();\n    while ((hrtc->Instance->ISR  & RTC_ISR_RECALPF)  != 0U)\n#endif \n    {\n      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n      {\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        __HAL_UNLOCK(hrtc);\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  MODIFY_REG(hrtc->Instance->CALR, (RTC_CALR_CALP | RTC_CALR_CALW8 | RTC_CALR_CALW16 | RTC_CALR_CALM), (uint32_t)(SmoothCalibPeriod | SmoothCalibPlusPulses | SmoothCalibMinusPulsesValue));\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef * hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)\n{\n  uint32_t tickstart;\n  assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));\n  assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  tickstart = HAL_GetTick();\n#if defined(TAMP)\n  while ((hrtc->Instance->ICSR & RTC_ICSR_SHPF) != 0U)\n#else\n    while ((hrtc->Instance->ISR  & RTC_ISR_SHPF)  != 0U)\n#endif \n    {\n      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n      {\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        __HAL_UNLOCK(hrtc);\n        return HAL_TIMEOUT;\n      }\n    }\n  if ((hrtc->Instance->CR & RTC_CR_REFCKON) == 0U)\n  {\n    hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);\n    if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)\n    {\n      if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)\n      {\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n        hrtc->State = HAL_RTC_STATE_ERROR;\n        __HAL_UNLOCK(hrtc);\n        return HAL_ERROR;\n      }\n    }\n  }\n  else\n  {\n    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n    hrtc->State = HAL_RTC_STATE_ERROR;\n    __HAL_UNLOCK(hrtc);\n    return HAL_ERROR;\n  }\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef * hrtc, uint32_t CalibOutput)\n{\n  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;\n  hrtc->Instance->CR |= (uint32_t)CalibOutput;\n  __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef * hrtc)\n{\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef * hrtc)\n{\n  HAL_StatusTypeDef status;\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  status = RTC_EnterInitMode(hrtc);\n  if (status == HAL_OK)\n  {\n    __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);\n    status = RTC_ExitInitMode(hrtc);\n  }\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  if (status == HAL_OK)\n  {\n    hrtc->State = HAL_RTC_STATE_READY;\n  }\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef * hrtc)\n{\n  HAL_StatusTypeDef status;\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  status = RTC_EnterInitMode(hrtc);\n  if (status == HAL_OK)\n  {\n    __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);\n    status = RTC_ExitInitMode(hrtc);\n  }\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  if (status == HAL_OK)\n  {\n    hrtc->State = HAL_RTC_STATE_READY;\n  }\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef * hrtc)\n{\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef * hrtc)\n{\n  __HAL_LOCK(hrtc);\n  hrtc->State = HAL_RTC_STATE_BUSY;\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n  hrtc->Instance->CR &= ((uint8_t)~RTC_CR_BYPSHAD);\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n  hrtc->State = HAL_RTC_STATE_READY;\n  __HAL_UNLOCK(hrtc);\n  return HAL_OK;\n}\n#if defined(TAMP)\nHAL_StatusTypeDef HAL_RTCEx_MonotonicCounterIncrement(RTC_HandleTypeDef *hrtc,  uint32_t Instance)\n{\n  UNUSED(hrtc);\n  UNUSED(Instance);\n  CLEAR_REG(TAMP->COUNTR);\n  return HAL_OK;\n}\nHAL_StatusTypeDef HAL_RTCEx_MonotonicCounterGet(RTC_HandleTypeDef *hrtc, uint32_t *Counter,  uint32_t Instance)\n{\n  UNUSED(hrtc);\n  UNUSED(Instance);\n  *Counter = READ_REG(TAMP->COUNTR);\n  return HAL_OK;\n}\n#endif \n__weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef * hrtc)\n{\n  UNUSED(hrtc);\n}\nHAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef * hrtc, uint32_t Timeout)\n{\n  uint32_t tickstart = HAL_GetTick();\n  while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == 0U)\n  {\n    if (Timeout != HAL_MAX_DELAY)\n    {\n      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);\n  hrtc->State = HAL_RTC_STATE_READY;\n  return HAL_OK;\n}\n#endif '"
"('Prompt: You are designing a software module for generating OFDM frames with certain properties. Write a C function that calculates the total length of the frame based on the number of symbols in the header and payload. Additionally, create a function that prints out the details of the OFDM frame generator including subcarrier information, cyclic prefix length, modulation scheme, FEC schemes, CRC scheme, and payload information such as decoded bytes and modulated symbols. The function should also calculate and print out the total OFDM symbols and spectral efficiency of the generated frame.","//...\n    unsigned int M;         \n    unsigned int cp_len;    \n    unsigned int taper_len; \n    unsigned char * p;      \n    unsigned int M_null;    \n    unsigned int M_pilot;   \n    unsigned int M_data;    \n    unsigned int num_symbols_header;    \n    unsigned int num_symbols_payload;   \n    unsigned int num_symbols_header;    \n    unsigned int payload_dec_len;       \n    unsigned char * payload_enc;        \n    unsigned char * payload_mod;        \n    unsigned int payload_enc_len;       \n    unsigned int payload_mod_len;       \n    int frame_assembled;                \n    ofdmflexframegenprops_s props;\nunsigned int ofdmflexframegen_getframelen(ofdmflexframegen _q)\n{\n    return  2 + \n            1 + \n            _q->num_symbols_header +\n            _q->num_symbols_payload;\n}\nint ofdmflexframegen_print(ofdmflexframegen _q)\n{\n    printf(""ofdmflexframegen:\\n"");\n    printf(""    num subcarriers     :   %-u\\n"", _q->M);\n    printf(""      * NULL            :   %-u\\n"", _q->M_null);\n    printf(""      * pilot           :   %-u\\n"", _q->M_pilot);\n    printf(""      * data            :   %-u\\n"", _q->M_data);\n    printf(""    cyclic prefix len   :   %-u\\n"", _q->cp_len);\n    printf(""    taper len           :   %-u\\n"", _q->taper_len);\n    printf(""    properties:\\n"");\n    printf(""      * mod scheme      :   %s\\n"", modulation_types[_q->props.mod_scheme].fullname);\n    printf(""      * fec (inner)     :   %s\\n"", fec_scheme_str[_q->props.fec0][1]);\n    printf(""      * fec (outer)     :   %s\\n"", fec_scheme_str[_q->props.fec1][1]);\n    printf(""      * CRC scheme      :   %s\\n"", crc_scheme_str[_q->props.check][1]);\n    printf(""    frame assembled     :   %s\\n"", _q->frame_assembled ? ""yes"" : ""no"");\n    if (_q->frame_assembled) {\n        printf(""    payload:\\n"");\n        printf(""      * decoded bytes   :   %-u\\n"", _q->payload_dec_len);\n        printf(""      * encoded bytes   :   %-u\\n"", _q->payload_enc_len);\n        printf(""      * modulated syms  :   %-u\\n"", _q->payload_mod_len);\n        printf(""    total OFDM symbols  :   %-u\\n"", ofdmflexframegen_getframelen(_q));\n        printf(""      * S0 symbols      :   %-u @ %u\\n"", 2, _q->M+_q->cp_len);\n        printf(""      * S1 symbols      :   %-u @ %u\\n"", 1, _q->M+_q->cp_len);\n        printf(""      * header symbols  :   %-u @ %u\\n"", _q->num_symbols_header,  _q->M+_q->cp_len);\n        printf(""      * payload symbols :   %-u @ %u\\n"", _q->num_symbols_payload, _q->M+_q->cp_len);\n        unsigned int num_bits = 8*_q->payload_dec_len;\n        unsigned int num_samples = (_q->M+_q->cp_len)*(3 + _q->num_symbols_header + _q->num_symbols_payload);\n        printf(""    spectral efficiency :   %-6.4f b/s/Hz\\n"", (float)num_bits / (float)num_samples);\n    }\n    return LIQUID_OK;\n}\n//...')
"
('Here is the prompt: . You are working on a project involving GMSK frame generation and you need a function that writes symbols to a buffer. Can you provide a function that writes symbols to a buffer based on the current state of the frame generation process?,"//...\n    unsigned int k;             \n    unsigned int m;             \n    int frame_complete;         \n    complex float * buf_sym;    \n    unsigned int    buf_idx;    \nint gmskframegen_write(gmskframegen   _q,\n                      float complex * _buf,\n                      unsigned int    _buf_len)\n{\n    unsigned int i;\n    for (i=0; i<_buf_len; i++) {\n        if (_q->buf_idx == _q->k)\n            gmskframegen_gen_symbol(_q);\n        _buf[i] = _q->buf_sym[_q->buf_idx++];\n    }\n    return _q->frame_complete;\n}\nint gmskframegen_write_header(gmskframegen _q)\n{\n    div_t d = div(_q->symbol_counter, 8);\n    unsigned int byte_index = d.quot;\n    unsigned int bit_index  = d.rem;\n    unsigned char byte = _q->header_enc[byte_index];\n    unsigned char bit  = (byte >> (8-bit_index-1)) & 0x01;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->header_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_PAYLOAD;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_payload(gmskframegen _q)\n{\n    div_t d = div(_q->symbol_counter, 8);\n    unsigned int byte_index = d.quot;\n    unsigned int bit_index  = d.rem;\n    unsigned char byte = _q->payload_enc[byte_index];\n    unsigned char bit  = (byte >> (8-bit_index-1)) & 0x01;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->payload_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_TAIL;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_tail(gmskframegen _q)\n{\n    unsigned char bit = rand() % 2;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    if (_q->symbol_counter >= _q->m) {\n        unsigned int i;\n        for (i=0; i<_q->k; i++)\n            _q->buf_sym[i] *= liquid_hamming(_q->m*_q->k + (_q->symbol_counter-_q->m)*_q->k + i, 2*_q->m*_q->k);\n    }\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->tail_len) {\n        _q->symbol_counter = 0;\n        _q->frame_complete = 1;\n        _q->state = STATE_UNASSEMBLED;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_zeros(gmskframegen _q)\n{\n    memset(_q->buf_sym, 0x0, _q->k*sizeof(float complex));\n    return LIQUID_OK;\n}\nint gmskframegen_gen_symbol(gmskframegen _q)\n{\n    _q->buf_idx = 0;\n    switch (_q->state) {\n    case STATE_UNASSEMBLED: gmskframegen_write_zeros   (_q); break;\n    case STATE_PREAMBLE:    gmskframegen_write_preamble(_q); break;\n    case STATE_HEADER:      gmskframegen_write_header  (_q); break;\n    case STATE_PAYLOAD:     gmskframegen_write_payload (_q); break;\n    case STATE_TAIL:        gmskframegen_write_tail    (_q); break;\n    default:\n        return liquid_error(LIQUID_EINT,""gmskframegen_writesymbol(), invalid internal state"");\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_preamble(gmskframegen _q)\n{\n    unsigned char bit = msequence_advance(_q->ms_preamble);\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    if (_q->symbol_counter < _q->m) {\n        unsigned int i;\n        for (i=0; i<_q->k; i++)\n            _q->buf_sym[i] *= liquid_hamming(_q->symbol_counter*_q->k + i, 2*_q->m*_q->k);\n    }\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->preamble_len) {\n        msequence_reset(_q->ms_preamble);\n        _q->symbol_counter = 0;\n        _q->state = STATE_HEADER;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write(gmskframegen   _q,\n                      float complex * _buf,\n                      unsigned int    _buf_len)\n{\n    unsigned int i;\n    for (i=0; i<_buf_len; i++) {\n        if (_q->buf_idx == _q->k)\n            gmskframegen_gen_symbol(_q);\n        _buf[i] = _q->buf_sym[_q->buf_idx++];\n    }\n    return _q->frame_complete;\n}\n//...')
"
"('Prompt: You are working on implementing a GMSK frame synchronization module for a digital communication system. The module uses a prefilter with a value of 1. Write a C function `gmskframesync_update_fi` that updates the estimated carrier frequency offset `fi_hat` using the received symbol `_x`. The function takes a `gmskframesync` object `_q` and a `float complex` symbol `_x` as input, computes the updated `fi_hat` value, updates the `x_prime` variable, and returns `LIQUID_OK`.","//...\n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int m;                 \n    float complex x_prime;          \n    float fi_hat;                   \nint gmskframesync_update_fi(gmskframesync _q,\n                            float complex _x)\n{\n    _q->fi_hat = cargf(conjf(_q->x_prime)*_x) * _q->k;\n    _q->x_prime = _x;\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: . . Please provide a code snippet demonstrating the usage of an arc object in LittlevGL with an infinite animation that changes the angle value over time. The scenario involves creating an arc object, setting its rotation and background angles, removing specific styles and flags, and then animating the arc to continuously change its angle value from 0 to 100 at a duration of 1000 milliseconds with a repeat delay of 500 milliseconds.","#if LV_USE_ARC && LV_BUILD_EXAMPLES\nstatic void set_angle(void * obj, int32_t v)\n{\n    lv_arc_set_value(obj, v);\n}\nvoid lv_example_arc_2(void)\n{\n    lv_obj_t * arc = lv_arc_create(lv_screen_active());\n    lv_arc_set_rotation(arc, 270);\n    lv_arc_set_bg_angles(arc, 0, 360);\n    lv_obj_remove_style(arc, NULL, LV_PART_KNOB);   \n    lv_obj_remove_flag(arc, LV_OBJ_FLAG_CLICKABLE);  \n    lv_obj_center(arc);\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, arc);\n    lv_anim_set_exec_cb(&a, set_angle);\n    lv_anim_set_duration(&a, 1000);\n    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);    \n    lv_anim_set_repeat_delay(&a, 500);\n    lv_anim_set_values(&a, 0, 100);\n    lv_anim_start(&a);\n}\n#endif'"
"('Prompt: ""I am looking to design a digital filter using the Nyquist design method. The filter needs to have either an exponential decay or a hyperbolic secant response. Can you provide me with C code that implements the design of these two types of filters using the Nyquist method?""","//...\nint liquid_firdes_fexp(unsigned int _k,\n                       unsigned int _m,\n                       float _beta,\n                       float _dt,\n                       float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FEXP, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_farcsech_freqresponse(unsigned int _k,\n                                        unsigned int _m,\n                                        float        _beta,\n                                        float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    float zeta  = 1.0f / (2.0f * _beta * B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f - (zeta/gamma)*liquid_asechf(zeta*(B*(1+_beta) - f));\n            } else {\n                _H[i] = (zeta/gamma)*liquid_asechf(zeta*(f - B*(1-_beta)));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_fsech(unsigned int _k,\n                        unsigned int _m,\n                        float _beta,\n                        float _dt,\n                        float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fexp_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(2.0f)/(_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = expf(gamma*(B*(1-_beta) - f));\n            } else {\n                _H[i] = 1.0f - expf(gamma*(f - (1+_beta)*B));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nfloat liquid_asechf(float _z)\n{\n    if (_z <= 0.0f || _z > 1.0f) {\n        liquid_error(LIQUID_EICONFIG,""liquid_asechf(), input (_z=%g)out of range (0,1)"", _z);\n        return 0.0f;\n    }\n    float z_inv = 1.0f / _z;\n    return logf( sqrtf(z_inv - 1.0f)*sqrtf(z_inv + 1.0f) + z_inv );\n}\nint liquid_firdes_fsech_freqresponse(unsigned int _k,\n                                    unsigned int _m,\n                                    float        _beta,\n                                    float *      _H)\n{\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m + 1;\n    float f0 = 0.5f*(1.0f - _beta) / (float)_k;\n    float f1 = 0.5f*(1.0f        ) / (float)_k;\n    float f2 = 0.5f*(1.0f + _beta) / (float)_k;\n    float B     = 0.5f/(float)_k;\n    float gamma = logf(sqrtf(3.0f) + 2.0f) / (_beta*B);\n    for (i=0; i<h_len; i++) {\n        float f = (float)i / (float)h_len;\n        if (f > 0.5f) f = f - 1.0f;\n        f = fabsf(f);\n        if ( f < f0 ) {\n            _H[i] = 1.0f;\n        } else if (f > f0 && f < f2) {\n            if ( f < f1) {\n                _H[i] = 1.0f / coshf(gamma*(f - B*(1-_beta)));\n            } else {\n                _H[i] = 1.0f - 1.0f / coshf(gamma*(B*(1+_beta) - f));\n            }\n        } else {\n            _H[i] = 0.0f;\n        }\n    }\n    return LIQUID_OK;\n}\nint liquid_firdes_farcsech(unsigned int _k,\n                           unsigned int _m,\n                           float _beta,\n                           float _dt,\n                           float * _h)\n{\n    return liquid_firdes_fnyquist(LIQUID_FIRFILT_FARCSECH, 0, _k, _m, _beta, _dt, _h);\n}\nint liquid_firdes_fnyquist(liquid_firfilt_type _type,\n                           int                 _root,\n                           unsigned int        _k,\n                           unsigned int        _m,\n                           float               _beta,\n                           float               _dt,\n                           float *             _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): beta must be in [0,1]"");\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m+1;   \n    float H_prime[h_len];   \n    float complex H[h_len]; \n    float complex h[h_len]; \n    switch (_type) {\n    case LIQUID_FIRFILT_FEXP:\n        liquid_firdes_fexp_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FSECH:\n        liquid_firdes_fsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FARCSECH:\n        liquid_firdes_farcsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    default:\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(), unknown/unsupported filter type"");\n    }\n    for (i=0; i<h_len; i++)\n        H[i] = _root ? sqrtf(H_prime[i]) : H_prime[i];\n    fft_run(h_len, H, h, LIQUID_FFT_BACKWARD, 0);\n    for (i=0; i<h_len; i++)\n        _h[i] = crealf( h[(i+_k*_m+1)%h_len] ) * (float)_k / (float)(h_len);\n    return LIQUID_OK;\n}\nint liquid_firdes_fnyquist(liquid_firfilt_type _type,\n                           int                 _root,\n                           unsigned int        _k,\n                           unsigned int        _m,\n                           float               _beta,\n                           float               _dt,\n                           float *             _h)\n{\n    if ( _k < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): k must be greater than 0"");\n    if ( _m < 1 )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): m must be greater than 0"");\n    if ( (_beta < 0.0f) || (_beta > 1.0f) )\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(): beta must be in [0,1]"");\n    unsigned int i;\n    unsigned int h_len = 2*_k*_m+1;   \n    float H_prime[h_len];   \n    float complex H[h_len]; \n    float complex h[h_len]; \n    switch (_type) {\n    case LIQUID_FIRFILT_FEXP:\n        liquid_firdes_fexp_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FSECH:\n        liquid_firdes_fsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    case LIQUID_FIRFILT_FARCSECH:\n        liquid_firdes_farcsech_freqresponse(_k, _m, _beta, H_prime);\n        break;\n    default:\n        return liquid_error(LIQUID_EICONFIG,""liquid_firdes_fnyquist(), unknown/unsupported filter type"");\n    }\n    for (i=0; i<h_len; i++)\n        H[i] = _root ? sqrtf(H_prime[i]) : H_prime[i];\n    fft_run(h_len, H, h, LIQUID_FFT_BACKWARD, 0);\n    for (i=0; i<h_len; i++)\n        _h[i] = crealf( h[(i+_k*_m+1)%h_len] ) * (float)_k / (float)(h_len);\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: ""You are tasked with writing a sorting function for a library management system. The function should be able to sort an array of books by title in ascending order. Implement this sorting function in C and save the code in the file libsort.c located in the libsort directory of the gear-lib library.""",../gear-lib/libsort/libsort.c'
"('Prompt: You are tasked with creating a benchmark function for a FIR decimator using complex floats in C. The benchmark function should take into account the runtime performance of the FIR decimator with specified parameters. Write a C function that benchmarks the FIR decimator with the following prototype:. void firdecim_crcf_bench(struct rusage *_start, struct rusage *_finish, unsigned long int *_num_iterations, unsigned int _M, unsigned int _h_len). Ensure that the benchmark function properly initializes the necessary arrays and executes the FIR decimator for the specified number of iterations. The function should calculate the runtime performance metrics and store them in the provided struct rusage pointers.","//...\nvoid benchmark_firdecim_crcf_m4_h16    F\nvoid firdecim_crcf_bench(struct rusage *     _start,\n                         struct rusage *     _finish,\n                         unsigned long int * _num_iterations,\n                         unsigned int        _M,\n                         unsigned int        _h_len)\n{\n    *_num_iterations /= _h_len;\n    if (*_num_iterations < 1) *_num_iterations = 1;\n    float h[_h_len];\n    unsigned int i;\n    for (i=0; i<_h_len; i++)\n        h[i] = 1.0f;\n    firdecim_crcf q = firdecim_crcf_create(_M,h,_h_len);\n    float complex x[_M];\n    for (i=0; i<_M; i++)\n        x[i] = (i%2) ? 1.0f : -1.0f;\n    float complex y;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        firdecim_crcf_execute(q, x, &y);\n        firdecim_crcf_execute(q, x, &y);\n        firdecim_crcf_execute(q, x, &y);\n        firdecim_crcf_execute(q, x, &y);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    firdecim_crcf_destroy(q);\n}\n//...')
"
"(""Prompt: . You are designing a genetic algorithm to solve the knapsack problem, where you have a struct defined as `knapsack_s` containing the number of items, their weights, values, and the knapsack's capacity. You need a utility function `knapsack_utility` that takes a pointer to the `knapsack_s` struct and a chromosome (which represents a possible solution) as arguments. The function should calculate the total value and weight of items in the knapsack based on the chromosome and return the total value if the weight does not exceed the capacity. Otherwise, it should return the difference between the capacity and total weight to penalize exceeding the weight limit. Implement the `knapsack_utility` function based on this scenario.","//...\nstruct knapsack_s {\n    unsigned int num_items; \n    float * weight;         \n    float * value;          \n    float capacity;         \n};\nfloat knapsack_utility(void * _userdata, chromosome _c)\n{\n    struct knapsack_s * _bag = (struct knapsack_s *) _userdata;\n    float total_value = 0;\n    float total_weight = 0;\n    unsigned int i;\n    for (i=0; i<_bag->num_items; i++) {\n        if ( chromosome_value(_c,i) == 1 ) {\n            total_value  += _bag->value[i];\n            total_weight += _bag->weight[i];\n        }\n    }\n    if (total_weight > _bag->capacity)\n        return _bag->capacity - total_weight;\n    return total_value;\n}\n//...')
"
"('Prompt: Can you provide a test harness function for a resampling block with a continuous-time resampler that uses a Kaiser windowed direct form filter? The function should take as parameters the interpolation factor (_P), decimation factor (_Q), filter semi-length (_m), desired bandwidth (_bw), and stop-band attenuation (_as). The function should perform resampling on a stream of symbols using the specified parameters, compute the power spectral density (PSD) of the output samples, and validate it against predefined frequency regions. Finally, the function should destroy the resampler and other related objects before exiting.","//...\nvoid test_harness_rresamp_crcf(unsigned int _P,\n                               unsigned int _Q,\n                               unsigned int _m,\n                               float        _bw,\n                               float        _as)\n{\n    unsigned int n=800000;  \n    float bw = 0.2f; \n    unsigned int nfft = 800;\n    float tol = 0.5f;\n    rresamp_crcf resamp = rresamp_crcf_create_kaiser(_P, _Q, _m, _bw, _as);\n    float r = rresamp_crcf_get_rate(resamp);\n    spgramcf     q   = spgramcf_create(nfft, LIQUID_WINDOW_HANN, nfft/2, nfft/4);\n    symstreamrcf gen = symstreamrcf_create_linear(LIQUID_FIRFILT_KAISER,r*bw,25,0.2f,LIQUID_MODEM_QPSK);\n    symstreamrcf_set_gain(gen, sqrtf(bw*r));\n    float complex buf_0[_Q]; \n    float complex buf_1[_P]; \n    while (spgramcf_get_num_samples_total(q) < n) {\n        symstreamrcf_write_samples(gen, buf_0, _Q);\n        rresamp_crcf_execute(resamp, buf_0, buf_1);\n        spgramcf_write(q, buf_1, _P);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-_as+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax=  0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-_as+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? ""autotest/logs/rresamp_crcf.m"" : NULL);\n    rresamp_crcf_destroy(resamp);\n    spgramcf_destroy(q);\n    symstreamrcf_destroy(gen);\n}\n//...')
"
"('Please provide a prompt asking for a code snippet that designs an infinite impulse response filter based on user-input parameters such as filter type, order, passband ripple, stopband attenuation, and angular cutoff frequency. This code should utilize getopt for command line option parsing and different filter design functions based on the filter type specified (Butterworth, Chebyshev Type I, Chebyshev Type II, Elliptic, or Bessel). The designed filter coefficients should be saved to a MATLAB script file for visualization and analysis.","#define OUTPUT_FILENAME ""iirdes_analog_example.m""\nvoid usage()\n{\n    printf(""iirdes_analog_example -- infinite impulse response filter design\\n"");\n    printf(""options (default values in []):\\n"");\n    printf(""  u/h   : print usage/help\\n"");\n    printf(""  t     : filter type: [butter], cheby1, cheby2, ellip, bessel\\n"");\n    printf(""  n     : filter order, n > 0 [5]\\n"");\n    printf(""  r     : passband ripple in dB (cheby1, ellip), r > 0 [3.0]\\n"");\n    printf(""  s     : stopband attenuation in dB (cheby2, ellip), s > 0 [60.0]\\n"");\n    printf(""  f     : angular passband cut-off frequency, f > 0 [1.0]\\n"");\n}\nint main(int argc, char*argv[]) {\n    unsigned int order=3;   \n    float wc=1.0f;          \n    float Ap=3.0f;          \n    float As=60.0f;         \n    liquid_iirdes_filtertype ftype = LIQUID_IIRDES_BUTTER;\n    int dopt;\n    while ((dopt = getopt(argc,argv,""uht:n:r:s:f:"")) != EOF) {\n        switch (dopt) {\n        case \'u\':\n        case \'h\':\n            usage();\n            return 0;\n        case \'t\':\n            if (strcmp(optarg,""butter"")==0) {\n                ftype = LIQUID_IIRDES_BUTTER;\n            } else if (strcmp(optarg,""cheby1"")==0) {\n                ftype = LIQUID_IIRDES_CHEBY1;\n            } else if (strcmp(optarg,""cheby2"")==0) {\n                ftype = LIQUID_IIRDES_CHEBY2;\n            } else if (strcmp(optarg,""ellip"")==0) {\n                ftype = LIQUID_IIRDES_ELLIP;\n            } else if (strcmp(optarg,""bessel"")==0) {\n                ftype = LIQUID_IIRDES_BESSEL;\n            } else {\n                fprintf(stderr,""error: %s, unknown filter type \\""%s\\""\\n"", argv[0], optarg);\n                usage();\n                exit(1);\n            }\n            break;\n        case \'n\': order = atoi(optarg); break;\n        case \'r\': Ap = atof(optarg);    break;\n        case \'s\': As = atof(optarg);    break;\n        case \'f\': wc = atof(optarg);    break;\n        default:\n            exit(1);\n        }\n    }\n    if (wc <= 0) {\n        fprintf(stderr,""error: %s, cutoff frequency out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    } else if (Ap <= 0) {\n        fprintf(stderr,""error: %s, pass-band ripple out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    } else if (As <= 0) {\n        fprintf(stderr,""error: %s, stop-band ripple out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    }\n    unsigned int npa = order;\n    unsigned int nza = 0;\n    float complex za[order];\n    float complex pa[order];\n    float complex ka;\n    unsigned int i;\n    unsigned int r = order % 2;\n    unsigned int L = (order-r)/2;\n    float Gp, Gs;\n    float ep = sqrtf( powf(10.0f, Ap / 10.0f) - 1.0f );\n    float es = powf(10.0f, -As / 20.0f);\n    switch (ftype) {\n    case LIQUID_IIRDES_BUTTER:\n        printf(""Butterworth filter design:\\n"");\n        nza = 0;\n        butter_azpkf(order,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_CHEBY1:\n        printf(""Cheby-I filter design:\\n"");\n        nza = 0;\n        cheby1_azpkf(order,ep,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_CHEBY2:\n        printf(""Cheby-II filter design:\\n"");\n        nza = 2*L;\n        float epsilon = powf(10.0f, -As/20.0f);\n        cheby2_azpkf(order,epsilon,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_ELLIP:\n        printf(""elliptic filter design:\\n"");\n        nza = 2*L;\n        Gp = powf(10.0f, -Ap / 20.0f);\n        Gs = powf(10.0f, -As / 20.0f);\n        printf(""  Gp = %12.8f\\n"", Gp);\n        printf(""  Gs = %12.8f\\n"", Gs);\n        ep = sqrtf(1.0f/(Gp*Gp) - 1.0f);\n        es = sqrtf(1.0f/(Gs*Gs) - 1.0f);\n        ellip_azpkf(order,ep,es,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_BESSEL:\n        printf(""Bessel filter design:\\n"");\n        bessel_azpkf(order,za,pa,&ka);\n        nza = 0;\n        break;\n    default:\n        fprintf(stderr,""error: %s: unknown filter type\\n"", argv[0]);\n        exit(1);\n    }\n    for (i=0; i<npa; i++) {\n        pa[i] *= wc;\n        ka *= wc;\n    }\n    for (i=0; i<nza; i++) {\n        za[i] *= wc;\n        ka /= wc;\n    }\n    for (i=0; i<nza; i++)\n        printf(""z(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(za[i]), cimagf(za[i]));\n    printf(""\\n"");\n    for (i=0; i<npa; i++)\n        printf(""p(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(pa[i]), cimagf(pa[i]));\n    printf(""\\n"");\n    printf(""ka = %12.4e + j*%12.4e;\\n"", crealf(ka), cimagf(ka));\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""\\n"");\n    fprintf(fid,""order=%u;\\n"", order);\n    fprintf(fid,""wc = %12.8f;\\n"", wc);\n    fprintf(fid,""npa = %u;\\n"", npa);\n    fprintf(fid,""nza = %u;\\n"", nza);\n    fprintf(fid,""pa = zeros(1,npa);\\n"");\n    fprintf(fid,""za = zeros(1,nza);\\n"");\n    for (i=0; i<npa; i++)\n        fprintf(fid,""pa(%3u) = %16.8e + j*%16.8e;\\n"", i+1, crealf(pa[i]), cimagf(pa[i]));\n    for (i=0; i<nza; i++)\n        fprintf(fid,""za(%3u) = %16.8e + j*%16.8e;\\n"", i+1, crealf(za[i]), cimagf(za[i]));\n    fprintf(fid,""k = %16.8e;\\n"", crealf(ka));\n    fprintf(fid,""b = 1;\\n"");\n    fprintf(fid,""for i=1:nza,\\n"");\n    fprintf(fid,""  b = conv(b,[1 za(i)]);\\n"");\n    fprintf(fid,""end;\\n"");\n    fprintf(fid,""a = 1;\\n"");\n    fprintf(fid,""for i=1:npa,\\n"");\n    fprintf(fid,""  a = conv(a,[1 pa(i)]);\\n"");\n    fprintf(fid,""end;\\n"");\n    fprintf(fid,""b = real(b)*k;\\n"");\n    fprintf(fid,""a = real(a);\\n"");\n    fprintf(fid,""w = 10.^[-2:0.002:2]*wc;\\n"");\n    fprintf(fid,""s = j*w;\\n"");\n    fprintf(fid,""h = polyval(b,s) ./ polyval(a,s);\\n"");\n    fprintf(fid,""H = 20*log10(abs(h));\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""t = [0:0.02:1]*2*pi;\\n"");\n    fprintf(fid,""plot(wc*cos(t),wc*sin(t),\'-\',\'Color\',[1 1 1]*0.7,...\\n"");\n    fprintf(fid,""     real(pa),imag(pa),\'x\');\\n"");\n    fprintf(fid,""if nza > 0,\\n"");\n    fprintf(fid,""  hold on; plot(real(za),imag(za),\'ob\'); hold off;\\n"");\n    fprintf(fid,""  legend(\'(\\\\omega_c)\',\'poles\',\'zeros\',0);\\n"");\n    fprintf(fid,""else,\\n"");\n    fprintf(fid,""  legend(\'(\\\\omega_c)\',\'poles\',0);\\n"");\n    fprintf(fid,""end;\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.2*max([wc abs(pa) abs(za)]));\\n"");\n    fprintf(fid,""axis square;\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""xlabel(\'real\');\\n"");\n    fprintf(fid,""ylabel(\'imag\');\\n"");\n    fprintf(fid,""\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""gd = gradient(unwrap(arg(h)))./gradient(w);\\n"");\n    fprintf(fid,""semilogx(w,gd);\\n"");\n    fprintf(fid,""xlabel(\'Angular frequency, \\\\omega [rad/s]\');\\n"");\n    fprintf(fid,""ylabel(\'group delay [s]\');\\n"");\n    fprintf(fid,""gd_min = min(gd); if gd_min < 0, gd_min=0; end;\\n"");\n    fprintf(fid,""axis([wc/100 wc*100 gd_min 1.1*max(gd)]);\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(2,1,1);\\n"");\n    fprintf(fid,""  semilogx(w,H,\'-\'); grid on;\\n"");\n    fprintf(fid,""  axis([wc/100 wc*100 -5 1]);\\n"");\n    fprintf(fid,""  xlabel(\'Angular frequency, \\\\omega [rad/s]\');\\n"");\n    fprintf(fid,""  ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""subplot(2,1,2);\\n"");\n    fprintf(fid,""  semilogx(w,H,\'-\'); grid on;\\n"");\n    fprintf(fid,""  axis([wc/100 wc*100 -100 10]);\\n"");\n    fprintf(fid,""  xlabel(\'Angular frequency, \\\\omega [rad/s]\');\\n"");\n    fprintf(fid,""  ylabel(\'PSD [dB]\');\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: You are working on a C program that requires a function to normalize a given array of floating-point numbers. Write a function that takes in a pointer to an array of floats and the number of elements in the array, loops through the array, computes the vector norm, and returns this norm. Additionally, the function should normalize the input array by dividing each element by the vector norm if the norm is not zero.","//...\nfloat gradsearch_norm(float *      _v,\n                      unsigned int _n)\n{\n    float vnorm = liquid_vectorf_norm(_v, _n);\n    float scale = vnorm == 0.0f ? 0.0f : 1.0f / vnorm;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        _v[i] *= scale;\n    return vnorm;\n}\n//...')
"
"(""Prompt: You are tasked with writing a function that performs LU decomposition using Doolittle's method for a given square matrix. The function should take in the matrix data, its dimensions, and return the lower triangular matrix L, upper triangular matrix U, and the permutation matrix P. Additionally, you need to implement a test function that verifies the correctness of the LU decomposition by multiplying L and U matrices and comparing them with the original matrix. The test should check if the elements of L and U matrices satisfy certain conditions based on their positions and also compare the product of L and U matrices with the original matrix within a certain tolerance level.","//...\nvoid autotest_matrixcf_ludecomp_doolittle()\n{\n    float tol = 1e-5f;  \n    float complex L[64];\n    float complex U[64];\n    float complex P[64];\n    float complex LU_test[64];\n    matrixcf_ludecomp_doolittle(matrixcf_data_ludecomp_A, 8, 8, L, U, P);\n    matrixcf_mul(L,       8, 8,\n                 U,       8, 8,\n                 LU_test, 8, 8);\n    if (liquid_autotest_verbose) {\n        printf(""ludecomp_doolittle:\\n"");\n        printf(""  A: "");  matrixcf_print(matrixcf_data_ludecomp_A, 8, 8);\n        printf(""  L: "");  matrixcf_print(L,                        8, 8);\n        printf(""  U: "");  matrixcf_print(U,                        8, 8);\n        printf(""  LU: ""); matrixcf_print(LU_test,                  8, 8);\n    }\n    unsigned int r,c;\n    for (r=0; r<8; r++) {\n        for (c=0; c<8; c++) {\n            if (r < c) {\n                CONTEND_DELTA( crealf(matrix_access(L,8,8,r,c)), 0.0f, tol );\n                CONTEND_DELTA( cimagf(matrix_access(L,8,8,r,c)), 0.0f, tol );\n            } else if (r==c) {\n                CONTEND_DELTA( crealf(matrix_access(L,8,8,r,c)), 1.0f, tol );\n                CONTEND_DELTA( cimagf(matrix_access(L,8,8,r,c)), 0.0f, tol );\n            } else {\n                CONTEND_DELTA( crealf(matrix_access(U,8,8,r,c)), 0.0f, tol );\n                CONTEND_DELTA( cimagf(matrix_access(U,8,8,r,c)), 0.0f, tol );\n            }\n        }\n    }\n    unsigned int i;\n    for (i=0; i<64; i++) {\n        CONTEND_DELTA( crealf(matrixcf_data_ludecomp_A[i]), crealf(LU_test[i]), tol );\n        CONTEND_DELTA( cimagf(matrixcf_data_ludecomp_A[i]), cimagf(LU_test[i]), tol );\n    }\n}\n//...')
"
"'Prompt: Design a system to store TLV (Type-Length-Value) data structure values in C programming language. The system should include functions to create a new TLV values structure, add a TLV value to the structure, and parse a TLV value. The system should use dynamic memory allocation for the TLV values and should be able to handle string values as well. Provide the code for the system functions.","//...\n    tlv_t *t = tlv_get_value(values, type);\n\n    return value;\n    int r = tlv_parse(t->value, t->size, value);\ntlv_values_t *tlv_new() {\n    tlv_values_t *values = malloc(sizeof(tlv_values_t));\n    values->head = NULL;\n    return values;\n}\nint tlv_add_value(tlv_values_t *values, byte type, const byte *value, size_t size) {\n    byte *data = NULL;\n    if (size) {\n        data = malloc(size);\n        memcpy(data, value, size);\n    }\n    return tlv_add_value_(values, type, data, size);\n}\nint tlv_add_value_(tlv_values_t *values, byte type, byte *value, size_t size) {\n    tlv_t *tlv = malloc(sizeof(tlv_t));\n    tlv->type = type;\n    tlv->size = size;\n    tlv->value = value;\n    tlv->next = NULL;\n    if (!values->head) {\n        values->head = tlv;\n    } else {\n        tlv_t *t = values->head;\n        while (t->next) {\n            t = t->next;\n        }\n        t->next = tlv;\n    }\n    return 0;\n}\nint tlv_add_string_value(tlv_values_t *values, byte type, const char *value) {\n    return tlv_add_value(values, type, (const byte *)value, strlen(value));\n}\n//...'"
"'Prompt: . You are working on a program that utilizes pthread attributes and you need to obtain the stack address value specified in the pthread attribute object. However, the function `pthread_attr_getstackaddr` needs to be implemented. Write a C code snippet for the `pthread_attr_getstackaddr` function that retrieves the stack address from the pthread attribute object. If the system does not support this feature, return an error code.","//...\nint\npthread_attr_getstackaddr (const pthread_attr_t * attr, void **stackaddr)\n{\n#if defined( _POSIX_THREAD_ATTR_STACKADDR ) && _POSIX_THREAD_ATTR_STACKADDR != -1\n  if (__ptw32_is_attr (attr) != 0)\n    {\n      return EINVAL;\n    }\n  *stackaddr = (*attr)->stackaddr;\n  return 0;\n#else\n  return ENOSYS;\n#endif \n}\n//...'"
"'Prompt: You are working on a project that involves multi-threading in C programming. Your task is to implement a function that sets the scheduling policy for a pthread attribute object. The function should set the policy to ""SCHED_OTHER"" and return 0 if successful. If the provided attribute is invalid, it should return EINVAL. If the specified policy is not supported, it should return ENOTSUP. Please provide a code snippet for this function considering the need to include the configuration header file.","#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_attr_setschedpolicy (pthread_attr_t * attr, int policy)\n{\n  if (__ptw32_is_attr (attr) != 0)\n    {\n      return EINVAL;\n    }\n  if (policy != SCHED_OTHER)\n    {\n      return ENOTSUP;\n    }\n  return 0;\n}'"
"('Prompt: You are working on an OFDM frame generator in a software defined radio application. You need to develop a function that generates symbols using provided data and writes them to a buffer. The symbol generation involves some specific operations like memmove, multiplication, and addition. The output buffer should be processed with a tapering function before writing the resulting symbols. You also need a separate function that copies data from one buffer to another and then calls the symbol generation function. Can you provide the implementation for these two functions, `ofdmframegen_gensymbol` and `ofdmframegen_write_S1`, in C programming language?","//...\nint ofdmframegen_gensymbol(ofdmframegen    _q,\n                           float complex * _buffer)\n{\n    memmove( &_buffer[0],          &_q->x[_q->M-_q->cp_len], _q->cp_len*sizeof(float complex));\n    memmove( &_buffer[_q->cp_len], &_q->x[               0], _q->M    * sizeof(float complex));\n    unsigned int i;\n    for (i=0; i<_q->taper_len; i++) {\n        _buffer[i] *= _q->taper[i];\n        _buffer[i] += _q->postfix[i] * _q->taper[_q->taper_len-i-1];\n    }\n    memmove(_q->postfix, _q->x, _q->taper_len*sizeof(float complex));\n    return LIQUID_OK;\n}\nint ofdmframegen_write_S1(ofdmframegen _q,\n                           float complex * _y)\n{\n    memmove(_q->x, _q->s1, (_q->M)*sizeof(float complex));\n    return ofdmframegen_gensymbol(_q, _y);\n}\n//...')
"
"('Prompt: You are working on a C library for signal processing and need a function to copy a `dotprod_crcf` object in order to create a duplicate for manipulation without altering the original. The `dotprod_crcf` struct consists of an unsigned integer `n` and a pointer to an array of floating-point numbers `h`. Write a function called `dotprod_crcf_copy` that takes in a `dotprod_crcf` object as a parameter and returns a new copy of that object. This function should perform error checking to ensure that the input object is not NULL. If the object provided is NULL, the function should return an error message. Otherwise, the function should allocate memory for a new `dotprod_crcf` object, copy the contents of the input object, and return the duplicate.","//...\nstruct dotprod_crcf_s {\n    unsigned int n;     \n    float * h;          \n};\ndotprod_crcf dotprod_crcf_copy(dotprod_crcf q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""dotprod_crcf_copy().neon, object cannot be NULL"");\n    dotprod_crcf q_copy = (dotprod_crcf)malloc(sizeof(struct dotprod_crcf_s));\n    q_copy->n = q_orig->n;\n    q_copy->h = (float*) malloc( 2*q_copy->n*sizeof(float) );\n    memmove(q_copy->h, q_orig->h, 2*q_orig->n*sizeof(float));\n    return q_copy;\n}\n//...')
"
'Prompt: Can you provide an example code snippet that demonstrates creating a bar chart with two series and custom scale labels for each month? The chart should have a flexible layout and dynamically generated data points. ,"#if LV_USE_CHART && LV_BUILD_EXAMPLES\nvoid lv_example_chart_2(void)\n{\n    lv_obj_t * main_cont = lv_obj_create(lv_screen_active());\n    lv_obj_set_size(main_cont, 200, 150);\n    lv_obj_center(main_cont);\n    lv_obj_t * wrapper = lv_obj_create(main_cont);\n    lv_obj_remove_style_all(wrapper);\n    lv_obj_set_size(wrapper, lv_pct(300), lv_pct(100));\n    lv_obj_set_flex_flow(wrapper, LV_FLEX_FLOW_COLUMN);\n    lv_obj_t * chart = lv_chart_create(wrapper);\n    lv_obj_set_width(chart, lv_pct(100));\n    lv_obj_set_flex_grow(chart, 1);\n    lv_chart_set_type(chart, LV_CHART_TYPE_BAR);\n    lv_chart_set_range(chart, LV_CHART_AXIS_PRIMARY_Y, 0, 100);\n    lv_chart_set_range(chart, LV_CHART_AXIS_SECONDARY_Y, 0, 400);\n    lv_chart_set_point_count(chart, 12);\n    lv_obj_set_style_radius(chart, 0, 0);\n    lv_obj_t * scale_bottom = lv_scale_create(wrapper);\n    lv_scale_set_mode(scale_bottom, LV_SCALE_MODE_HORIZONTAL_BOTTOM);\n    lv_obj_set_size(scale_bottom, lv_pct(100), 25);\n    lv_scale_set_total_tick_count(scale_bottom, 12);\n    lv_scale_set_major_tick_every(scale_bottom, 1);\n    lv_obj_set_style_pad_hor(scale_bottom, lv_chart_get_first_point_center_offset(chart), 0);\n    static const char * month[] = {""Jan"", ""Febr"", ""March"", ""Apr"", ""May"", ""Jun"", ""July"", ""Aug"", ""Sept"", ""Oct"", ""Nov"", ""Dec"", NULL};\n    lv_scale_set_text_src(scale_bottom, month);\n    lv_chart_series_t * ser1 = lv_chart_add_series(chart, lv_palette_lighten(LV_PALETTE_GREEN, 2), LV_CHART_AXIS_PRIMARY_Y);\n    lv_chart_series_t * ser2 = lv_chart_add_series(chart, lv_palette_darken(LV_PALETTE_GREEN, 2), LV_CHART_AXIS_PRIMARY_Y);\n    uint32_t i;\n    for(i = 0; i < 12; i++) {\n        lv_chart_set_next_value(chart, ser1, lv_rand(10, 60));\n        lv_chart_set_next_value(chart, ser2, lv_rand(50, 90));\n    }\n    lv_chart_refresh(chart); \n}\n#endif'"
"('Create a scenario where you need to test the modulation and demodulation functionality of a modem in a PSK8 (8-phase shift keying) modulation scheme. The objective is to ensure that the modulated and demodulated signals match and evaluate the phase error, error vector magnitude (EVM), and the overall signal quality. The prompt should require you to write a test function that sets up the modem with PSK8 modulation, performs mod-demod operations on symbols, checks for correctness, and evaluates the signal quality metrics within acceptable margins.","//...\nvoid modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_psk8()      { modemcf_test_mod_demod(LIQUID_MODEM_PSK8);      }\n//...')
"
"'The technical scenario prompt could be: ""You are working on a project that involves generating QR codes and need to implement a function that retrieves a specific module (bit) from a QR code array. The QR code array contains information about the QR code size and layout of modules. Write a C++ function that, given a QR code array, x and y coordinates, retrieves the module (bit) located at the specified x and y position in the QR code grid. Ensure that the function performs bounds checking to prevent accessing out-of-bounds memory addresses.""","//...\nstatic bool getBit(int x, int i)\n{\n    return ((x >> i) & 1) != 0;\n}\ntestable bool getModule(const uint8_t qrcode[], int x, int y)\n{\n    int qrsize = qrcode[0];\n    LV_ASSERT(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n    int index = y * qrsize + x;\n    return getBit(qrcode[(index >> 3) + 1], index & 7);\n}\nbool qrcodegen_getModule(const uint8_t qrcode[], int x, int y)\n{\n    LV_ASSERT(qrcode != NULL);\n    int qrsize = qrcode[0];\n    return (0 <= x && x < qrsize && 0 <= y && y < qrsize) && getModule(qrcode, x, y);\n}\n//...'"
"('Prompt: ""I need a function that performs a Hilbert transform decimation on a given input signal using a FIR Hilbert filter with a specific order and decimation rate. The input signal is an array of 32 float values, and the expected output is an array of 16 complex float values. The function should compare the output with a pre-defined set of test values with a tolerance of 0.005 and print the results if verbose mode is enabled. Can you provide me with the C code for this scenario?""","//...\nvoid autotest_firhilbf_decim()\n{\n    float x[32] = {\n         1.0000,  0.7071,  0.0000, -0.7071, -1.0000, -0.7071, -0.0000,  0.7071,\n         1.0000,  0.7071,  0.0000, -0.7071, -1.0000, -0.7071, -0.0000,  0.7071,\n         1.0000,  0.7071,  0.0000, -0.7071, -1.0000, -0.7071, -0.0000,  0.7071,\n         1.0000,  0.7071, -0.0000, -0.7071, -1.0000, -0.7071, -0.0000,  0.7071\n    };\n    float complex test[16] = {\n         0.0000+J*-0.0055, -0.0000+J* 0.0231,  0.0000+J*-0.0605, -0.0000+J* 0.1459,\n         0.0000+J*-0.5604, -0.7071+J*-0.7669, -0.7071+J* 0.7294,  0.7071+J* 0.7008,\n         0.7071+J*-0.7064, -0.7071+J*-0.7064, -0.7071+J* 0.7064,  0.7071+J* 0.7064,\n         0.7071+J*-0.7064, -0.7071+J*-0.7064, -0.7071+J* 0.7064,  0.7071+J* 0.7064\n    };\n    float complex y[16];\n    unsigned int m=5;   \n    firhilbf ht = firhilbf_create(m,60.0f);\n    float tol=0.005f;\n    unsigned int i;\n    for (i=0; i<16; i++)\n        firhilbf_decim_execute(ht, &x[2*i], &y[i]);\n    if (liquid_autotest_verbose) {\n        printf(""hilbert transform decimator output:\\n"");\n        for (i=0; i<16; i++)\n            printf(""  y(%3u) = %8.5f + j*%8.5f;\\n"", i+1, crealf(y[i]), cimagf(y[i]));\n    }\n    for (i=0; i<16; i++) {\n        CONTEND_DELTA(crealf(y[i]), crealf(test[i]), tol);\n        CONTEND_DELTA(cimagf(y[i]), cimagf(test[i]), tol);\n    }\n    firhilbf_destroy(ht);\n}\n//...')
"
"'Prompt: You are working on a user interface project using LittlevGL graphics library and you need to create an animation example with a switch component. The animation should move a text label to the right when the switch is checked, and move it to the left when the switch is unchecked. Can you provide a code snippet that demonstrates this animation behavior using LittlevGL and includes event handling for the switch component?. . Response:. #if LV_BUILD_EXAMPLES && LV_USE_SWITCH. static void anim_x_cb(void * var, int32_t v). {.     lv_obj_set_x(var, v);. }. static void sw_event_cb(lv_event_t * e). {.     lv_obj_t * sw = lv_event_get_target(e);.     lv_obj_t * label = lv_event_get_user_data(e);.     if(lv_obj_has_state(sw, LV_STATE_CHECKED)) {.         lv_anim_t a;.         lv_anim_init(&a);.         lv_anim_set_var(&a, label);.         lv_anim","#if LV_BUILD_EXAMPLES && LV_USE_SWITCH\nstatic void anim_x_cb(void * var, int32_t v)\n{\n    lv_obj_set_x(var, v);\n}\nstatic void sw_event_cb(lv_event_t * e)\n{\n    lv_obj_t * sw = lv_event_get_target(e);\n    lv_obj_t * label = lv_event_get_user_data(e);\n    if(lv_obj_has_state(sw, LV_STATE_CHECKED)) {\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, label);\n        lv_anim_set_values(&a, lv_obj_get_x(label), 100);\n        lv_anim_set_duration(&a, 500);\n        lv_anim_set_exec_cb(&a, anim_x_cb);\n        lv_anim_set_path_cb(&a, lv_anim_path_overshoot);\n        lv_anim_start(&a);\n    }\n    else {\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, label);\n        lv_anim_set_values(&a, lv_obj_get_x(label), -lv_obj_get_width(label));\n        lv_anim_set_duration(&a, 500);\n        lv_anim_set_exec_cb(&a, anim_x_cb);\n        lv_anim_set_path_cb(&a, lv_anim_path_ease_in);\n        lv_anim_start(&a);\n    }\n}\nvoid lv_example_anim_1(void)\n{\n    lv_obj_t * label = lv_label_create(lv_screen_active());\n    lv_label_set_text(label, ""Hello animations!"");\n    lv_obj_set_pos(label, 100, 10);\n    lv_obj_t * sw = lv_switch_create(lv_screen_active());\n    lv_obj_center(sw);\n    lv_obj_add_state(sw, LV_STATE_CHECKED);\n    lv_obj_add_event_cb(sw, sw_event_cb, LV_EVENT_VALUE_CHANGED, label);\n}\n#endif'"
"'Please provide the prompt in which you need the code, focusing on initializing and configuring the LCD interface controller (LCIF) for RGB mode operation. This includes setting up pixel format, panel size, synchronization signals, as well as clock control and data bus configuration.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.elcdif""\n#endif\nstatic uint32_t ELCDIF_GetInstance(const LCDIF_Type *base);\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_elcdifApbClocks[] = LCDIF_CLOCKS;\n#if defined(LCDIF_PERIPH_CLOCKS)\nstatic const clock_ip_name_t s_elcdifPixClocks[] = LCDIF_PERIPH_CLOCKS;\n#endif\n#endif \nstatic const elcdif_pixel_format_reg_t s_pixelFormatReg[] = {\n    {\n     LCDIF_CTRL_WORD_LENGTH(1U),\n     LCDIF_CTRL1_BYTE_PACKING_FORMAT(0x0FU)},\n    {\n     LCDIF_CTRL_WORD_LENGTH(0U),\n     LCDIF_CTRL1_BYTE_PACKING_FORMAT(0x0FU)},\n    {\n     LCDIF_CTRL_WORD_LENGTH(3U) | LCDIF_CTRL_DATA_FORMAT_24_BIT(1U),\n     LCDIF_CTRL1_BYTE_PACKING_FORMAT(0x07U)},\n    {\n     LCDIF_CTRL_WORD_LENGTH(3U),\n     LCDIF_CTRL1_BYTE_PACKING_FORMAT(0x07U)},\n    {\n     LCDIF_CTRL_WORD_LENGTH(3U),\n     LCDIF_CTRL1_BYTE_PACKING_FORMAT(0x0FU)},\n};\nstatic uint32_t ELCDIF_GetInstance(const LCDIF_Type *base)\n{\n    static LCDIF_Type *const s_elcdifBases[] = LCDIF_BASE_PTRS;\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_elcdifBases); instance++)\n    {\n        if (s_elcdifBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_elcdifBases));\n    return instance;\n}\nvoid ELCDIF_RgbModeInit(LCDIF_Type *base, const elcdif_rgb_mode_config_t *config)\n{\n    assert(NULL != config);\n    assert((uint32_t)config->pixelFormat < ARRAY_SIZE(s_pixelFormatReg));\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && (0 != FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))\n    uint32_t instance = ELCDIF_GetInstance(base);\n    (void)CLOCK_EnableClock(s_elcdifApbClocks[instance]);\n#if defined(LCDIF_PERIPH_CLOCKS)\n    (void)CLOCK_EnableClock(s_elcdifPixClocks[instance]);\n#endif\n#endif \n    ELCDIF_Reset(base);\n    base->CTRL = s_pixelFormatReg[(uint32_t)config->pixelFormat].regCtrl | (uint32_t)(config->dataBus) |\n                 LCDIF_CTRL_DOTCLK_MODE_MASK |  \n                 LCDIF_CTRL_BYPASS_COUNT_MASK | \n                 LCDIF_CTRL_MASTER_MASK;\n    base->CTRL1 = s_pixelFormatReg[(uint32_t)config->pixelFormat].regCtrl1;\n    base->CTRL2 = (base->CTRL2 & ~LCDIF_CTRL2_OUTSTANDING_REQS_MASK) | (LCDIF_CTRL2_OUTSTANDING_REQS(4));\n    base->TRANSFER_COUNT = ((uint32_t)config->panelHeight << LCDIF_TRANSFER_COUNT_V_COUNT_SHIFT) |\n                           ((uint32_t)config->panelWidth << LCDIF_TRANSFER_COUNT_H_COUNT_SHIFT);\n    base->VDCTRL0 = LCDIF_VDCTRL0_ENABLE_PRESENT_MASK |         \n                    LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT_MASK |      \n                    LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT_MASK | \n                    (uint32_t)config->polarityFlags | (uint32_t)config->vsw;\n    base->VDCTRL1 =\n        (uint32_t)config->vsw + (uint32_t)config->panelHeight + (uint32_t)config->vfp + (uint32_t)config->vbp;\n    base->VDCTRL2 =\n        ((uint32_t)config->hsw << LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH_SHIFT) |\n        ((uint32_t)config->hfp + (uint32_t)config->hbp + (uint32_t)config->panelWidth + (uint32_t)config->hsw)\n            << LCDIF_VDCTRL2_HSYNC_PERIOD_SHIFT;\n    base->VDCTRL3 = (((uint32_t)config->hbp + config->hsw) << LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT_SHIFT) |\n                    (((uint32_t)config->vbp + config->vsw) << LCDIF_VDCTRL3_VERTICAL_WAIT_CNT_SHIFT);\n    base->VDCTRL4 = LCDIF_VDCTRL4_SYNC_SIGNALS_ON_MASK |\n                    ((uint32_t)config->panelWidth << LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT_SHIFT);\n    base->CUR_BUF  = ELCDIF_ADDR_CPU_2_IP(config->bufferAddr);\n    base->NEXT_BUF = ELCDIF_ADDR_CPU_2_IP(config->bufferAddr);\n}\nvoid ELCDIF_RgbModeGetDefaultConfig(elcdif_rgb_mode_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n    config->panelWidth    = 480U;\n    config->panelHeight   = 272U;\n    config->hsw           = 41;\n    config->hfp           = 4;\n    config->hbp           = 8;\n    config->vsw           = 10;\n    config->vfp           = 4;\n    config->vbp           = 2;\n    config->polarityFlags = (uint32_t)kELCDIF_VsyncActiveLow | (uint32_t)kELCDIF_HsyncActiveLow |\n                            (uint32_t)kELCDIF_DataEnableActiveLow | (uint32_t)kELCDIF_DriveDataOnFallingClkEdge;\n    config->bufferAddr  = 0U;\n    config->pixelFormat = kELCDIF_PixelFormatRGB888;\n    config->dataBus     = kELCDIF_DataBus24Bit;\n}\nvoid ELCDIF_RgbModeSetPixelFormat(LCDIF_Type *base, elcdif_pixel_format_t pixelFormat)\n{\n    assert((uint32_t)pixelFormat < ARRAY_SIZE(s_pixelFormatReg));\n    base->CTRL = (base->CTRL & ~(LCDIF_CTRL_WORD_LENGTH_MASK | LCDIF_CTRL_DATA_FORMAT_24_BIT_MASK |\n                                 LCDIF_CTRL_DATA_FORMAT_18_BIT_MASK | LCDIF_CTRL_DATA_FORMAT_16_BIT_MASK)) |\n                 s_pixelFormatReg[(uint32_t)pixelFormat].regCtrl;\n    base->CTRL1 = s_pixelFormatReg[(uint32_t)pixelFormat].regCtrl1;\n}\nvoid ELCDIF_Deinit(LCDIF_Type *base)\n{\n    ELCDIF_Reset(base);\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && (0 != FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))\n    uint32_t instance = ELCDIF_GetInstance(base);\n#if defined(LCDIF_PERIPH_CLOCKS)\n    (void)CLOCK_DisableClock(s_elcdifPixClocks[instance]);\n#endif\n    (void)CLOCK_DisableClock(s_elcdifApbClocks[instance]);\n#endif \n}\nvoid ELCDIF_RgbModeStop(LCDIF_Type *base)\n{\n    base->CTRL_CLR = LCDIF_CTRL_DOTCLK_MODE_MASK;\n    while (0U != (base->CTRL & LCDIF_CTRL_DOTCLK_MODE_MASK))\n    {\n    }\n}\nvoid ELCDIF_Reset(LCDIF_Type *base)\n{\n    base->CTRL_CLR = LCDIF_CTRL_CLKGATE_MASK;\n    if (0U == (base->CTRL & LCDIF_CTRL_SFTRST_MASK))\n    {\n        base->CTRL_SET = LCDIF_CTRL_SFTRST_MASK;\n        while (0U == (base->CTRL & LCDIF_CTRL_CLKGATE_MASK))\n        {\n        }\n        base->CTRL_CLR = LCDIF_CTRL_CLKGATE_MASK;\n    }\n    base->CTRL_CLR = LCDIF_CTRL_SFTRST_MASK;\n}\n#if !(defined(FSL_FEATURE_LCDIF_HAS_NO_AS) && (0 != FSL_FEATURE_LCDIF_HAS_NO_AS))\nvoid ELCDIF_SetAlphaSurfaceBufferConfig(LCDIF_Type *base, const elcdif_as_buffer_config_t *config)\n{\n    assert(NULL != config);\n    base->AS_CTRL     = (base->AS_CTRL & ~LCDIF_AS_CTRL_FORMAT_MASK) | LCDIF_AS_CTRL_FORMAT(config->pixelFormat);\n    base->AS_BUF      = ELCDIF_ADDR_CPU_2_IP(config->bufferAddr);\n    base->AS_NEXT_BUF = ELCDIF_ADDR_CPU_2_IP(config->bufferAddr);\n}\nvoid ELCDIF_SetAlphaSurfaceBlendConfig(LCDIF_Type *base, const elcdif_as_blend_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t reg;\n    reg = base->AS_CTRL;\n    reg &= ~(LCDIF_AS_CTRL_ALPHA_INVERT_MASK | LCDIF_AS_CTRL_ROP_MASK | LCDIF_AS_CTRL_ALPHA_MASK |\n             LCDIF_AS_CTRL_ALPHA_CTRL_MASK);\n    reg |= (LCDIF_AS_CTRL_ROP(config->ropMode) | LCDIF_AS_CTRL_ALPHA(config->alpha) |\n            LCDIF_AS_CTRL_ALPHA_CTRL(config->alphaMode));\n    if (config->invertAlpha)\n    {\n        reg |= LCDIF_AS_CTRL_ALPHA_INVERT_MASK;\n    }\n    base->AS_CTRL = reg;\n}\n#endif \n#if (defined(FSL_FEATURE_LCDIF_HAS_LUT) && (0 != FSL_FEATURE_LCDIF_HAS_LUT))\nstatus_t ELCDIF_UpdateLut(\n    LCDIF_Type *base, elcdif_lut_t lut, uint16_t startIndex, const uint32_t *lutData, uint16_t count)\n{\n    volatile uint32_t *regLutAddr;\n    volatile uint32_t *regLutData;\n    uint32_t i;\n    status_t status;\n    if ((startIndex + count) > ELCDIF_LUT_ENTRY_NUM)\n    {\n        status = kStatus_InvalidArgument;\n    }\n    else\n    {\n        if (kELCDIF_Lut0 == lut)\n        {\n            regLutAddr = &(base->LUT0_ADDR);\n            regLutData = &(base->LUT0_DATA);\n        }\n        else\n        {\n            regLutAddr = &(base->LUT1_ADDR);\n            regLutData = &(base->LUT1_DATA);\n        }\n        *regLutAddr = startIndex;\n        for (i = 0; i < count; i++)\n        {\n            *regLutData = lutData[i];\n        }\n        status = kStatus_Success;\n    }\n    return status;\n}\n#endif '"
"'Prompt: ""Imagine you want to create an example function using LibJPEG-Turbo library in a project that includes LVGL. Write a code snippet that includes a function called lv_example_libjpeg_turbo_1. This function should create an image object displaying \'flower.jpg\' using LVGL\'s image creation function. If LV_USE_LIBJPEG_TURBO is enabled, use the image path \'A:lvgl/examples/libs/libjpeg_turbo/flower.jpg\'. If not, display a label saying \'LibJPEG-Turbo is not installed\'. Make sure to center the image or label on the screen.""","#if LV_BUILD_EXAMPLES\n#if LV_USE_LIBJPEG_TURBO\nvoid lv_example_libjpeg_turbo_1(void)\n{\n    lv_obj_t * wp;\n    wp = lv_image_create(lv_screen_active());\n    lv_image_set_src(wp, ""A:lvgl/examples/libs/libjpeg_turbo/flower.jpg"");\n    lv_obj_center(wp);\n}\n#else\nvoid lv_example_libjpeg_turbo_1(void)\n{\n    lv_obj_t * label = lv_label_create(lv_screen_active());\n    lv_label_set_text(label, ""LibJPEG-Turbo is not installed"");\n    lv_obj_center(label);\n}\n#endif\n#endif'"
"('Prompt: You are working on testing a digital signal processing function that involves resampling of a complex signal. The function takes in parameters P, Q, m, and n. Can you write a test harness function that creates two resampler objects using the Kaiser window design method, generates input signal buffers, executes resampling on these buffers, compares the output of different resampler objects, and performs testing for correctness with a certain tolerance level? The function should handle complex numbers and perform specific actions on the input signal buffers before and after resampling.","//...\nvoid test_harness_rresamp_crcf_part(unsigned int _P, \n                                    unsigned int _Q, \n                                    unsigned int _m, \n                                    unsigned int _n) \n{\n    float tol = 1e-12f; \n    float bw  = 0.5f;   \n    float As  = 60.0f;  \n    rresamp_crcf q0 = rresamp_crcf_create_kaiser(_P,_Q,_m,bw,As);\n    rresamp_crcf q1 = rresamp_crcf_create_kaiser(_P,_Q,_m,bw,As);\n    float complex buf_in   [2*_Q*_n]; \n    float complex buf_out_0[2*_P*_n]; \n    float complex buf_out_1[2*_P*_n]; \n    unsigned int i;\n    for (i=0; i<2*_Q*_n; i++)\n        buf_in[i] = liquid_hamming(i,2*_Q*_n) * cexpf(_Complex_I*2*M_PI*0.037f*i);\n    rresamp_crcf_execute_block(q0, buf_in, 2*_n, buf_out_0);\n    rresamp_crcf_reset(q0);\n    rresamp_crcf_execute_block(q0, buf_in, _n, buf_out_1);\n    for (i=0; i<_m; i++)\n        rresamp_crcf_write(q1, buf_in + _Q*_n - (_m-i)*_Q);\n    rresamp_crcf_execute_block(q1, buf_in + _Q*_n, _n, buf_out_1 + _P*_n);\n    rresamp_crcf_destroy(q0);\n    rresamp_crcf_destroy(q1);\n    for (i=0; i<2*_P*_n; i++) {\n        CONTEND_DELTA( crealf(buf_out_0[i]), crealf(buf_out_1[i]), tol );\n        CONTEND_DELTA( cimagf(buf_out_0[i]), cimagf(buf_out_1[i]), tol );\n    }\n}\n//...')
"
"(""Prompt: Write a C function that takes in a 'fec_scheme' enum type as input and returns 1 if the scheme is LIQUID_FEC_REP3 or LIQUID_FEC_REP5, and 0 otherwise. Include a switch statement in the implementation.","//...\nint fec_scheme_is_repeat(fec_scheme _scheme)\n{\n    switch (_scheme) {\n    case LIQUID_FEC_REP3:\n    case LIQUID_FEC_REP5:\n        return 1;\n    default:;\n    }\n    return 0;\n}\n//...')
"
"('Prompt: Please write a function that performs an automated test for pilot synchronization using the given parameters. The function should take in a modulation scheme, payload length, pilot spacing, carrier frequency offset, carrier phase offset, channel gain, and SNR in dB as input parameters. In the test, random symbols are generated and modulated using the specified modulation scheme. Pilots are inserted into the frame, transmitted over a noisy channel with specified SNR, and then the received signal is processed to extract the payload symbols. The function should calculate and display the received bit errors, estimated carrier frequency offset, estimated carrier phase offset, estimated channel gain, and error vector magnitude. It should also perform various tests to verify the correctness of the synchronization algorithm and clean up allocated resources after the test. Additionally, please include a specific test case for a payload length of 200 symbols with a pilot spacing of 20 symbols, using QPSK modulation, carrier frequency offset of 0.07, carrier phase offset of ","//...\nvoid qpilotsync_test(modulation_scheme _ms,\n                     unsigned int      _payload_len,\n                     unsigned int      _pilot_spacing,\n                     float             _dphi,\n                     float             _phi,\n                     float             _gamma,\n                     float             _SNRdB)\n{\n    unsigned int i;\n    float nstd = powf(10.0f, -_SNRdB/20.0f);\n    qpilotgen  pg = qpilotgen_create( _payload_len, _pilot_spacing);\n    qpilotsync ps = qpilotsync_create(_payload_len, _pilot_spacing);\n    unsigned int frame_len = qpilotgen_get_frame_len(pg);\n    CONTEND_EQUALITY(frame_len, qpilotsync_get_frame_len(ps));\n    unsigned char payload_sym_tx[_payload_len]; \n    float complex payload_tx    [_payload_len]; \n    float complex frame_tx      [frame_len];    \n    float complex frame_rx      [frame_len];    \n    float complex payload_rx    [_payload_len]; \n    unsigned char payload_sym_rx[_payload_len]; \n    modemcf mod = modemcf_create(_ms);\n    modemcf dem = modemcf_create(_ms);\n    for (i=0; i<_payload_len; i++) {\n        payload_sym_tx[i] = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod, payload_sym_tx[i], &payload_tx[i]);\n    }\n    qpilotgen_execute(pg, payload_tx, frame_tx);\n    for (i=0; i<frame_len; i++) {\n        frame_rx[i]  = frame_tx[i] * cexpf(_Complex_I*_dphi*i + _Complex_I*_phi);\n        frame_rx[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n        frame_rx[i] *= _gamma;\n    }\n    qpilotsync_execute(ps, frame_rx, payload_rx);\n    for (i=0; i<_payload_len; i++) {\n        unsigned int sym_demod;\n        modemcf_demodulate(dem, payload_rx[i], &sym_demod);\n        payload_sym_rx[i] = (unsigned char)sym_demod;\n    }\n    unsigned int bit_errors = 0;\n    for (i=0; i<_payload_len; i++)\n        bit_errors += count_bit_errors(payload_sym_rx[i], payload_sym_tx[i]);\n    float dphi_hat  = qpilotsync_get_dphi(ps);\n    float phi_hat   = qpilotsync_get_phi (ps);\n    float gamma_hat = qpilotsync_get_gain(ps);\n    float evm_hat   = qpilotsync_get_evm (ps);\n    if (liquid_autotest_verbose) {\n        qpilotgen_print(pg);\n        printf(""  received bit errors : %u / %u\\n"", bit_errors, _payload_len * modemcf_get_bps(mod));\n        printf(""  dphi (carrier freq.): %12.8f (expected %12.8f, error=%12.8f)\\n"", dphi_hat,  _dphi, _dphi-dphi_hat);\n        printf(""  phi  (carrier phase): %12.8f (expected %12.8f, error=%12.8f)\\n"", phi_hat,   _phi, _phi-phi_hat);\n        printf(""  gamma (channel gain): %12.8f (expected %12.8f, error=%12.8f)\\n"", gamma_hat, _gamma, _gamma-gamma_hat);\n        printf(""  error vector mag.   : %12.8f (expected %12.8f, error=%12.8f)\\n"", evm_hat,   -_SNRdB,_SNRdB+evm_hat);\n    }\n    CONTEND_DELTA   (   dphi_hat,  _dphi, 0.010f );\n    CONTEND_DELTA   (    phi_hat,   _phi, 0.087f );  \n    CONTEND_DELTA   (  gamma_hat, _gamma, 0.010f );\n    CONTEND_EQUALITY( bit_errors, 0 );\n    qpilotgen_destroy(pg);\n    qpilotsync_destroy(ps);\n    modemcf_destroy(mod);\n    modemcf_destroy(dem);\n#if 0\n    FILE * fp = fopen(""qpilotsync_errors.txt"", ""a"");\n    fprintf(fp,""%12.4e %12.4e %12.4e %12.4e\\n"",dphi_hat-_dphi,phi_hat-_phi,gamma_hat-_gamma,evm_hat+_SNRdB);\n    fclose(fp);\n#endif\n#if 0 \n    char filename[256];\n    sprintf(filename,""autotest/logs/qpilotsync_autotest_%u_%u_debug.m"", _payload_len, _pilot_spacing);\n    FILE * fid = fopen(filename,""w"");\n    if (!fid) {\n        liquid_error(LIQUID_EIO,""could not open \'%s\' for writing"", filename);\n        return;\n    }\n    fprintf(fid,""%% %s : auto-generated file\\n"", filename);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""payload_len = %u;\\n"", _payload_len);\n    fprintf(fid,""frame_len   = %u;\\n"", frame_len);\n    fprintf(fid,""frame_tx   = zeros(1,frame_len);\\n"");\n    fprintf(fid,""payload_rx = zeros(1,payload_len);\\n"");\n    for (i=0; i<frame_len; i++)\n        fprintf(fid,""frame_rx(%6u) = %12.4e + 1i*%12.4e;\\n"", i+1, crealf(frame_rx[i]), cimagf(frame_rx[i]));\n    for (i=0; i<_payload_len; i++)\n        fprintf(fid,""payload_rx(%6u) = %12.4e + 1i*%12.4e;\\n"", i+1, crealf(payload_rx[i]), cimagf(payload_rx[i]));\n    fprintf(fid,""figure(\'Color\',\'white\',\'position\',[100 100 950 400]);\\n"");\n    fprintf(fid,""subplot(1,2,1);\\n"");\n    fprintf(fid,""  plot(real(frame_rx),  imag(frame_rx),  \'x\',\'MarkerSize\',3);\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.5);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'real\');\\n"");\n    fprintf(fid,""  ylabel(\'imag\');\\n"");\n    fprintf(fid,""  title(\'received\');\\n"");\n    fprintf(fid,""subplot(1,2,2);\\n"");\n    fprintf(fid,""  plot(real(payload_rx),imag(payload_rx),\'x\',\'MarkerSize\',3);\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.5);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'real\');\\n"");\n    fprintf(fid,""  ylabel(\'imag\');\\n"");\n    fprintf(fid,""  title(\'recovered\');\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", filename);\n#endif\n}\nvoid autotest_qpilotsync_200_20() { qpilotsync_test(LIQUID_MODEM_QPSK, 200, 20, 0.07f, 1.2f, 0.7f, 40.0f); }\n//...')
"
"('Please provide a prompt in which you want to test the functionality of a finite impulse response polyphase filter bank channelizer with time-varying coefficients. During the test, you want to verify the correctness of the filter bank by comparing the output signal with the input signal and calculating the root mean square error. Additionally, you want to print the root mean square error if the test is run in verbose mode.","//...\nvoid firpfbch2_crcf_runtest(unsigned int _M,\n                            unsigned int _m,\n                            float        _as)\n{\n    float tol = 1e-3f;\n    unsigned int i;\n    unsigned int num_symbols = 8*_m;    \n    unsigned int num_samples = _M * num_symbols;\n    float complex x[num_samples];\n    float complex y[num_samples];\n    unsigned int s = 1;         \n    unsigned int p = 524287;    \n    unsigned int g =   1031;    \n    for (i=0; i<num_samples; i++) {\n        s = (s * p) % g;\n        x[i] = (float)s / (float)g - 0.5f;\n    }\n    firpfbch2_crcf qa = firpfbch2_crcf_create_kaiser(LIQUID_ANALYZER,    _M, _m, _as);\n    firpfbch2_crcf qs = firpfbch2_crcf_create_kaiser(LIQUID_SYNTHESIZER, _M, _m, _as);\n    float complex Y[_M];\n    for (i=0; i<num_samples; i+=_M/2) {\n        firpfbch2_crcf_execute(qa, &x[i], Y);\n        firpfbch2_crcf_execute(qs, Y, &y[i]);\n    }\n    firpfbch2_crcf_destroy(qa); \n    firpfbch2_crcf_destroy(qs); \n    unsigned int delay = 2*_M*_m - _M/2 + 1;\n    float rmse = 0.0f;\n    for (i=0; i<num_samples; i++) {\n        if (i < delay) {\n            CONTEND_DELTA( crealf(y[i]), 0.0f, tol );\n            CONTEND_DELTA( cimagf(y[i]), 0.0f, tol );\n        } else {\n            CONTEND_DELTA( crealf(y[i]), crealf(x[i-delay]), tol );\n            CONTEND_DELTA( cimagf(y[i]), cimagf(x[i-delay]), tol );\n        }\n        float complex err = y[i] - (i < delay ? 0.0f : x[i-delay]);\n        rmse += crealf(err * conjf(err));\n    }\n    rmse = sqrtf(rmse / (float)num_samples);\n    if (liquid_autotest_verbose)\n        printf(""firpfbch2:  M=%3u, m=%2u, as=%8.2f dB, rmse=%12.4e\\n"", _M, _m, _as, rmse);\n}\nvoid autotest_firpfbch2_crcf_n8()    { firpfbch2_crcf_runtest(   8, 5, 60.0f); }\n//...')
"
'Prompt: You are developing a program in C that requires a function to handle the CTRL+C signal and exit the program gracefully. Please provide the code for a function named `ctrl_c_op` that takes an integer parameter representing the signal number and exits the program with a status code of 0.,//...\nvoid ctrl_c_op(int signo)\n{\n    exit(0);\n}\n//...'
('Prompt: You are working on a signal processing project and need to design a filter using Finite Impulse Response (FIR) technique. You have the specifications for the filter and now need to compute the interpolation and filter taps. Can you provide a code snippet that computes the interpolation and filter taps using Lagrange barycentric interpolation method for the given FIR filter specifications?,"//...\n#define LIQUID_FIRDESPM_DEBUG       0\n    for (i=0; i<_q->grid_size; i++) {\n    for (i=0; i<_q->r+1; i++) {\n        fprintf(fid,""iext(%4u) = %u;\\n"", i+1, _q->iext[i]+1);\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""grid on;\\n"");\n        double f = (double) i / (double)(2*(n-1));\n        double x = cos(2*M_PI*f);\n        double c = poly_val_lagrange_barycentric(_q->x,_q->c,_q->alpha,x,_q->r+1);\n    liquid_firdespm_btype btype = LIQUID_FIRDESPM_BANDPASS;\n    unsigned int h_len = 4*_m + 1;\n    float des[2]     = {1.0f, 0.0f};\n    for (i=0; i<_q->grid_size; i++) {\nint firdespm_compute_interp(firdespm _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->r+1; i++) {\n        _q->x[i] = cos(2*M_PI*_q->F[_q->iext[i]]);\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n        printf(""x[%3u] = %12.8f\\n"", i, _q->x[i]);\n#endif\n    }\n    poly_fit_lagrange_barycentric(_q->x,_q->r+1,_q->alpha);\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n    for (i=0; i<_q->r+1; i++)\n        printf(""a[%3u] = %12.8f\\n"", i, _q->alpha[i]);\n#endif\n    double t0 = 0.0;    \n    double t1 = 0.0;    \n    for (i=0; i<_q->r+1; i++) {\n        t0 += _q->alpha[i] * _q->D[_q->iext[i]];\n        t1 += _q->alpha[i] / _q->W[_q->iext[i]] * (i % 2 ? -1.0 : 1.0);\n    }\n    _q->rho = t0/t1;\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n    printf(""  rho   :   %12.4e\\n"", _q->rho);\n    printf(""\\n"");\n#endif\n    for (i=0; i<_q->r+1; i++) {\n        _q->c[i] = _q->D[_q->iext[i]] - (i % 2 ? -1 : 1) * _q->rho / _q->W[_q->iext[i]];\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n        printf(""c[%3u] = %16.8e\\n"", i, _q->c[i]);\n#endif\n    }\n    return LIQUID_OK;\n}\nint firdespm_compute_taps(firdespm _q, float * _h)\n{\n    unsigned int i;\n    firdespm_compute_interp(_q);\n    unsigned int p = _q->r - _q->s + 1;\n    double G[p];\n    for (i=0; i<p; i++) {\n        double f = (double)(i) / (double)(_q->h_len);\n        double xf = cos(2*M_PI*f);\n        double cf = poly_val_lagrange_barycentric(_q->x,_q->c,_q->alpha,xf,_q->r+1);\n        double g=1.0;\n        if (_q->btype == LIQUID_FIRDESPM_BANDPASS && _q->s==1) {\n            g = 1.0;\n        } else if (_q->btype == LIQUID_FIRDESPM_BANDPASS && _q->s==0) {\n            g = cos(M_PI * i / _q->h_len);\n        } else if (_q->btype != LIQUID_FIRDESPM_BANDPASS && _q->s==1) {\n        } else if (_q->btype != LIQUID_FIRDESPM_BANDPASS && _q->s==0) {\n        }\n        G[i] = cf * g;\n    }\n    unsigned int j;\n    if (_q->btype == LIQUID_FIRDESPM_BANDPASS) {\n        for (i=0; i<_q->h_len; i++) {\n            double v = G[0];\n            double f = ((double)i - (double)(p-1) + 0.5*(1-_q->s)) / (double)(_q->h_len);\n            for (j=1; j<_q->r; j++)\n                v += 2.0 * G[j] * cos(2*M_PI*f*j);\n            _h[i] = v / (double)(_q->h_len);\n        }\n    } else if (_q->btype != LIQUID_FIRDESPM_BANDPASS && _q->s==1) {\n        return liquid_error(LIQUID_EINT,""firdespm_compute_taps(), filter configuration not yet supported"");\n    } else if (_q->btype != LIQUID_FIRDESPM_BANDPASS && _q->s==0) {\n        return liquid_error(LIQUID_EINT,""firdespm_compute_taps(), filter configuration not yet supported"");\n    }\n#if LIQUID_FIRDESPM_DEBUG_PRINT\n    printf(""\\n"");\n    for (i=0; i<_q->h_len; i++)\n        printf(""h(%3u) = %12.8f;\\n"", i+1, _h[i]);\n#endif\n    return LIQUID_OK;\n}\n//...')
"
"'Please provide the prompt to write a code snippet that defines and implements a SPI bus using LPC24XX SSP (Synchronous Serial Port) for communication on an ARM Cortex-M microcontroller. The code should include structures for configuring the SSP, setting up the SSP for communication, handling SPI message transfers, managing interrupts, and registering the SSP buses for communication on different SPI channels.","typedef struct {\n  spi_bus base;\n  volatile lpc24xx_ssp *regs;\n  size_t tx_todo;\n  const uint8_t *tx_buf;\n  size_t tx_inc;\n  size_t rx_todo;\n  uint8_t *rx_buf;\n  size_t rx_inc;\n  const spi_ioc_transfer *msg;\n  uint32_t msg_todo;\n  int msg_error;\n  rtems_binary_semaphore sem;\n  lpc24xx_module module;\n  rtems_vector_number irq;\n} lpc24xx_ssp_bus;\ntypedef struct {\n  volatile lpc24xx_ssp *regs;\n  lpc24xx_module module;\n  rtems_vector_number irq;\n} lpc24xx_ssp_config;\nstatic uint8_t lpc24xx_ssp_trash;\nstatic const uint8_t lpc24xx_ssp_idle = 0xff;\nstatic void lpc24xx_ssp_done(lpc24xx_ssp_bus *bus, int error)\n{\n  bus->msg_error = error;\n  rtems_binary_semaphore_post(&bus->sem);\n}\nstatic int lpc24xx_ssp_do_setup(\n  lpc24xx_ssp_bus *bus,\n  uint32_t speed_hz,\n  uint32_t mode\n)\n{\n  volatile lpc24xx_ssp *regs;\n  uint32_t clk;\n  uint32_t scr_plus_one;\n  uint32_t cr0;\n  if (speed_hz > bus->base.max_speed_hz || speed_hz == 0) {\n    return -EINVAL;\n  }\n  if ((mode & ~(SPI_CPOL | SPI_CPHA)) != 0) {\n    return -EINVAL;\n  }\n  regs = bus->regs;\n  clk = bus->base.max_speed_hz;\n  scr_plus_one = (clk + speed_hz - 1) / speed_hz;\n  if (scr_plus_one > 256) {\n    uint32_t pre;\n    pre = (scr_plus_one + 255) / 256;\n    if (pre <= 127) {\n      scr_plus_one = (clk / pre + speed_hz - 1) / speed_hz;\n    } else {\n      pre = 127;\n      scr_plus_one = 256;\n    }\n    regs->cpsr = 2 * pre;\n  }\n  cr0 = SET_SSP_CR0_DSS(0, 0x7) | SET_SSP_CR0_SCR(0, scr_plus_one - 1);\n  if ((mode & SPI_CPOL) != 0) {\n    cr0 |= SSP_CR0_CPOL;\n  }\n  if ((mode & SPI_CPHA) != 0) {\n    cr0 |= SSP_CR0_CPHA;\n  }\n  regs->cr0 = cr0;\n  bus->base.speed_hz = speed_hz;\n  bus->base.mode = mode;\n  return 0;\n}\nstatic bool lpc24xx_ssp_msg_setup(\n  lpc24xx_ssp_bus *bus,\n  const spi_ioc_transfer *msg\n)\n{\n  if (msg->cs_change == 0 || msg->bits_per_word != 8) {\n    lpc24xx_ssp_done(bus, -EINVAL);\n    return false;\n  }\n  if (msg->speed_hz != bus->base.speed_hz || msg->mode != bus->base.mode) {\n    int error;\n    error = lpc24xx_ssp_do_setup(bus, msg->speed_hz, msg->mode);\n    if (error != 0) {\n      lpc24xx_ssp_done(bus, error);\n      return false;\n    }\n  }\n  bus->tx_todo = msg->len;\n  bus->rx_todo = msg->len;\n  if (msg->tx_buf != NULL) {\n    bus->tx_buf = msg->tx_buf;\n    bus->tx_inc = 1;\n  } else {\n    bus->tx_buf = &lpc24xx_ssp_idle;\n    bus->tx_inc = 0;\n  }\n  if (msg->rx_buf != NULL) {\n    bus->rx_buf = msg->rx_buf;\n    bus->rx_inc = 1;\n  } else {\n    bus->rx_buf = &lpc24xx_ssp_trash;\n    bus->rx_inc = 0;\n  }\n  return true;\n}\nstatic bool lpc24xx_ssp_do_tx_and_rx(\n  lpc24xx_ssp_bus *bus,\n  volatile lpc24xx_ssp *regs,\n  uint32_t sr\n)\n{\n  size_t tx_todo;\n  const uint8_t *tx_buf;\n  size_t tx_inc;\n  size_t rx_todo;\n  uint8_t *rx_buf;\n  size_t rx_inc;\n  uint32_t imsc;\n  tx_todo = bus->tx_todo;\n  tx_buf = bus->tx_buf;\n  tx_inc = bus->tx_inc;\n  rx_todo = bus->rx_todo;\n  rx_buf = bus->rx_buf;\n  rx_inc = bus->rx_inc;\n  while (tx_todo > 0 && (sr & SSP_SR_TNF) != 0) {\n    regs->dr = *tx_buf;\n    --tx_todo;\n    tx_buf += tx_inc;\n    if (rx_todo > 0 && (sr & SSP_SR_RNE) != 0) {\n      *rx_buf = regs->dr;\n      --rx_todo;\n      rx_buf += rx_inc;\n    }\n    sr = regs->sr;\n  }\n  while (rx_todo > 0 && (sr & SSP_SR_RNE) != 0) {\n    *rx_buf = regs->dr;\n    --rx_todo;\n    rx_buf += rx_inc;\n    sr = regs->sr;\n  }\n  bus->tx_todo = tx_todo;\n  bus->tx_buf = tx_buf;\n  bus->rx_todo = rx_todo;\n  bus->rx_buf = rx_buf;\n  imsc = 0;\n  if (tx_todo > 0) {\n    imsc |= SSP_IMSC_TXIM;\n  } else if (rx_todo > 0) {\n    imsc |= SSP_IMSC_RXIM | SSP_IMSC_RTIM;\n    regs->icr = SSP_ICR_RTRIS;\n  }\n  regs->imsc = imsc;\n  return tx_todo == 0 && rx_todo == 0;\n}\nstatic void lpc24xx_ssp_start(\n  lpc24xx_ssp_bus *bus,\n  const spi_ioc_transfer *msg\n)\n{\n  while (true) {\n    if (lpc24xx_ssp_msg_setup(bus, msg)) {\n      volatile lpc24xx_ssp *regs;\n      uint32_t sr;\n      bool next_msg;\n      regs = bus->regs;\n      sr = regs->sr;\n      if ((sr & (SSP_SR_RNE | SSP_SR_TFE)) != SSP_SR_TFE) {\n        lpc24xx_ssp_done(bus, -EIO);\n        break;\n      }\n      next_msg = lpc24xx_ssp_do_tx_and_rx(bus, regs, sr);\n      if (!next_msg) {\n        break;\n      }\n      --bus->msg_todo;\n      if (bus->msg_todo == 0) {\n        lpc24xx_ssp_done(bus, 0);\n        break;\n      }\n      ++msg;\n      bus->msg = msg;\n    } else {\n      break;\n    }\n  }\n}\nstatic void lpc24xx_ssp_interrupt(void *arg)\n{\n  lpc24xx_ssp_bus *bus;\n  volatile lpc24xx_ssp *regs;\n  bus = arg;\n  regs = bus->regs;\n  while (true) {\n    if (lpc24xx_ssp_do_tx_and_rx(bus, regs, regs->sr)) {\n      --bus->msg_todo;\n      if (bus->msg_todo > 0) {\n        ++bus->msg;\n        if (!lpc24xx_ssp_msg_setup(bus, bus->msg)) {\n          break;\n        }\n      } else {\n        lpc24xx_ssp_done(bus, 0);\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n}\nstatic int lpc24xx_ssp_transfer(\n  spi_bus *base,\n  const spi_ioc_transfer *msgs,\n  uint32_t msg_count\n)\n{\n  lpc24xx_ssp_bus *bus;\n  if (msg_count == 0) {\n    return 0;\n  }\n  bus = (lpc24xx_ssp_bus *) base;\n  bus->msg = msgs;\n  bus->msg_todo = msg_count;\n  lpc24xx_ssp_start(bus, msgs);\n  rtems_binary_semaphore_wait(&bus->sem);\n  return bus->msg_error;\n}\nstatic void lpc24xx_ssp_destroy(spi_bus *base)\n{\n  lpc24xx_ssp_bus *bus;\n  rtems_status_code sc;\n  bus = (lpc24xx_ssp_bus *) base;\n  sc = rtems_interrupt_handler_remove(\n    bus->irq,\n    lpc24xx_ssp_interrupt,\n    bus\n  );\n  _Assert(sc == RTEMS_SUCCESSFUL);\n  (void) sc;\n  bus->regs->cr1 = 0;\n  sc = lpc24xx_module_disable(bus->module);\n  _Assert(sc == RTEMS_SUCCESSFUL);\n  (void) sc;\n  rtems_binary_semaphore_destroy(&bus->sem);\n  spi_bus_destroy_and_free(&bus->base);\n}\nstatic int lpc24xx_ssp_setup(spi_bus *base)\n{\n  lpc24xx_ssp_bus *bus;\n  bus = (lpc24xx_ssp_bus *) base;\n  if (bus->base.bits_per_word != 8) {\n    return -EINVAL;\n  }\n  return lpc24xx_ssp_do_setup(bus, bus->base.speed_hz, bus->base.mode);\n}\nstatic int lpc24xx_ssp_init(lpc24xx_ssp_bus *bus)\n{\n  rtems_status_code sc;\n  sc = lpc24xx_module_enable(bus->module, LPC24XX_MODULE_PCLK_DEFAULT);\n  _Assert(sc == RTEMS_SUCCESSFUL);\n  (void) sc;\n  bus->regs->cr1 = 0;\n  sc = rtems_interrupt_handler_install(\n    bus->irq,\n    ""SSP"",\n    RTEMS_INTERRUPT_UNIQUE,\n    lpc24xx_ssp_interrupt,\n    bus\n  );\n  if (sc != RTEMS_SUCCESSFUL) {\n    return EAGAIN;\n  }\n  rtems_binary_semaphore_init(&bus->sem, ""SSP"");\n  bus->regs->dmacr = 0;\n  bus->regs->imsc = 0;\n  bus->regs->cpsr = 2;\n  bus->regs->cr0 = SET_SSP_CR0_DSS(0, 0x7);\n  bus->regs->cr1 = SSP_CR1_SSE;\n  return 0;\n}\nstatic int spi_bus_register_lpc24xx_ssp(\n  const char *bus_path,\n  const lpc24xx_ssp_config *config\n)\n{\n  lpc24xx_ssp_bus *bus;\n  int eno;\n  bus = (lpc24xx_ssp_bus *) spi_bus_alloc_and_init(sizeof(*bus));\n  if (bus == NULL) {\n    return -1;\n  }\n  bus->base.max_speed_hz = LPC24XX_PCLK / 2;\n  bus->base.bits_per_word = 8;\n  bus->base.speed_hz = bus->base.max_speed_hz;\n  bus->regs = config->regs;\n  bus->module = config->module;\n  bus->irq = config->irq;\n  eno = lpc24xx_ssp_init(bus);\n  if (eno != 0) {\n    (*bus->base.destroy)(&bus->base);\n    rtems_set_errno_and_return_minus_one(eno);\n  }\n  bus->base.transfer = lpc24xx_ssp_transfer;\n  bus->base.destroy = lpc24xx_ssp_destroy;\n  bus->base.setup = lpc24xx_ssp_setup;\n  return spi_bus_register(&bus->base, bus_path);\n}\nint lpc24xx_register_ssp_0(void)\n{\n  static const lpc24xx_ssp_config config = {\n    .regs = (volatile lpc24xx_ssp *) SSP0_BASE_ADDR,\n    .module = LPC24XX_MODULE_SSP_0,\n    .irq = LPC24XX_IRQ_SPI_SSP_0\n  };\n  return spi_bus_register_lpc24xx_ssp(\n    LPC24XX_SSP_0_BUS_PATH,\n    &config\n  );\n}\nint lpc24xx_register_ssp_1(void)\n{\n  static const lpc24xx_ssp_config config = {\n    .regs = (volatile lpc24xx_ssp *) SSP1_BASE_ADDR,\n    .module = LPC24XX_MODULE_SSP_1,\n    .irq = LPC24XX_IRQ_SSP_1\n  };\n  return spi_bus_register_lpc24xx_ssp(\n    LPC24XX_SSP_2_BUS_PATH,\n    &config\n  );\n}\n#ifdef ARM_MULTILIB_ARCH_V7M\nint lpc24xx_register_ssp_2(void)\n{\n  static const lpc24xx_ssp_config config = {\n    .regs = (volatile lpc24xx_ssp *) SSP2_BASE_ADDR,\n    .module = LPC24XX_MODULE_SSP_2,\n    .irq = LPC24XX_IRQ_SSP_2\n  };\n  return spi_bus_register_lpc24xx_ssp(\n    LPC24XX_SSP_2_BUS_PATH,\n    &config\n  );\n}\n#endif'"
"('Prompt: You have a software module that designs prototype filters for digital signal processing. Please create a testbench function that validates the prototype filter design for a raised cosine filter using a specific set of parameters. The function should compute the filter characteristics, generate a PSD plot, and save the results to a file. The raised cosine filter should have a roll-off factor of 0.3 and a stopband attenuation of 45dB. The testbench function should be named `autotest_firdes_prototype_rrcos`.","//...\nvoid testbench_firdes_prototype(const char * _type,\n                                unsigned int _k,\n                                unsigned int _m,\n                                float        _beta,\n                                float        _as)\n{\n    unsigned int h_len = 2*_k*_m+1;\n    float        h[h_len];\n    liquid_firfilt_type type = liquid_getopt_str2firfilt(_type);\n    if (type == LIQUID_FIRFILT_UNKNOWN) {\n        AUTOTEST_FAIL(""invalid configuration"");\n        return;\n    }\n    liquid_firdes_prototype(type, _k, _m, _beta, 0.0f, h);\n    liquid_vectorf_mulscalar(h, h_len, 1.0f/(float)_k, h);\n    float bw = 1.0f / (float)_k;\n    float f0 = 0.45*bw*(1-_beta);\n    float f1 = 0.55*bw*(1+_beta);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5,.fmax=-f1, .pmin= 0, .pmax=-_as, .test_lo=0, .test_hi=1},\n      {.fmin=-f0, .fmax= f0, .pmin=-1, .pmax=+1,   .test_lo=1, .test_hi=1},\n      {.fmin= f1, .fmax=+0.5,.pmin= 0, .pmax=-_as, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/firdes_prototype_%s.m"", _type);\n    liquid_autotest_validate_psd_signalf(h, h_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\nvoid autotest_firdes_prototype_rrcos    (){ testbench_firdes_prototype(""rrcos"",    4, 12, 0.3f, 45.0f); }\n//...')
"
"(""Prompt: You are testing a multi-stage resampler in C. The first testbench function `testbench_msresamp_crcf` sets up a scenario where a resampler is created with specific parameters and processes a signal, then validates its output spectrum against predefined regions. The second testbench function `testbench_msresamp_crcf_num_output` tests the `msresamp_crcf_get_num_output` function with different input sizes to ensure the output size is correct. Provide code that sets up these test scenarios for the resampler.. . Technical scenario: You are developing a digital signal processing application that involves resampling signals. To ensure accurate and efficient resampling, you have implemented a multi-stage resampler in C. The first testbench function `testbench_msresamp_crcf` is used to validate the resampler's output spectrum by processing a signal and comparing the output power spectral density against predefined regions. The second testbench function `testbench_msresamp_crcf_num_output` is","//...\nvoid testbench_msresamp_crcf(float r, float As)\n{\n    unsigned int n=800000;      \n    float bw = 0.2f; \n    unsigned int nfft = 800;\n    float tol = 0.5f;\n    spgramcf     q   = spgramcf_create(nfft, LIQUID_WINDOW_HANN, nfft/2, nfft/4);\n    symstreamrcf gen = symstreamrcf_create_linear(LIQUID_FIRFILT_KAISER,r*bw,25,0.2f,LIQUID_MODEM_QPSK);\n    symstreamrcf_set_gain(gen, sqrtf(bw));\n    msresamp_crcf resamp = msresamp_crcf_create(r,As);\n    unsigned int  buf_len = 256;\n    float complex buf_0[buf_len]; \n    float complex buf_1[buf_len]; \n    while (spgramcf_get_num_samples_total(q) < n) {\n        symstreamrcf_write_samples(gen, buf_0, buf_len);\n        unsigned int nw = 0;\n        msresamp_crcf_execute(resamp, buf_0, buf_len, buf_1, &nw);\n        spgramcf_write(q, buf_1, nw);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/msresamp_crcf_r%.3u_a%.2u_autotest.m"", (int)(r*1000), (int)(As));\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    spgramcf_destroy(q);\n    symstreamrcf_destroy(gen);\n    msresamp_crcf_destroy(resamp);\n}\nvoid testbench_msresamp_crcf_num_output(float _rate)\n{\n    if (liquid_autotest_verbose)\n        printf(""testing msresamp_crcf_get_num_output() with r=%g\\n"", _rate);\n    float As = 60.0f;\n    msresamp_crcf q = msresamp_crcf_create(_rate, As);\n    unsigned int s = _rate < 0.1f ? 131 : 1; \n    unsigned int sizes[10] = {1*s, 2*s, 3*s, 20*s, 7*s, 64*s, 4*s, 4*s, 4*s, 27*s};\n    unsigned int max_input = 64*s;\n    unsigned int max_output = 16 + (unsigned int)(4.0f * max_input * _rate);\n    printf(""max_input : %u, max_output : %u\\n"", max_input, max_output);\n    float complex buf_0[max_input];\n    float complex buf_1[max_output];\n    unsigned int i;\n    for (i=0; i<max_input; i++)\n        buf_0[i] = 0.0f;\n    unsigned int b;\n    for (b=0; b<8; b++) {\n        for (i=0; i<10; i++) {\n            unsigned int num_input  = sizes[i];\n            unsigned int num_output = msresamp_crcf_get_num_output(q, num_input);\n            unsigned int num_written;\n            msresamp_crcf_execute(q, buf_0, num_input, buf_1, &num_written);\n            if (liquid_autotest_verbose) {\n                printf("" b[%2u][%2u], num_input:%5u, num_output:%5u, num_written:%5u\\n"",\n                        b, i, num_input, num_output, num_written);\n            }\n            CONTEND_EQUALITY(num_output, num_written)\n        }\n    }\n    msresamp_crcf_destroy(q);\n}\n//...')
"
"(""Prompt: Can you provide code for a test harness function that performs linear predictive coding (LPC) using a lowpass filter and compares the results with a given tolerance value?. . Technical Scenario: You have a requirement to create a test harness function for LPC algorithm evaluation. The function should initialize a lowpass filter with given specifications, generate random samples using a m-sequence generator, apply the lowpass filter to the samples, calculate LPC coefficients using the 'liquid_lpc' function, create an LPC filter using the calculated coefficients, and then compare the output of the lowpass and LPC filters. The function should calculate the Root Mean Square Error (RMSE) between the outputs and output the result. Additionally, the function should print the filter details if in verbose mode and check if the RMSE is below a specified tolerance. Finally, the function should clean up by destroying the filters and m-sequence generator. . . You can use the provided code snippet as a reference for implementing the test harness function.","//...\nvoid lpc_test_harness(unsigned int _n,\n                      unsigned int _p,\n                      float        _fc,\n                      float        _tol)\n{\n    iirfilt_rrrf lowpass = iirfilt_rrrf_create_lowpass(7,_fc);\n    float y[_n];         \n    float a_hat[_p+1];   \n    float g_hat[_p+1];   \n    unsigned int i;\n    msequence ms = msequence_create_default(15);\n    for (i=0; i<_n; i++) {\n        float v = (float)msequence_generate_symbol(ms,10)/1023.0f - 0.5f;\n        iirfilt_rrrf_execute(lowpass, v, &y[i]);\n    }\n    liquid_lpc(y,_n,_p,a_hat,g_hat);\n    float a_lpc[_p+1];\n    float b_lpc[_p+1];\n    for (i=0; i<_p+1; i++) {\n        a_lpc[i] = (i==0) ? 1.0f : 0.0f;\n        b_lpc[i] = (i==0) ? 0.0f : -a_hat[i];\n    }\n    iirfilt_rrrf lpc = iirfilt_rrrf_create(b_lpc,_p+1, a_lpc,_p+1);\n    float rmse = 0.0f;\n    unsigned int n_error = 5000;\n    for (i=0; i<n_error; i++) {\n        float v = (float)msequence_generate_symbol(ms,10)/1023.0f - 0.5f;\n        float s0, s1;\n        iirfilt_rrrf_execute(lowpass, v,  &s0); \n        iirfilt_rrrf_execute(lpc,     s0, &s1); \n        rmse += (s0-s1)*(s0-s1);\n    }\n    rmse = 10*log10f( rmse / (float)n_error );\n    if (liquid_autotest_verbose) {\n        printf(""original lowpass filter:\\n"");\n        iirfilt_rrrf_print(lowpass);\n        printf(""linear predictive filter:\\n"");\n        iirfilt_rrrf_print(lpc);\n        printf(""lpc(n=%u,p=%u,fc=%.3f), rmse: %.2f (tol: %.2f) dB\\n"", _n, _p, _fc, rmse, _tol);\n    }\n    CONTEND_LESS_THAN(rmse, _tol);\n    iirfilt_rrrf_destroy(lowpass);\n    iirfilt_rrrf_destroy(lpc);\n    msequence_destroy(ms);\n}\nvoid autotest_lpc_p16() { lpc_test_harness(1600, 16, 0.055, -40.0f); }\n//...')
"
"'Prompt: You are developing a low-level driver for a Multi-Level Cell (MLC) flash memory on an embedded system. Your task is to implement a function that writes data to a range of blocks within the flash memory. The function should handle block erasing, writing pages with error correction code (ECC), and managing spare areas. The given code snippet shows a function `lpc32xx_mlc_write_blocks` that performs these tasks. Your prompt is to provide the implementation details for this function.","static const uint32_t ones_spare [MLC_LARGE_SPARE_WORD_COUNT] = {\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff,\n  0xffffffff\n};\nrtems_status_code lpc32xx_mlc_write_blocks(\n  uint32_t block_begin,\n  uint32_t block_end,\n  const void *src,\n  size_t src_size,\n  uint32_t *page_data_buffer\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  uint32_t pages_per_block = lpc32xx_mlc_pages_per_block();\n  uint32_t block_count = lpc32xx_mlc_block_count();\n  uint32_t page_size = lpc32xx_mlc_page_size();\n  uint32_t block = 0;\n  const uint8_t *current = src;\n  const uint8_t *last = current;\n  const uint8_t *end = current + src_size;\n  if (block_begin > block_end || block_end > block_count) {\n    return RTEMS_INVALID_ID;\n  }\n  for (block = block_begin; block != block_end; ++block) {\n    uint32_t page_begin = block * pages_per_block;\n    uint32_t page_end = page_begin + pages_per_block;\n    uint32_t page = 0;\n    sc = lpc32xx_mlc_erase_block_safe_3(block, page_begin, page_end);\n    if (sc != RTEMS_SUCCESSFUL) {\n      continue;\n    }\n    for (page = page_begin; page < page_end; ++page) {\n      uintptr_t remainder = (uintptr_t) end - (uintptr_t) current;\n      size_t delta = remainder < page_size ? remainder : page_size;\n      if (remainder > 0) {\n        memcpy(page_data_buffer, current, delta);\n        sc = lpc32xx_mlc_write_page_with_ecc(\n          page,\n          page_data_buffer,\n          ones_spare\n        );\n        if (sc != RTEMS_SUCCESSFUL) {\n          lpc32xx_mlc_erase_block(block);\n          lpc32xx_mlc_zero_pages(page_begin, page_end);\n          current = last;\n          continue;\n        }\n        current += delta;\n      } else {\n        goto done;\n      }\n    }\n    last = current;\n  }\ndone:\n  if (current != end) {\n    return RTEMS_IO_ERROR;\n  }\n  return RTEMS_SUCCESSFUL;\n}'"
"'Prompt: . You are building a network application that requires the implementation of TCP and UDP communication functionalities using callback functions. Provide a C code snippet that includes a struct with function pointers to handle TCP socket initialization, sending, receiving, closing, and error handling. Additionally, include a function to initialize a UDP client socket given a host and port, as well as a function to receive data over TCP.","//...\nstruct xfer_callback ptcp_cbs = {\n    ptcp_server_init,\n    ptcp_client_init,\n    _ptcp_send,\n    _ptcp_recv,\n    _ptcp_close,\n    ptcp_errno\n};\n    int fd;\n    struct sockaddr_in si;\n    socklen_t len = sizeof(si);\nstatic void *udp_client_init(const char *host, uint16_t port)\n{\n    int *fd = (int *)calloc(1, sizeof(int));\n    struct sockaddr_in si;\n    *fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    if (-1 == *fd) {\n        printf(""socket: %s\\n"", strerror(errno));\n        return NULL;\n    }\n    si.sin_family = AF_INET;\n    si.sin_addr.s_addr = inet_addr(host);\n    si.sin_port = htons(port);\n    if (-1 == connect(*fd, (struct sockaddr*)&si, sizeof(si))) {\n        printf(""connect: %s\\n"", strerror(errno));\n        close(*fd);\n        return NULL;\n    }\n    return (void *)fd;\n}\nstatic int tcp_recv(void *arg, void *buf, size_t len)\n{\n    int *fd = (int *)arg;\n    return recv(*fd, buf, len, 0);\n}\n//...'"
('Prompt: Design a function in C that disables debugging in a GMSK frame synchronization module. The function should return an integer value indicating successful completion. Assume that the GMSK frame synchronization module contains a prefilter with the defined constant `GMSKFRAMESYNC_PREFILTER` and an unsigned integer variable `m`. . . Response:. ```c. int gmskframesync_debug_disable(gmskframesync _q). {.     return LIQUID_OK;. }. ```,"//...\n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int m;                 \nint gmskframesync_debug_disable(gmskframesync _q)\n{\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are developing a digital signal processing application and you have implemented a function to disable debug mode for a Direct Sequence Spread Spectrum (DSSS) frame synchronization process. However, you are encountering an error message in the function ""dsssframesync_debug_disable()"" stating that the mode is not supported. Can you provide a possible implementation for how this function could handle the error situation?","//...\nint dsssframesync_debug_disable(dsssframesync _q)\n{\n    return liquid_error(LIQUID_EIMODE,""dsssframesync_debug_disable(), mode not supported"");\n}\n//...')
"
"('Prompt: ""In a technical scenario where you are tasked with optimizing the performance of a qdetector signal processing algorithm that analyzes 2048 samples, can you provide a code snippet for a function called \'benchmark_qdetector_cccf_2048\' that measures the execution time of this algorithm?""","//...\nvoid benchmark_qdetector_cccf_2048 Q\n//...')
"
"'Prompt: ""Imagine you are developing a bootloader for a custom embedded system using an NXP i.MX RT microcontroller. The bootloader needs to store initial boot data such as the start address of the flash memory, the size of the flash memory, a plugin flag, and a placeholder value. Can you provide a code snippet in C that defines a constant structure for this boot data, using the given memory and plugin information?""","const BOOT_DATA_T imxrt_boot_data = {\n  .start = (uint32_t) imxrt_memory_flash_raw_begin,\n  .size = IMXRT_MEMORY_FLASH_SIZE,\n  .plugin = PLUGIN_FLAG,\n  .placeholder = 0xFFFFFFFF,\n};'"
"('Prompt: You are working on a project involving signal processing and communication systems. Your task is to implement a function that performs pilot symbol synchronization. The function should take in a structure `_q`, an array of complex floats `_frame`, and an array of complex floats `_payload`. Your function should calculate various metrics for synchronization including the error vector magnitude (EVM). The function should also handle debugging output if a specific flag is enabled. Can you write the C code for this function?","//...\nint qpilotsync_execute(qpilotsync      _q,\n                       float complex * _frame,\n                       float complex * _payload)\n{\n    unsigned int i;\n    unsigned int n = 0;\n    unsigned int p = 0;\n    for (i=0; i<_q->num_pilots; i++) {\n        _q->buf_time[i] = _frame[i*_q->pilot_spacing] * conjf(_q->pilots[i]);\n#if DEBUG_QPILOTSYNC\n        printf(""(%8.4f,%8.4f) = (%8.4f,%8.4f) * conj(%8.4f,%8.4f)\\n"",\n            crealf(_q->buf_time[i]),\n            cimagf(_q->buf_time[i]),\n            crealf(_frame[i*_q->pilot_spacing]),\n            cimagf(_frame[i*_q->pilot_spacing]),\n            crealf(_q->pilots[i]),\n            cimagf(_q->pilots[i]));\n#endif\n    }\n    FFT_EXECUTE(_q->fft);\n    unsigned int i0 = 0;\n    float        y0 = 0;\n    for (i=0; i<_q->nfft; i++) {\n#if DEBUG_QPILOTSYNC\n        printf(""X(%3u) = %12.8f + 1i*%12.8f; %% %12.8f\\n"",\n                i+1, crealf(_q->buf_freq[i]), cimagf(_q->buf_freq[i]), cabsf(_q->buf_freq[i]));\n#endif\n        if (i==0 || cabsf(_q->buf_freq[i]) > y0) {\n            i0 = i;\n            y0 = cabsf(_q->buf_freq[i]);\n        }\n    }\n    unsigned int ineg = (i0 + _q->nfft - 1) % _q->nfft;\n    unsigned int ipos = (i0 +            1) % _q->nfft;\n    float        ypos = cabsf(_q->buf_freq[ipos]);\n    float        yneg = cabsf(_q->buf_freq[ineg]);\n    float        a    =  0.5f*(ypos + yneg) - y0;\n    float        b    =  0.5f*(ypos - yneg);\n    float        idx  = -b / (2.0f*a); \n    float index = (float)i0 + idx;\n    _q->dphi_hat = (i0 > _q->nfft/2 ? index-(float)_q->nfft : index) * 2*M_PI / (float)(_q->nfft * _q->pilot_spacing);\n#if DEBUG_QPILOTSYNC\n    printf(""X[%3u] = %12.8f <%12.8f>\\n"", ineg, yneg, cargf(_q->buf_freq[ineg]));\n    printf(""X[%3u] = %12.8f <%12.8f>\\n"", i0,   y0,   cargf(_q->buf_freq[i0]));\n    printf(""X[%3u] = %12.8f <%12.8f>\\n"", ipos, ypos, cargf(_q->buf_freq[ipos]));\n    printf(""yneg  = %12.8f;\\n"", yneg);\n    printf(""ypos  = %12.8f;\\n"", ypos);\n    printf(""y0    = %12.8f;\\n"", y0);\n    printf(""interpolated peak at %12.8f (%u + %12.8f)\\n"", index, i0, idx);\n#endif\n#if 0\n    float v0 = cargf(_q->buf_freq[ idx < 0 ? ineg : i0   ]);\n    float v1 = cargf(_q->buf_freq[ idx < 0 ? i0   : ipos ]);\n    float xp = idx < 0 ? 1+idx : idx;\n    float phi_hat  = (v1-v0)*xp + v0;\n    float g_hat = (a*idx*idx + b*idx + c) / (float)(_q->num_pilots);\n#else\n    float complex metric = 0;\n    for (i=0; i<_q->num_pilots; i++)\n        metric += _q->buf_time[i] * cexpf(-_Complex_I*_q->dphi_hat*i*(float)(_q->pilot_spacing));\n    _q->phi_hat = cargf(metric);\n    _q->g_hat   = cabsf(metric) / (float)(_q->num_pilots);\n#endif\n    float g = 1.0f / _q->g_hat;\n    _q->evm_hat = 0.0f;\n    for (i=0; i<_q->frame_len; i++) {\n        float complex v = g * _frame[i] * cexpf(-_Complex_I*(_q->dphi_hat*i + _q->phi_hat));\n        if ( (i % _q->pilot_spacing)==0 ) {\n            float complex e = _q->pilots[p] - v;\n            _q->evm_hat += crealf( e * conjf(e) );\n            p++;\n        } else {\n            _payload[n++] = v;\n        }\n    }\n    _q->evm_hat = 10*log10f( _q->evm_hat / (float)(_q->num_pilots) );\n#if DEBUG_QPILOTSYNC\n    printf(""dphi-hat    :   %12.8f\\n"", _q->dphi_hat);\n    printf("" phi-hat    :   %12.8f\\n"",  _q->phi_hat);\n    printf(""   g-hat    :   %12.8f\\n"",    _q->g_hat);\n    printf("" evm-hat    :   %12.8f\\n"",  _q->evm_hat);\n#endif\n    if (n != _q->payload_len)\n        return liquid_error(LIQUID_EINT,""qpilotsync_execute(), unexpected internal payload length"");\n    if (p != _q->num_pilots)\n        return liquid_error(LIQUID_EINT,""qpilotsync_execute(), unexpected internal number of pilots"");\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on testing a Numerically Controlled Oscillator (NCO) with Continuous Phase Frequency Shift Keying (CRCF) modulation. The scenario requires you to create a testbench function called `testbench_nco_crcf_mix` that simulates mixing a signal with a given phase and frequency, applying a modulation, and verifying the output using a tolerance value. You need to generate an input signal `buf_0`, mix it using the `nco_crcf_mix_block_up` function, calculate the expected output `buf_1`, and check if the output matches the expected values within a tolerance level. The phase and frequency of the NCO should be set accordingly. Additionally, you need to implement an automated test function `autotest_nco_crcf_mix_vco_8` that calls the `testbench_nco_crcf_mix` function with specific parameters (type: LIQUID_VCO, phase: 0.000f, frequency: -0","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_vco_8() { testbench_nco_crcf_mix(LIQUID_VCO,  0.000f, -0.123f); }\n//...')
"
"(""Prompt: You are working on a project that involves testing forward error correction (FEC) schemes. Your task is to create a function that tests a specific FEC scheme, but you also need to account for the availability of the 'libfec' library. If the library is not enabled, certain FEC schemes such as convolutional and Reed-Solomon codes should display a warning message. Write a function that tests an FEC scheme by encoding and decoding a random message using the 'fec' library. For example, you should include randomizing the message, encoding the message, introducing an error by flipping a bit, and then decoding the message to check if the error is corrected. Additionally, include an automated test function specifically for the SEC-DED (Single Error Correction, Double Error Detection) code with a message length of 64 bytes.","//...\nvoid fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    fec q = fec_create(_fs,_opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,_n);\n    unsigned char msg[_n];          \n    unsigned char msg_enc[n_enc];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg[i] = rand() & 0xff;\n        msg_dec[i] = 0;\n    }\n    fec_encode(q,_n,msg,msg_enc);\n    msg_enc[0] ^= 0x01;\n    fec_decode(q,_n,msg_enc,msg_dec);\n    CONTEND_SAME_DATA(msg,msg_dec,_n);\n    fec_destroy(q);\n}\nvoid autotest_fec_secded7264() { fec_test_codec(LIQUID_FEC_SECDED7264, 64, NULL); }\n//...')
"
"('Prompt: You are tasked with testing a function that implements a Nyquist filter for GMSK signals in a digital communication system. The function takes in parameters such as filter type, alpha, length of filter, and time step. Can you provide a code snippet that defines a testbench for this function, specifically testing the baseline performance of the filter for a GMSK transmitter and receiver with particular parameters (filter type: GMSKTX, k: 2, m: 9, beta: 0.3, dt: 0.0)? The testbench should calculate metrics such as autocorrelation at lag 0 (rxx[0]), root mean square of the intersymbol interference (isi), and spectral shape (As). The testbench should output these metrics along with expected values and perform assertions based on predefined tolerances. Thank you.","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\nvoid autotest_firfilt_rnyquist_baseline_gmsktxrx (){ testbench_firfilt_rnyquist(LIQUID_FIRFILT_GMSKTX,   2,9,0.3f,0.0f); }\n//...')
"
"('Prompt: You are developing a software application that processes digital communication signals. You need to implement a function that adds noise to a frame of 64 complex floats based on a given signal-to-noise ratio in decibels. The noise should be modeled as complex Gaussian noise with a specific standard deviation. Write a C function that takes a pointer to an array of complex floats and the signal-to-noise ratio in decibels as inputs, and then adds noise to each element in the array according to the SNR provided.","//...\nvoid frame64_add_noise(float complex * _buf, float _SNRdB)\n{\n    float nstd = powf(10.0f, -_SNRdB/20.0f);\n    nstd *= M_SQRT2; \n    unsigned int i;\n    for (i=0; i<LIQUID_FRAME64_LEN; i++)\n        _buf[i] += nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2;\n}\n//...')
"
"'Please provide a prompt detailing a scenario where you need to enable and disable clock control for specific modules in an STM32H7 microcontroller, as well as initialize GPIO and implement polled UART communication functions.","#ifdef HAVE_CONFIG_H\n#endif\nstm32h7_module_index stm32h7_get_module_index(const void *regs)\n{\n  switch ((uintptr_t) regs) {\n    case GPIOA_BASE:\n      return STM32H7_MODULE_GPIOA;\n    case GPIOB_BASE:\n      return STM32H7_MODULE_GPIOB;\n    case GPIOC_BASE:\n      return STM32H7_MODULE_GPIOC;\n    case GPIOD_BASE:\n      return STM32H7_MODULE_GPIOD;\n    case GPIOE_BASE:\n      return STM32H7_MODULE_GPIOE;\n    case GPIOF_BASE:\n      return STM32H7_MODULE_GPIOF;\n    case GPIOG_BASE:\n      return STM32H7_MODULE_GPIOG;\n    case GPIOH_BASE:\n      return STM32H7_MODULE_GPIOH;\n    case GPIOI_BASE:\n      return STM32H7_MODULE_GPIOI;\n    case GPIOJ_BASE:\n      return STM32H7_MODULE_GPIOJ;\n    case GPIOK_BASE:\n      return STM32H7_MODULE_GPIOK;\n    case USART1_BASE:\n      return STM32H7_MODULE_USART1;\n    case USART2_BASE:\n      return STM32H7_MODULE_USART2;\n    case USART3_BASE:\n      return STM32H7_MODULE_USART3;\n    case UART4_BASE:\n      return STM32H7_MODULE_UART4;\n    case UART5_BASE:\n      return STM32H7_MODULE_UART5;\n    case USART6_BASE:\n      return STM32H7_MODULE_USART6;\n    case UART7_BASE:\n      return STM32H7_MODULE_UART7;\n    case UART8_BASE:\n      return STM32H7_MODULE_UART8;\n#ifdef UART9_BASE\n    case UART9_BASE:\n      return STM32H7_MODULE_UART9;\n#endif\n#ifdef USART10_BASE\n    case USART10_BASE:\n      return STM32H7_MODULE_USART10;\n#endif\n    case RNG_BASE:\n      return STM32H7_MODULE_RNG;\n    case SDMMC1_BASE:\n    case DLYB_SDMMC1_BASE:\n      return STM32H7_MODULE_SDMMC1;\n    case SDMMC2_BASE:\n    case DLYB_SDMMC2_BASE:\n      return STM32H7_MODULE_SDMMC2;\n  }\n  return STM32H7_MODULE_INVALID;\n}\ntypedef struct {\n  __IO uint32_t *enr;\n  uint32_t enable_bit;\n} stm32h7_clk_info;\nstatic const stm32h7_clk_info stm32h7_clk[] = {\n  [STM32H7_MODULE_INVALID] = { NULL, 0 },\n  [STM32H7_MODULE_GPIOA] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOAEN },\n  [STM32H7_MODULE_GPIOB] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOBEN },\n  [STM32H7_MODULE_GPIOC] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOCEN },\n  [STM32H7_MODULE_GPIOD] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIODEN },\n  [STM32H7_MODULE_GPIOE] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOEEN },\n  [STM32H7_MODULE_GPIOF] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOFEN },\n  [STM32H7_MODULE_GPIOG] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOGEN },\n  [STM32H7_MODULE_GPIOH] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOHEN },\n  [STM32H7_MODULE_GPIOI] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOIEN },\n  [STM32H7_MODULE_GPIOJ] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOJEN },\n  [STM32H7_MODULE_GPIOK] = { &RCC->AHB4ENR, RCC_AHB4ENR_GPIOKEN },\n  [STM32H7_MODULE_USART1] = { &RCC->APB2ENR, RCC_APB2ENR_USART1EN },\n  [STM32H7_MODULE_USART2] = { &RCC->APB1LENR, RCC_APB1LENR_USART2EN },\n  [STM32H7_MODULE_USART3] = { &RCC->APB1LENR, RCC_APB1LENR_USART3EN },\n  [STM32H7_MODULE_UART4] = { &RCC->APB1LENR, RCC_APB1LENR_UART4EN },\n  [STM32H7_MODULE_UART5] = { &RCC->APB1LENR, RCC_APB1LENR_UART5EN },\n  [STM32H7_MODULE_USART6] = { &RCC->APB2ENR, RCC_APB2ENR_USART6EN },\n  [STM32H7_MODULE_UART7] = { &RCC->APB1LENR, RCC_APB1LENR_UART7EN },\n  [STM32H7_MODULE_UART8] = { &RCC->APB1LENR, RCC_APB1LENR_UART8EN },\n#ifdef UART9_BASE\n  [STM32H7_MODULE_UART9] = { &RCC->APB2ENR, RCC_APB2ENR_UART9EN },\n#else\n  [STM32H7_MODULE_UART9] = { NULL, 0 },\n#endif\n#ifdef USART10_BASE\n  [STM32H7_MODULE_USART10] = { &RCC->APB2ENR, RCC_APB2ENR_USART10EN },\n#else\n  [STM32H7_MODULE_USART10] = { NULL, 0 },\n#endif\n  [STM32H7_MODULE_RNG] = { &RCC->AHB2ENR, RCC_AHB2ENR_RNGEN },\n#ifdef RCC_AHB1ENR_ETH1MACEN\n  [STM32H7_MODULE_ETH1MAC] = { &RCC->AHB1ENR, RCC_AHB1ENR_ETH1MACEN },\n#endif\n#ifdef RCC_AHB1ENR_ETH1TXEN\n  [STM32H7_MODULE_ETH1TX] = { &RCC->AHB1ENR, RCC_AHB1ENR_ETH1TXEN },\n#endif\n#ifdef RCC_AHB1ENR_ETH1RXEN\n  [STM32H7_MODULE_ETH1RX] = { &RCC->AHB1ENR, RCC_AHB1ENR_ETH1RXEN },\n#endif\n  [STM32H7_MODULE_USB1_OTG] = { &RCC->AHB1ENR, RCC_AHB1ENR_USB1OTGHSEN },\n  [STM32H7_MODULE_USB1_OTG_ULPI] = { &RCC->AHB1ENR, RCC_AHB1ENR_USB1OTGHSULPIEN },\n#ifdef RCC_AHB1ENR_USB20TGHSEN\n  [STM32H7_MODULE_USB2_OTG] = { &RCC->AHB1ENR, RCC_AHB1ENR_USB2OTGHSEN },\n#endif\n#ifdef RCC_AHB1ENR_USB20TGHSULPIEN\n  [STM32H7_MODULE_USB2_OTG_ULPI] = { &RCC->AHB1ENR, RCC_AHB1ENR_USB2OTGHSULPIEN },\n#endif\n  [STM32H7_MODULE_SDMMC1] = { &RCC->AHB3ENR, RCC_AHB3ENR_SDMMC1EN },\n  [STM32H7_MODULE_SDMMC2] = { &RCC->AHB2ENR, RCC_AHB2ENR_SDMMC2EN },\n};\nvoid stm32h7_clk_enable(stm32h7_module_index index)\n{\n  __IO uint32_t *enr;\n  uint32_t enable_bit;\n  rtems_interrupt_level level;\n  enr = stm32h7_clk[index].enr;\n  enable_bit = stm32h7_clk[index].enable_bit;\n  rtems_interrupt_disable(level);\n  SET_BIT(*enr, enable_bit);\n  *enr;\n  rtems_interrupt_enable(level);\n}\nvoid stm32h7_clk_disable(stm32h7_module_index index)\n{\n  __IO uint32_t *enr;\n  uint32_t enable_bit;\n  rtems_interrupt_level level;\n  enr = stm32h7_clk[index].enr;\n  enable_bit = stm32h7_clk[index].enable_bit;\n  rtems_interrupt_disable(level);\n  CLEAR_BIT(*enr, enable_bit);\n  rtems_interrupt_enable(level);\n}\nstatic const stm32h7_clk_info stm32h7_clk_low_power[] = {\n  [STM32H7_MODULE_INVALID] = { NULL, 0 },\n  [STM32H7_MODULE_GPIOA] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOALPEN },\n  [STM32H7_MODULE_GPIOB] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOBLPEN },\n  [STM32H7_MODULE_GPIOC] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOCLPEN },\n  [STM32H7_MODULE_GPIOD] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIODLPEN },\n  [STM32H7_MODULE_GPIOE] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOELPEN },\n  [STM32H7_MODULE_GPIOF] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOFLPEN },\n  [STM32H7_MODULE_GPIOG] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOGLPEN },\n  [STM32H7_MODULE_GPIOH] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOHLPEN },\n  [STM32H7_MODULE_GPIOI] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOILPEN },\n  [STM32H7_MODULE_GPIOJ] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOJLPEN },\n  [STM32H7_MODULE_GPIOK] = { &RCC->AHB4LPENR, RCC_AHB4LPENR_GPIOKLPEN },\n  [STM32H7_MODULE_USART1] = { &RCC->APB2LPENR, RCC_APB2LPENR_USART1LPEN },\n  [STM32H7_MODULE_USART2] = { &RCC->APB1LLPENR, RCC_APB1LLPENR_USART2LPEN },\n  [STM32H7_MODULE_USART3] = { &RCC->APB1LLPENR, RCC_APB1LLPENR_USART3LPEN },\n  [STM32H7_MODULE_UART4] = { &RCC->APB1LLPENR, RCC_APB1LLPENR_UART4LPEN },\n  [STM32H7_MODULE_UART5] = { &RCC->APB1LLPENR, RCC_APB1LLPENR_UART5LPEN },\n  [STM32H7_MODULE_USART6] = { &RCC->APB2LPENR, RCC_APB2LPENR_USART6LPEN },\n  [STM32H7_MODULE_UART7] = { &RCC->APB1LLPENR, RCC_APB1LLPENR_UART7LPEN },\n  [STM32H7_MODULE_UART8] = { &RCC->APB1LLPENR, RCC_APB1LLPENR_UART8LPEN },\n#ifdef UART9_BASE\n  [STM32H7_MODULE_UART9] = { &RCC->APB2LPENR, RCC_APB2LPENR_UART9LPEN },\n#else\n  [STM32H7_MODULE_UART9] = { NULL, 0 },\n#endif\n#ifdef USART10_BASE\n  [STM32H7_MODULE_USART10] = { &RCC->APB2LPENR, RCC_APB2LPENR_USART10LPEN },\n#else\n  [STM32H7_MODULE_USART10] = { NULL, 0 },\n#endif\n  [STM32H7_MODULE_RNG] = { &RCC->AHB2LPENR, RCC_AHB2LPENR_RNGLPEN },\n#ifdef RCC_AHB1LPENR_ETH1MACLPEN\n  [STM32H7_MODULE_ETH1MAC] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_ETH1MACLPEN },\n#endif\n#ifdef RCC_AHB1LPENR_ETH1TXLPEN\n  [STM32H7_MODULE_ETH1TX] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_ETH1TXLPEN },\n#endif\n#ifdef RCC_AHB1LPENR_ETH1RXLPEN\n  [STM32H7_MODULE_ETH1RX] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_ETH1RXLPEN },\n#endif\n  [STM32H7_MODULE_USB1_OTG] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_USB1OTGHSLPEN },\n  [STM32H7_MODULE_USB1_OTG_ULPI] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_USB1OTGHSULPILPEN },\n#ifdef RCC_AHB1LPENR_USB2OTGHSLPEN\n  [STM32H7_MODULE_USB2_OTG] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_USB2OTGHSLPEN },\n#endif\n#ifdef RCC_AHB1LPENR_USB2OTGHSULPILPEN\n  [STM32H7_MODULE_USB2_OTG_ULPI] = { &RCC->AHB1LPENR, RCC_AHB1LPENR_USB2OTGHSULPILPEN },\n#endif\n  [STM32H7_MODULE_SDMMC1] = { &RCC->AHB3LPENR, RCC_AHB3LPENR_SDMMC1LPEN },\n  [STM32H7_MODULE_SDMMC2] = { &RCC->AHB2LPENR, RCC_AHB2LPENR_SDMMC2LPEN },\n};\nvoid stm32h7_clk_low_power_enable(stm32h7_module_index index)\n{\n  __IO uint32_t *enr;\n  uint32_t enable_bit;\n  rtems_interrupt_level level;\n  enr = stm32h7_clk_low_power[index].enr;\n  enable_bit = stm32h7_clk_low_power[index].enable_bit;\n  rtems_interrupt_disable(level);\n  SET_BIT(*enr, enable_bit);\n  *enr;\n  rtems_interrupt_enable(level);\n}\nvoid stm32h7_clk_low_power_disable(stm32h7_module_index index)\n{\n  __IO uint32_t *enr;\n  uint32_t enable_bit;\n  rtems_interrupt_level level;\n  enr = stm32h7_clk_low_power[index].enr;\n  enable_bit = stm32h7_clk_low_power[index].enable_bit;\n  rtems_interrupt_disable(level);\n  CLEAR_BIT(*enr, enable_bit);\n  rtems_interrupt_enable(level);\n}\nvoid stm32h7_gpio_init(const stm32h7_gpio_config *config)\n{\n  stm32h7_module_index index;\n  index = stm32h7_get_module_index(config->regs);\n  stm32h7_clk_enable(index);\n  HAL_GPIO_Init(config->regs, &config->config);\n}\nvoid stm32h7_uart_polled_write(rtems_termios_device_context *base, char c)\n{\n  stm32h7_uart_context *ctx;\n  USART_TypeDef *regs;\n  ctx = stm32h7_uart_get_context(base);\n  regs = ctx->uart.Instance;\n  while ((regs->ISR & USART_ISR_TXE_TXFNF) == 0) {\n  }\n  regs->TDR = (uint8_t) c;\n}\nint stm32h7_uart_polled_read(rtems_termios_device_context *base)\n{\n  stm32h7_uart_context *ctx;\n  USART_TypeDef *regs;\n  ctx = stm32h7_uart_get_context(base);\n  regs = ctx->uart.Instance;\n  if ((regs->ISR & USART_ISR_RXNE_RXFNE) == 0) {\n    return -1;\n  }\n  return (uint8_t) regs->RDR;\n}'"
"'Prompt: ""Imagine you are developing a graphics library that can be used to draw on different surfaces. How would you implement a function that retrieves the color of a pixel at a specified coordinate on the surface? Please provide a code snippet that demonstrates how the function hagl_get_pixel works using the given parameters and returns the color of the pixel at the specified x and y coordinates. Also, make sure to handle cases where the coordinates are outside the clipping area of the surface.""","//...\nhagl_color_t\nhagl_get_pixel(void const *_surface, int16_t x0, int16_t y0)\n{\n    const hagl_surface_t *surface = _surface;\n    if ((x0 < surface->clip.x0) || (y0 < surface->clip.y0))  {\n        return hagl_color(surface, 0, 0, 0);\n    }\n    if ((x0 > surface->clip.x1) || (y0 > surface->clip.y1)) {\n        return hagl_color(surface, 0, 0, 0);\n    }\n    if (surface->get_pixel) {\n        return surface->get_pixel(&surface, x0, y0);\n    }\n    return hagl_color(surface, 0, 0, 0);\n}\n//...'"
"'Prompt:. You are working on a project where you need to implement communication between different processes using Netlink sockets in the Linux kernel. You need to handle sending and receiving messages between the processes. Develop a function that sends a message via Netlink socket based on the message type and direction. Additionally, create a function that parses incoming messages and determines their direction. Lastly, implement a handler function that receives messages from the Netlink socket and processes them accordingly. . In this scenario, you need to write code for sending messages, parsing incoming messages, and handling received messages using Netlink sockets in the Linux kernel.","//...\n            printk(""%s:%d invalid buf=%p, len=%d\\n"", __func__, __LINE__, buf, len);       \\\n            break;                                              \\\n        for (_i = 0; _i < len; _i++) {                          \\\n\tskb = nlmsg_new(data_len, GFP_KERNEL);\n\tNETLINK_CB(skb).portid = 0;\n\treturn 0;\nstatic int nl_send_msg(int pid, const u8 *data, int data_len, int dir)\n{\n\tint ret;\n\tstruct nlmsghdr *rep;\n\tu8 *res;\n\tstruct sk_buff *skb;\n\tskb = nlmsg_new(data_len, GFP_KERNEL);\n\tif(!skb) {\n\t\tprintk(""nlmsg_new failed!!!\\n"");\n\t\treturn -ENOMEM;\n\t}\n\trep = __nlmsg_put(skb, pid, 0, dir, data_len, 0);\n\tres = nlmsg_data(rep);\n\tmemcpy(res, data, data_len);\n\tret = netlink_unicast(nlfd, skb, pid, 0);\n\tprintk(""%s:%d ret = %d, pid = %d, data_len = %d\\n"", __func__, __LINE__,\n\t\t\tret, pid, data_len);\n\treturn 0;\n}\nstatic int parse_msg(int type, char *msg, int len)\n{\n    int dir;\n    printk(""%s:%d msg = %s\\n"", __func__, __LINE__, msg);\n    if (!strncmp(msg, IPC_SERVER_PREFIX, strlen(IPC_SERVER_PREFIX))) {\n        dir = SERVER_TO_SERVER;\n    } else if (!strncmp(msg, IPC_CLIENT_PREFIX, strlen(IPC_CLIENT_PREFIX))) {\n        dir = CLIENT_TO_CLIENT;\n    } else {\n        dir = type;\n        printk(""%s:%d nlmsg_type %d\\n"", __func__, __LINE__, dir);\n    }\n    return dir;\n}\nstatic void nl_recv_msg_handler(struct sk_buff * skb)\n{\n\tstruct nlmsghdr * nlhdr = NULL;\n\tint len;\n\tint msg_len;\n\tchar *msg;\n\tint towards;\n\tnlhdr = nlmsg_hdr(skb);\n\tlen = skb->len;\n\tfor(; NLMSG_OK(nlhdr, len); nlhdr = NLMSG_NEXT(nlhdr, len)) {\n\t\tif (nlhdr->nlmsg_len < sizeof(struct nlmsghdr)) {\n\t\t\tprintk(""NETLINK ERR: Corruptted msg!\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tmsg_len = nlhdr->nlmsg_len - NLMSG_LENGTH(0);\n\t\tprintk(""%s:%d skb->len=%d,nlmsg_len=%d,msg_len=%d, buf=%s\\n"", __func__, __LINE__, skb->len, nlhdr->nlmsg_len, msg_len, (char *)NLMSG_DATA(nlhdr));\n\t\tmsg = NLMSG_DATA(nlhdr);\n\t\ttowards = parse_msg(nlhdr->nlmsg_type, msg, msg_len);\n\t\tswitch (towards) {\n\t\t\tcase SERVER_TO_SERVER:\n\t\t\t\tprintk(""%s:%d SERVER_TO_SERVER\\n"", __func__, __LINE__);\n\t\t\t\tnl_send_msg(NETLINK_CB(skb).portid, NLMSG_DATA(nlhdr), msg_len, SERVER_TO_SERVER);\n\t\t\t\tbreak;\n\t\t\tcase CLIENT_TO_CLIENT:\n\t\t\t\tprintk(""%s:%d CLIENT_TO_CLIENT\\n"", __func__, __LINE__);\n\t\t\t\tnl_send_msg(NETLINK_CB(skb).portid, NLMSG_DATA(nlhdr), msg_len, CLIENT_TO_CLIENT);\n\t\t\t\tbreak;\n\t\t\tcase SERVER_TO_CLIENT:\n\t\t\t\tprintk(""%s:%d SERVER_TO_CLIENT\\n"", __func__, __LINE__);\n\t\t\t\tnl_send_msg(NETLINK_CB(skb).portid, NLMSG_DATA(nlhdr), msg_len, SERVER_TO_CLIENT);\n\t\t\t\tbreak;\n\t\t\tcase CLIENT_TO_SERVER:\n\t\t\t\tprintk(""%s:%d CLIENT_TO_SERVER\\n"", __func__, __LINE__);\n\t\t\t\tnl_send_msg(NETLINK_CB(skb).portid, NLMSG_DATA(nlhdr), msg_len, CLIENT_TO_SERVER);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(""%s:%d to unknown\\n"", __func__, __LINE__);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n//...'"
"('Prompt: Imagine you are testing a function that calculates the square root of a complex number using the CSqrtf function. Write a function called autotest_csqrtf that tests the accuracy of the CSqrtf function. The function should compare the calculated square roots of a set of complex numbers with expected values, each with a tolerance of 1e-3f. Use the CONTEND_DELTA macro to check the real and imaginary parts of the calculated square root.. . Code response:. ```c. float tol = 1e-3f;. void autotest_csqrtf(). {.     float tol = 1e-3f;.     unsigned int n = 32;.     float complex z[32] = {.         1.3608e+00+_Complex_I* -4.2247e-01,   1.1324e+00+_Complex_I*  1.1938e+00,.         1.6466e+","//...\n    float tol = 1e-3f;\nvoid autotest_csqrtf()\n{\n    float tol = 1e-3f;\n    unsigned int n = 32;\n    float complex z[32] = {\n        1.3608e+00+_Complex_I* -4.2247e-01,   1.1324e+00+_Complex_I*  1.1938e+00,\n        1.6466e+00+_Complex_I* -1.2098e+00,  -6.5911e-01+_Complex_I*  1.0729e+00,\n       -8.8890e-01+_Complex_I*  2.1588e-01,  -9.0412e-02+_Complex_I*  5.1548e-01,\n       -5.4086e-01+_Complex_I*  5.3604e-02,   1.8089e+00+_Complex_I*  1.6648e+00,\n        5.4285e-01+_Complex_I*  8.6919e-01,  -1.4336e+00+_Complex_I*  4.2788e-01,\n       -1.9348e+00+_Complex_I* -1.0285e+00,  -1.4511e+00+_Complex_I*  1.2167e+00,\n       -1.3733e+00+_Complex_I* -3.9622e-01,  -1.4808e+00+_Complex_I* -1.5648e+00,\n        1.9957e+00+_Complex_I* -1.1270e+00,   5.1730e-02+_Complex_I*  1.3564e+00,\n        4.5056e-01+_Complex_I* -8.1587e-01,   5.5021e-01+_Complex_I*  9.7149e-02,\n       -2.5668e-02+_Complex_I*  1.8911e+00,  -8.2993e-01+_Complex_I*  1.0854e+00,\n        1.0698e-01+_Complex_I*  1.0797e+00,  -3.9909e-01+_Complex_I*  1.5661e+00,\n       -8.6674e-01+_Complex_I* -5.9017e-01,   1.2309e+00+_Complex_I*  1.6761e+00,\n       -1.7210e+00+_Complex_I*  1.7973e+00,   1.0398e-01+_Complex_I* -1.6558e+00,\n       -1.2311e+00+_Complex_I*  6.5291e-01,   1.5609e+00+_Complex_I* -6.0443e-01,\n       -1.7433e+00+_Complex_I* -1.9199e+00,  -1.6919e-01+_Complex_I* -1.7476e+00,\n       -1.0469e+00+_Complex_I*  1.8825e+00,   1.6088e+00+_Complex_I*  1.4037e+00};\n    float complex test[32] = {\n        1.1802e+00+_Complex_I* -1.7899e-01,   1.1785e+00+_Complex_I*  5.0647e-01,\n        1.3583e+00+_Complex_I* -4.4534e-01,   5.4776e-01+_Complex_I*  9.7936e-01,\n        1.1366e-01+_Complex_I*  9.4964e-01,   4.6526e-01+_Complex_I*  5.5397e-01,\n        3.6399e-02+_Complex_I*  7.3633e-01,   1.4607e+00+_Complex_I*  5.6986e-01,\n        8.8533e-01+_Complex_I*  4.9088e-01,   1.7676e-01+_Complex_I*  1.2103e+00,\n        3.5802e-01+_Complex_I* -1.4363e+00,   4.7042e-01+_Complex_I*  1.2932e+00,\n        1.6736e-01+_Complex_I* -1.1838e+00,   5.8032e-01+_Complex_I* -1.3482e+00,\n        1.4642e+00+_Complex_I* -3.8485e-01,   8.3939e-01+_Complex_I*  8.0799e-01,\n        8.3144e-01+_Complex_I* -4.9064e-01,   7.4462e-01+_Complex_I*  6.5233e-02,\n        9.6582e-01+_Complex_I*  9.7902e-01,   5.1789e-01+_Complex_I*  1.0479e+00,\n        7.7199e-01+_Complex_I*  6.9927e-01,   7.8009e-01+_Complex_I*  1.0038e+00,\n        3.0154e-01+_Complex_I* -9.7860e-01,   1.2866e+00+_Complex_I*  6.5140e-01,\n        6.1944e-01+_Complex_I*  1.4508e+00,   9.3889e-01+_Complex_I* -8.8178e-01,\n        2.8497e-01+_Complex_I*  1.1456e+00,   1.2718e+00+_Complex_I* -2.3763e-01,\n        6.5191e-01+_Complex_I* -1.4725e+00,   8.9067e-01+_Complex_I* -9.8107e-01,\n        7.4403e-01+_Complex_I*  1.2651e+00,   1.3682e+00+_Complex_I*  5.1297e-01};\n    unsigned int i;\n    for (i=0; i<n; i++) {\n        float complex t = liquid_csqrtf(z[i]);\n        CONTEND_DELTA(crealf(t), crealf(test[i]), tol);\n        CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);\n    }\n}\n//...')
"
"('Prompt: Please provide a code snippet that defines a function `firdespm_destroy()` which deallocates memory and frees all dynamically allocated arrays and variables within a structure `firdespm _q`. Also, include a conditional macro definition `LIQUID_FIRDESPM_DEBUG` to enable debugging output within the function if it is set to 1. The function should return `LIQUID_OK` upon successful completion.","//...\n#define LIQUID_FIRDESPM_DEBUG       0\n    for (i=0; i<_q->grid_size; i++) {\n        fprintf(fid,""iext(%4u) = %u;\\n"", i+1, _q->iext[i]+1);\n    fprintf(fid,""grid on;\\n"");\n        double f = (double) i / (double)(2*(n-1));\n        double x = cos(2*M_PI*f);\n        double c = poly_val_lagrange_barycentric(_q->x,_q->c,_q->alpha,x,_q->r+1);\n    float bands[4]   = {0.0f, f0, f1, 0.5f};\n    float des[2]     = {1.0f, 0.0f};\n    float weights[2] = {1.0f, 1.0f}; \n#define LIQUID_FIRDESPM_DEBUG       0\nint firdespm_destroy(firdespm _q)\n{\n#if LIQUID_FIRDESPM_DEBUG\n    firdespm_output_debug_file(_q);\n#endif\n    free(_q->iext);\n    free(_q->x);\n    free(_q->alpha);\n    free(_q->c);\n    free(_q->F);\n    free(_q->D);\n    free(_q->W);\n    free(_q->E);\n    free(_q->bands);\n    free(_q->des);\n    free(_q->weights);\n    free(_q->wtype);\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
'Prompt: You need to implement the initialization function for a pthread read-write lock in a multi-threaded C program. The function should handle creating and initializing the necessary mutexes and condition variables for the read-write lock. Make sure to check for any errors during initialization and clean up resources properly before returning.,"#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_rwlock_init (pthread_rwlock_t * rwlock,\n\t\t     const pthread_rwlockattr_t * attr)\n{\n  int result;\n  pthread_rwlock_t rwl = 0;\n  if (rwlock == NULL)\n    {\n      return EINVAL;\n    }\n  if (attr != NULL && *attr != NULL)\n    {\n      result = EINVAL;\t\t\n      goto DONE;\n    }\n  rwl = (pthread_rwlock_t) calloc (1, sizeof (*rwl));\n  if (rwl == NULL)\n    {\n      result = ENOMEM;\n      goto DONE;\n    }\n  rwl->nSharedAccessCount = 0;\n  rwl->nExclusiveAccessCount = 0;\n  rwl->nCompletedSharedAccessCount = 0;\n  result = pthread_mutex_init (&rwl->mtxExclusiveAccess, NULL);\n  if (result != 0)\n    {\n      goto FAIL0;\n    }\n  result = pthread_mutex_init (&rwl->mtxSharedAccessCompleted, NULL);\n  if (result != 0)\n    {\n      goto FAIL1;\n    }\n  result = pthread_cond_init (&rwl->cndSharedAccessCompleted, NULL);\n  if (result != 0)\n    {\n      goto FAIL2;\n    }\n  rwl->nMagic =  __PTW32_RWLOCK_MAGIC;\n  result = 0;\n  goto DONE;\nFAIL2:\n  (void) pthread_mutex_destroy (&(rwl->mtxSharedAccessCompleted));\nFAIL1:\n  (void) pthread_mutex_destroy (&(rwl->mtxExclusiveAccess));\nFAIL0:\n  (void) free (rwl);\n  rwl = NULL;\nDONE:\n  *rwlock = rwl;\n  return result;\n}'"
"'Prompt: You are working on an operating system kernel for an embedded system running on an ARM-based AArch64 processor. You need to implement a function that maps a memory region in the virtual address space to a physical address space using the MMU. Please provide me with a code snippet for a function that takes the virtual address, size, and flags as input parameters and performs the necessary memory mapping using the translation table base address provided in the BSP. The function should return a status code based on the success or failure of the mapping operation.","rtems_status_code aarch64_mmu_map(\n  uintptr_t addr,\n  uint64_t size,\n  uint64_t flags\n)\n{\n  rtems_status_code sc;\n  ISR_Level        level;\n  uint64_t max_mappable = 1LLU << aarch64_mmu_get_cpu_pa_bits();\n  if ( addr >= max_mappable || (addr + size) > max_mappable ) {\n    return RTEMS_INVALID_ADDRESS;\n  }\n  _ISR_Local_disable( level );\n  sc = aarch64_mmu_map_block(\n    (uint64_t *) bsp_translation_table_base,\n    0x0,\n    addr,\n    size,\n    -1,\n    flags\n  );\n  _AARCH64_Data_synchronization_barrier();\n  __asm__ volatile(\n    ""tlbi vmalle1\\n""\n  );\n  _AARCH64_Data_synchronization_barrier();\n  _AARCH64_Instruction_synchronization_barrier();\n  _ISR_Local_enable( level );\n  return sc;\n}'"
"(""Prompt: You are working on a project that involves testing an OFDM flexframe generator and synchronizer. Please write a testbench function that initializes the properties of the OFDM flexframe generator and synchronizer, assembles a frame with a given header and payload, and then checks the frame's statistics after synchronization. The testbench function should take parameters for modulation order, cyclic prefix length, taper length, payload length, and modulation scheme. Additionally, provide an autotest function that calls the testbench function with specific parameters (2048, 32, 16, 800, QPSK modulation) for testing purposes.","//...\nvoid testbench_ofdmflexframe(unsigned int      _M,\n                             unsigned int      _cp_len,\n                             unsigned int      _taper_len,\n                             unsigned int      _payload_len,\n                             modulation_scheme _ms)\n{\n    ofdmflexframegenprops_s fgprops;\n    ofdmflexframegenprops_init_default(&fgprops);\n    fgprops.check        = LIQUID_CRC_32;\n    fgprops.fec0         = LIQUID_FEC_NONE;\n    fgprops.fec1         = LIQUID_FEC_NONE;\n    fgprops.mod_scheme   = _ms;\n    ofdmflexframegen  fg = ofdmflexframegen_create( _M, _cp_len, _taper_len, NULL, &fgprops);\n    ofdmflexframesync fs = ofdmflexframesync_create(_M, _cp_len, _taper_len, NULL, NULL, NULL);\n    unsigned char header[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    unsigned char payload[_payload_len];\n    memset(payload, 0x00, _payload_len);\n    ofdmflexframegen_assemble(fg, header, payload, _payload_len);\n    if (liquid_autotest_verbose)\n        ofdmflexframegen_print(fg);\n    unsigned int  buf_len = 1024;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = ofdmflexframegen_write(fg, buf, buf_len);\n        ofdmflexframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        ofdmflexframesync_print(fs);\n    framedatastats_s stats = ofdmflexframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY( stats.num_frames_detected, 1 );\n    CONTEND_EQUALITY( stats.num_headers_valid,   1 );\n    CONTEND_EQUALITY( stats.num_payloads_valid,  1 );\n    CONTEND_EQUALITY( stats.num_bytes_received,  _payload_len );\n    ofdmflexframegen_destroy(fg);\n    ofdmflexframesync_destroy(fs);\n}\nvoid autotest_ofdmflexframe_04() { testbench_ofdmflexframe(2048, 32, 16,  800, LIQUID_MODEM_QPSK); }\n//...')
"
"'Please provide the code for managing interrupt priorities and channels in a TMS570 microcontroller, including setting and getting priorities, enabling and disabling interrupt vectors, checking for pending interrupts, and initializing the interrupt facility.","#define VIM_CHANCTRL_COUNT 24\n#define VIM_CHANMAP_MASK UINT32_C(0x7f)\n#define VIM_CHANMAP_SHIFT(i) (24 - (8 * (i)))\n#define VIM_REQ_REG(vector) ((vector) >> 5)\n#define VIM_REQ_BIT(vector) (UINT32_C(1) << ((vector) & 0x1f))\nstatic void vim_set_channel_request(uint32_t channel, uint32_t request)\n{\n  uint32_t chanctrl;\n  int shift;\n  chanctrl = TMS570_VIM.CHANCTRL[channel / 4];\n  shift = VIM_CHANMAP_SHIFT(channel % 4);\n  chanctrl &= ~(VIM_CHANMAP_MASK << shift);\n  chanctrl |= request << shift;\n  TMS570_VIM.CHANCTRL[channel / 4] = chanctrl;\n}\nrtems_status_code tms570_irq_set_priority(\n  rtems_vector_number vector,\n  uint32_t            priority\n)\n{\n  rtems_interrupt_level level;\n  uint32_t current_channel;\n  uint32_t chanctrl;\n  size_t i;\n  size_t j;\n  if (!bsp_interrupt_is_valid_vector(vector)) {\n   return RTEMS_INVALID_ID;\n  }\n  if (priority < 2) {\n    return RTEMS_INVALID_PRIORITY;\n  }\n  if (priority >= BSP_INTERRUPT_VECTOR_COUNT) {\n    return RTEMS_INVALID_PRIORITY;\n  }\n  rtems_interrupt_disable(level);\n  current_channel = TMS570_VIM.CHANCTRL[priority / 4];\n  current_channel >>= VIM_CHANMAP_SHIFT(priority % 4);\n  current_channel &= VIM_CHANMAP_MASK;\n  for (i = 0; i < VIM_CHANCTRL_COUNT; ++i) {\n    chanctrl = TMS570_VIM.CHANCTRL[i];\n    for (j = 0; j < 4; ++j) {\n      uint32_t channel_vector;\n      channel_vector = (chanctrl >> VIM_CHANMAP_SHIFT(j)) & VIM_CHANMAP_MASK;\n      if (channel_vector == vector) {\n        vim_set_channel_request(i * 4 + j, current_channel);\n        goto set_my_request;\n      }\n    }\n  }\nset_my_request:\n  vim_set_channel_request(priority, vector);\n  rtems_interrupt_enable(level);\n  return RTEMS_SUCCESSFUL;\n}\nrtems_status_code tms570_irq_get_priority(\n  rtems_vector_number  vector,\n  unsigned            *priority\n)\n{\n  rtems_interrupt_level level;\n  size_t i;\n  size_t j;\n  if (priority == NULL) {\n    return RTEMS_INVALID_ADDRESS;\n  }\n  if (!bsp_interrupt_is_valid_vector(vector)) {\n   return RTEMS_INVALID_ID;\n  }\n  rtems_interrupt_disable(level);\n  for (i = 0; i < VIM_CHANCTRL_COUNT; ++i) {\n    uint32_t chanctrl;\n    chanctrl = TMS570_VIM.CHANCTRL[i];\n    for (j = 0; j < 4; ++j) {\n      uint32_t channel_vector;\n      channel_vector = (chanctrl >> VIM_CHANMAP_SHIFT(j)) & VIM_CHANMAP_MASK;\n      if (channel_vector == vector) {\n        rtems_interrupt_enable(level);\n        *priority = i * 4 + j;\n        return RTEMS_SUCCESSFUL;\n      }\n    }\n  }\n  rtems_interrupt_enable(level);\n  *priority = UINT32_MAX;\n  return RTEMS_NOT_DEFINED;\n}\nvoid bsp_interrupt_dispatch(void)\n{\n  while (true) {\n    uint32_t irqindex;\n    irqindex = TMS570_VIM.IRQINDEX;\n    if (irqindex == 0) {\n      return;\n    }\n    bsp_interrupt_handler_dispatch(irqindex - 1);\n  }\n}\nstatic bool can_disable(rtems_vector_number vector)\n{\n  return vector >= 2;\n}\nrtems_status_code bsp_interrupt_get_attributes(\n  rtems_vector_number         vector,\n  rtems_interrupt_attributes *attributes\n)\n{\n  bool can_disable_vector;\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  bsp_interrupt_assert(attributes != NULL);\n  can_disable_vector = can_disable(vector);\n  attributes->is_maskable = can_disable_vector;\n  attributes->can_enable = true;\n  attributes->maybe_enable = true;\n  attributes->can_disable = can_disable_vector;\n  attributes->maybe_disable = can_disable_vector;\n  attributes->can_get_affinity = true;\n  attributes->can_set_affinity = true;\n  return RTEMS_SUCCESSFUL;\n}\nrtems_status_code bsp_interrupt_is_pending(\n  rtems_vector_number vector,\n  bool               *pending\n)\n{\n  uint32_t intreq;\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  bsp_interrupt_assert(pending != NULL);\n  intreq = TMS570_VIM.INTREQ[VIM_REQ_REG(vector)];\n  *pending = (intreq & VIM_REQ_BIT(vector)) != 0;\n  return RTEMS_SUCCESSFUL;\n}\nrtems_status_code bsp_interrupt_raise(rtems_vector_number vector)\n{\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  return RTEMS_UNSATISFIED;\n}\nrtems_status_code bsp_interrupt_clear(rtems_vector_number vector)\n{\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  return RTEMS_UNSATISFIED;\n}\nrtems_status_code bsp_interrupt_vector_is_enabled(\n  rtems_vector_number vector,\n  bool               *enabled\n)\n{\n  uint32_t reqen;\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  bsp_interrupt_assert(enabled != NULL);\n  reqen = TMS570_VIM.REQENASET[VIM_REQ_REG(vector)];\n  *enabled = (reqen & VIM_REQ_BIT(vector)) != 0;\n  return RTEMS_SUCCESSFUL;\n}\nrtems_status_code bsp_interrupt_vector_enable(\n  rtems_vector_number vector\n)\n{\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  TMS570_VIM.REQENASET[VIM_REQ_REG(vector)] = VIM_REQ_BIT(vector);\n  return RTEMS_SUCCESSFUL;\n}\nrtems_status_code bsp_interrupt_vector_disable(\n  rtems_vector_number vector\n)\n{\n  if (!can_disable(vector)) {\n    return RTEMS_UNSATISFIED;\n  }\n  bsp_interrupt_assert(bsp_interrupt_is_valid_vector(vector));\n  TMS570_VIM.REQENACLR[VIM_REQ_REG(vector)] = VIM_REQ_BIT(vector);\n  return RTEMS_SUCCESSFUL;\n}\nvoid bsp_interrupt_facility_initialize(void)\n{\n  void (**vim_vec)(void) = (void (**)(void)) 0xFFF82000;\n  unsigned int value = 0x00010203;\n  unsigned int i = 0;\n  uint32_t sctlr;\n  for ( i = 0; i < 3; i++ ) {\n    TMS570_VIM.REQENACLR[i] = 0xffffffff;\n  }\n  for ( i = 0; i < VIM_CHANCTRL_COUNT; i += 1, value += 0x04040404) {\n    TMS570_VIM.CHANCTRL[i] = value;\n  }\n  TMS570_VIM.FIRQPR[0] = 3;\n  TMS570_VIM.FIRQPR[1] = 0;\n  TMS570_VIM.FIRQPR[2] = 0;\n  for ( i = 0; i <= 94; ++i ) {\n    vim_vec[i] = _ARMV4_Exception_interrupt;\n  }\n  asm volatile (""mrc p15, 0, %0, c1, c0, 0\\n"": ""=r"" (sctlr));\n  sctlr &= ~(1 << 24);\n  #if 0\n    sctlr |= 1 << 24;\n  #endif\n  asm volatile (""mcr p15, 0, %0, c1, c0, 0\\n"": : ""r"" (sctlr));\n}'"
('Prompt: You are working on a project involving frequency-shift keying (FSK) modulation and need to generate frames with specific payloads. Write a function that generates the payload symbols for the FSK frame. The function should take a parameter of type `fskframegen` and return an integer value. Use the given data members and helper functions to complete the task.,"//...\n    unsigned int    m;                  \n    unsigned int    k;                  \n    float complex * buf;                \n    int             frame_assembled;    \n    unsigned int    sample_counter;     \nint fskframegen_generate_payload(fskframegen _q)\n{\n    unsigned int s = _q->payload_sym[_q->symbol_counter];\n    fskmod_modulate(_q->mod, s, _q->buf);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->payload_sym_len) {\n        _q->symbol_counter = 0;\n        _q->frame_assembled = 0;\n        _q->state = STATE_OFF;\n    }\n    return LIQUID_OK;\n}\nint fskframegen_generate_symbol(fskframegen _q)\n{\n    switch (_q->state) {\n    case STATE_OFF:      return fskframegen_generate_zeros(_q);\n    case STATE_PREAMBLE: return fskframegen_generate_preamble(_q);\n    case STATE_HEADER:   return fskframegen_generate_header(_q);\n    case STATE_PAYLOAD:  return fskframegen_generate_payload(_q);\n    default:;\n    }\n    return liquid_error(LIQUID_EINT,""fskframegen_writesymbol(), unknown/unsupported internal state"");\n}\nint fskframegen_generate_header(fskframegen _q)\n{\n    unsigned int s = _q->header_sym[_q->symbol_counter];\n    fskmod_modulate(_q->mod_header, s, _q->buf);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->header_sym_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_PAYLOAD;\n    }\n    return LIQUID_OK;\n}\nint fskframegen_generate_preamble(fskframegen _q)\n{\n    unsigned char s = _q->preamble_sym[_q->symbol_counter];\n    fskmod_modulate(_q->mod_header, s, _q->buf);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == 2*_q->preamble_sym_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_HEADER;\n    }\n    return LIQUID_OK;\n}\nint fskframegen_generate_zeros(fskframegen _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->k; i++)\n        _q->buf[i] = 0.0f;\n    return LIQUID_OK;\n}\nint fskframegen_write_samples(fskframegen     _q,\n                              float complex * _buf,\n                              unsigned int    _buf_len)\n{\n    unsigned int i;\n    for (i=0; i<_buf_len; i++) {\n        if (_q->sample_counter == _q->k) {\n            fskframegen_generate_symbol(_q);\n            _q->sample_counter = 0;\n        }\n        _buf[i] = _q->buf[_q->sample_counter++];\n    }\n    return _q->frame_assembled ? 0 : 1;\n}\n//...')
"
"('Prompt: You are working on a project that involves utilizing a QAM packet modem for wireless communication. Write a function that sets up and tests the unmodulated transmission and reception of data packets using the QAM modem. The function must configure the modem with specific parameters, generate random data payloads for transmission and reception, encode and decode the data frames, and verify the correctness of the received payload. Make sure to include error checking and cleanup of resources used by the modem.","//...\nvoid qpacketmodem_unmodulated(unsigned int _payload_len,\n                              int          _check,\n                              int          _fec0,\n                              int          _fec1,\n                              int          _ms)\n{\n    unsigned int i;\n    qpacketmodem q = qpacketmodem_create();\n    qpacketmodem_configure(q, _payload_len, _check, _fec0, _fec1, _ms);\n    if (liquid_autotest_verbose)\n        qpacketmodem_print(q);\n    unsigned char payload_tx[_payload_len];\n    unsigned char payload_rx[_payload_len];\n    for (i=0; i<_payload_len; i++) {\n        payload_tx[i] = rand() & 0xff;\n        payload_rx[i] = rand() & 0xff;\n    }\n    unsigned int frame_len = qpacketmodem_get_frame_len(q);\n    unsigned char frame_syms[frame_len];\n    qpacketmodem_encode_syms(q, payload_tx, frame_syms);\n    int crc_pass = qpacketmodem_decode_syms(q, frame_syms, payload_rx);\n    qpacketmodem_destroy(q);\n    CONTEND_EQUALITY( crc_pass, 1 );\n    CONTEND_SAME_DATA( payload_tx, payload_rx, _payload_len );\n}\n//...')
"
"('Generate automated tests for testing demodulation and soft bit processing for various modulation schemes using a software-defined modem. The tests should cover PSK, DPSK, QAM, APSK, BPSK, QPSK, OOK, SQAM, V29, ARB, and PI4DQPSK modulations with different constellation sizes. The tests will call the `modemcf_test_demodsoft` function with different modulation schemes as input parameters to verify demodulation correctness. The expected behavior is that the demodulated symbol should match the original symbol before modulation, and the soft bits extracted should match the symbol index after packing.","void modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_psk2()      { modemcf_test_demodsoft(LIQUID_MODEM_PSK2);      }\nvoid autotest_demodsoft_psk4()      { modemcf_test_demodsoft(LIQUID_MODEM_PSK4);      }\nvoid autotest_demodsoft_psk8()      { modemcf_test_demodsoft(LIQUID_MODEM_PSK8);      }\nvoid autotest_demodsoft_psk16()     { modemcf_test_demodsoft(LIQUID_MODEM_PSK16);     }\nvoid autotest_demodsoft_psk32()     { modemcf_test_demodsoft(LIQUID_MODEM_PSK32);     }\nvoid autotest_demodsoft_psk64()     { modemcf_test_demodsoft(LIQUID_MODEM_PSK64);     }\nvoid autotest_demodsoft_psk128()    { modemcf_test_demodsoft(LIQUID_MODEM_PSK128);    }\nvoid autotest_demodsoft_psk256()    { modemcf_test_demodsoft(LIQUID_MODEM_PSK256);    }\nvoid autotest_demodsoft_dpsk2()     { modemcf_test_demodsoft(LIQUID_MODEM_DPSK2);     }\nvoid autotest_demodsoft_dpsk4()     { modemcf_test_demodsoft(LIQUID_MODEM_DPSK4);     }\nvoid autotest_demodsoft_dpsk8()     { modemcf_test_demodsoft(LIQUID_MODEM_DPSK8);     }\nvoid autotest_demodsoft_dpsk16()    { modemcf_test_demodsoft(LIQUID_MODEM_DPSK16);    }\nvoid autotest_demodsoft_dpsk32()    { modemcf_test_demodsoft(LIQUID_MODEM_DPSK32);    }\nvoid autotest_demodsoft_dpsk64()    { modemcf_test_demodsoft(LIQUID_MODEM_DPSK64);    }\nvoid autotest_demodsoft_dpsk128()   { modemcf_test_demodsoft(LIQUID_MODEM_DPSK128);   }\nvoid autotest_demodsoft_dpsk256()   { modemcf_test_demodsoft(LIQUID_MODEM_DPSK256);   }\nvoid autotest_demodsoft_ask2()      { modemcf_test_demodsoft(LIQUID_MODEM_ASK2);      }\nvoid autotest_demodsoft_ask4()      { modemcf_test_demodsoft(LIQUID_MODEM_ASK4);      }\nvoid autotest_demodsoft_ask8()      { modemcf_test_demodsoft(LIQUID_MODEM_ASK8);      }\nvoid autotest_demodsoft_ask16()     { modemcf_test_demodsoft(LIQUID_MODEM_ASK16);     }\nvoid autotest_demodsoft_ask32()     { modemcf_test_demodsoft(LIQUID_MODEM_ASK32);     }\nvoid autotest_demodsoft_ask64()     { modemcf_test_demodsoft(LIQUID_MODEM_ASK64);     }\nvoid autotest_demodsoft_ask128()    { modemcf_test_demodsoft(LIQUID_MODEM_ASK128);    }\nvoid autotest_demodsoft_ask256()    { modemcf_test_demodsoft(LIQUID_MODEM_ASK256);    }\nvoid autotest_demodsoft_qam4()      { modemcf_test_demodsoft(LIQUID_MODEM_QAM4);      }\nvoid autotest_demodsoft_qam8()      { modemcf_test_demodsoft(LIQUID_MODEM_QAM8);      }\nvoid autotest_demodsoft_qam16()     { modemcf_test_demodsoft(LIQUID_MODEM_QAM16);     }\nvoid autotest_demodsoft_qam32()     { modemcf_test_demodsoft(LIQUID_MODEM_QAM32);     }\nvoid autotest_demodsoft_qam64()     { modemcf_test_demodsoft(LIQUID_MODEM_QAM64);     }\nvoid autotest_demodsoft_qam128()    { modemcf_test_demodsoft(LIQUID_MODEM_QAM128);    }\nvoid autotest_demodsoft_qam256()    { modemcf_test_demodsoft(LIQUID_MODEM_QAM256);    }\nvoid autotest_demodsoft_apsk4()     { modemcf_test_demodsoft(LIQUID_MODEM_APSK4);     }\nvoid autotest_demodsoft_apsk8()     { modemcf_test_demodsoft(LIQUID_MODEM_APSK8);     }\nvoid autotest_demodsoft_apsk16()    { modemcf_test_demodsoft(LIQUID_MODEM_APSK16);    }\nvoid autotest_demodsoft_apsk32()    { modemcf_test_demodsoft(LIQUID_MODEM_APSK32);    }\nvoid autotest_demodsoft_apsk64()    { modemcf_test_demodsoft(LIQUID_MODEM_APSK64);    }\nvoid autotest_demodsoft_apsk128()   { modemcf_test_demodsoft(LIQUID_MODEM_APSK128);   }\nvoid autotest_demodsoft_apsk256()   { modemcf_test_demodsoft(LIQUID_MODEM_APSK256);   }\nvoid autotest_demodsoft_bpsk()      { modemcf_test_demodsoft(LIQUID_MODEM_BPSK);      }\nvoid autotest_demodsoft_qpsk()      { modemcf_test_demodsoft(LIQUID_MODEM_QPSK);      }\nvoid autotest_demodsoft_ook()       { modemcf_test_demodsoft(LIQUID_MODEM_OOK);       }\nvoid autotest_demodsoft_sqam32()    { modemcf_test_demodsoft(LIQUID_MODEM_SQAM32);    }\nvoid autotest_demodsoft_sqam128()   { modemcf_test_demodsoft(LIQUID_MODEM_SQAM128);   }\nvoid autotest_demodsoft_V29()       { modemcf_test_demodsoft(LIQUID_MODEM_V29);       }\nvoid autotest_demodsoft_arb16opt()  { modemcf_test_demodsoft(LIQUID_MODEM_ARB16OPT);  }\nvoid autotest_demodsoft_arb32opt()  { modemcf_test_demodsoft(LIQUID_MODEM_ARB32OPT);  }\nvoid autotest_demodsoft_arb64opt()  { modemcf_test_demodsoft(LIQUID_MODEM_ARB64OPT);  }\nvoid autotest_demodsoft_arb128opt() { modemcf_test_demodsoft(LIQUID_MODEM_ARB128OPT); }\nvoid autotest_demodsoft_arb256opt() { modemcf_test_demodsoft(LIQUID_MODEM_ARB256OPT); }\nvoid autotest_demodsoft_arb64vt()   { modemcf_test_demodsoft(LIQUID_MODEM_ARB64VT);   }\nvoid autotest_demodsoft_pi4dqpsk()  { modemcf_test_demodsoft(LIQUID_MODEM_PI4DQPSK);  }')
"
"('Prompt: ""You are designing a system that utilizes orthogonal frequency-division multiplexing (OFDM) for transmitting data over a wireless channel. One critical metric for assessing the performance of OFDM signals is the Peak-to-Average Power Ratio (PAPR). To calculate PAPR, an OFDM frame consisting of complex symbols needs to be analyzed. Can you provide a function that computes the PAPR of an OFDM frame represented by an array of complex numbers?""","//...\nfloat ofdmframe_PAPR(float complex * _x,\n                     unsigned int    _n)\n{\n    float e;\n    float e_mean = 0.0f;\n    float e_max  = 0.0f;\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        e = crealf( _x[i] * conjf(_x[i]) );\n        e_mean += e;\n        e_max   = (e > e_max) ? e : e_max;\n    }\n    e_mean = e_mean / (float)_n;\n    return 10*log10f(e_max / e_mean);\n}\n//...')
"
"('Prompt: Can you provide a function that serves as an automated test to verify that a certain feature or functionality does not crash when provided with a null input? The function should be named ""autotest_null"" and should use the macro AUTOTEST_PASS() to indicate a successful test.","void autotest_null()\n{\n    AUTOTEST_PASS();\n}')
"
"'Prompt: ""I need a code snippet for creating a chart with a cursor in an LVGL example. The chart should display random values when clicked on a point, and a label should prompt the user to \'Click on a point\'. Can you assist with this?"". . Technical Scenario: In this scenario, we are creating a chart in LVGL with a cursor that can be used to interact with the chart. The chart displays random values when a point is clicked, and a label above the chart instructs the user to interact by clicking on a point.","#if LV_USE_CHART && LV_BUILD_EXAMPLES\nstatic lv_obj_t * chart;\nstatic lv_chart_series_t * ser;\nstatic lv_chart_cursor_t * cursor;\nstatic void value_changed_event_cb(lv_event_t * e)\n{\n    static int32_t last_id = -1;\n    lv_obj_t * obj = lv_event_get_target(e);\n    last_id = lv_chart_get_pressed_point(obj);\n    if(last_id != LV_CHART_POINT_NONE) {\n        lv_chart_set_cursor_point(obj, cursor, NULL, last_id);\n    }\n}\nvoid lv_example_chart_6(void)\n{\n    chart = lv_chart_create(lv_screen_active());\n    lv_obj_set_size(chart, 200, 150);\n    lv_obj_align(chart, LV_ALIGN_CENTER, 0, -10);\n    lv_obj_add_event_cb(chart, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    lv_obj_refresh_ext_draw_size(chart);\n    cursor = lv_chart_add_cursor(chart, lv_palette_main(LV_PALETTE_BLUE), LV_DIR_LEFT | LV_DIR_BOTTOM);\n    ser = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_RED), LV_CHART_AXIS_PRIMARY_Y);\n    uint32_t i;\n    for(i = 0; i < 10; i++) {\n        lv_chart_set_next_value(chart, ser, lv_rand(10, 90));\n    }\n    lv_obj_t * label = lv_label_create(lv_screen_active());\n    lv_label_set_text(label, ""Click on a point"");\n    lv_obj_align_to(label, chart, LV_ALIGN_OUT_TOP_MID, 0, -5);\n}\n#endif'"
"('Prompt: You are working on a signal processing project where you need to implement a function to unwrap phase values in floating-point format. The issue is that the phase values might wrap around due to the nature of signals. You need a solution that can handle the phase unwrapping correctly. . . Response: . ```c. void liquid_unwrap_phase(float * _theta, unsigned int _n). {.     unsigned int i;.     for (i = 1; i < _n; i++) {.         while ((_theta[i] - _theta[i - 1]) > LIQUID_PI) _theta[i] -= 2 * LIQUID_PI;.         while ((_theta[i] - _theta[i - 1]) < -LIQUID_PI) _theta[i] += 2 * LIQUID_PI;.     }. }. . void liquid_unwrap_phase2(float *_theta, unsigned int _n). {.     unsigned int i;.     float dphi = 0.","//...\nvoid liquid_unwrap_phase(float * _theta,\n                         unsigned int _n)\n{\n    unsigned int i;\n    for (i=1; i<_n; i++) {\n        while ( (_theta[i] - _theta[i-1]) >  LIQUID_PI ) _theta[i] -= 2*LIQUID_PI;\n        while ( (_theta[i] - _theta[i-1]) < -LIQUID_PI ) _theta[i] += 2*LIQUID_PI;\n    }\n}\nvoid liquid_unwrap_phase2(float * _theta,\n                          unsigned int _n)\n{\n    unsigned int i;\n    float dphi = 0.0f;\n    for (i=1; i<_n; i++)\n        dphi += _theta[i] - _theta[i-1];\n    dphi /= (float)(_n-1);\n    for (i=1; i<_n; i++) {\n        while ( (_theta[i] - _theta[i-1]) >  LIQUID_PI+dphi ) _theta[i] -= 2*LIQUID_PI;\n        while ( (_theta[i] - _theta[i-1]) < -LIQUID_PI+dphi ) _theta[i] += 2*LIQUID_PI;\n    }\n}\n//...')
"
"'The prompt could have been: . . You need to initialize a TMS570 SCI driver for console output on a specific microcontroller. Write a code snippet that sets up the necessary context for the driver, initializes the driver, installs the relevant device, handles interrupts and polled operations, as well as setting attributes for the termios device. Make sure to differentiate between interrupt-driven and polled operation modes.","tms570_sci_context driver_context_table[] = {\n  {\n    .base = RTEMS_TERMIOS_DEVICE_CONTEXT_INITIALIZER(""TMS570 SCI1""),\n    .device_name = ""/dev/console"",\n    .regs = (volatile tms570_sci_t *) &TMS570_LIN,\n    .irq = TMS570_IRQ_SCI_LEVEL_0,\n  },\n  {\n    .base = RTEMS_TERMIOS_DEVICE_CONTEXT_INITIALIZER(""TMS570 SCI2""),\n    .device_name = ""/dev/ttyS1"",\n    .regs = &TMS570_SCI,\n    .irq = TMS570_IRQ_SCI2_LEVEL_0,\n  }\n};\nvoid tms570_sci_initialize(tms570_sci_context *ctx)\n{\n  uint32_t rx_pin = 1 << 1;\n  uint32_t tx_pin = 1 << 2;\n  ctx->regs->GCR0 = TMS570_SCI_GCR0_RESET * 0;\n  ctx->regs->GCR0 = TMS570_SCI_GCR0_RESET * 1;\n  ctx->regs->CLEARINT = 0xffffffff;\n  ctx->regs->CLEARINTLVL = 0xffffffff;\n  ctx->regs->GCR1 = TMS570_SCI_GCR1_TXENA * 0 |\n                    TMS570_SCI_GCR1_RXENA * 0 |\n                    TMS570_SCI_GCR1_CONT * 0 | \n                    TMS570_SCI_GCR1_LOOP_BACK * 0 |\n                    TMS570_SCI_GCR1_POWERDOWN * 0 |\n                    TMS570_SCI_GCR1_SLEEP * 0 |\n                    TMS570_SCI_GCR1_SWnRST * 0 | \n                    TMS570_SCI_GCR1_CLOCK * 1 | \n                    TMS570_SCI_GCR1_TIMING_MODE * 1 |\n                    TMS570_SCI_GCR1_COMM_MODE * 0;\n  ctx->regs->PIO0 = rx_pin * 1 | tx_pin * 1; \n  ctx->regs->PIO3 = rx_pin * 0 | tx_pin * 0; \n  ctx->regs->PIO1 = rx_pin * 0 | tx_pin * 0; \n  ctx->regs->PIO6 = rx_pin * 0 | tx_pin * 0; \n  ctx->regs->PIO7 = rx_pin * 0 | tx_pin * 0; \n  ctx->regs->PIO8 = rx_pin * 1 | tx_pin * 1; \n  ctx->regs->GCR1 |= TMS570_SCI_GCR1_SWnRST;\n}\nrtems_device_driver console_initialize(\n  rtems_device_major_number  major,\n  rtems_device_minor_number  minor,\n  void                      *arg\n)\n{\n  rtems_status_code sc;\n#if CONSOLE_USE_INTERRUPTS\n  const rtems_termios_device_handler *handler = &tms570_sci_handler_interrupt;\n#else\n  const rtems_termios_device_handler *handler = &tms570_sci_handler_polled;\n#endif\n  rtems_termios_initialize();\n  for (\n    minor = 0;\n    minor < RTEMS_ARRAY_SIZE(driver_context_table);\n    ++minor\n  ) {\n    tms570_sci_context *ctx = &driver_context_table[minor];\n    tms570_sci_initialize(ctx);\n    sc = rtems_termios_device_install(\n        ctx->device_name,\n        handler,\n        NULL,\n        &ctx->base\n    );\n    if ( sc != RTEMS_SUCCESSFUL ) {\n      bsp_fatal(BSP_FATAL_CONSOLE_NO_DEV);\n    }\n  }\n  return RTEMS_SUCCESSFUL;\n}\nstatic void tms570_sci_enable_interrupts(tms570_sci_context * ctx)\n{\n  ctx->regs->SETINT = TMS570_SCI_SETINT_SET_RX_INT;\n}\nstatic void tms570_sci_disable_interrupts(tms570_sci_context * ctx)\n{\n  ctx->regs->CLEARINT = TMS570_SCI_CLEARINT_CLR_RX_INT;\n}\nstatic int tms570_sci_transmitted_chars(tms570_sci_context * ctx)\n{\n  int ret;\n  ret = ctx->tx_chars_in_hw;\n  if ( ret == 1 ) {\n    ctx->tx_chars_in_hw = 0;\n    return 1;\n  }\n  return ret;\n}\nbool tms570_sci_set_attributes(\n  rtems_termios_device_context *base,\n  const struct termios *t\n)\n{\n  tms570_sci_context *ctx = (tms570_sci_context *) base;\n  rtems_interrupt_lock_context lock_context;\n  int32_t bauddiv;\n  int32_t baudrate;\n  uint32_t flr_tx_ready = TMS570_SCI_FLR_TX_EMPTY;\n  baudrate = rtems_termios_baud_to_number(cfgetospeed(t));\n  rtems_termios_device_lock_acquire(base, &lock_context);\n  while ( (ctx->regs->GCR1 & TMS570_SCI_GCR1_TXENA) &&\n          (ctx->regs->FLR & flr_tx_ready) != flr_tx_ready) {\n    rtems_interval tw;\n    rtems_termios_device_lock_release(base, &lock_context);\n    tw = rtems_clock_get_ticks_per_second();\n    tw = tw * 5 / baudrate + 1;\n    rtems_task_wake_after( tw );\n    rtems_termios_device_lock_acquire(base, &lock_context);\n  }\n  ctx->regs->GCR1 &= ~( TMS570_SCI_GCR1_SWnRST | TMS570_SCI_GCR1_TXENA |\n                        TMS570_SCI_GCR1_RXENA );\n  ctx->regs->GCR1 &= ~TMS570_SCI_GCR1_STOP;    \n  ctx->regs->FORMAT = TMS570_SCI_FORMAT_CHAR(0x7);\n  switch ( t->c_cflag & ( PARENB|PARODD ) ) {\n    case ( PARENB|PARODD ):\n      ctx->regs->GCR1 &= ~TMS570_SCI_GCR1_PARITY;\n      ctx->regs->GCR1 |= TMS570_SCI_GCR1_PARITY_ENA;\n      break;\n    case PARENB:\n      ctx->regs->GCR1 |= TMS570_SCI_GCR1_PARITY;\n      ctx->regs->GCR1 |= TMS570_SCI_GCR1_PARITY_ENA;\n      break;\n    default:\n    case 0:\n    case PARODD:\n      ctx->regs->GCR1 &= ~TMS570_SCI_GCR1_PARITY_ENA;\n  }\n  baudrate *= 2 * 16;\n  bauddiv = (BSP_PLL_OUT_CLOCK + baudrate / 2) / baudrate;\n  ctx->regs->BRS = bauddiv? bauddiv - 1: 0;\n  ctx->regs->GCR1 |= TMS570_SCI_GCR1_SWnRST | TMS570_SCI_GCR1_TXENA |\n                     TMS570_SCI_GCR1_RXENA;\n  rtems_termios_device_lock_release(base, &lock_context);\n  return true;\n}\nstatic void tms570_sci_interrupt_handler(void * arg)\n{\n  rtems_termios_tty *tty = arg;\n  tms570_sci_context *ctx = rtems_termios_get_device_context(tty);\n   if ( (ctx->regs->FLR & TMS570_SCI_FLR_RXRDY ) == TMS570_SCI_FLR_RXRDY ) {\n      char buf[1];\n      buf[0] = ctx->regs->RD & 0x000000FF;\n      rtems_termios_enqueue_raw_characters(tty, buf, 1);\n    }\n  if ( (ctx->regs->FLR & TMS570_SCI_FLR_TXRDY ) == TMS570_SCI_FLR_TXRDY ) {\n    size_t n;\n    n = tms570_sci_transmitted_chars(ctx);\n    if ( n > 0 ) {\n      rtems_termios_dequeue_characters(tty, n);\n    }\n  }\n}\nstatic void tms570_sci_interrupt_write(\n  rtems_termios_device_context *base,\n  const char *buf,\n  size_t len\n)\n{\n  tms570_sci_context *ctx = (tms570_sci_context *) base;\n  if ( len > 0 ) {\n    ctx->regs->TD = *buf;\n    ctx->tx_chars_in_hw = 1;\n    ctx->regs->SETINT = (1<<8);\n  } else {\n    ctx->regs->CLEARINT = (1<<8);\n  }\n}\nstatic void tms570_sci_poll_write(\n  rtems_termios_device_context *base,\n  const char *buf,\n  size_t n\n)\n{\n  tms570_sci_context *ctx = (tms570_sci_context *) base;\n  size_t i;\n  for ( i = 0; i < n; ++i ) {\n    while ( (ctx->regs->FLR & TMS570_SCI_FLR_TX_EMPTY ) == 0) {\n      ;\n    }\n    ctx->regs->TD = buf[i];\n  }\n}\nstatic int TMS570_sci_can_read_char(\n  tms570_sci_context * ctx\n)\n{\n  return ctx->regs->FLR & TMS570_SCI_FLR_RXRDY;\n}\nstatic char TMS570_sci_read_char(\n  tms570_sci_context * ctx\n)\n{\n  return ctx->regs->RD;\n}\nstatic int tms570_sci_poll_read(rtems_termios_device_context *base)\n{\n  tms570_sci_context *ctx = (tms570_sci_context *) base;\n  if ( TMS570_sci_can_read_char(ctx) ) {\n    return TMS570_sci_read_char(ctx);\n  } else {\n    return -1;\n  }\n}\nstatic bool tms570_sci_poll_first_open(\n  rtems_termios_tty             *tty,\n  rtems_termios_device_context  *ctx,\n  struct termios                *term,\n  rtems_libio_open_close_args_t *args\n)\n{\n  bool ok;\n  rtems_termios_set_best_baud(term, TMS570_SCI_BAUD_RATE);\n  ok = tms570_sci_set_attributes(ctx, term);\n  if ( !ok ) {\n    return false;\n  }\n  return true;\n}\nstatic bool tms570_sci_interrupt_first_open(\n  rtems_termios_tty             *tty,\n  rtems_termios_device_context  *base,\n  struct termios                *term,\n  rtems_libio_open_close_args_t *args\n)\n{\n  tms570_sci_context *ctx = (tms570_sci_context *) base;\n  rtems_status_code sc;\n  bool ret;\n  ret = tms570_sci_poll_first_open(tty, base, term, args);\n  if ( ret == false ) {\n    return false;\n  }\n  sc = rtems_interrupt_handler_install(ctx->irq,\n      ctx->device_name,\n      RTEMS_INTERRUPT_SHARED,\n      tms570_sci_interrupt_handler,\n      tty\n  );\n  if ( sc != RTEMS_SUCCESSFUL ) {\n    return false;\n  }\n  tms570_sci_enable_interrupts(ctx);\n  return true;\n}\nstatic void tms570_sci_poll_last_close(\n  rtems_termios_tty             *tty,\n  rtems_termios_device_context  *base,\n  rtems_libio_open_close_args_t *args\n)\n{\n  ;\n}\nstatic void tms570_sci_interrupt_last_close(\n  rtems_termios_tty             *tty,\n  rtems_termios_device_context  *base,\n  rtems_libio_open_close_args_t *args\n)\n{\n  tms570_sci_context *ctx = (tms570_sci_context *) base;\n  rtems_interrupt_lock_context lock_context;\n  rtems_interval tw;\n  int32_t baudrate;\n  rtems_termios_device_lock_acquire(base, &lock_context);\n  tms570_sci_disable_interrupts(ctx);\n  rtems_termios_device_lock_release(base, &lock_context);\n  tw = rtems_clock_get_ticks_per_second();\n  baudrate = rtems_termios_baud_to_number(cfgetospeed(&tty->termios));\n  tw = tw * 10 / baudrate + 1;\n  while ( ( ctx->regs->FLR & TMS570_SCI_FLR_TX_EMPTY ) == 0 ) {\n     rtems_task_wake_after(tw);\n  }\n  rtems_interrupt_handler_remove(ctx->irq, tms570_sci_interrupt_handler, tty);\n  tms570_sci_poll_last_close(tty, base, args);\n}\nconst rtems_termios_device_handler tms570_sci_handler_polled = {\n  .first_open = tms570_sci_poll_first_open,\n  .last_close = tms570_sci_poll_last_close,\n  .poll_read = tms570_sci_poll_read,\n  .write = tms570_sci_poll_write,\n  .set_attributes = tms570_sci_set_attributes,\n  .mode = TERMIOS_POLLED\n};\nconst rtems_termios_device_handler tms570_sci_handler_interrupt  = {\n  .first_open = tms570_sci_interrupt_first_open,\n  .last_close = tms570_sci_interrupt_last_close,\n  .poll_read = NULL,\n  .write = tms570_sci_interrupt_write,\n  .set_attributes = tms570_sci_set_attributes,\n  .mode = TERMIOS_IRQ_DRIVEN\n};'"
"('To receive the code for initializing a DSSS frame generator with the specified properties, you could have asked:. . ""Can you provide the code for initializing a DSSS frame generator struct in C, including setting properties for frame generation and configuring the header properties? The struct should have fields for parameters like k, m, beta, preamble values, encoders, and modulation data.""","//...\nstruct dsssframegen_s {\n    unsigned int        k;             \n    unsigned int        m;             \n    float               beta;          \n    firinterp_crcf      interp;        \n    float complex       buf_interp[2]; \n    dsssframegenprops_s props;        \n    dsssframegenprops_s header_props; \n    float complex *     preamble_pn; \n    synth_crcf          header_synth;\n    synth_crcf          payload_synth;\n    unsigned char *     header;          \n    unsigned int        header_user_len; \n    unsigned int        header_dec_len;  \n    qpacketmodem        header_encoder;  \n    unsigned int        header_mod_len;  \n    float complex *     header_mod;\n    unsigned int        payload_dec_len; \n    qpacketmodem        payload_encoder;\n    unsigned int        payload_mod_len;\n    float complex *     payload_mod;\n    unsigned int        symbol_counter; \n    unsigned int        sample_counter; \n    unsigned int        bit_counter;    \n    int                 bit_high;       \n    float complex       sym;\n    int                 frame_assembled; \n    int                 frame_complete;  \n    enum state          state;           \n};\n        return 0.f;\nint dsssframegen_setprops(dsssframegen _q, dsssframegenprops_s * _props)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_setprops(), frame is already assembled; must reset() first"");\n    if (_props == NULL) {\n        dsssframegen_setprops(_q, &dsssframegenprops_default);\n        return LIQUID_OK;\n    }\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_setprops(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_setprops(), invalid/unsupported FEC scheme"");\n    memmove(&_q->props, _props, sizeof(dsssframegenprops_s));\n    return dsssframegen_reconfigure(_q);\n}\nint dsssframegen_set_header_len(dsssframegen _q, unsigned int _len)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_set_header_len(), frame is already assembled; must reset() first"");\n    _q->header_user_len = _len;\n    _q->header_dec_len  = DSSSFRAME_H_DEC + _q->header_user_len;\n    _q->header = (unsigned char *)realloc(_q->header, _q->header_dec_len * sizeof(unsigned char));\n    return dsssframegen_reconfigure_header(_q);\n}\nint dsssframegen_reconfigure(dsssframegen _q)\n{\n    qpacketmodem_configure(_q->payload_encoder,\n                           _q->payload_dec_len,\n                           _q->props.check,\n                           _q->props.fec0,\n                           _q->props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->payload_mod_len = qpacketmodem_get_frame_len(_q->payload_encoder);\n    _q->payload_mod     = (float complex *)realloc(\n        _q->payload_mod, _q->payload_mod_len * sizeof(float complex));\n    return LIQUID_OK;\n}\nint dsssframegen_set_header_props(dsssframegen _q, dsssframegenprops_s * _props)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_set_header_props(), frame is already assembled; must reset() first"");\n    if (_props == NULL)\n        _props = &dsssframegenprops_header_default;\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EIMODE,""dsssframegen_set_header_props(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EIMODE,""dsssframegen_set_header_props(), invalid/unsupported FEC scheme"");\n    memmove(&_q->header_props, _props, sizeof(dsssframegenprops_s));\n    return dsssframegen_reconfigure_header(_q);\n}\nint dsssframegen_reset(dsssframegen _q)\n{\n    _q->symbol_counter  = 0;\n    _q->bit_counter     = 0;\n    _q->sample_counter  = 0;\n    _q->frame_assembled = 0;\n    _q->frame_complete  = 0;\n    _q->state           = STATE_PREAMBLE;\n    return LIQUID_OK;\n}\nint dsssframegen_reconfigure_header(dsssframegen _q)\n{\n    qpacketmodem_configure(_q->header_encoder,\n                           _q->header_dec_len,\n                           _q->header_props.check,\n                           _q->header_props.fec0,\n                           _q->header_props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_encoder);\n    _q->header_mod     = (float complex *)realloc(\n        _q->header_mod, _q->header_mod_len * sizeof(float complex));\n    return LIQUID_OK;\n}\ndsssframegen dsssframegen_create(dsssframegenprops_s * _fgprops)\n{\n    dsssframegen q = (dsssframegen)calloc(1, sizeof(struct dsssframegen_s));\n    unsigned int i;\n    q->k      = 2;\n    q->m      = 7;\n    q->beta   = 0.25f;\n    q->interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER, q->k, q->m, q->beta, 0);\n    q->preamble_pn = (float complex *)malloc(64 * sizeof(float complex));\n    msequence ms   = msequence_create(7, 0x0089, 1);\n    for (i = 0; i < 64; i++) {\n        q->preamble_pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        q->preamble_pn[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;\n    }\n    msequence_destroy(ms);\n    float complex * pn = (float complex *)malloc(64 * sizeof(float complex));\n    ms                        = msequence_create(7, 0x00cb, 0x53);\n    for (i = 0; i < 64; i++) {\n        pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        pn[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;\n    }\n    q->header_synth  = synth_crcf_create(pn, 64);\n    q->payload_synth = synth_crcf_create(pn, 64);\n    free(pn);\n    msequence_destroy(ms);\n    dsssframegen_reset(q);\n    q->header          = NULL;\n    q->header_user_len = DSSSFRAME_H_USER_DEFAULT;\n    q->header_dec_len  = DSSSFRAME_H_DEC + q->header_user_len;\n    q->header_mod      = NULL;\n    q->header_encoder  = qpacketmodem_create();\n    q->payload_encoder = qpacketmodem_create();\n    q->payload_dec_len = 0;\n    q->payload_mod_len = 0;\n    q->payload_mod     = NULL;\n    dsssframegen_setprops(q, _fgprops);\n    dsssframegen_set_header_props(q, NULL);\n    dsssframegen_set_header_len(q, q->header_user_len);\n    return q;\n}\n//...')
"
('Prompt: You are tasked with creating a function that properly deallocates memory for a struct named `qpilotgen`. The struct contains a member named `pilots` which points to a dynamically allocated array of pilot data. The function should free memory for both the `pilots` array and the `qpilotgen` struct itself. The function should return a constant value `LIQUID_OK` upon successful deallocation. Provide the code for the `qpilotgen_destroy` function that achieves this.,"//...\nint qpilotgen_destroy(qpilotgen _q)\n{\n    free(_q->pilots);   \n    free(_q);           \n    return LIQUID_OK;\n}\n//...')
"
"('To receive the code for implementing the `liquid_rosenbrock` and `liquid_spiral` functions for optimization algorithms or mathematical modeling, you could have prompted me with the following technical scenario:. . ""I am working on designing optimization algorithms and mathematical modeling functions with floating-point vector inputs. Can you provide me with C functions implementing the Rosenbrock function and a spiral function, named `liquid_rosenbrock` and `liquid_spiral` respectively, that take a void pointer to user data, a float array `_v` representing the input vector, and an unsigned integer `_n` indicating the length of the input vector? The `liquid_rosenbrock` function should compute the Rosenbrock function with the given input vector `_v`, and `liquid_spiral` should compute a spiral function. Additionally, handle error cases where the input vector length is zero.""","//...\nfloat liquid_rosenbrock(void *       _userdata,\n                        float *      _v,\n                        unsigned int _n)\n{\n    if (_n == 0) {\n        liquid_error(LIQUID_EICONFIG,""liquid_rosenbrock(), input vector length cannot be zero"");\n        return 0.0f;\n    } else if (_n == 1) {\n        return (1.0f-_v[0])*(1.0f-_v[0]);\n    }\n    float u=0.0f;\n    unsigned int i;\n    for (i=0; i<_n-1; i++)\n        u += powf(1-_v[i],2) + 100*powf( _v[i+1] - powf(_v[i],2), 2);\n    return u;\n}\nfloat liquid_spiral(void *       _userdata,\n                    float *      _v,\n                    unsigned int _n)\n{\n    if (_n == 0) {\n        liquid_error(LIQUID_EICONFIG,""liquid_rosenbrock(), input vector length cannot be zero"");\n        return 0.0f;\n    } else if (_n == 1) {\n        return _v[0]*_v[0];\n    }\n    float r_hat     = sqrtf(_v[0]*_v[0] + _v[1]*_v[1]);\n    float theta_hat = atan2f(_v[1], _v[0]);\n    float delta = theta_hat - r_hat * 10;\n    while (delta >  M_PI) delta -= 2*M_PI;\n    while (delta < -M_PI) delta += 2*M_PI;\n    delta = delta / M_PI;\n    float u = 1 - delta*delta*expf(-r_hat*r_hat/10);\n    unsigned int i;\n    for (i=2; i<_n; i++)\n        u += _v[i]*_v[i];\n    return u;\n}\n//...')
"
"('Please provide the necessary prompt and technical scenario for creating a test case in C that checks the functionality of performing a copy operation on a Finite Impulse Response (FIR) design using a Parks-McClellan algorithm for a bandpass filter. Make sure the test case initializes two filter design objects, executes them to generate impulse response arrays, and then compares the arrays to check if the filter designs were accurately copied.","//...\nvoid autotest_firdespm_copy()\n{\n    float bands[4] = {0.0, 0.2, 0.3, 0.5};  \n    float   des[2] = {1.0,      0.0};       \n    float     w[2] = {1.0,      1.0};       \n    liquid_firdespm_wtype wtype[2] = {LIQUID_FIRDESPM_FLATWEIGHT, LIQUID_FIRDESPM_FLATWEIGHT};\n    firdespm q0 = firdespm_create(51, 2, bands, des, w, wtype, LIQUID_FIRDESPM_BANDPASS);\n    firdespm q1 = firdespm_copy(q0);\n    float h0[51], h1[51];\n    firdespm_execute(q0, h0);\n    firdespm_execute(q1, h1);\n    CONTEND_SAME_DATA(h0, h1, 51*sizeof(float));\n    firdespm_destroy(q0);\n    firdespm_destroy(q1);\n}\n//...')
"
('Please provide a prompt in which you are setting up a software project that involves signal processing using complex numbers in C programming and you need helper macros for common operations.,"#define EXTENSION_SHORT     ""f""\n#define EXTENSION_FULL      ""cccf""\n#define PRINTVAL(x)         printf(""%12.4e + j%12.4e"", crealf(x), cimagf(x))\n#define T                   float\n#define TO                  float complex\n#define TC                  float complex\n#define TI                  float complex\n#define ABS(X)              cabsf(X)\n#define REAL(X)             crealf(X)\n#define IMAG(X)             cimagf(X)\n#define TO_COMPLEX          1\n#define TC_COMPLEX          1\n#define TI_COMPLEX          1\n#define AGC(name)           LIQUID_CONCAT(agc_crcf,name)\n#define BSYNC(name)         LIQUID_CONCAT(bsync_cccf,name)\n#define DOTPROD(name)       LIQUID_CONCAT(dotprod_rrrf,name)\n#define EQLMS(name)         LIQUID_CONCAT(eqlms_cccf,name)\n#define MODEM(name)         LIQUID_CONCAT(modemcf,name)\n#define NCO(name)           LIQUID_CONCAT(nco_crcf,name)\n#define QDETECTOR(name)     LIQUID_CONCAT(qdetector_cccf,name)\n#define SYMSYNC(name)       LIQUID_CONCAT(symsync_crcf,name)\n#define WINDOW(name)        LIQUID_CONCAT(windowf,name)\n#define BPRESYNC(name)      LIQUID_CONCAT(bpresync_cccf,name)\n#define BSYNC(name)         LIQUID_CONCAT(bsync_cccf,name)\n#define PRESYNC(name)       LIQUID_CONCAT(presync_cccf,name)\n#define QDETECTOR(name)     LIQUID_CONCAT(qdetector_cccf,name)\n#define QDSYNC(name)        LIQUID_CONCAT(qdsync_cccf,name)\n#define SYMTRACK(name)      LIQUID_CONCAT(symtrack_cccf,name)')
"
"('Please provide me with a prompt describing a scenario in which you need to implement an interleaver for a communication system. Your prompt should include details such as the required input parameters for the interleaving functions, the desired functionality of each function, and the specific interleaving patterns that need to be applied to the input data.","//...\nint interleaver_permute_mask(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N,\n                             unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp0;\n    unsigned char tmp1;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp0 = (_x[2*i+0] & (~_mask)) | (_x[2*j+1] & ( _mask));\n        tmp1 = (_x[2*i+0] & ( _mask)) | (_x[2*j+1] & (~_mask));\n        _x[2*i+0] = tmp0;\n        _x[2*j+1] = tmp1;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute(unsigned char * _x,\n                        unsigned int    _n,\n                        unsigned int    _M,\n                        unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp = _x[2*j+1];\n        _x[2*j+1] = _x[2*i+0];\n        _x[2*i+0] = tmp;\n    }\n    return LIQUID_OK;\n}\nint interleaver_encode(interleaver     _q,\n                       unsigned char * _msg_dec,\n                       unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, _q->n);\n    if (_q->depth > 0) interleaver_permute(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\n//...')
"
('Prompt: You are working on a project where you need to implement a function that prints the binary representation of a given unsigned integer. The function should take two parameters: the unsigned integer to be converted to binary (_x) and the number of bits to consider while converting (_n). Write a function in C that accomplishes this task.,"//...\nvoid print_bitstring(unsigned int _x,\n                     unsigned int _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        printf(""%1u"", (_x >> (_n-i-1)) & 1);\n}\n//...')
"
"'Prompt: In a graphical user interface development scenario using LittlevGL library, I need a code snippet to create a styled container with a rounded radius, specific width and height, vertical padding, and positioned at a specific percentage X and Y offset on the active screen. Additionally, I want to add a label with the text ""Hello"" inside the container. Can you provide me with the code for this scenario?","#if LV_BUILD_EXAMPLES && LV_USE_IMAGE\nvoid lv_example_style_1(void)\n{\n    static lv_style_t style;\n    lv_style_init(&style);\n    lv_style_set_radius(&style, 5);\n    lv_style_set_width(&style, 150);\n    lv_style_set_height(&style, LV_SIZE_CONTENT);\n    lv_style_set_pad_ver(&style, 20);\n    lv_style_set_pad_left(&style, 5);\n    lv_style_set_x(&style, lv_pct(50));\n    lv_style_set_y(&style, 80);\n    lv_obj_t * obj = lv_obj_create(lv_screen_active());\n    lv_obj_add_style(obj, &style, 0);\n    lv_obj_t * label = lv_label_create(obj);\n    lv_label_set_text(label, ""Hello"");\n}\n#endif'"
"('Prompt: Can you provide a set of functions for creating and destroying a dot product object for optimized cross-correlation processing using SIMD instructions?. . Response:. ```c. int dotprod_crcf_destroy(dotprod_crcf _q). {.     _mm_free(_q->h);.     free(_q);.     return LIQUID_OK;. }. dotprod_crcf dotprod_crcf_create_opt(float *      _h,.                                      unsigned int _n,.                                      int          _rev). {.     dotprod_crcf q = (dotprod_crcf)malloc(sizeof(struct dotprod_crcf_s));.     q->n = _n;.     q->h = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );.     unsigned int i;.     for (i=0; i<q->n; i++) {.         unsigned int k = _rev ? q->n-i-1 : i;.         q->h[2*i+0] = _","//...\nint dotprod_crcf_destroy(dotprod_crcf _q)\n{\n    _mm_free(_q->h);\n    free(_q);\n    return LIQUID_OK;\n}\ndotprod_crcf dotprod_crcf_create_opt(float *      _h,\n                                     unsigned int _n,\n                                     int          _rev)\n{\n    dotprod_crcf q = (dotprod_crcf)malloc(sizeof(struct dotprod_crcf_s));\n    q->n = _n;\n    q->h = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );\n    unsigned int i;\n    for (i=0; i<q->n; i++) {\n        unsigned int k = _rev ? q->n-i-1 : i;\n        q->h[2*i+0] = _h[k];\n        q->h[2*i+1] = _h[k];\n    }\n    return q;\n}\ndotprod_crcf dotprod_crcf_create(float *      _h,\n                                 unsigned int _n)\n{\n    return dotprod_crcf_create_opt(_h, _n, 0);\n}\ndotprod_crcf dotprod_crcf_recreate(dotprod_crcf _q,\n                                   float *      _h,\n                                   unsigned int _n)\n{\n    dotprod_crcf_destroy(_q);\n    return dotprod_crcf_create(_h,_n);\n}\n//...')
"
"('Prompt: You are testing a DSSS frame synchronization mechanism in a software-defined radio application. Can you provide a code snippet for an automated test function that generates a DSSS frame, processes it using a frame synchronizer, and checks for successful synchronization by updating a success flag in the callback function?. . Response: . ```c. static int callback_dsssframe(.     unsigned char *  _header,.     int              _header_valid,.     unsigned char *  _payload,.     unsigned int     _payload_len,.     int              _payload_valid,.     framesyncstats_s _stats,.     void *           _userdata). {.     printf(""*** dsssframe callback invoked ***\\n"");.     framesyncstats_print(&_stats);.     if (_payload_valid).         *((int*)_userdata) = 1; .     return 0;. }. void autotest_dsssframesync(). {.     unsigned int _payload_len = 400;.     dsssframegenprops_s fgprops","static int callback_dsssframe(\n    unsigned char *  _header,\n    int              _header_valid,\n    unsigned char *  _payload,\n    unsigned int     _payload_len,\n    int              _payload_valid,\n    framesyncstats_s _stats,\n    void *           _userdata)\n{\n    printf(""*** dsssframe callback invoked ***\\n"");\n    framesyncstats_print(&_stats);\n    if (_payload_valid)\n        *((int*)_userdata) = 1; \n    return 0;\n}\nvoid autotest_dsssframesync()\n{\n    unsigned int _payload_len = 400;\n    dsssframegenprops_s fgprops;\n    fgprops.check = LIQUID_CRC_32;\n    fgprops.fec0  = LIQUID_FEC_NONE;\n    fgprops.fec1  = LIQUID_FEC_NONE;\n    dsssframegen fg = dsssframegen_create(&fgprops);\n    dsssframegen_assemble(fg, NULL, NULL, _payload_len);\n    int success = 0;\n    dsssframesync fs = dsssframesync_create(callback_dsssframe,(void*)&success);\n    int frame_complete = 0;\n    unsigned int buf_len = 256;\n    float complex buf[buf_len];\n    while (!frame_complete) {\n        frame_complete = dsssframegen_write_samples(fg, buf, buf_len);\n        dsssframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        dsssframesync_print(fs);\n#if 0\n    framedatastats_s stats = dsssframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY( stats.num_frames_detected, 1 );\n    CONTEND_EQUALITY( stats.num_headers_valid,   1 );\n    CONTEND_EQUALITY( stats.num_payloads_valid,  1 );\n    CONTEND_EQUALITY( stats.num_bytes_received,  _payload_len );\n#endif\n    CONTEND_EQUALITY( success, 1 );\n    dsssframegen_destroy(fg);\n    dsssframesync_destroy(fs);\n}')
"
"('Prompt: ""You are tasked with writing a function called `framedatastats_reset` that takes a pointer to a structure called `framedatastats_s` as a parameter. The function should reset the fields of the structure to zero if the pointer is not NULL. Can you provide the C code for this function?""","//...\nint framedatastats_reset(framedatastats_s * _stats)\n{\n    if (_stats == NULL)\n        return LIQUID_OK;\n    _stats->num_frames_detected = 0;\n    _stats->num_headers_valid   = 0;\n    _stats->num_payloads_valid  = 0;\n    _stats->num_bytes_received  = 0;\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are testing a function that creates a modem configuration object based on a given modulation scheme, then copies this object to create a new one. The function should handle modulation and demodulation processes for both the original and copied modem objects. Additionally, the function should compare the output of modulation and demodulation for both objects to ensure they are identical. Could you provide a code snippet that demonstrates this scenario?","//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_arb256opt() { modemcf_test_copy(LIQUID_MODEM_ARB256OPT); }\n//...')
"
"('You would like to test and benchmark the performance of a function called `sumsqcf_bench` that calculates and manipulates complex numbers stored in an array. The benchmarking process should include measuring the CPU time used during the function execution using `struct rusage`, adjusting the number of iterations based on array size `_n`, and verifying that the calculations are correct by evaluating the sum of squares of the complex numbers. You are interested in seeing how the function performs under different workload scenarios and ensuring that the computation results are accurate.","//...\nvoid benchmark_sumsqcf_256      S\nvoid sumsqcf_bench(struct rusage *     _start,\n                   struct rusage *     _finish,\n                   unsigned long int * _num_iterations,\n                   unsigned int        _n)\n{\n    *_num_iterations = *_num_iterations * 10 / _n;\n    if (*_num_iterations < 1) *_num_iterations = 1;\n    float complex x[_n];\n    float complex y = 0.0f;\n    unsigned int long i;\n    for (i=0; i<_n; i++)\n        x[i] = 0.2f + 0.2f*_Complex_I;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        y += liquid_sumsqcf(x, _n);\n        y -= liquid_sumsqcf(x, _n);\n        y += liquid_sumsqcf(x, _n);\n        y -= liquid_sumsqcf(x, _n);\n        x[i%_n] = y;\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n}\n//...')
"
"'Prompt: ""I need a code snippet that includes functions to enable/disable ECC, inject errors, and retrieve error information for different types of memory (OCRAM, ITCM, DTCM) in a microcontroller platform with FlexRAM. The code should also include detailed error information lookup tables for ECC errors. Can you provide this code?"". Technical Scenario: You are working on a microcontroller platform that includes FlexRAM and need to implement functions to manage ECC (Error Correction Code) for different types of memory (OCRAM, ITCM, DTCM). The code should allow enabling/disabling ECC, injecting errors, and retrieving error information. Additionally, detailed error information lookup tables must be included for accurate error analysis.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.flexram""\n#endif\nstatic uint32_t FLEXRAM_GetInstance(FLEXRAM_Type *base);\nstatic FLEXRAM_Type *const s_flexramBases[] = FLEXRAM_BASE_PTRS;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_flexramClocks[] = FLEXRAM_CLOCKS;\n#endif \n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\nstatic const uint8_t ItcmLookUpTable[64] = {\n    0xC1, 0x43, 0x9E, 0x83, 0x15, 0x4C, 0x4A, 0x8C, 0x31, 0x1C, 0xA2, 0xE0, 0x51, 0x2C, 0xC2, 0xD0,\n    0x19, 0x1A, 0x26, 0xEA, 0x29, 0x94, 0x16, 0x64, 0x37, 0xA4, 0x0D, 0xC4, 0x75, 0x38, 0x4F, 0x58,\n    0x46, 0x91, 0x86, 0x61, 0x49, 0x98, 0x89, 0x68, 0x32, 0x34, 0x07, 0xC8, 0x92, 0xA8, 0xA7, 0x54,\n    0xA1, 0xD9, 0x25, 0xF8, 0x0E, 0x0B, 0x8A, 0x2A, 0x52, 0x45, 0x13, 0x85, 0x62, 0x70, 0x23, 0xB0};\nstatic const uint8_t DtcmLookUpTable[32] = {0x61, 0x51, 0x19, 0x45, 0x43, 0x31, 0x29, 0x13, 0x62, 0x52, 0x4A,\n                                            0x46, 0x32, 0x2A, 0x23, 0x1A, 0x2C, 0x64, 0x26, 0x25, 0x34, 0x16,\n                                            0x15, 0x54, 0x0B, 0x58, 0x1C, 0x4C, 0x38, 0x0E, 0x0D, 0x49};\n#endif \nstatic uint32_t FLEXRAM_GetInstance(FLEXRAM_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_flexramBases); instance++)\n    {\n        if (s_flexramBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_flexramBases));\n    return instance;\n}\nvoid FLEXRAM_Init(FLEXRAM_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(s_flexramClocks[FLEXRAM_GetInstance(base)]);\n#endif \n    base->INT_STAT_EN |= (uint32_t)kFLEXRAM_InterruptStatusAll;\n    base->INT_STATUS |= (uint32_t)kFLEXRAM_InterruptStatusAll;\n    base->INT_SIG_EN = 0U;\n}\nvoid FLEXRAM_Deinit(FLEXRAM_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_DisableClock(s_flexramClocks[FLEXRAM_GetInstance(base)]);\n#endif \n}\n#if (defined(FSL_FEATURE_FLEXRAM_HAS_ECC) && FSL_FEATURE_FLEXRAM_HAS_ECC)\nvoid FLEXRAM_EnableECC(FLEXRAM_Type *base, bool OcramECCEnable, bool TcmECCEnable)\n{\n    if (true == OcramECCEnable)\n    {\n        base->FLEXRAM_CTRL |= FLEXRAM_FLEXRAM_CTRL_OCRAM_ECC_EN_MASK;\n    }\n    else\n    {\n        base->FLEXRAM_CTRL &= ~FLEXRAM_FLEXRAM_CTRL_OCRAM_ECC_EN_MASK;\n    }\n    if (true == TcmECCEnable)\n    {\n        base->FLEXRAM_CTRL |= FLEXRAM_FLEXRAM_CTRL_TCM_ECC_EN_MASK;\n    }\n    else\n    {\n        base->FLEXRAM_CTRL &= ~FLEXRAM_FLEXRAM_CTRL_TCM_ECC_EN_MASK;\n    }\n}\nvoid FLEXRAM_ErrorInjection(FLEXRAM_Type *base, flexram_memory_type_t memory, flexram_ecc_error_type_t *error)\n{\n    assert(error != NULL);\n    switch (memory)\n    {\n        case kFLEXRAM_OCRAM:\n            base->OCRAM_ECC_ERROR_INJEC =\n                FLEXRAM_OCRAM_ECC_ERROR_INJEC_OCRAM_ERR1BIT(error->SingleBitPos) |\n                FLEXRAM_OCRAM_ECC_ERROR_INJEC_OCRAM_ERR2BIT(error->SecondBitPos) |\n                FLEXRAM_OCRAM_ECC_ERROR_INJEC_OCRAM_FR11BI(error->Fource1BitDataInversion) |\n                FLEXRAM_OCRAM_ECC_ERROR_INJEC_OCRAM_FR1NCI(error->FourceOneNCDataInversion) |\n                FLEXRAM_OCRAM_ECC_ERROR_INJEC_OCRAM_FRC1BI(error->FourceConti1BitDataInversion) |\n                FLEXRAM_OCRAM_ECC_ERROR_INJEC_OCRAM_FRCNCI(error->FourceContiNCDataInversion);\n            break;\n        case kFLEXRAM_ITCM:\n            base->ITCM_ECC_ERROR_INJEC = FLEXRAM_ITCM_ECC_ERROR_INJEC_ITCM_ERR1BIT(error->SingleBitPos) |\n                                         FLEXRAM_ITCM_ECC_ERROR_INJEC_ITCM_ERR2BIT(error->SecondBitPos) |\n                                         FLEXRAM_ITCM_ECC_ERROR_INJEC_ITCM_FR11BI(error->Fource1BitDataInversion) |\n                                         FLEXRAM_ITCM_ECC_ERROR_INJEC_ITCM_FR1NCI(error->FourceOneNCDataInversion) |\n                                         FLEXRAM_ITCM_ECC_ERROR_INJEC_ITCM_FRC1BI(error->FourceConti1BitDataInversion) |\n                                         FLEXRAM_ITCM_ECC_ERROR_INJEC_ITCM_FRCNCI(error->FourceContiNCDataInversion);\n            break;\n        case kFLEXRAM_D0TCM:\n            base->D0TCM_ECC_ERROR_INJEC =\n                FLEXRAM_D0TCM_ECC_ERROR_INJEC_D0TCM_ERR1BIT(error->SingleBitPos) |\n                FLEXRAM_D0TCM_ECC_ERROR_INJEC_D0TCM_ERR2BIT(error->SecondBitPos) |\n                FLEXRAM_D0TCM_ECC_ERROR_INJEC_D0TCM_FR11BI(error->Fource1BitDataInversion) |\n                FLEXRAM_D0TCM_ECC_ERROR_INJEC_D0TCM_FR1NCI(error->FourceOneNCDataInversion) |\n                FLEXRAM_D0TCM_ECC_ERROR_INJEC_D0TCM_FRC1BI(error->FourceConti1BitDataInversion) |\n                FLEXRAM_D0TCM_ECC_ERROR_INJEC_D0TCM_FRCNCI(error->FourceContiNCDataInversion);\n            break;\n        case kFLEXRAM_D1TCM:\n            base->D1TCM_ECC_ERROR_INJEC =\n                FLEXRAM_D1TCM_ECC_ERROR_INJEC_D1TCM_ERR1BIT(error->SingleBitPos) |\n                FLEXRAM_D1TCM_ECC_ERROR_INJEC_D1TCM_ERR2BIT(error->SecondBitPos) |\n                FLEXRAM_D1TCM_ECC_ERROR_INJEC_D1TCM_FR11BI(error->Fource1BitDataInversion) |\n                FLEXRAM_D1TCM_ECC_ERROR_INJEC_D1TCM_FR1NCI(error->FourceOneNCDataInversion) |\n                FLEXRAM_D1TCM_ECC_ERROR_INJEC_D1TCM_FRC1BI(error->FourceConti1BitDataInversion) |\n                FLEXRAM_D1TCM_ECC_ERROR_INJEC_D1TCM_FRCNCI(error->FourceContiNCDataInversion);\n            break;\n        default:\n            assert(NULL);\n            break;\n    }\n    __DSB();\n}\nvoid FLEXRAM_GetOcramSingleErroInfo(FLEXRAM_Type *base, flexram_ocram_ecc_single_error_info_t *info)\n{\n    assert(NULL != info);\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n    info->OcramSingleErrorECCCipher =\n        (uint8_t)((base->OCRAM_ECC_SINGLE_ERROR_INFO & FLEXRAM_OCRAM_ECC_SINGLE_ERROR_INFO_OCRAM_ECCS_ERRED_ECC_MASK) >>\n                  FLEXRAM_OCRAM_ECC_SINGLE_ERROR_INFO_OCRAM_ECCS_ERRED_ECC_SHIFT);\n    info->OcramSingleErrorECCSyndrome =\n        (uint8_t)((base->OCRAM_ECC_SINGLE_ERROR_INFO & FLEXRAM_OCRAM_ECC_SINGLE_ERROR_INFO_OCRAM_ECCS_ERRED_SYN_MASK) >>\n                  FLEXRAM_OCRAM_ECC_SINGLE_ERROR_INFO_OCRAM_ECCS_ERRED_SYN_SHIFT);\n#else\n    info->OcramSingleErrorInfo = base->OCRAM_ECC_SINGLE_ERROR_INFO;\n#endif \n    info->OcramSingleErrorAddr    = base->OCRAM_ECC_SINGLE_ERROR_ADDR;\n    info->OcramSingleErrorDataLSB = base->OCRAM_ECC_SINGLE_ERROR_DATA_LSB;\n    info->OcramSingleErrorDataMSB = base->OCRAM_ECC_SINGLE_ERROR_DATA_MSB;\n}\nvoid FLEXRAM_GetOcramMultiErroInfo(FLEXRAM_Type *base, flexram_ocram_ecc_multi_error_info_t *info)\n{\n    assert(NULL != info);\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n    info->OcramMultiErrorECCCipher =\n        (uint8_t)((base->OCRAM_ECC_MULTI_ERROR_INFO & FLEXRAM_OCRAM_ECC_MULTI_ERROR_INFO_OCRAM_ECCM_ERRED_ECC_MASK) >>\n                  FLEXRAM_OCRAM_ECC_MULTI_ERROR_INFO_OCRAM_ECCM_ERRED_ECC_SHIFT);\n#else\n    info->OcramMultiErrorInfo  = base->OCRAM_ECC_MULTI_ERROR_INFO;\n#endif \n    info->OcramMultiErrorAddr    = base->OCRAM_ECC_MULTI_ERROR_ADDR;\n    info->OcramMultiErrorDataLSB = base->OCRAM_ECC_MULTI_ERROR_DATA_LSB;\n    info->OcramMultiErrorDataMSB = base->OCRAM_ECC_MULTI_ERROR_DATA_MSB;\n}\nvoid FLEXRAM_GetItcmSingleErroInfo(FLEXRAM_Type *base, flexram_itcm_ecc_single_error_info_t *info)\n{\n    assert(NULL != info);\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n    uint8_t singleErrorECCSyndrome = 0x00U;\n    info->ItcmSingleErrorTCMWriteRead =\n        (uint8_t)((base->ITCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFW_MASK) >>\n                  FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFW_SHIFT);\n    info->ItcmSingleErrorTCMAccessSize =\n        (uint8_t)((base->ITCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFSIZ_MASK) >>\n                  FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFSIZ_SHIFT);\n    info->ItcmSingleErrorTCMMaster =\n        (uint8_t)((base->ITCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFMST_MASK) >>\n                  FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFMST_SHIFT);\n    info->ItcmSingleErrorTCMPrivilege =\n        (uint8_t)((base->ITCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFPRT_MASK) >>\n                  FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFPRT_SHIFT);\n    singleErrorECCSyndrome =\n        (uint8_t)((base->ITCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFSYN_MASK) >>\n                  FLEXRAM_ITCM_ECC_SINGLE_ERROR_INFO_ITCM_ECCS_EFSYN_SHIFT);\n    for (uint8_t i = 0x00U; i < sizeof(ItcmLookUpTable) / sizeof(ItcmLookUpTable[0]); i++)\n    {\n        if (singleErrorECCSyndrome == ItcmLookUpTable[i])\n        {\n            info->ItcmSingleErrorBitPostion = i;\n            break;\n        }\n    }\n#else\n    info->ItcmSingleErrorInfo  = base->ITCM_ECC_SINGLE_ERROR_INFO;\n#endif \n    info->ItcmSingleErrorAddr    = base->ITCM_ECC_SINGLE_ERROR_ADDR;\n    info->ItcmSingleErrorDataLSB = base->ITCM_ECC_SINGLE_ERROR_DATA_LSB;\n    info->ItcmSingleErrorDataMSB = base->ITCM_ECC_SINGLE_ERROR_DATA_MSB;\n}\nvoid FLEXRAM_GetItcmMultiErroInfo(FLEXRAM_Type *base, flexram_itcm_ecc_multi_error_info_t *info)\n{\n    assert(NULL != info);\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n    info->ItcmMultiErrorTCMWriteRead =\n        (uint8_t)((base->ITCM_ECC_MULTI_ERROR_INFO & FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFW_MASK) >>\n                  FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFW_SHIFT);\n    info->ItcmMultiErrorTCMAccessSize =\n        (uint8_t)((base->ITCM_ECC_MULTI_ERROR_INFO & FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFSIZ_MASK) >>\n                  FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFSIZ_SHIFT);\n    info->ItcmMultiErrorTCMMaster =\n        (uint8_t)((base->ITCM_ECC_MULTI_ERROR_INFO & FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFMST_MASK) >>\n                  FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFMST_SHIFT);\n    info->ItcmMultiErrorTCMPrivilege =\n        (uint8_t)((base->ITCM_ECC_MULTI_ERROR_INFO & FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFPRT_MASK) >>\n                  FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFPRT_SHIFT);\n    info->ItcmMultiErrorECCSyndrome =\n        (uint8_t)((base->ITCM_ECC_MULTI_ERROR_INFO & FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFSYN_MASK) >>\n                  FLEXRAM_ITCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFSYN_SHIFT);\n#else\n    info->ItcmMultiErrorInfo   = base->ITCM_ECC_MULTI_ERROR_INFO;\n#endif \n    info->ItcmMultiErrorAddr    = base->ITCM_ECC_MULTI_ERROR_ADDR;\n    info->ItcmMultiErrorDataLSB = base->ITCM_ECC_MULTI_ERROR_DATA_LSB;\n    info->ItcmMultiErrorDataMSB = base->ITCM_ECC_MULTI_ERROR_DATA_MSB;\n}\nvoid FLEXRAM_GetDtcmSingleErroInfo(FLEXRAM_Type *base, flexram_dtcm_ecc_single_error_info_t *info, uint8_t bank)\n{\n    assert(NULL != info);\n    assert((0x00U == bank) || (0x01U == bank));\n    if (0x00U == bank)\n    {\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n        uint8_t singleErrorECCSyndrome = 0x00U;\n        info->DtcmSingleErrorTCMWriteRead =\n            (uint8_t)((base->D0TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFW_MASK) >>\n                      FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFW_SHIFT);\n        info->DtcmSingleErrorTCMAccessSize =\n            (uint8_t)((base->D0TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFSIZ_MASK) >>\n                      FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFSIZ_SHIFT);\n        info->DtcmSingleErrorTCMMaster =\n            (uint8_t)((base->D0TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFMST_MASK) >>\n                      FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFMST_SHIFT);\n        info->DtcmSingleErrorTCMPrivilege =\n            (uint8_t)((base->D0TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFPRT_MASK) >>\n                      FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFPRT_SHIFT);\n        singleErrorECCSyndrome =\n            (uint8_t)((base->D0TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFSYN_MASK) >>\n                      FLEXRAM_D0TCM_ECC_SINGLE_ERROR_INFO_D0TCM_ECCS_EFSYN_SHIFT);\n        for (uint8_t i = 0x00U; i < sizeof(ItcmLookUpTable) / sizeof(ItcmLookUpTable[0]); i++)\n        {\n            if (singleErrorECCSyndrome == ItcmLookUpTable[i])\n            {\n                info->DtcmSingleErrorBitPostion = i;\n                break;\n            }\n        }\n#else\n        info->DtcmSingleErrorInfo = base->D0TCM_ECC_SINGLE_ERROR_INFO;\n#endif \n        info->DtcmSingleErrorAddr = base->D0TCM_ECC_SINGLE_ERROR_ADDR;\n        info->DtcmSingleErrorData = base->D0TCM_ECC_SINGLE_ERROR_DATA;\n    }\n    else\n    {\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n        uint8_t singleErrorECCSyndrome = 0x00U;\n        info->DtcmSingleErrorTCMWriteRead =\n            (uint8_t)((base->D1TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFW_MASK) >>\n                      FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFW_SHIFT);\n        info->DtcmSingleErrorTCMAccessSize =\n            (uint8_t)((base->D1TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFSIZ_MASK) >>\n                      FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFSIZ_SHIFT);\n        info->DtcmSingleErrorTCMMaster =\n            (uint8_t)((base->D1TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFMST_MASK) >>\n                      FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFMST_SHIFT);\n        info->DtcmSingleErrorTCMPrivilege =\n            (uint8_t)((base->D1TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFPRT_MASK) >>\n                      FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFPRT_SHIFT);\n        singleErrorECCSyndrome =\n            (uint8_t)((base->D1TCM_ECC_SINGLE_ERROR_INFO & FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFSYN_MASK) >>\n                      FLEXRAM_D1TCM_ECC_SINGLE_ERROR_INFO_D1TCM_ECCS_EFSYN_SHIFT);\n        for (uint8_t i = 0x00U; i < sizeof(DtcmLookUpTable) / sizeof(DtcmLookUpTable[0]); i++)\n        {\n            if (singleErrorECCSyndrome == DtcmLookUpTable[i])\n            {\n                info->DtcmSingleErrorBitPostion = i;\n                break;\n            }\n        }\n#else\n        info->DtcmSingleErrorInfo = base->D1TCM_ECC_SINGLE_ERROR_INFO;\n#endif \n        info->DtcmSingleErrorAddr = base->D1TCM_ECC_SINGLE_ERROR_ADDR;\n        info->DtcmSingleErrorData = base->D1TCM_ECC_SINGLE_ERROR_DATA;\n    }\n}\nvoid FLEXRAM_GetDtcmMultiErroInfo(FLEXRAM_Type *base, flexram_dtcm_ecc_multi_error_info_t *info, uint8_t bank)\n{\n    assert(NULL != info);\n    assert((0x00U == bank) || (0x01U == bank));\n    if (0x00U == bank)\n    {\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n        info->DtcmMultiErrorTCMWriteRead =\n            (uint8_t)((base->D0TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFW_MASK) >>\n                      FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFW_SHIFT);\n        info->DtcmMultiErrorTCMAccessSize =\n            (uint8_t)((base->D0TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFSIZ_MASK) >>\n                      FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFSIZ_SHIFT);\n        info->DtcmMultiErrorTCMMaster =\n            (uint8_t)((base->D0TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFMST_MASK) >>\n                      FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFMST_SHIFT);\n        info->DtcmMultiErrorTCMPrivilege =\n            (uint8_t)((base->D0TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFPRT_MASK) >>\n                      FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFPRT_SHIFT);\n        info->DtcmMultiErrorECCSyndrome =\n            (uint8_t)((base->D0TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFSYN_MASK) >>\n                      FLEXRAM_D0TCM_ECC_MULTI_ERROR_INFO_D0TCM_ECCS_EFSYN_SHIFT);\n#else\n        info->DtcmMultiErrorInfo  = base->D0TCM_ECC_MULTI_ERROR_INFO;\n#endif \n        info->DtcmMultiErrorAddr = base->D0TCM_ECC_MULTI_ERROR_ADDR;\n        info->DtcmMultiErrorData = base->D0TCM_ECC_MULTI_ERROR_DATA;\n    }\n    else\n    {\n#if defined(FLEXRAM_ECC_ERROR_DETAILED_INFO) && FLEXRAM_ECC_ERROR_DETAILED_INFO\n        info->DtcmMultiErrorTCMWriteRead =\n            (uint8_t)((base->D1TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFW_MASK) >>\n                      FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_D1TCM_ECCS_EFW_SHIFT);\n        info->DtcmMultiErrorTCMAccessSize =\n            (uint8_t)((base->D1TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFSIZ_MASK) >>\n                      FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_D1TCM_ECCS_EFSIZ_SHIFT);\n        info->DtcmMultiErrorTCMMaster =\n            (uint8_t)((base->D1TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFMST_MASK) >>\n                      FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_D1TCM_ECCS_EFMST_SHIFT);\n        info->DtcmMultiErrorTCMPrivilege =\n            (uint8_t)((base->D1TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFPRT_MASK) >>\n                      FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_D1TCM_ECCS_EFPRT_SHIFT);\n        info->DtcmMultiErrorECCSyndrome =\n            (uint8_t)((base->D1TCM_ECC_MULTI_ERROR_INFO & FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_ITCM_ECCS_EFSYN_MASK) >>\n                      FLEXRAM_D1TCM_ECC_MULTI_ERROR_INFO_D1TCM_ECCS_EFSYN_SHIFT);\n#else\n        info->DtcmMultiErrorInfo  = base->D1TCM_ECC_MULTI_ERROR_INFO;\n#endif \n        info->DtcmMultiErrorAddr = base->D1TCM_ECC_MULTI_ERROR_ADDR;\n        info->DtcmMultiErrorData = base->D1TCM_ECC_MULTI_ERROR_DATA;\n    }\n}\n#endif '"
"('Prompt: ""I need a function that calculates the dot product of two vectors represented by arrays of complex numbers in C. The function should multiply each element of one array by the corresponding element of the other array and sum the results. Additionally, the function should store the result in an output array of complex numbers. Can you provide me with the code for this function?""","//...\nint dotprod_crcf_run(float *         _h,\n                     float complex * _x,\n                     unsigned int    _n,\n                     float complex * _y)\n{\n    float complex r = 0;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\n//...')
"
('Prompt: You are working on a program that needs to calculate the weight of a vector represented by an unsigned character array. The function `vector_weight` should take two parameters: a pointer to the array `_x` and the length of the vector `_n`. The function should iterate over the elements of the array and increment the weight `w` for each non-zero element it encounters. Write a C function for `vector_weight` that implements this logic and returns the total weight of the vector.,"//...\n    return 0;\nunsigned int vector_weight(unsigned char * _x,\n                           unsigned int _n)\n{\n    unsigned int w = 0;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        w += _x[i] ? 1 : 0;\n    return w;\n}\n//...')
"
"'Prompt: You are working on a file handling system in C and need to implement functions for reading, writing, and managing files. Write code that includes functions for reading and writing to files, getting file system statistics, getting file information, and a file watcher feature that monitors file system events and prints notifications when a file or directory is created, deleted, or modified. Make sure to include all necessary headers and definitions.","#ifdef ENABLE_FILEWATCHER\n#endif\n#define __STDC_FORMAT_MACROS\nstatic void foo(void)\n{\n    int len = 0;\n    int i = 0;\n    file_backend_type type;\n    struct file *fw;\n    struct file *f;\n    struct iovec *iobuf;\n    char buf[128] = {0};\n    for (i = 0; i < 2; ++i) {\n        if (i == 0)\n            type = FILE_BACKEND_IO;\n        else if (i == 1)\n            type = FILE_BACKEND_FIO;\n        file_backend(type);\n        printf(""backend=%d\\n"", type);\n        fw = file_open(""lsusb"", F_CREATE);\n        file_write(fw, ""hello file\\n"", 11);\n        file_sync(fw);\n        file_seek(fw, 0, SEEK_SET);\n        memset(buf, 0, sizeof(buf));\n        len = file_read(fw, buf, sizeof(buf));\n        printf(""read len = %d, buf = %s"", len, buf);\n        file_close(fw);\n        f = file_open(""lsusb"", F_RDONLY);\n        memset(buf, 0, sizeof(buf));\n        len = file_read(f, buf, sizeof(buf));\n        printf(""read len = %d, buf = %s"", len, buf);\n        printf(""len=%zu\\n"", file_get_size(""lsusb""));\n        iobuf = file_dump(""lsusb"");\n        if (iobuf) {\n        }\n        iovec_destroy(iobuf);\n        file_close(f);\n    }\n}\nstatic void foo2(void)\n{\n    struct file_systat *stat = file_get_systat(""./Makefile"");\n    if (!stat)\n        return;\n    printf(""total = %"" PRIu64 ""MB\\n"", stat->size_total/(1024*1024));\n    printf(""avail = %"" PRIu64 ""MB\\n"", stat->size_avail/(1024*1024));\n    printf(""free = %"" PRIu64 ""MB\\n"", stat->size_free/(1024*1024));\n    printf(""fs type name = %s\\n"", stat->fs_type_name);\n    free(stat);\n}\nstatic void foo3(void)\n{\n    printf(""local path=%s\\n"", file_path_pwd());\n    printf(""suffix=%s\\n"", file_path_suffix(file_path_pwd()));\n    printf(""prefix=%s\\n"", file_path_prefix(file_path_pwd()));\n}\nstatic void foo4(void)\n{\n    int len = 0;\n    char buf[128] = {0};\n    struct file *fw = file_open(""lsusb"", F_APPEND);\n    file_write(fw, ""hello file\\n"", 11);\n    file_sync(fw);\n    file_seek(fw, 0, SEEK_SET);\n    memset(buf, 0, sizeof(buf));\n    len = file_read(fw, buf, sizeof(buf));\n    printf(""read len = %d, buf = %s"", len, buf);\n    file_close(fw);\n}\nstatic void foo5(void)\n{\n    struct file_info info;\n    file_get_info(""lsusb"", &info);\n    printf(""info->size = %"" PRIu64 ""\\n"", info.size);\n    printf(""info->type = %d\\n"", info.type);\n    printf(""info->time_modify = %"" PRIu64 ""\\n"", info.modify_sec);\n    printf(""info->time_access = %"" PRIu64 ""\\n"", info.access_sec);\n}\n#ifdef ENABLE_FILEWATCHER\n#define ROOT_DIR\t\t""./""\nstatic struct fw *_fw = NULL;\nvoid on_change(struct fw *fw, enum fw_type type, char *path)\n{\n    switch (type) {\n    case FW_CREATE_DIR:\n        printf(""[CREATE DIR] %s\\n"", path);\n        break;\n    case FW_CREATE_FILE:\n        printf(""[CREATE FILE] %s\\n"", path);\n        break;\n    case FW_DELETE_DIR:\n        printf(""[DELETE DIR] %s\\n"", path);\n        break;\n    case FW_DELETE_FILE:\n        printf(""[DELETE FILE] %s\\n"", path);\n        break;\n    case FW_MOVE_FROM_DIR:\n        printf(""[MOVE FROM DIR] %s\\n"", path);\n        break;\n    case FW_MOVE_TO_DIR:\n        printf(""[MOVE TO DIR] %s\\n"", path);\n        break;\n    case FW_MOVE_FROM_FILE:\n        printf(""[MOVE FROM FILE] %s\\n"", path);\n        break;\n    case FW_MOVE_TO_FILE:\n        printf(""[MOVE TO FILE] %s\\n"", path);\n        break;\n    case FW_MODIFY_FILE:\n        printf(""[MODIFY FILE] %s\\n"", path);\n        break;\n    default:\n        break;\n    }\n}\nint file_watcher_foo()\n{\n    _fw = fw_init(on_change);\n    if (!_fw) {\n        printf(""fw_init failed!\\n"");\n        return -1;\n    }\n    fw_add_watch_recursive(_fw, ROOT_DIR);\n    fw_dispatch(_fw);\n    return 0;\n}\n#endif\nstatic void sigint_handler(int sig)\n{\n#ifdef ENABLE_FILEWATCHER\n    fw_deinit(_fw);\n#endif\n}\nvoid signal_init()\n{\n    signal(SIGINT, sigint_handler);\n}\nint main(int argc, char **argv)\n{\n    uint64_t size = 1000;\n    signal_init();\n    file_dir_size(""./"", &size);\n    printf(""folder_size=%"" PRIu64 ""\\n"", size);\n    file_dir_tree(""./"");\n    foo5();\n    foo4();\n    foo();\n    foo2();\n    foo3();\n    if (0 != file_create(""jjj.c"")) {\n        printf(""file_create failed!\\n"");\n    }\n#ifdef ENABLE_FILEWATCHER\n    file_watcher_foo();\n#endif\n    return 0;\n}'"
"('Please implement functions to create, recreate, reset, and destroy a synchronization object for a digital communication system using orthogonal frequency-division multiplexing (OFDM). The synchronization object maintains information about the pilot symbols used in the system and performs synchronization tasks. The `qpilotsync_create` function initializes the synchronization object, generating pilot symbols based on a specific pilot spacing scheme. The `qpilotsync_recreate` function recreates the synchronization object with new payload length and pilot spacing parameters. The `qpilotsync_reset` function resets the synchronization object to its initial state. Lastly, the `qpilotsync_destroy` function frees allocated memory and resources associated with the synchronization object.","//...\nint qpilotsync_destroy(qpilotsync _q)\n{\n    free(_q->pilots);\n    FFT_FREE(_q->buf_time);\n    FFT_FREE(_q->buf_freq);\n    FFT_DESTROY_PLAN(_q->fft);\n    free(_q);\n    return LIQUID_OK;\n}\nint qpilotsync_reset(qpilotsync _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->nfft; i++)\n        _q->buf_time[i] = 0.0f;\n    _q->dphi_hat = 0.0f;\n    _q->phi_hat  = 0.0f;\n    _q->g_hat    = 1.0f;\n    return LIQUID_OK;\n}\nqpilotsync qpilotsync_create(unsigned int _payload_len,\n                             unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0)\n        return liquid_error_config(""qpilotsync_create(), frame length must be at least 1 symbol"");\n    if (_pilot_spacing < 2)\n        return liquid_error_config(""qpilotsync_create(), pilot spacing must be at least 2 symbols"");\n    qpilotsync q = (qpilotsync) malloc(sizeof(struct qpilotsync_s));\n    q->payload_len   = _payload_len;\n    q->pilot_spacing = _pilot_spacing;\n    q->num_pilots = qpilot_num_pilots(q->payload_len, q->pilot_spacing);\n    q->frame_len  = q->payload_len + q->num_pilots;\n    q->pilots = (float complex*) malloc(q->num_pilots*sizeof(float complex));\n    unsigned int m = liquid_nextpow2(q->num_pilots);\n    unsigned int i;\n    msequence seq = msequence_create_default(m);\n    for (i=0; i<q->num_pilots; i++) {\n        unsigned int s = msequence_generate_symbol(seq, 2);\n        float theta = (2 * M_PI * (float)s / 4.0f) + M_PI / 4.0f;\n        q->pilots[i] = cexpf(_Complex_I*theta);\n    }\n    msequence_destroy(seq);\n    q->nfft = 1 << liquid_nextpow2(q->num_pilots + (q->num_pilots>>1));\n    q->buf_time = (float complex*) FFT_MALLOC(q->nfft*sizeof(float complex));\n    q->buf_freq = (float complex*) FFT_MALLOC(q->nfft*sizeof(float complex));\n    q->fft      = FFT_CREATE_PLAN(q->nfft, q->buf_time, q->buf_freq, FFT_DIR_FORWARD, 0);\n    qpilotsync_reset(q);\n    return q;\n}\nqpilotsync qpilotsync_recreate(qpilotsync   _q,\n                               unsigned int _payload_len,\n                               unsigned int _pilot_spacing)\n{\n    if (_q != NULL)\n        qpilotsync_destroy(_q);\n    return qpilotsync_create(_payload_len, _pilot_spacing);\n}\n//...')
"
"('Prompt: Can you provide a code snippet that tests the modulation and demodulation functionality of a GMSK modem with varying parameters? The code should generate input symbols, modulate them, demodulate them, and compare the results to ensure accurate transmission. Additionally, could you include tests for copying a GMSK modem and demodulator to check if the copied objects behave the same as the original ones?","void gmskmodem_test_mod_demod(unsigned int _k,\n                              unsigned int _m,\n                              float        _bt)\n{\n    gmskmod mod = gmskmod_create(_k, _m, _bt);\n    gmskdem dem = gmskdem_create(_k, _m, _bt);\n    unsigned int delay = _m + _m;\n    unsigned int  num_symbols = 80 + delay; \n    msequence ms = msequence_create_default(7);\n    float complex buf[_k];      \n    unsigned int  sym_in [num_symbols]; \n    unsigned int  sym_out[num_symbols]; \n    unsigned int i;\n    for (i=0; i<num_symbols; i++) {\n        sym_in[i] = msequence_generate_symbol(ms, 1);\n        gmskmod_modulate(mod, sym_in[i], buf);\n        gmskdem_demodulate(dem, buf, sym_out + i);\n    }\n    for (i=0; i<num_symbols; i++) {\n        if (i >= delay) {\n#if 0\n            if (liquid_autotest_verbose) {\n                printf(""  %3u : input = %2u, output = %2u %s\\n"",\n                        i, sym_in[i-delay], sym_out[i],\n                        (sym_in[i-delay] == sym_out[i]) ? """" : ""*"");\n            }\n#endif\n            CONTEND_EQUALITY(sym_in[i-delay], sym_out[i]);\n        }\n    }\n    msequence_destroy(ms);\n    gmskmod_destroy(mod);\n    gmskdem_destroy(dem);\n}\nvoid autotest_gmskmodem_k4_m3_b025() { gmskmodem_test_mod_demod( 4, 3, 0.25f); }\nvoid autotest_gmskmodem_k2_m3_b025() { gmskmodem_test_mod_demod( 2, 3, 0.25f); }\nvoid autotest_gmskmodem_k3_m3_b025() { gmskmodem_test_mod_demod( 3, 3, 0.25f); }\nvoid autotest_gmskmodem_k5_m3_b025() { gmskmodem_test_mod_demod( 5, 3, 0.25f); }\nvoid autotest_gmskmodem_k8_m3_b033() { gmskmodem_test_mod_demod( 8, 3, 0.25f); }\nvoid autotest_gmskmodem_k4_m1_b025() { gmskmodem_test_mod_demod( 4, 1, 0.25f); }\nvoid autotest_gmskmodem_k4_m2_b025() { gmskmodem_test_mod_demod( 4, 2, 0.25f); }\nvoid autotest_gmskmodem_k4_m8_b025() { gmskmodem_test_mod_demod( 4, 8, 0.25f); }\nvoid autotest_gmskmodem_k4_m3_b020() { gmskmodem_test_mod_demod( 4, 3, 0.20f); }\nvoid autotest_gmskmodem_k4_m3_b033() { gmskmodem_test_mod_demod( 4, 3, 0.25f); }\nvoid autotest_gmskmodem_k4_m3_b050() { gmskmodem_test_mod_demod( 4, 3, 0.25f); }\nvoid autotest_gmskmod_copy()\n{\n    unsigned int k  = 5;\n    unsigned int m  = 3;\n    float        bt = 0.2345f;\n    gmskmod mod_orig = gmskmod_create(k, m, bt);\n    unsigned int num_symbols = 16;\n    float complex buf_orig[k];\n    float complex buf_copy[k];\n    msequence ms = msequence_create_default(7);\n    unsigned int i;\n    for (i=0; i<num_symbols; i++) {\n        unsigned char s = msequence_generate_symbol(ms, 1);\n        gmskmod_modulate(mod_orig, s, buf_orig);\n    }\n    gmskmod mod_copy = gmskmod_copy(mod_orig);\n    for (i=0; i<num_symbols; i++) {\n        unsigned char s = msequence_generate_symbol(ms, 1);\n        gmskmod_modulate(mod_orig, s, buf_orig);\n        gmskmod_modulate(mod_copy, s, buf_copy);\n        CONTEND_SAME_DATA(buf_orig, buf_copy, k*sizeof(float complex));\n    }\n    msequence_destroy(ms);\n    gmskmod_destroy(mod_orig);\n    gmskmod_destroy(mod_copy);\n}\nvoid autotest_gmskdem_copy()\n{\n    unsigned int k  = 5;\n    unsigned int m  = 3;\n    float        bt = 0.2345f;\n    gmskdem dem_orig = gmskdem_create(k, m, bt);\n    unsigned int num_symbols = 16;\n    float complex buf[k];\n    unsigned int  sym_orig;\n    unsigned int  sym_copy;\n    unsigned int i, j;\n    for (i=0; i<num_symbols; i++) {\n        for (j=0; j<k; j++)\n            buf[j] = randnf() + _Complex_I*randnf();\n        gmskdem_demodulate(dem_orig, buf, &sym_orig);\n    }\n    gmskdem dem_copy = gmskdem_copy(dem_orig);\n    for (i=0; i<num_symbols; i++) {\n        for (j=0; j<k; j++)\n            buf[j] = randnf() + _Complex_I*randnf();\n        gmskdem_demodulate(dem_orig, buf, &sym_orig);\n        gmskdem_demodulate(dem_copy, buf, &sym_copy);\n        CONTEND_EQUALITY(sym_orig, sym_copy);\n    }\n    gmskdem_destroy(dem_orig);\n    gmskdem_destroy(dem_copy);\n}')
"
('Please provide a prompt that describes a scenario where you need to test an equalizer using Liquid DSP library functions for a specific modulation scheme and parameters.,"//...\nvoid testbench_eqlms(unsigned int k, unsigned int m, float beta, int init,\n                     unsigned int p, float mu, unsigned int num_symbols,\n                     int update, int ms)\n{\n    unsigned int   i;\n    modemcf        mod    = modemcf_create(ms);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,k,m,beta,0);\n    float complex h[5] = {\n         1.00f +  0.00f*_Complex_I,\n         0.00f + -0.01f*_Complex_I,\n        -0.11f +  0.02f*_Complex_I,\n         0.02f +  0.01f*_Complex_I,\n        -0.09f + -0.04f*_Complex_I };\n    firfilt_cccf fchannel = firfilt_cccf_create(h,5);\n    float complex hp[2*k*p+1];\n    for (i=0; i<2*k*p+1; i++)\n        hp[i] = sincf( (float)i/(float)k - p) * liquid_hamming(i,2*k*p+1) / k;\n    eqlms_cccf eq;\n    switch (init) {\n    case 0: eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER,k,p,beta,0); break;\n    case 1: eq = eqlms_cccf_create_lowpass (2*k*p+1, 0.5f/(float)k); break;\n    case 2: eq = eqlms_cccf_create         (hp, 2*k*p+1); break; \n    default:eq = eqlms_cccf_create         (NULL, 2*k*p+1); break; \n    }\n    eqlms_cccf_set_bw(eq, mu);\n    float complex buf[k];                   \n    float complex sym_in, sym_out;          \n    wdelaycf buf_sym = wdelaycf_create(m+p);\n    float rmse = 0.0f; \n    for (i=0; i<2*num_symbols; i++) {\n        unsigned int sym = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod, sym, &sym_in);\n        wdelaycf_push(buf_sym, sym_in);\n        firinterp_crcf_execute(interp, sym_in, buf);\n        firfilt_cccf_execute_block(fchannel, buf, k, buf);\n        eqlms_cccf_decim_execute(eq, buf, &sym_out, k);\n        if (i < m + p) continue;\n        wdelaycf_read(buf_sym, &sym_in);\n        if (i < num_symbols) {\n            float complex d_hat;\n            unsigned int  index;\n            switch (update) {\n            case 0: eqlms_cccf_step(eq, sym_in, sym_out); break; \n            case 1: eqlms_cccf_step_blind(eq, sym_out);   break; \n            case 2:\n                modemcf_demodulate(mod, sym_out, &index);\n                modemcf_get_demodulator_sample(mod, &d_hat);\n                eqlms_cccf_step(eq, d_hat, sym_out);\n                break;\n            default:;\n            }\n            continue;\n        }\n        float error = cabsf(sym_in-sym_out);\n        rmse += error * error;\n#if 0\n        if (liquid_autotest_verbose) {\n            printf(""%3u : x = {%12.8f,%12.8f}, y = {%12.8f,%12.8f}, error=%12.8f %s\\n"",\n                    i, crealf(sym_in ), cimagf(sym_in ), crealf(sym_out), cimagf(sym_out),\n                    error, error > tol ? ""*"" : """");\n        }\n#endif\n    }\n    rmse = 10*log10f( rmse/num_symbols );\n    printf(""rmse : %.3f dB\\n"", rmse);\n    CONTEND_LESS_THAN(rmse, -20.0f);\n    wdelaycf_destroy(buf_sym);\n    firfilt_cccf_destroy(fchannel);\n    firinterp_crcf_destroy(interp);\n    eqlms_cccf_destroy(eq);\n    modemcf_destroy(mod);\n}\nvoid autotest_eqlms_04() { testbench_eqlms(2,7, 0.3,   1,7,0.3,800,     0,LIQUID_MODEM_QAM16); }\n//...')
"
"('Prompt: You are working on a software testing framework for a math library that includes functions to compute Bessel functions. You need to implement an automated test for the `besselj0f` function, which computes the Bessel function of the first kind of order 0 for floating-point numbers. Write a function `autotest_besselj0f` that performs a series of delta comparisons with expected values for different input values using a specified tolerance `tol`. The function should call the `liquid_besselj0f` function with various inputs and compare the results to expected values within the tolerance range. The delta comparisons should ensure that the Bessel function implementation is accurate within the specified tolerance.","//...\nvoid autotest_besselj0f()\n{\n    float tol = 1e-3f;\n    CONTEND_DELTA(liquid_besselj0f(0.0f),  1.0f, tol);\n    CONTEND_DELTA(liquid_besselj0f(0.1f),  0.997501562066040f, tol);\n    CONTEND_DELTA(liquid_besselj0f(0.2f),  0.990024972239576f, tol);\n    CONTEND_DELTA(liquid_besselj0f(0.5f),  0.938469807240813f, tol);\n    CONTEND_DELTA(liquid_besselj0f(1.0f),  0.765197686557967f, tol);\n    CONTEND_DELTA(liquid_besselj0f(2.0f),  0.223890779141236f, tol);\n    CONTEND_DELTA(liquid_besselj0f(2.5f), -0.048383776468199f, tol);\n    CONTEND_DELTA(liquid_besselj0f(3.0f), -0.260051954901934f, tol);\n    CONTEND_DELTA(liquid_besselj0f(3.5f), -0.380127739987263f, tol);\n    CONTEND_DELTA(liquid_besselj0f(4.0f), -0.397149809863848f, tol);\n    CONTEND_DELTA(liquid_besselj0f(4.5f), -0.320542508985121f, tol);\n}\n//...')
"
"('Prompt: You are working on a project where you need to calculate the root mean square error (RMSE) between a set of test values contained in the array `lngamma_test` and the values returned by the `sandbox_lngammaf` function for a given set of parameters in the `_v` array. Can you provide a C code snippet that defines the `sandbox_lngammaf` function and the `gserror` function which calculates RMSE based on the results of `sandbox_lngammaf` function for a total of 41 test values?. . Response:. ```c. //.... float z[41] = { ... }; // 41 test values. float sandbox_lngammaf(float _z,.                        float * _v). {.     float v0 = _v[0];.     float v1 = _v[1];.     float g_hat = (0.5f+_z)*logf(1.0f+_z) - (1.0f+_","//...\nfloat z[41] = {\nfloat z[41] = {\nfloat sandbox_lngammaf(float _z,\n                       float * _v)\n{\n    float v0 = _v[0];\n    float v1 = _v[1];\n    float g_hat = (0.5f+_z)*logf(1.0f+_z) - (1.0f+_z) + 0.5f*logf(2*M_PI) - logf(_z) +\n           v0*(1.0f - tanhf(v1*logf(_z)));\n    return g_hat;\n}\nfloat gserror(void * _userdata,\n              float * _v,\n              unsigned int _n)\n{\n    float rmse = 0.0f;\n    unsigned int i;\n    for (i=0; i<41; i++) {\n        float g = sandbox_lngammaf(z[i], _v);\n        float e = g - lngamma_test[i];\n        rmse += e*e;\n    }\n    return sqrtf(rmse / 41.0f);\n}\n//...')
"
'Prompt: You are developing a software application that needs to handle file operations on both 32-bit and 64-bit Windows systems. Write a conditional preprocessor directive that specifies using a 32-bit time_t type and a 32-bit file offset on Windows systems.,#ifndef  _WIN64 \n#define _USE_32BIT_TIME_T\n#define _FILE_OFFSET_BITS 32\n#endif'
"('Please provide the code for testing polynomial fitting, Lagrange interpolation, binomial expansion, and other polynomial operations.","void autotest_polyf_fit_q3n3()\n{\n    unsigned int Q=2;   \n    unsigned int n=3;   \n    float x[3] = {-1.0f, 0.0f, 1.0f};\n    float y[3] = { 1.0f, 0.0f, 1.0f};\n    float p[3];\n    float p_test[3] = {0.0f, 0.0f, 1.0f};\n    float tol = 1e-3f;\n    unsigned int k=Q+1;\n    polyf_fit(x,y,n, p,k);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        for (i=0; i<3; i++)\n            printf(""%3u : %12.8f > %12.8f\\n"", i, x[i], y[i]);\n        for (i=0; i<3; i++)\n            printf(""p[%3u] = %12.8f\\n"", i, p[i]);\n    }\n    CONTEND_DELTA(p[0], p_test[0], tol);\n    CONTEND_DELTA(p[1], p_test[1], tol);\n    CONTEND_DELTA(p[2], p_test[2], tol);\n}\nvoid autotest_polyf_lagrange_issue165()\n{\n    unsigned int n=3;   \n    float x[3] = {-1.0f, 0.0f, 1.0f};\n    float y[3] = {7.059105f, 24.998369f, 14.365907f};\n    float p[3];\n    float tol = 1e-3f;\n    polyf_fit_lagrange(x,y,n,p);\n    unsigned int j;\n    for (j=0; j<n; j++)\n        printf(""%3u : %12.8f > %12.8f\\n"", j, x[j], y[j]);\n    for (j=0; j<n; j++)\n        printf(""p[%3u] = %12.8f\\n"", j, p[j]);\n    float y_out[3];\n    for (j=0; j<n; j++) {\n        y_out[j] = polyf_val(p, n, x[j]);\n        printf(""y_out[%3u] = %12.8f exp=%12.8f\\n"", j, y_out[j], y[j]);\n        CONTEND_DELTA(y[j], y_out[j], tol);\n    }\n    polyf_fit(x,y,n,p,n);\n    for (j=0; j<n; j++)\n        printf(""p_least_sq[%3u] = %12.8f\\n"", j, p[j]);\n    float y_least_sq[3];\n    for (j=0; j<n; j++) {\n        y_least_sq[j] = polyf_val(p, n, x[j]);\n        printf(""y_least_sq[%3u] = %12.8f exp=%12.8f\\n"", j, y_least_sq[j], y[j]);\n        CONTEND_DELTA(y_least_sq[j], y_out[j], tol);\n    }\n}\nvoid autotest_polyf_lagrange()\n{\n    unsigned int n=3; \n    float x[3] = {1.0f, 2.0f, 3.0f};\n    float y[3] = {1.0f, 8.0f, 27.0f};\n    float p[3];\n    float tol = 1e-3;\n    polyf_fit_lagrange(x,y,n,p);\n    unsigned int j;\n    for (j=0; j<n; j++)\n        printf(""p[%3u] = %12.8f\\n"", j, p[j]);\n    float y_out[3];\n    for (j=0; j<n; j++) {\n        y_out[j] = polyf_val(p, n, x[j]);\n        printf(""y_out[%3u] = %12.8f exp=%12.8f\\n"", j, y_out[j], y[j]);\n        CONTEND_DELTA(y[j], y_out[j], tol);\n    }\n}\n#if 0\nvoid xautotest_polyf_expandbinomial_4()\n{\n    float a[4] = { 3, 2, -5, 1 };\n    float c[5];\n    float c_test[5] = { 1, 1, -19, -49, -30 };\n    float tol = 1e-3f;\n    polyf_expandbinomial(a,4,c);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        printf(""c[5] = "");\n        for (i=0; i<5; i++)\n            printf(""%8.2f"", c[i]);\n        printf(""\\n"");\n    }\n    CONTEND_DELTA(c[0], c_test[0], tol);\n    CONTEND_DELTA(c[1], c_test[1], tol);\n    CONTEND_DELTA(c[2], c_test[2], tol);\n    CONTEND_DELTA(c[3], c_test[3], tol);\n    CONTEND_DELTA(c[4], c_test[4], tol);\n}\n#endif\nvoid autotest_polyf_expandroots_4()\n{\n    float roots[5] = { -2, -1, -4, 5, 3 };\n    float c[6];\n    float c_test[6] = { 120, 146, 1, -27, -1, 1 };\n    float tol = 1e-3f;\n    polyf_expandroots(roots,5,c);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        printf(""c[6] = "");\n        for (i=0; i<6; i++)\n            printf(""%8.2f"", c[i]);\n        printf(""\\n"");\n    }\n    CONTEND_DELTA(c[0], c_test[0], tol);\n    CONTEND_DELTA(c[1], c_test[1], tol);\n    CONTEND_DELTA(c[2], c_test[2], tol);\n    CONTEND_DELTA(c[3], c_test[3], tol);\n    CONTEND_DELTA(c[4], c_test[4], tol);\n    CONTEND_DELTA(c[5], c_test[5], tol);\n}\nvoid autotest_polyf_expandroots_11()\n{\n    float roots[11] = { -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11 };\n    float c[12];\n    float c_test[12] = {39916800,\n                        120543840,\n                        150917976,\n                        105258076,\n                        45995730,\n                        13339535,\n                        2637558,\n                        357423,\n                        32670,\n                        1925,\n                        66,\n                        1};\n    float tol = 1e-6f;\n    polyf_expandroots(roots,11,c);\n    unsigned int i;\n    for (i=0; i<12; i++) {\n        if (liquid_autotest_verbose)\n            printf(""  c[%3u] : %16.8e (expected %16.8e)\\n"", i, c[i], c_test[i]);\n        CONTEND_DELTA(c[i], c_test[i], fabsf(tol*c_test[i]));\n    }\n}\nvoid autotest_polycf_expandroots_4()\n{\n    float theta = 1.7f;\n    float complex a[2] = { -cexpf(_Complex_I*theta), -cexpf(-_Complex_I*theta) };\n    float complex c[3];\n    float complex c_test[3] = { 1, 2*cosf(theta), 1 };\n    float tol = 1e-3f;\n    polycf_expandroots(a,2,c);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        for (i=0; i<3; i++)\n            printf(""c[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(c[i]), cimagf(c[i]));\n    }\n    CONTEND_DELTA(crealf(c[0]), crealf(c_test[0]), tol);\n    CONTEND_DELTA(cimagf(c[0]), cimagf(c_test[0]), tol);\n    CONTEND_DELTA(crealf(c[1]), crealf(c_test[1]), tol);\n    CONTEND_DELTA(cimagf(c[1]), cimagf(c_test[1]), tol);\n    CONTEND_DELTA(crealf(c[2]), crealf(c_test[2]), tol);\n    CONTEND_DELTA(cimagf(c[2]), cimagf(c_test[2]), tol);\n}\nvoid autotest_polyf_expandroots2_3()\n{\n    unsigned int n=3;\n    float a[3] = {  2,  3, -1 };\n    float b[3] = {  5, -2, -3 };\n    float c[4];\n    float c_test[4] = { -6, 29, -23, -30 };\n    float tol = 1e-3f;\n    polyf_expandroots2(a,b,n,c);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        printf(""c[%u] = "", n+1);\n        for (i=0; i<n+1; i++)\n            printf(""%8.2f"", c[i]);\n        printf(""\\n"");\n    }\n    CONTEND_DELTA(c[0], c_test[0], tol);\n    CONTEND_DELTA(c[1], c_test[1], tol);\n    CONTEND_DELTA(c[2], c_test[2], tol);\n    CONTEND_DELTA(c[3], c_test[3], tol);\n}\nvoid autotest_polyf_mul_2_3()\n{\n    float a[3] = {  2, -4,  3 };\n    float b[4] = { -9,  3, -2,  5};\n    float c[6];\n    float c_test[6] = { -18, 42, -43, 27, -26, 15 };\n    float tol = 1e-3f;\n    polyf_mul(a,2,b,3,c);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        printf(""c[6] = "");\n        for (i=0; i<6; i++)\n            printf(""%8.2f"", c[i]);\n        printf(""\\n"");\n    }\n    CONTEND_DELTA(c[0], c_test[0], tol);\n    CONTEND_DELTA(c[1], c_test[1], tol);\n    CONTEND_DELTA(c[2], c_test[2], tol);\n    CONTEND_DELTA(c[3], c_test[3], tol);\n    CONTEND_DELTA(c[4], c_test[4], tol);\n    CONTEND_DELTA(c[5], c_test[5], tol);\n}\nvoid autotest_poly_expandbinomial_n6()\n{\n    unsigned int n=6;\n    float c[7];\n    float c_test[7] = {1, 6, 15, 20, 15, 6, 1};\n    polyf_expandbinomial(n,c);\n    if (liquid_autotest_verbose) {\n        unsigned int i;\n        printf(""c[%2u] = "", n+1);\n        for (i=0; i<=n; i++)\n            printf(""%6.1f"", c[i]);\n        printf(""\\n"");\n    }\n    CONTEND_SAME_DATA(c,c_test,sizeof(c));\n}\nvoid autotest_poly_binomial_expand_pm_m6_k1()\n{\n    unsigned int m=5;\n    unsigned int k=1;\n    unsigned int n = m+k;\n    float c[7];\n    float c_test[7] = {1,  4,  5,  0, -5, -4, -1};\n    polyf_expandbinomial_pm(m,k,c);\n    unsigned int i;\n    if (liquid_autotest_verbose) {\n        printf(""c[%u] = "", m+1);\n        for (i=0; i<=n; i++)\n            printf(""%6.1f"", c[i]);\n        printf(""\\n"");\n    }\n    for (i=0; i<=n; i++)\n        CONTEND_DELTA(c[i], c_test[i], 1e-3f);\n}\nvoid autotest_poly_expandbinomial_pm_m5_k2()\n{\n    unsigned int m=5;\n    unsigned int k=2;\n    unsigned int n = m+k;\n    float c[8];\n    float c_test[8] = {  1.0f,  3.0f,  1.0f, -5.0f,\n                        -5.0f,  1.0f,  3.0f,  1.0f};\n    polyf_expandbinomial_pm(m,k,c);\n    unsigned int i;\n    if (liquid_autotest_verbose) {\n        printf(""c[%u] = "", n+1);\n        for (i=0; i<=n; i++)\n            printf(""%6.2f"", c[i]);\n        printf(""\\n"");\n    }\n    for (i=0; i<=n; i++)\n        CONTEND_DELTA(c[i], c_test[i], 1e-3f);\n}')
"
('Please provide the prompt in which you would like to use the given code snippet.,"//...\n    unsigned int M;         \n    unsigned int M2;        \n    unsigned int cp_len;    \n    unsigned char * p;      \n    float complex * x;      \n    windowcf input_buffer;  \n    unsigned int M_S0;      \n    float g0;               \n    float complex * G0a;    \n    float complex * G;      \n    float complex * B;      \n    float complex * R;      \n#define DEBUG_OFDMFRAMESYNC             0\n    float complex s_hat_0;      \n    for (i=0; i<_q->M; i++)\n        float complex w;\n    return LIQUID_OK;\nint ofdmframesync_execute_S1(ofdmframesync _q)\n{\n    _q->timer--;\n    if (_q->timer > 0)\n        return LIQUID_OK;\n    _q->num_symbols++;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S1(_q, &rc[_q->cp_len], _q->G);\n    float complex g_hat = 0.0f;\n    unsigned int i;\n    for (i=0; i<_q->M; i++) {\n        g_hat += _q->G[(i+1)%_q->M]*conjf(_q->G[i]);\n    }\n    g_hat /= _q->M_S1; \n    g_hat *= _q->g0;\n    g_hat *= liquid_cexpjf((float)(_q->backoff)*2.0f*M_PI/(float)(_q->M));\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf(""    g_hat   :   %12.4f <%12.8f>\\n"", cabsf(g_hat), cargf(g_hat));\n#endif\n    if (cabsf(g_hat) > _q->plcp_sync_thresh && fabsf(cargf(g_hat)) < 0.1f*M_PI ) {\n        _q->state = OFDMFRAMESYNC_STATE_RXSYMBOLS;\n        _q->timer = _q->M + _q->cp_len + _q->backoff;\n        _q->num_symbols = 0;\n        float g = (float)(_q->M) / sqrtf(_q->M_pilot + _q->M_data);\n        for (i=0; i<_q->M; i++) {\n            _q->G[i] *= g;          \n            _q->G[i] *= _q->B[i];   \n        }\n#if 0\n        unsigned int ntaps = (_q->M < 8) ? 2 : 8;\n        ofdmframesync_estimate_eqgain(_q, ntaps);\n#else\n        unsigned int poly_order = 4;\n        if (poly_order >= _q->M_pilot + _q->M_data)\n            poly_order = _q->M_pilot + _q->M_data - 1;\n        ofdmframesync_estimate_eqgain_poly(_q, poly_order);\n#endif\n#if 1\n        unsigned int i;\n        for (i=0; i<_q->M; i++)\n            _q->R[i] = _q->B[i] / _q->G[i];\n#endif\n        return LIQUID_OK;\n    }\n    if (_q->num_symbols == 16) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""could not find S1 symbol. bailing...\\n"");\n#endif\n        ofdmframesync_reset(_q);\n    }\n    _q->timer = _q->M2;\n    return LIQUID_OK;\n}\nint ofdmframesync_rxsymbol(ofdmframesync _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        _q->X[i] *= _q->R[i];\n    float x_phase[_q->M_pilot];\n    float y_phase[_q->M_pilot];\n    float p_phase[2];\n    unsigned int n=0;\n    unsigned int k;\n    float complex pilot = 1.0f;\n    for (i=0; i<_q->M; i++) {\n        k = (i + _q->M2) % _q->M;\n        if (_q->p[k]==OFDMFRAME_SCTYPE_PILOT) {\n            if (n == _q->M_pilot)\n                return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n            pilot = (msequence_advance(_q->ms_pilot) ? 1.0f : -1.0f);\n#if 0\n            printf(""pilot[%3u] = %12.4e + j*%12.4e (expected %12.4e + j*%12.4e)\\n"",\n                    k,\n                    crealf(_q->X[k]), cimagf(_q->X[k]),\n                    crealf(pilot),    cimagf(pilot));\n#endif\n            x_phase[n] = (k > _q->M2) ? (float)k - (float)(_q->M) : (float)k;\n            y_phase[n] = cargf(_q->X[k]*conjf(pilot));\n            n++;\n        }\n    }\n    if (n != _q->M_pilot)\n        return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n    liquid_unwrap_phase(y_phase, _q->M_pilot);\n    polyf_fit(x_phase, y_phase, _q->M_pilot, p_phase, 2);\n    float alpha = 0.3f;\n    p_phase[1] = alpha*p_phase[1] + (1-alpha)*_q->p1_prime;\n    _q->p1_prime = p_phase[1];\n#if DEBUG_OFDMFRAMESYNC\n    if (_q->debug_enabled) {\n        memmove(_q->px, x_phase, _q->M_pilot*sizeof(float));\n        memmove(_q->py, y_phase, _q->M_pilot*sizeof(float));\n        _q->p_phase[0] = p_phase[1];\n        _q->p_phase[1] = p_phase[0];\n        windowf_push(_q->debug_pilot_0, p_phase[0]);\n        windowf_push(_q->debug_pilot_1, p_phase[1]);\n    }\n#endif\n    for (i=0; i<_q->M; i++) {\n        if (_q->p[i] == OFDMFRAME_SCTYPE_NULL) {\n            _q->X[i] = 0.0f;\n        } else {\n            float fx    = (i > _q->M2) ? (float)i - (float)(_q->M) : (float)i;\n            float theta = polyf_val(p_phase, 2, fx);\n            _q->X[i] *= liquid_cexpjf(-theta);\n        }\n    }\n    if (_q->num_symbols > 0) {\n        float dphi_prime = p_phase[0] - _q->phi_prime;\n        while (dphi_prime >  M_PI) dphi_prime -= M_2_PI;\n        while (dphi_prime < -M_PI) dphi_prime += M_2_PI;\n        nco_crcf_adjust_frequency(_q->nco_rx, 1e-3f*dphi_prime);\n    }\n    _q->phi_prime = p_phase[0];\n    _q->num_symbols++;\n#if 0\n    for (i=0; i<_q->M_pilot; i++)\n        printf(""x_phase(%3u) = %12.8f; y_phase(%3u) = %12.8f;\\n"", i+1, x_phase[i], i+1, y_phase[i]);\n    printf(""poly : p0=%12.8f, p1=%12.8f\\n"", p_phase[0], p_phase[1]);\n#endif\n    return LIQUID_OK;\n}\nint ofdmframesync_S0_metrics(ofdmframesync   _q,\n                             float complex * _G,\n                             float complex * _s_hat)\n{\n    unsigned int i;\n    float complex s_hat = 0.0f;\n    for (i=0; i<_q->M; i+=2) {\n        s_hat += _G[(i+2)%_q->M]*conjf(_G[i]);\n    }\n    s_hat /= _q->M_S0; \n    *_s_hat = s_hat;\n    return LIQUID_OK;\n}\nint ofdmframesync_estimate_gain_S0(ofdmframesync   _q,\n                                   float complex * _x,\n                                   float complex * _G)\n{\n    memmove(_q->x, _x, (_q->M)*sizeof(float complex));\n    FFT_EXECUTE(_q->fft);\n    unsigned int i;\n    float gain = sqrtf(_q->M_S0) / (float)(_q->M);\n    for (i=0; i<_q->M; i++) {\n        if (_q->p[i] != OFDMFRAME_SCTYPE_NULL && (i%2)==0) {\n            _G[i] = _q->X[i] * conjf(_q->S0[i]);\n        } else {\n            _G[i] = 0.0f;\n        }\n        _G[i] *= gain;\n    }\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_S0b(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M2)\n        return LIQUID_OK;\n    _q->timer = _q->M + _q->cp_len - _q->backoff;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0b);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0b, &s_hat);\n    s_hat *= _q->g0;\n    _q->s_hat_1 = s_hat;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n    printf(""********** S0[1] received ************\\n"");\n    printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n    printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n    tau_hat  = cargf(_q->s_hat_0 + _q->s_hat_1) * (float)(_q->M2) / (2*M_PI);\n    printf(""  tau_hat * :   %12.8f\\n"", tau_hat);\n    printf(""**********\\n"");\n#endif\n    float tau_prime = cargf(_q->s_hat_0 + _q->s_hat_1) * (float)(_q->M2) / (2*M_PI);\n    _q->timer -= (int)roundf(tau_prime);\n#if 0\n    if (cabsf(s_hat) < 0.3f) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""false alarm S0[1]\\n"");\n#endif\n        ofdmframesync_reset(_q);\n        return;\n    }\n#endif\n    unsigned int i;\n#if 0\n    float complex g_hat = 0.0f;\n    for (i=0; i<_q->M; i++)\n        g_hat += _q->G0b[i] * conjf(_q->G0a[i]);\n    float nu_hat = 2.0f * cargf(g_hat) / (float)(_q->M);\n#else\n    float complex t0 = 0.0f;\n    for (i=0; i<_q->M2; i++) {\n        t0 += conjf(rc[i])       *       _q->s0[i] * \n                    rc[i+_q->M2] * conjf(_q->s0[i+_q->M2]);\n    }\n    float nu_hat = cargf(t0) / (float)(_q->M2);\n#endif\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf(""   nu_hat   :   %12.8f\\n"", nu_hat);\n#endif\n    nco_crcf_set_frequency(_q->nco_rx, nu_hat);\n    _q->state = OFDMFRAMESYNC_STATE_PLCPLONG;\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_seekplcp(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M)\n        return LIQUID_OK;\n    _q->timer = 0;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    unsigned int i;\n    float g = 1.0e-9f;\n    for (i=_q->cp_len; i<_q->M + _q->cp_len; i++) {\n        g += crealf(rc[i])*crealf(rc[i]) + cimagf(rc[i])*cimagf(rc[i]);\n    }\n    g = (float)(_q->M) / g;\n#if OFDMFRAMESYNC_ENABLE_SQUELCH\n    if ( -10*log10f( sqrtf(g) ) < _q->squelch_threshold &&\n         _q->squelch_enabled)\n    {\n        printf(""squelch\\n"");\n        return LIQUID_OK;\n    }\n#endif\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);\n    s_hat *= g;\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf("" - gain=%12.3f, rssi=%12.8f, s_hat=%12.4f <%12.8f>, tau_hat=%8.3f\\n"",\n            sqrt(g),\n            -10*log10(g),\n            cabsf(s_hat), cargf(s_hat),\n            tau_hat);\n#endif\n    _q->g0 = g;\n    if (cabsf(s_hat) > _q->plcp_detect_thresh) {\n        int dt = (int)roundf(tau_hat);\n        _q->timer = (_q->M + dt) % (_q->M2);\n        _q->timer += _q->M; \n        _q->state = OFDMFRAMESYNC_STATE_PLCPSHORT0;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""********** frame detected! ************\\n"");\n        printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n        printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n        printf(""    dt      :   %12d\\n"", dt);\n        printf(""    timer   :   %12u\\n"", _q->timer);\n#endif\n    }\n    return LIQUID_OK;\n}\nint ofdmframesync_estimate_eqgain_poly(ofdmframesync _q,\n                                       unsigned int _order)\n{\n#if DEBUG_OFDMFRAMESYNC\n    if (_q->debug_enabled) {\n        memmove(_q->G_hat, _q->G, _q->M*sizeof(float complex));\n    }\n#endif\n    unsigned int i;\n    unsigned int N = _q->M_pilot + _q->M_data;\n    if (_order > N-1) _order = N-1;\n    if (_order > 10)  _order = 10;\n    float x_freq[N];\n    float y_abs[N];\n    float y_arg[N];\n    float p_abs[_order+1];\n    float p_arg[_order+1];\n    unsigned int n=0;\n    unsigned int k;\n    for (i=0; i<_q->M; i++) {\n        k = (i + _q->M2) % _q->M;\n        if (_q->p[k] != OFDMFRAME_SCTYPE_NULL) {\n            if (n == N)\n                return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n            x_freq[n] = (k > _q->M2) ? (float)k - (float)(_q->M) : (float)k;\n            x_freq[n] = x_freq[n] / (float)(_q->M);\n            y_abs[n] = cabsf(_q->G[k]);\n            y_arg[n] = cargf(_q->G[k]);\n            n++;\n        }\n    }\n    if (n != N)\n        return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n    liquid_unwrap_phase(y_arg, N);\n    polyf_fit(x_freq, y_abs, N, p_abs, _order+1);\n    polyf_fit(x_freq, y_arg, N, p_arg, _order+1);\n    for (i=0; i<_q->M; i++) {\n        float freq = (i > _q->M2) ? (float)i - (float)(_q->M) : (float)i;\n        freq = freq / (float)(_q->M);\n        float A     = polyf_val(p_abs, _order+1, freq);\n        float theta = polyf_val(p_arg, _order+1, freq);\n        _q->G[i] = (_q->p[i] == OFDMFRAME_SCTYPE_NULL) ? 0.0f : A * liquid_cexpjf(theta);\n    }\n#if 0\n    for (i=0; i<N; i++)\n        printf(""x(%3u) = %12.8f; y_abs(%3u) = %12.8f; y_arg(%3u) = %12.8f;\\n"",\n                i+1, x_freq[i],\n                i+1, y_abs[i],\n                i+1, y_arg[i]);\n    for (i=0; i<=_order; i++)\n        printf(""p_abs(%3u) = %12.8f;\\n"", i+1, p_abs[i]);\n    for (i=0; i<=_order; i++)\n        printf(""p_arg(%3u) = %12.8f;\\n"", i+1, p_arg[i]);\n#endif\n    return LIQUID_OK;\n}\nint ofdmframesync_estimate_gain_S1(ofdmframesync _q,\n                                   float complex * _x,\n                                   float complex * _G)\n{\n    memmove(_q->x, _x, (_q->M)*sizeof(float complex));\n    FFT_EXECUTE(_q->fft);\n    unsigned int i;\n    float gain = sqrtf(_q->M_S1) / (float)(_q->M);\n    for (i=0; i<_q->M; i++) {\n        if (_q->p[i] != OFDMFRAME_SCTYPE_NULL) {\n            _G[i] = _q->X[i] * conjf(_q->S1[i]);\n        } else {\n            _G[i] = 0.0f;\n        }\n        _G[i] *= gain;\n    }   \n    return LIQUID_OK;\n}\nint ofdmframesync_reset(ofdmframesync _q)\n{\n#if 0\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        _q->G[i] = 1.0f;\n#endif\n    nco_crcf_reset(_q->nco_rx);\n    msequence_reset(_q->ms_pilot);\n    _q->timer = 0;\n    _q->num_symbols = 0;\n    _q->s_hat_0 = 0.0f;\n    _q->s_hat_1 = 0.0f;\n    _q->phi_prime = 0.0f;\n    _q->p1_prime = 0.0f;\n    _q->plcp_detect_thresh = (_q->M > 44) ? 0.35f : 0.35f + 0.01f*(44 - _q->M);\n    _q->plcp_sync_thresh   = (_q->M > 44) ? 0.30f : 0.30f + 0.01f*(44 - _q->M);\n    _q->state = OFDMFRAMESYNC_STATE_SEEKPLCP;\n    return LIQUID_OK;\n}\nint ofdmframesync_execute(ofdmframesync   _q,\n                          float complex * _x,\n                          unsigned int    _n)\n{\n    unsigned int i;\n    float complex x;\n    for (i=0; i<_n; i++) {\n        x = _x[i];\n        if (_q->state != OFDMFRAMESYNC_STATE_SEEKPLCP) {\n            nco_crcf_mix_down(_q->nco_rx, x, &x);\n            nco_crcf_step(_q->nco_rx);\n        }\n        windowcf_push(_q->input_buffer,x);\n#if DEBUG_OFDMFRAMESYNC\n        if (_q->debug_enabled) {\n            windowcf_push(_q->debug_x, x);\n            windowf_push(_q->debug_rssi, crealf(x)*crealf(x) + cimagf(x)*cimagf(x));\n        }\n#endif\n        switch (_q->state) {\n        case OFDMFRAMESYNC_STATE_SEEKPLCP:\n            ofdmframesync_execute_seekplcp(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_PLCPSHORT0:\n            ofdmframesync_execute_S0a(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_PLCPSHORT1:\n            ofdmframesync_execute_S0b(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_PLCPLONG:\n            ofdmframesync_execute_S1(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_RXSYMBOLS:\n            ofdmframesync_execute_rxsymbols(_q);\n            break;\n        default:;\n        }\n    } \n    return LIQUID_OK;\n}\nint ofdmframesync_execute_S0a(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M2)\n        return LIQUID_OK;\n    _q->timer = 0;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);\n    s_hat *= _q->g0;\n    _q->s_hat_0 = s_hat;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n    printf(""********** S0[0] received ************\\n"");\n    printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n    printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n#endif\n#if 0\n    if (cabsf(s_hat) < 0.3f) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""false alarm S0[0]\\n"");\n#endif\n        ofdmframesync_reset(_q);\n        return;\n    }\n#endif\n    _q->state = OFDMFRAMESYNC_STATE_PLCPSHORT1;\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_rxsymbols(ofdmframesync _q)\n{\n    _q->timer--;\n    if (_q->timer == 0) {\n        float complex * rc;\n        windowcf_read(_q->input_buffer, &rc);\n        memmove(_q->x, &rc[_q->cp_len-_q->backoff], (_q->M)*sizeof(float complex));\n        FFT_EXECUTE(_q->fft);\n        ofdmframesync_rxsymbol(_q);\n#if DEBUG_OFDMFRAMESYNC\n        if (_q->debug_enabled) {\n            unsigned int i;\n            for (i=0; i<_q->M; i++) {\n                if (_q->p[i] == OFDMFRAME_SCTYPE_DATA)\n                    windowcf_push(_q->debug_framesyms, _q->X[i]);\n            }\n        }\n#endif\n        if (_q->callback != NULL) {\n            int retval = _q->callback(_q->X, _q->p, _q->M, _q->userdata);\n            if (retval != 0)\n                ofdmframesync_reset(_q);\n        }\n        _q->timer = _q->M + _q->cp_len;\n    }\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_S0a(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M2)\n        return LIQUID_OK;\n    _q->timer = 0;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);\n    s_hat *= _q->g0;\n    _q->s_hat_0 = s_hat;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n    printf(""********** S0[0] received ************\\n"");\n    printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n    printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n#endif\n#if 0\n    if (cabsf(s_hat) < 0.3f) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""false alarm S0[0]\\n"");\n#endif\n        ofdmframesync_reset(_q);\n        return;\n    }\n#endif\n    _q->state = OFDMFRAMESYNC_STATE_PLCPSHORT1;\n    return LIQUID_OK;\n}\n//...')
"
"'You are working on a project that involves using a chart feature and you need to implement event handling for the chart. The prompt is: . . ""Can you write a function that handles various events for a chart object, such as value changed, external draw size refresh, post draw end and release events? The function should update the chart accordingly based on the event type. Also, can you create an example function that sets up a chart with two series and random data values for each series?""","#if LV_USE_CHART && LV_BUILD_EXAMPLES\nstatic void event_cb(lv_event_t * e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * chart = lv_event_get_target(e);\n    if(code == LV_EVENT_VALUE_CHANGED) {\n        lv_obj_invalidate(chart);\n    }\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        int32_t * s = lv_event_get_param(e);\n        *s = LV_MAX(*s, 20);\n    }\n    else if(code == LV_EVENT_DRAW_POST_END) {\n        int32_t id = lv_chart_get_pressed_point(chart);\n        if(id == LV_CHART_POINT_NONE) return;\n        LV_LOG_USER(""Selected point %d"", (int)id);\n        lv_chart_series_t * ser = lv_chart_get_series_next(chart, NULL);\n        while(ser) {\n            lv_point_t p;\n            lv_chart_get_point_pos_by_id(chart, ser, id, &p);\n            int32_t * y_array = lv_chart_get_y_array(chart, ser);\n            int32_t value = y_array[id];\n            char buf[16];\n            lv_snprintf(buf, sizeof(buf), LV_SYMBOL_DUMMY""$%d"", value);\n            lv_draw_rect_dsc_t draw_rect_dsc;\n            lv_draw_rect_dsc_init(&draw_rect_dsc);\n            draw_rect_dsc.bg_color = lv_color_black();\n            draw_rect_dsc.bg_opa = LV_OPA_50;\n            draw_rect_dsc.radius = 3;\n            draw_rect_dsc.bg_image_src = buf;\n            draw_rect_dsc.bg_image_recolor = lv_color_white();\n            lv_area_t a;\n            a.x1 = chart->coords.x1 + p.x - 20;\n            a.x2 = chart->coords.x1 + p.x + 20;\n            a.y1 = chart->coords.y1 + p.y - 30;\n            a.y2 = chart->coords.y1 + p.y - 10;\n            lv_layer_t * layer = lv_event_get_layer(e);\n            lv_draw_rect(layer, &draw_rect_dsc, &a);\n            ser = lv_chart_get_series_next(chart, ser);\n        }\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        lv_obj_invalidate(chart);\n    }\n}\nvoid lv_example_chart_3(void)\n{\n    lv_obj_t * chart;\n    chart = lv_chart_create(lv_screen_active());\n    lv_obj_set_size(chart, 200, 150);\n    lv_obj_center(chart);\n    lv_obj_add_event_cb(chart, event_cb, LV_EVENT_ALL, NULL);\n    lv_obj_refresh_ext_draw_size(chart);\n    lv_chart_series_t * ser1 = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_RED), LV_CHART_AXIS_PRIMARY_Y);\n    lv_chart_series_t * ser2 = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_GREEN), LV_CHART_AXIS_PRIMARY_Y);\n    uint32_t i;\n    for(i = 0; i < 10; i++) {\n        lv_chart_set_next_value(chart, ser1, lv_rand(60, 90));\n        lv_chart_set_next_value(chart, ser2, lv_rand(10, 40));\n    }\n}\n#endif'"
"(""Prompt: You are working on a C library for signal processing that includes a structure `dotprod_crcf_s` representing a dot product with circular convolution (dotprod) filter. You need to implement a function `dotprod_crcf_copy` that creates a copy of a given dot product filter. The function should check if the input pointer is NULL and return an error message if so. The copy should have the same length `n` and filter coefficients `h` as the original. Additionally, the function should allocate memory for the copy's coefficients using AVX instructions for alignment and optimal performance. Implement the `dotprod_crcf_copy` function to fulfill these requirements.","//...\nstruct dotprod_crcf_s {\n    unsigned int n;     \n    float * h;          \n};\ndotprod_crcf dotprod_crcf_copy(dotprod_crcf q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""dotprod_crcf_copy().avx, object cannot be NULL"");\n    dotprod_crcf q_copy = (dotprod_crcf)malloc(sizeof(struct dotprod_crcf_s));\n    q_copy->n = q_orig->n;\n    q_copy->h = (float*) _mm_malloc( 2*q_copy->n*sizeof(float), 32 );\n    memmove(q_copy->h, q_orig->h, 2*q_orig->n*sizeof(float));\n    return q_copy;\n}\n//...')
"
"'Prompt: ""In your STM32H7 project, you need to configure the system clocks. Please provide the code for initializing the clock configuration using the RCC_ClkInitTypeDef structure. Make sure to include the necessary preprocessor directive for the configuration header file. The configuration should specify the clock types for HCLK, SYSCLK, PCLK1, PCLK2, D3PCLK1, and D1PCLK1. Additionally, set the SYSCLK source to PLLCLK with a divider of 1, AHBCLK divider of 1, APB3 divider of 2, and APB1, APB2, and APB4 dividers of 2 as well.""","#ifdef HAVE_CONFIG_H\n#endif\nconst RCC_ClkInitTypeDef stm32h7_config_clocks = {\n  .ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK\n    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2\n    | RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1,\n  .SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK,\n  .SYSCLKDivider = RCC_SYSCLK_DIV1,\n  .AHBCLKDivider = RCC_HCLK_DIV1,\n  .APB3CLKDivider = RCC_APB3_DIV2,\n  .APB1CLKDivider = RCC_APB1_DIV2,\n  .APB2CLKDivider = RCC_APB2_DIV2,\n  .APB4CLKDivider = RCC_APB4_DIV2\n};'"
"('Please provide a prompt to benchmark two functions related to Gaussian Minimum Shift Keying (GMSK) frame synchronization. The first function, `benchmark_gmskframesync`, simulates a GMSK signal with noise and measures the execution time of the GMSK frame synchronization process. The second function, `benchmark_gmskframesync_noise`, specifically focuses on noise in GMSK frame synchronization and measures the execution time of this process.","//...\nvoid benchmark_gmskframesync(struct rusage *     _start,\n                             struct rusage *     _finish,\n                             unsigned long int * _num_iterations)\n{\n    *_num_iterations /= 128;\n    unsigned long int i;\n    unsigned int k = 2;                 \n    unsigned int m = 3;                 \n    float BT = 0.5f;                    \n    unsigned int payload_len = 8;       \n    float SNRdB = 30.0f;                \n    float nstd  = powf(10.0f, -SNRdB/20.0f);\n    gmskframegen fg = gmskframegen_create_set(k, m, BT);\n    gmskframegen_assemble(fg, NULL, NULL, payload_len,\n            LIQUID_CRC_NONE, LIQUID_FEC_NONE, LIQUID_FEC_NONE);\n    unsigned int frame_len = gmskframegen_getframelen(fg);\n    float complex frame[frame_len];\n    gmskframegen_write(fg, frame, frame_len);\n    for (i=0; i<frame_len; i++)\n        frame[i] += nstd*(randnf() + _Complex_I*randnf());\n    gmskframesync fs = gmskframesync_create_set(k, m, BT, NULL, NULL);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        gmskframesync_execute(fs, frame, frame_len);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n}\nvoid benchmark_gmskframesync_noise(struct rusage *     _start,\n                                   struct rusage *     _finish,\n                                   unsigned long int * _num_iterations)\n{\n    *_num_iterations /= 2000;\n    unsigned long int i;\n    gmskframesync fs = gmskframesync_create_set(2, 3, 0.5f, NULL, NULL);\n    unsigned int num_samples = 1024;\n    float complex y[num_samples];\n    for (i=0; i<num_samples; i++)\n        y[i] = 0.01f*(randnf() + randnf()*_Complex_I)*M_SQRT1_2;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        gmskframesync_execute(fs, y, num_samples);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= num_samples;\n    gmskframesync_destroy(fs);\n}\n//...')
"
"('Prompt: You are working on testing a resampling function in a digital signal processing library. The function takes in parameters including resampling factor, stopband attenuation, and an ID for logging purposes. Write a testbench function that creates a resampling object, generates an input signal, performs resampling, and validates the output power spectral density against specific frequency regions. Additionally, implement an automated test function for the resampling with specific parameters (resampling factor: 0.127115323, stopband attenuation: 80.0, ID: 10).","//...\nvoid testbench_resamp_crcf(float r, float As, int _id)\n{\n    float        bw   = 0.25f;  \n    float        tol  = 0.5f;   \n    unsigned int m    = 20;     \n    unsigned int npfb = 2048;   \n    float        fc   = 0.45f;  \n    resamp_crcf resamp = resamp_crcf_create(r,m,fc,As,npfb);\n    unsigned int p = (unsigned int) (40.0f / r);\n    unsigned int pulse_len = 4*p + 1;\n    float        pulse[pulse_len];\n    liquid_firdes_kaiser(pulse_len, 0.5*r*bw, 120, 0, pulse);\n    unsigned int  num_input  = pulse_len + 2*m + 1;\n    unsigned int  num_output = resamp_crcf_get_num_output(resamp, num_input);\n    float complex buf_0[num_input];  \n    float complex buf_1[num_output]; \n    unsigned int i;\n    for (i=0; i<num_input; i++)\n        buf_0[i] = i < pulse_len ? pulse[i]*bw : 0;\n    unsigned int nw = 0;\n    resamp_crcf_execute_block(resamp, buf_0, num_input, buf_1, &nw);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/resamp_crcf_%.2d.m"", _id);\n    liquid_autotest_validate_psd_signal(buf_1, nw, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    resamp_crcf_destroy(resamp);\n}\nvoid autotest_resamp_crcf_10() { testbench_resamp_crcf(0.127115323f, 80.0f, 10); }\n//...')
"
"'Prompt: You are working on a project that involves SPI communication and DMA transfers. You need to implement a function that configures the SPI peripheral for DMA transfers, sets up DMA channels for both transmit and receive operations, and initiates a SPI transfer using DMA. Can you provide the code for this scenario?","#define USE_SPI_DMA\n#define DMA_SPI_LLI     2\nstatic uint32_t spiDmaTxChannel;\nstatic uint32_t spiDmaRxChannel;\nstatic void SPID_Rx_Cb(uint32_t channel, Spid *pArg)\n{\n\tSpidCmd *pSpidCmd = pArg->pCurrentCommand;\n\tSpi *pSpiHw = pArg->pSpiHw;\n\tif (channel != spiDmaRxChannel)\n\t\treturn;\n\tSPI_Disable (pSpiHw);\n\tTRACE_INFO(""SPI Rx DMA Callback has been called %d bytes received\\n\\r"",\n\t\t\t   pArg->pCurrentCommand->RxSize);\n\tNVIC_ClearPendingIRQ(XDMAC_IRQn);\n\tNVIC_DisableIRQ(XDMAC_IRQn);\n\tPMC_DisablePeripheral (pArg->spiId);\n\tSPI_ReleaseCS(pSpiHw);\n\tXDMAD_FreeChannel(pArg->pXdmad, spiDmaRxChannel);\n\tXDMAD_FreeChannel(pArg->pXdmad, spiDmaTxChannel);\n\tSCB_InvalidateDCache_by_Addr((uint32_t *)pArg->pCurrentCommand->pRxBuff,\n\t\t\t\t\t\t\t\t pArg->pCurrentCommand->RxSize);\n\tpArg->semaphore++;\n\tprintf("" %s\\n\\r"", pArg->pCurrentCommand->pRxBuff);\n\tif (pSpidCmd && pSpidCmd->callback) {\n\t\tpSpidCmd->callback(0, pSpidCmd->pArgument);\n\t}\n}\nstatic uint8_t _spid_configureDmaChannels(Spid *pSpid)\n{\n\tXDMAD_FreeChannel(pSpid->pXdmad, spiDmaTxChannel);\n\tXDMAD_FreeChannel(pSpid->pXdmad, spiDmaRxChannel);\n\tspiDmaTxChannel = XDMAD_AllocateChannel(pSpid->pXdmad,\n\t\t\t\t\t  XDMAD_TRANSFER_MEMORY, pSpid->spiId);\n\tif (spiDmaTxChannel == XDMAD_ALLOC_FAILED)\n\t\treturn SPID_ERROR;\n\tspiDmaRxChannel =\n\t\tXDMAD_AllocateChannel(pSpid->pXdmad, pSpid->spiId, XDMAD_TRANSFER_MEMORY);\n\tif (spiDmaRxChannel == XDMAD_ALLOC_FAILED)\n\t\treturn SPID_ERROR;\n\tXDMAD_SetCallback(pSpid->pXdmad, spiDmaRxChannel,\n\t\t\t\t\t  (XdmadTransferCallback)SPID_Rx_Cb, pSpid);\n\tif (XDMAD_PrepareChannel(pSpid->pXdmad, spiDmaRxChannel))\n\t\treturn SPID_ERROR;\n\tXDMAD_SetCallback(pSpid->pXdmad, spiDmaTxChannel, NULL, NULL);\n\tif (XDMAD_PrepareChannel(pSpid->pXdmad, spiDmaTxChannel))\n\t\treturn SPID_ERROR;\n\treturn 0;\n}\nstatic uint8_t _spid_configureLinkList(Spi *pSpiHw, void *pXdmad,\n\t\t\t\t\t\t\t\t\t   SpidCmd *pCommand)\n{\n\tsXdmadCfg xdmadRxCfg, xdmadTxCfg;\n\tuint32_t xdmaCndc, xdmaInt;\n\tuint32_t spiId;\n\tif ((unsigned int)pSpiHw == (unsigned int)SPI0) spiId = ID_SPI0;\n\tif ((unsigned int)pSpiHw == (unsigned int)SPI1) spiId = ID_SPI1;\n\txdmadTxCfg.mbr_sa = (uint32_t)pCommand->pTxBuff;\n\txdmadTxCfg.mbr_da = (uint32_t)&pSpiHw->SPI_TDR;\n\txdmadTxCfg.mbr_ubc =  XDMA_UBC_NVIEW_NDV0 |\n\t\t\t\t\t\t  XDMA_UBC_NDE_FETCH_DIS |\n\t\t\t\t\t\t  XDMA_UBC_NSEN_UPDATED | pCommand->TxSize;\n\txdmadTxCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |\n\t\t\t\t\t\t XDMAC_CC_MBSIZE_SINGLE |\n\t\t\t\t\t\t XDMAC_CC_DSYNC_MEM2PER |\n\t\t\t\t\t\t XDMAC_CC_CSIZE_CHK_1 |\n\t\t\t\t\t\t XDMAC_CC_DWIDTH_BYTE |\n\t\t\t\t\t\t XDMAC_CC_SIF_AHB_IF1 |\n\t\t\t\t\t\t XDMAC_CC_DIF_AHB_IF1 |\n\t\t\t\t\t\t XDMAC_CC_SAM_INCREMENTED_AM |\n\t\t\t\t\t\t XDMAC_CC_DAM_FIXED_AM |\n\t\t\t\t\t\t XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber(spiId, XDMAD_TRANSFER_TX));\n\txdmadTxCfg.mbr_bc = 0;\n\txdmadTxCfg.mbr_sus = 0;\n\txdmadTxCfg.mbr_dus = 0;\n\txdmadRxCfg.mbr_ubc = XDMA_UBC_NVIEW_NDV0 |\n\t\t\t\t\t\t XDMA_UBC_NDE_FETCH_DIS |\n\t\t\t\t\t\t XDMA_UBC_NDEN_UPDATED | pCommand->RxSize;\n\txdmadRxCfg.mbr_da = (uint32_t)pCommand->pRxBuff;\n\txdmadRxCfg.mbr_sa = (uint32_t)&pSpiHw->SPI_RDR;\n\txdmadRxCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |\n\t\t\t\t\t\t XDMAC_CC_MBSIZE_SINGLE |\n\t\t\t\t\t\t XDMAC_CC_DSYNC_PER2MEM |\n\t\t\t\t\t\t XDMAC_CC_CSIZE_CHK_1 |\n\t\t\t\t\t\t XDMAC_CC_DWIDTH_BYTE |\n\t\t\t\t\t\t XDMAC_CC_SIF_AHB_IF1 |\n\t\t\t\t\t\t XDMAC_CC_DIF_AHB_IF1 |\n\t\t\t\t\t\t XDMAC_CC_SAM_FIXED_AM |\n\t\t\t\t\t\t XDMAC_CC_DAM_INCREMENTED_AM |\n\t\t\t\t\t\t XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber(spiId, XDMAD_TRANSFER_RX));\n\txdmadRxCfg.mbr_bc = 0;\n\txdmadRxCfg.mbr_sus = 0;\n\txdmadRxCfg.mbr_dus = 0;\n\txdmaCndc = 0;\n\txdmaInt =  (XDMAC_CIE_BIE   |\n\t\t\t\tXDMAC_CIE_DIE   |\n\t\t\t\tXDMAC_CIE_FIE   |\n\t\t\t\tXDMAC_CIE_RBIE  |\n\t\t\t\tXDMAC_CIE_WBIE  |\n\t\t\t\tXDMAC_CIE_ROIE);\n\tif (XDMAD_ConfigureTransfer(pXdmad, spiDmaRxChannel, &xdmadRxCfg, xdmaCndc, 0,\n\t\t\t\t\t\t\t\t xdmaInt))\n\t\treturn SPID_ERROR;\n\tif (XDMAD_ConfigureTransfer(pXdmad, spiDmaTxChannel, &xdmadTxCfg, xdmaCndc, 0,\n\t\t\t\t\t\t\t\t xdmaInt))\n\t\treturn SPID_ERROR;\n\treturn 0;\n}\nuint32_t SPID_Configure(Spid *pSpid ,\n\t\t\t\t\t\t Spi *pSpiHw ,\n\t\t\t\t\t\t uint8_t spiId,\n\t\t\t\t\t\t uint32_t spiMode,\n\t\t\t\t\t\t sXdmad *pXdmad)\n{\n\tpSpid->pSpiHw = pSpiHw;\n\tpSpid->spiId  = spiId;\n\tpSpid->semaphore = 1;\n\tpSpid->pCurrentCommand = 0;\n\tassert(pXdmad == &XDMAD_Instance);\n\tpSpid->pXdmad = pXdmad;\n\tSPI_Configure (pSpiHw, pSpid->spiId, spiMode);\n\treturn 0;\n}\nvoid SPID_ConfigureCS(Spid *pSpid,\n\t\t\t\t\t   uint32_t dwCS,\n\t\t\t\t\t   uint32_t dwCsr)\n{\n\tSpi *pSpiHw = pSpid->pSpiHw;\n\tPMC_EnablePeripheral (pSpid->spiId);\n\tSPI_ConfigureNPCS(pSpiHw, dwCS, dwCsr);\n\tPMC_DisablePeripheral (pSpid->spiId);\n}\nuint32_t SPID_SendCommand(Spid *pSpid, SpidCmd *pCommand)\n{\n\tSpi *pSpiHw = pSpid->pSpiHw;\n\tif (pSpid->semaphore == 0)\n\t\treturn SPID_ERROR_LOCK;\n\tpSpid->semaphore--;\n\tPMC_EnablePeripheral (pSpid->spiId);\n\tSPI_ChipSelect (pSpiHw, 1 << pCommand->spiCs);\n\tpSpid->pCurrentCommand = pCommand;\n\tif (_spid_configureDmaChannels(pSpid))\n\t\treturn SPID_ERROR_LOCK;\n\tNVIC_ClearPendingIRQ(XDMAC_IRQn);\n\tNVIC_SetPriority(XDMAC_IRQn , 1);\n\tNVIC_EnableIRQ(XDMAC_IRQn);\n\tif (_spid_configureLinkList(pSpiHw, pSpid->pXdmad, pCommand))\n\t\treturn SPID_ERROR_LOCK;\n\tSPI_Enable (pSpiHw);\n\tSCB_CleanDCache_by_Addr((uint32_t *)pCommand->pTxBuff, pCommand->TxSize);\n\tif (XDMAD_StartTransfer(pSpid->pXdmad, spiDmaRxChannel))\n\t\treturn SPID_ERROR_LOCK;\n\tif (XDMAD_StartTransfer(pSpid->pXdmad, spiDmaTxChannel))\n\t\treturn SPID_ERROR_LOCK;\n\treturn 0;\n}\nuint32_t SPID_IsBusy(const Spid *pSpid)\n{\n\tif (pSpid->semaphore == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}'"
"('Prompt: Can you provide code for benchmarking quantize_adc and quantize_dac functions using rusage to measure the start and finish times, along with the number of iterations? The functions should perform multiple iterations of quantize_adc and quantize_dac with specific parameters and update the number of iterations accordingly based on the results.","void benchmark_quantize_adc(struct rusage *     _start,\n                            struct rusage *     _finish,\n                            unsigned long int * _num_iterations)\n{\n    unsigned long int i;\n    unsigned int q = 0;\n    unsigned int num_bits=8;\n    float x=-0.1f;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        q ^= quantize_adc(x,num_bits);\n        q ^= quantize_adc(x,num_bits);\n        q ^= quantize_adc(x,num_bits);\n        q ^= quantize_adc(x,num_bits);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    *_num_iterations += q & 1; \n}\nvoid benchmark_quantize_dac(struct rusage *     _start,\n                            struct rusage *     _finish,\n                            unsigned long int * _num_iterations)\n{\n    unsigned long int i;\n    unsigned int q=0x0f;\n    unsigned int num_bits=8;\n    float x = 0;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        x += quantize_dac(q,num_bits);\n        x += quantize_dac(q,num_bits);\n        x += quantize_dac(q,num_bits);\n        x += quantize_dac(q,num_bits);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    *_num_iterations += x > 0; \n}')
"
"('Prompt: . You are working on a project involving communication systems where you need to implement a function for frame synchronization. The function should take in a header, payload, and other parameters, and update a variable based on the validity of the header and payload. Additionally, you need to create a test function `autotest_framesync64` to validate the frame synchronization functionality by generating a random frame, processing it, and checking the recovered frames and statistics. Can you provide the code for the frame synchronization function and the test function?","//...\nstatic int callback_framesync64_autotest(\n    unsigned char *  _header,\n    int              _header_valid,\n    unsigned char *  _payload,\n    unsigned int     _payload_len,\n    int              _payload_valid,\n    framesyncstats_s _stats,\n    void *           _userdata)\n{\n    *((int*)(_userdata)) += _header_valid && _payload_valid ? 1 : 0;\n    return 0;\n}\nvoid autotest_framesync64()\n{\n    unsigned int i;\n    int frames_recovered = 0;\n    framegen64 fg = framegen64_create();\n    framesync64 fs = framesync64_create(callback_framesync64_autotest,\n            (void*)&frames_recovered);\n    float complex frame[LIQUID_FRAME64_LEN];\n    framegen64_execute(fg, NULL, NULL, frame);\n    for (i=0; i<LIQUID_FRAME64_LEN; i++)\n        frame[i] += 0.01f*(randnf() + _Complex_I*randnf()) * M_SQRT1_2;\n    framesync64_execute(fs, frame, LIQUID_FRAME64_LEN);\n    CONTEND_EQUALITY( frames_recovered, 1 );\n    framedatastats_s stats = framesync64_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received, 64);\n    framegen64_destroy(fg);\n    framesync64_destroy(fs);\n}\nvoid autotest_framesync64_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping framesync64 config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(framesync64_copy(NULL));\n    CONTEND_ISNULL(framegen64_copy (NULL));\n    framesync64 q = framesync64_create(NULL, NULL);\n    CONTEND_EQUALITY(LIQUID_OK, framesync64_print(q))\n    CONTEND_EQUALITY(LIQUID_OK, framesync64_set_callback(q,callback_framesync64_autotest))\n    CONTEND_EQUALITY(LIQUID_OK, framesync64_set_userdata(q,NULL))\n    CONTEND_EQUALITY(LIQUID_OK, framesync64_set_threshold(q,0.654321f))\n    CONTEND_EQUALITY(0.654321f, framesync64_get_threshold(q))\n    framesync64_destroy(q);\n}\n//...')
"
"('Prompt: You are building a test harness for a resampler function in a signal processing library. You need to test the functionality of resampling using a Kaiser window design method with specific parameters. Here is the scenario you need to code: Create two resampler objects using the Kaiser window design method with parameters P=3, Q=5, m=15, bandwidth=0.5, and stop-band attenuation=60. Generate input signals for these resamplers, execute them, and compare the output signals. Ensure that the difference between corresponding elements of the output signals is within a tolerance of 1e-12. Lastly, destroy the resampler objects after testing. Your test harness should also include an automated test function specifically for these parameter values.","//...\nvoid test_harness_rresamp_crcf_part(unsigned int _P, \n                                    unsigned int _Q, \n                                    unsigned int _m, \n                                    unsigned int _n) \n{\n    float tol = 1e-12f; \n    float bw  = 0.5f;   \n    float As  = 60.0f;  \n    rresamp_crcf q0 = rresamp_crcf_create_kaiser(_P,_Q,_m,bw,As);\n    rresamp_crcf q1 = rresamp_crcf_create_kaiser(_P,_Q,_m,bw,As);\n    float complex buf_in   [2*_Q*_n]; \n    float complex buf_out_0[2*_P*_n]; \n    float complex buf_out_1[2*_P*_n]; \n    unsigned int i;\n    for (i=0; i<2*_Q*_n; i++)\n        buf_in[i] = liquid_hamming(i,2*_Q*_n) * cexpf(_Complex_I*2*M_PI*0.037f*i);\n    rresamp_crcf_execute_block(q0, buf_in, 2*_n, buf_out_0);\n    rresamp_crcf_reset(q0);\n    rresamp_crcf_execute_block(q0, buf_in, _n, buf_out_1);\n    for (i=0; i<_m; i++)\n        rresamp_crcf_write(q1, buf_in + _Q*_n - (_m-i)*_Q);\n    rresamp_crcf_execute_block(q1, buf_in + _Q*_n, _n, buf_out_1 + _P*_n);\n    rresamp_crcf_destroy(q0);\n    rresamp_crcf_destroy(q1);\n    for (i=0; i<2*_P*_n; i++) {\n        CONTEND_DELTA( crealf(buf_out_0[i]), crealf(buf_out_1[i]), tol );\n        CONTEND_DELTA( cimagf(buf_out_0[i]), cimagf(buf_out_1[i]), tol );\n    }\n}\nvoid autotest_rresamp_crcf_part_P3_Q5() { test_harness_rresamp_crcf_part( 3, 5, 15, 20); }\n//...')
"
"('Please provide a prompt detailing a scenario in which you need a C function to generate a GMSK frame, including header, payload, and tail, using a specific modulation scheme and symbol generation process.","//...\n    gmskmod mod;                \n    unsigned int k;             \n    unsigned int m;             \n    unsigned int payload_len;   \n    unsigned char * payload_enc;\n    } state;\n    unsigned int symbol_counter;\n    complex float * buf_sym;    \nint gmskframegen_write(gmskframegen   _q,\n                      float complex * _buf,\n                      unsigned int    _buf_len)\n{\n    unsigned int i;\n    for (i=0; i<_buf_len; i++) {\n        if (_q->buf_idx == _q->k)\n            gmskframegen_gen_symbol(_q);\n        _buf[i] = _q->buf_sym[_q->buf_idx++];\n    }\n    return _q->frame_complete;\n}\nint gmskframegen_write_header(gmskframegen _q)\n{\n    div_t d = div(_q->symbol_counter, 8);\n    unsigned int byte_index = d.quot;\n    unsigned int bit_index  = d.rem;\n    unsigned char byte = _q->header_enc[byte_index];\n    unsigned char bit  = (byte >> (8-bit_index-1)) & 0x01;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->header_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_PAYLOAD;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_payload(gmskframegen _q)\n{\n    div_t d = div(_q->symbol_counter, 8);\n    unsigned int byte_index = d.quot;\n    unsigned int bit_index  = d.rem;\n    unsigned char byte = _q->payload_enc[byte_index];\n    unsigned char bit  = (byte >> (8-bit_index-1)) & 0x01;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->payload_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_TAIL;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_tail(gmskframegen _q)\n{\n    unsigned char bit = rand() % 2;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    if (_q->symbol_counter >= _q->m) {\n        unsigned int i;\n        for (i=0; i<_q->k; i++)\n            _q->buf_sym[i] *= liquid_hamming(_q->m*_q->k + (_q->symbol_counter-_q->m)*_q->k + i, 2*_q->m*_q->k);\n    }\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->tail_len) {\n        _q->symbol_counter = 0;\n        _q->frame_complete = 1;\n        _q->state = STATE_UNASSEMBLED;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_zeros(gmskframegen _q)\n{\n    memset(_q->buf_sym, 0x0, _q->k*sizeof(float complex));\n    return LIQUID_OK;\n}\nint gmskframegen_gen_symbol(gmskframegen _q)\n{\n    _q->buf_idx = 0;\n    switch (_q->state) {\n    case STATE_UNASSEMBLED: gmskframegen_write_zeros   (_q); break;\n    case STATE_PREAMBLE:    gmskframegen_write_preamble(_q); break;\n    case STATE_HEADER:      gmskframegen_write_header  (_q); break;\n    case STATE_PAYLOAD:     gmskframegen_write_payload (_q); break;\n    case STATE_TAIL:        gmskframegen_write_tail    (_q); break;\n    default:\n        return liquid_error(LIQUID_EINT,""gmskframegen_writesymbol(), invalid internal state"");\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_preamble(gmskframegen _q)\n{\n    unsigned char bit = msequence_advance(_q->ms_preamble);\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    if (_q->symbol_counter < _q->m) {\n        unsigned int i;\n        for (i=0; i<_q->k; i++)\n            _q->buf_sym[i] *= liquid_hamming(_q->symbol_counter*_q->k + i, 2*_q->m*_q->k);\n    }\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->preamble_len) {\n        msequence_reset(_q->ms_preamble);\n        _q->symbol_counter = 0;\n        _q->state = STATE_HEADER;\n    }\n    return LIQUID_OK;\n}\nint gmskframegen_write_payload(gmskframegen _q)\n{\n    div_t d = div(_q->symbol_counter, 8);\n    unsigned int byte_index = d.quot;\n    unsigned int bit_index  = d.rem;\n    unsigned char byte = _q->payload_enc[byte_index];\n    unsigned char bit  = (byte >> (8-bit_index-1)) & 0x01;\n    gmskmod_modulate(_q->mod, bit, _q->buf_sym);\n    _q->symbol_counter++;\n    if (_q->symbol_counter == _q->payload_len) {\n        _q->symbol_counter = 0;\n        _q->state = STATE_TAIL;\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are building a filter design software and need a function to expand a state-space filter into second order sections. Write a C function that takes a pointer to a filter coefficients struct and an integer debug flag as arguments. Inside the function, call a function `iirdes_dzpk2sosf` that converts the filter poles and zeros to second-order sections and store the results in arrays `B` and `A` inside the struct. If the debug flag is set, print the contents of arrays `B` and `A`. Make sure to handle the arrays properly with the correct indexing.","//...\ntypedef struct gs_s * gs;\na = [1.00000000   0.06440119   0.31432679];\nb = [0.30749798   0.61379653   0.30749798];\nvoid gs_expand(gs _q, int _debug)\n{\n    iirdes_dzpk2sosf(_q->zd,_q->pd,_q->n,_q->kd,_q->B,_q->A);\n    if (_debug) {\n        unsigned int i;\n        printf(""B [%u x 3] :\\n"", _q->L+_q->r);\n        for (i=0; i<_q->L+_q->r; i++)\n            printf(""  %12.8f %12.8f %12.8f\\n"", _q->B[3*i+0], _q->B[3*i+1], _q->B[3*i+2]);\n        printf(""A [%u x 3] :\\n"", _q->L+_q->r);\n        for (i=0; i<_q->L+_q->r; i++)\n            printf(""  %12.8f %12.8f %12.8f\\n"", _q->A[3*i+0], _q->A[3*i+1], _q->A[3*i+2]);\n    }\n}\n//...')
"
"('Please provide a prompt for implementing a Finite Digital Delay structure (FDELAY) with the specified functions in the C programming language. The FDELAY structure should include parameters for maximum delay, filter semi-length, and number of filters. Additionally, the prompt should include functions for creating and destroying the FDELAY structure, setting and adjusting the delay, pushing and executing data, and retrieving specific parameters of the FDELAY structure.","struct FDELAY(_s) {\n    unsigned int    nmax;       \n    unsigned int    m;          \n    unsigned int    npfb;       \n    float           delay;      \n    WINDOW()        w;          \n    FIRPFB()        pfb;        \n    unsigned int    w_index;    \n    unsigned int    f_index;    \n};\nFDELAY() FDELAY(_create)(unsigned int _nmax,\n                         unsigned int _m,\n                         unsigned int _npfb)\n{\n    if (_nmax == 0)\n        return liquid_error_config(""fdelay_%s_create(), max delay must be greater than 0"", EXTENSION_FULL);\n    if (_m == 0)\n        return liquid_error_config(""fdelay_%s_create(), filter semi-length must be greater than 0"", EXTENSION_FULL);\n    if (_npfb == 0)\n        return liquid_error_config(""fdelay_%s_create(), number of filters must be greater than 0"", EXTENSION_FULL);\n    FDELAY() q = (FDELAY()) malloc(sizeof(struct FDELAY(_s)));\n    q->nmax = _nmax;\n    q->m    = _m;\n    q->npfb = _npfb;\n    q->w = WINDOW(_create)(q->nmax + 1);\n    q->pfb = FIRPFB(_create_default)(q->npfb, q->m);\n    FDELAY(_reset)(q);\n    return q;\n}\nFDELAY() FDELAY(_create_default)(unsigned int _nmax)\n{\n    return FDELAY(_create)(_nmax, 8, 64);\n}\nint FDELAY(_destroy)(FDELAY() _q)\n{\n    WINDOW(_destroy)(_q->w);\n    FIRPFB(_destroy)(_q->pfb);\n    free(_q);\n    return LIQUID_OK;\n}\nint FDELAY(_reset)(FDELAY() _q)\n{\n    _q->delay = 0.0f;\n    _q->w_index = _q->nmax-1;\n    _q->f_index = 0;\n    WINDOW(_reset)(_q->w);\n    FIRPFB(_reset)(_q->pfb);\n    return LIQUID_OK;\n}\nint FDELAY(_print)(FDELAY() _q)\n{\n    printf(""<fdelay, nmax=%u, m=%u, npfb=%u, delay=%.6f>\\n"",\n            _q->nmax, _q->m, _q->npfb, _q->delay);\n    return LIQUID_OK;\n}\nfloat FDELAY(_get_delay)(FDELAY() _q)\n{\n    return _q->delay;\n}\nint FDELAY(_set_delay)(FDELAY() _q,\n                       float    _delay)\n{\n    if (_delay < 0) {\n        return liquid_error(LIQUID_EIVAL,""fdelay_%s_set_delay(), delay (%g) cannot be negative"",\n                EXTENSION_FULL, _delay);\n    } else if (_delay > _q->nmax) {\n        return liquid_error(LIQUID_EIVAL,""fdelay_%s_set_delay(), delay (%g) cannot exceed maximum (%u)"",\n                EXTENSION_FULL, _delay, _q->nmax);\n    }\n    float offset   = (float)(_q->nmax) - _delay;\n    int   intpart  = (int) floorf(offset);\n    float fracpart = offset - (float)intpart;\n    _q->w_index = intpart;\n    _q->f_index = (unsigned int)roundf(_q->npfb * fracpart);\n    while (_q->f_index >= _q->npfb) {\n        _q->w_index++;\n        _q->f_index -= _q->npfb;\n    }\n    if (_q->w_index > _q->nmax)\n        return liquid_error(LIQUID_EINT,""fdelay_%s_set_delay(), window index exceeds maximum"", EXTENSION_FULL);\n#if 0\n    printf(""delay:%f -> offset:%f -> %d + %f -> %d + (%u/%u)\\n"",\n           _delay, offset, intpart, fracpart, _q->w_index, _q->f_index, _q->npfb);\n#endif\n    _q->delay = _delay;\n    return LIQUID_OK;\n}\nint FDELAY(_adjust_delay)(FDELAY() _q, float _delta)\n{\n    return FDELAY(_set_delay)(_q, _q->delay + _delta);\n}\nunsigned int FDELAY(_get_nmax)(FDELAY() _q)\n{\n    return _q->nmax;\n}\nunsigned int FDELAY(_get_m)(FDELAY() _q)\n{\n    return _q->m;\n}\nunsigned int FDELAY(_get_npfb)(FDELAY() _q)\n{\n    return _q->npfb;\n}\nint FDELAY(_push)(FDELAY() _q,\n                  TI       _x)\n{\n    WINDOW(_push)(_q->w, _x);\n    TO v;\n    WINDOW(_index)(_q->w, _q->w_index, &v);\n    FIRPFB(_push)(_q->pfb, v);\n    return LIQUID_OK;\n}\nint FDELAY(_write)(FDELAY()     _q,\n                   TI *         _x,\n                   unsigned int _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        if ( FDELAY(_push)(_q, _x[i]) != LIQUID_OK) {\n            return liquid_error(LIQUID_EINT,""fdelay_%s_write(), could not write sample"", EXTENSION_FULL);\n        }\n    }\n    return LIQUID_OK;\n}\nint FDELAY(_execute)(FDELAY() _q,\n                     TO *     _y)\n{\n    FIRPFB(_execute)(_q->pfb, _q->f_index, _y);\n    return LIQUID_OK;\n}\nint FDELAY(_execute_block)(FDELAY()     _q,\n                           TI *         _x,\n                           unsigned int _n,\n                           TO *         _y)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        FDELAY(_push)(_q, _x[i]);\n        FDELAY(_execute)(_q, _y+i);\n    }\n    return LIQUID_OK;\n}')
"
"('Prompt: ""I need a function in C that implements the decoding process for a SECDED (Single Error Correction, Double Error Detection) code with a 22-bit message length. The function should take the encoded message as input and output the decoded message. It should also handle cases where there is a single error detected or multiple errors detected. Additionally, I need a helper function to compute the syndrome for the SECDED code.""","//...\nint fec_secded2216_decode_symbol(unsigned char * _sym_enc,\n                                 unsigned char * _sym_dec)\n{\n#if 0\n    if (_sym_enc[0] >= (1<<6)) {\n        fprintf(stderr,""warning, fec_secded2216_decode_symbol(), input symbol too large\\n"");\n    }\n#endif\n    unsigned char e_hat[3] = {0,0,0};\n    int syndrome_flag = fec_secded2216_estimate_ehat(_sym_enc, e_hat);\n    _sym_dec[0] = _sym_enc[1] ^ e_hat[1];\n    _sym_dec[1] = _sym_enc[2] ^ e_hat[2];\n#if DEBUG_FEC_SECDED2216\n    if (syndrome_flag == 1) {\n        printf(""secded2216_decode_symbol(): single error detected!\\n"");\n    } else if (syndrome_flag == 2) {\n        printf(""secded2216_decode_symbol(): no match found (multiple errors detected)\\n"");\n    }\n#endif\n    return syndrome_flag;\n}\nunsigned char fec_secded2216_compute_syndrome(unsigned char * _v)\n{\n    unsigned int i;\n    unsigned char syndrome = 0x00;\n    for (i=0; i<6; i++) {\n        syndrome <<= 1;\n        unsigned int p =\n            ( (_v[0] & (1<<(6-i-1))) ? 1 : 0 )+\n            liquid_c_ones[ secded2216_P[2*i+0] & _v[1] ] +\n            liquid_c_ones[ secded2216_P[2*i+1] & _v[2] ];\n        syndrome |= p & 0x01;\n    }\n    return syndrome;\n}\nint fec_secded2216_decode(fec             _q,\n                          unsigned int    _dec_msg_len,\n                          unsigned char * _msg_enc,\n                          unsigned char * _msg_dec)\n{\n    unsigned int i=0;       \n    unsigned int j=0;       \n    unsigned int r = _dec_msg_len % 2;\n    for (i=0; i<_dec_msg_len-r; i+=2) {\n        fec_secded2216_decode_symbol(&_msg_enc[j], &_msg_dec[i]);\n        j += 3;\n    }\n    if (r) {\n        unsigned char v[3] = {_msg_enc[j+0], _msg_enc[j+1], 0x00};\n        unsigned char m_hat[2];\n        fec_secded2216_decode_symbol(v, m_hat);\n        _msg_dec[i] = m_hat[0];\n        i += r;\n        j += r+1;\n    }\n    assert( j == fec_get_enc_msg_length(LIQUID_FEC_SECDED2216,_dec_msg_len) );\n    assert( i == _dec_msg_len);\n    return LIQUID_OK;\n}\nint fec_secded2216_estimate_ehat(unsigned char * _sym_enc,\n                                 unsigned char * _e_hat)\n{\n    _e_hat[0] = 0x00;\n    _e_hat[1] = 0x00;\n    _e_hat[2] = 0x00;\n    unsigned char s = fec_secded2216_compute_syndrome(_sym_enc);\n    unsigned int ws = liquid_c_ones[s];\n    if (ws == 0) {\n        return 0;\n    } else {\n        unsigned int n;\n        for (n=0; n<22; n++) {\n            if (s == secded2216_syndrome_w1[n]) {\n                div_t d = div(n,8);\n                _e_hat[3-d.quot-1] = 1 << d.rem;\n                return 1;\n            }\n        }\n    }\n    return 2;\n}\nint fec_secded2216_decode(fec             _q,\n                          unsigned int    _dec_msg_len,\n                          unsigned char * _msg_enc,\n                          unsigned char * _msg_dec)\n{\n    unsigned int i=0;       \n    unsigned int j=0;       \n    unsigned int r = _dec_msg_len % 2;\n    for (i=0; i<_dec_msg_len-r; i+=2) {\n        fec_secded2216_decode_symbol(&_msg_enc[j], &_msg_dec[i]);\n        j += 3;\n    }\n    if (r) {\n        unsigned char v[3] = {_msg_enc[j+0], _msg_enc[j+1], 0x00};\n        unsigned char m_hat[2];\n        fec_secded2216_decode_symbol(v, m_hat);\n        _msg_dec[i] = m_hat[0];\n        i += r;\n        j += r+1;\n    }\n    assert( j == fec_get_enc_msg_length(LIQUID_FEC_SECDED2216,_dec_msg_len) );\n    assert( i == _dec_msg_len);\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: Please provide a code example that demonstrates the use of the grid system in the LittlevGL library. The scenario involves creating a grid layout with 3 columns and 3 rows, where each cell stretches to fill the available space. Additionally, the grid layout should be right-to-left aligned.","#if LV_USE_GRID && LV_BUILD_EXAMPLES\nvoid lv_example_grid_6(void)\n{\n    static int32_t col_dsc[] = {60, 60, 60, LV_GRID_TEMPLATE_LAST};\n    static int32_t row_dsc[] = {45, 45, 45, LV_GRID_TEMPLATE_LAST};\n    lv_obj_t * cont = lv_obj_create(lv_screen_active());\n    lv_obj_set_size(cont, 300, 220);\n    lv_obj_center(cont);\n    lv_obj_set_style_base_dir(cont, LV_BASE_DIR_RTL, 0);\n    lv_obj_set_grid_dsc_array(cont, col_dsc, row_dsc);\n    lv_obj_t * label;\n    lv_obj_t * obj;\n    uint32_t i;\n    for(i = 0; i < 9; i++) {\n        uint8_t col = i % 3;\n        uint8_t row = i / 3;\n        obj = lv_obj_create(cont);\n        lv_obj_set_grid_cell(obj, LV_GRID_ALIGN_STRETCH, col, 1,\n                             LV_GRID_ALIGN_STRETCH, row, 1);\n        label = lv_label_create(obj);\n        lv_label_set_text_fmt(label, ""%d,%d"", col, row);\n        lv_obj_center(label);\n    }\n}\n#endif'"
"'You are designing a program to generate QR codes, and need functions to calculate different parameters related to the QR code generation process. The prompt is to provide code for functions to calculate the number of raw data modules in a QR code based on its version, calculate the bit length of a segment based on its mode and number of characters, determine the number of bits needed to encode the character count in a segment based on the mode and version, calculate the total number of bits needed for a given set of segments in a QR code version, obtain the number of data codewords in a QR code based on its version and error correction level, and find the minimum version that can fit a given amount of data with a specific error correction level.","//...\ntestable int getNumRawDataModules(int ver)\n{\n    LV_ASSERT(qrcodegen_VERSION_MIN <= ver && ver <= qrcodegen_VERSION_MAX);\n    int result = (16 * ver + 128) * ver + 64;\n    if(ver >= 2) {\n        int numAlign = ver / 7 + 2;\n        result -= (25 * numAlign - 10) * numAlign - 55;\n        if(ver >= 7)\n            result -= 36;\n    }\n    return result;\n}\ntestable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars)\n{\n    if(numChars > (unsigned int)INT16_MAX)\n        return -1;\n    long result = (long)numChars;\n    if(mode == qrcodegen_Mode_NUMERIC)\n        result = (result * 10 + 2) / 3;  \n    else if(mode == qrcodegen_Mode_ALPHANUMERIC)\n        result = (result * 11 + 1) / 2;  \n    else if(mode == qrcodegen_Mode_BYTE)\n        result *= 8;\n    else if(mode == qrcodegen_Mode_KANJI)\n        result *= 13;\n    else if(mode == qrcodegen_Mode_ECI && numChars == 0)\n        result = 3 * 8;\n    else {  \n        LV_ASSERT(false);\n        return -1;\n    }\n    LV_ASSERT(result >= 0);\n    if((unsigned int)result > (unsigned int)INT16_MAX)\n        return -1;\n    return (int)result;\n}\nstatic int numCharCountBits(enum qrcodegen_Mode mode, int version)\n{\n    LV_ASSERT(qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);\n    int i = (version + 7) / 17;\n    switch(mode) {\n        case qrcodegen_Mode_NUMERIC     : {\n                static const int temp[] = {10, 12, 14};\n                return temp[i];\n            }\n        case qrcodegen_Mode_ALPHANUMERIC: {\n                static const int temp[] = { 9, 11, 13};\n                return temp[i];\n            }\n        case qrcodegen_Mode_BYTE        : {\n                static const int temp[] = { 8, 16, 16};\n                return temp[i];\n            }\n        case qrcodegen_Mode_KANJI       : {\n                static const int temp[] = { 8, 10, 12};\n                return temp[i];\n            }\n        case qrcodegen_Mode_ECI         :\n            return 0;\n        default:\n            LV_ASSERT(false);\n            return -1;  \n    }\n}\ntestable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version)\n{\n    LV_ASSERT(segs != NULL || len == 0);\n    long result = 0;\n    for(size_t i = 0; i < len; i++) {\n        int numChars  = segs[i].numChars;\n        int bitLength = segs[i].bitLength;\n        LV_ASSERT(0 <= numChars  && numChars  <= INT16_MAX);\n        LV_ASSERT(0 <= bitLength && bitLength <= INT16_MAX);\n        int ccbits = numCharCountBits(segs[i].mode, version);\n        LV_ASSERT(0 <= ccbits && ccbits <= 16);\n        if(numChars >= (1L << ccbits))\n            return -1;  \n        result += 4L + ccbits + bitLength;\n        if(result > INT16_MAX)\n            return -1;  \n    }\n    LV_ASSERT(0 <= result && result <= INT16_MAX);\n    return (int)result;\n}\ntestable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl)\n{\n    int v = version, e = (int)ecl;\n    LV_ASSERT(0 <= e && e < 4);\n    return getNumRawDataModules(v) / 8\n           - ECC_CODEWORDS_PER_BLOCK    [e][v]\n           * NUM_ERROR_CORRECTION_BLOCKS[e][v];\n}\nint qrcodegen_getMinFitVersion(enum qrcodegen_Ecc ecl, size_t dataLen)\n{\n    struct qrcodegen_Segment seg;\n    seg.mode = qrcodegen_Mode_BYTE;\n    seg.bitLength = calcSegmentBitLength(seg.mode, dataLen);\n    seg.numChars = (int)dataLen;\n    for(int version = qrcodegen_VERSION_MIN; version <= qrcodegen_VERSION_MAX; version++) {\n        int dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  \n        int dataUsedBits = getTotalBits(&seg, 1, version);\n        if(dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)\n            return version;\n    }\n    return -1;\n}\n//...'"
"('Prompt: Please write a code snippet that includes a test bench function to generate a signal using the function `spgramcf_create()` and `symstreamrcf_create_linear()`. The function should set certain parameters like window type, carrier frequency, and SNR in dB. The generated signal should be mixed with noise and written to a spectrum using `spgramcf_write()`. Finally, validate the spectrum against predefined regions and log the results if in verbose mode. An example test case should be included that tests the signal generation with specific parameters (nfft=800, window type = HANN, carrier frequency = 0.2, SNR = 10.0).","//...\nvoid testbench_spgramcf_signal(unsigned int _nfft, int _wtype, float _fc, float _SNRdB)\n{\n    float bw = 0.25f; \n    unsigned int m = 25;\n    float beta = 0.2f, n0 = -80.0f, tol = 0.5f;\n    if (liquid_autotest_verbose) {\n        printf(""  spgramcf test (signal): nfft=%6u, wtype=%24s, fc=%6.2f Fs, snr=%6.1f dB\\n"",\n                _nfft, liquid_window_str[_wtype][1], _fc, _SNRdB);\n    }\n    spgramcf     q     = spgramcf_create(_nfft, _wtype, _nfft/2, _nfft/4);\n    symstreamrcf gen   = symstreamrcf_create_linear(LIQUID_FIRFILT_KAISER,bw,m,beta,LIQUID_MODEM_QPSK);\n    nco_crcf     mixer = nco_crcf_create(LIQUID_VCO);\n    float nstd = powf(10.0f,n0/20.0f); \n    symstreamrcf_set_gain(gen, powf(10.0f, (n0 + _SNRdB + 10*log10f(bw))/20.0f));\n    nco_crcf_set_frequency(mixer, 2*M_PI*_fc);\n    unsigned int i, buf_len = 256, num_samples = 0;\n    float complex buf[buf_len];\n    while (num_samples < 2000*_nfft) {\n        symstreamrcf_write_samples(gen, buf, buf_len);\n        nco_crcf_mix_block_up(mixer, buf, buf, buf_len);\n        for (i=0; i<buf_len; i++)\n            buf[i] += nstd*(randnf()+_Complex_I*randnf())*M_SQRT1_2;\n        spgramcf_write(q, buf, buf_len);\n        num_samples += buf_len;\n    }\n    float psd[_nfft];\n    spgramcf_get_psd(q, psd);\n    float sn  = 10*log10f(powf(10,(_SNRdB+n0)/10.0f) + powf(10.0f,n0/10.0f));\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,       .fmax=_fc-0.6f*bw, .pmin=n0-tol, .pmax=n0+tol, .test_lo=1, .test_hi=1},\n        {.fmin=_fc-0.4f*bw, .fmax=_fc+0.4f*bw, .pmin=sn-tol, .pmax=sn+tol, .test_lo=1, .test_hi=1},\n        {.fmin=_fc+0.6f*bw, .fmax=+0.5f,       .pmin=n0-tol, .pmax=n0+tol, .test_lo=1, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/spgramcf_signal_%s_n%u_f%c%.0f_s%c%.0f.m"",\n        liquid_window_str[_wtype][0], _nfft,\n        _fc < 0 ? \'m\' : \'p\', fabsf(_fc*1000),\n        _SNRdB < 0 ? \'m\' : \'p\', fabsf(_SNRdB*1000));\n    liquid_autotest_validate_spectrum(psd, _nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    spgramcf_destroy(q);\n    symstreamrcf_destroy(gen);\n    nco_crcf_destroy(mixer);\n}\nvoid autotest_spgramcf_signal_02() { testbench_spgramcf_signal(800,LIQUID_WINDOW_HANN,    0.2f,10.0f); }\n//...')
"
"('Prompt: You are developing a communication system that involves packetizing data for transmission. You need to write a test function that will encode and decode packets for different configurations. Write a function that takes in the packet length, CRC scheme, and two FEC schemes as parameters, creating a packetizer object, encoding a message, and then decoding it. Finally, compare the transmitted and received messages and check if the CRC passes. Additionally, write separate test functions for packetizer configurations with a packet length of 16 and different FEC schemes.","void packetizer_test_codec(unsigned int _n,\n                           crc_scheme _crc,\n                           fec_scheme _fec0,\n                           fec_scheme _fec1)\n{\n    unsigned char msg_tx[_n];\n    unsigned char msg_rx[_n];\n    unsigned int pkt_len = packetizer_compute_enc_msg_len(_n,_crc,_fec0,_fec1);\n    unsigned char packet[pkt_len];\n    packetizer p = packetizer_create(_n,_crc,_fec0,_fec1);\n    if (liquid_autotest_verbose)\n        packetizer_print(p);\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg_tx[i] = i % 256;\n        msg_rx[i] = 0;\n    }\n    packetizer_encode(p, msg_tx, packet);\n    int crc_pass = packetizer_decode(p, packet, msg_rx);\n    CONTEND_SAME_DATA(msg_tx, msg_rx, _n);\n    CONTEND_EQUALITY(crc_pass, 1);\n    packetizer_destroy(p);\n}\nvoid autotest_packetizer_n16_0_0()  { packetizer_test_codec(16, LIQUID_CRC_32, LIQUID_FEC_NONE, LIQUID_FEC_NONE);       }\nvoid autotest_packetizer_n16_0_1()  { packetizer_test_codec(16, LIQUID_CRC_32, LIQUID_FEC_NONE, LIQUID_FEC_REP3);       }\nvoid autotest_packetizer_n16_0_2()  { packetizer_test_codec(16, LIQUID_CRC_32, LIQUID_FEC_NONE, LIQUID_FEC_HAMMING74);  }')
"
"('Prompt: Your task is to write a function that tests the functionality of copying a modem configuration. The function should create a modem configuration using a specified modulation scheme, modulate and demodulate some random data using this configuration, then create a copy of the configuration and test if the modulated output and demodulated data are the same for both configurations. Finally, the function should destroy both configurations. Write this function in C using the Liquid DSP library.","//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_arb64opt()  { modemcf_test_copy(LIQUID_MODEM_ARB64OPT);  }\n//...')
"
('Prompt: Write a code snippet that defines several macros related to a specific type of digital signal processing. The macros should generate names for functions based on a given suffix and include mathematical operations specific to a certain data type. The macros should also define a specific value for the mathematical constant pi.,"#define NCO(name)   LIQUID_CONCAT(nco_crcf,name)\n#define SYNTH(name) LIQUID_CONCAT(synth_crcf,name)\n#define EXTENSION   ""crcf""\n#define T           float\n#define TC          float complex\n#define SIN         sinf\n#define COS         cosf\n#define CONJ        conjf\n#define SQRT        sqrtf\n#define LIQUID_PI   (3.14159265358979323846264338327950288f)')
"
"('Prompt: You are working on a project that involves testing the timing synchronization and frequency offset estimation in an OFDM system. Can you provide a C code snippet that sets up parameters for the OFDM frame synchronization and CFO test, generates OFDM frames with specified characteristics, introduces noise, performs the synchronization and estimation, and records the results in an output file?. . ```c. #define OUTPUT_FILENAME ""ofdmframesync_cfo_test.dat"". void usage(). {.     printf(""Usage: ofdmframesync_cfo_test [OPTION]\\n"");.     printf(""  h     : print help\\n"");.     printf(""  M     : number of subcarriers (must be even), default: 64\\n"");.     printf(""  C     : cyclic prefix length, default: 16\\n"");.     printf(""  T     : taper length, default: 4\\n"");.     printf(""  S     : signal-to-noise ratio [dB], default: 20\\n"");.     printf("" ","#define OUTPUT_FILENAME ""ofdmframesync_cfo_test.dat""\nvoid usage()\n{\n    printf(""Usage: ofdmframesync_cfo_test [OPTION]\\n"");\n    printf(""  h     : print help\\n"");\n    printf(""  M     : number of subcarriers (must be even), default: 64\\n"");\n    printf(""  C     : cyclic prefix length, default: 16\\n"");\n    printf(""  T     : taper length, default: 4\\n"");\n    printf(""  S     : signal-to-noise ratio [dB], default: 20\\n"");\n    printf(""  t     : number of trials, default: 500\\n"");\n    printf(""  s     : number of steps, default: 21\\n"");\n}\nstatic int callback(float complex * _X,\n                    unsigned char * _p,\n                    unsigned int    _M,\n                    void *          _userdata);\nint main(int argc, char*argv[])\n{\n    srand(time(NULL));\n    unsigned int M           = 64;      \n    unsigned int cp_len      = 16;      \n    unsigned int taper_len   = 4;       \n    float noise_floor        = -30.0f;  \n    float SNRdB              = 20.0f;   \n    unsigned int num_trials  = 500;     \n    unsigned int num_steps   = 21;      \n    int dopt;\n    while((dopt = getopt(argc,argv,""hM:C:T:S:t:s:"")) != EOF){\n        switch (dopt) {\n        case \'h\': usage();                  return 0;\n        case \'M\': M         = atoi(optarg); break;\n        case \'C\': cp_len    = atoi(optarg); break;\n        case \'T\': taper_len = atoi(optarg); break;\n        case \'S\': SNRdB     = atof(optarg); break;\n        case \'t\': num_trials= atoi(optarg); break;\n        case \'s\': num_steps = atoi(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    unsigned int i;\n    unsigned int num_symbols = 1;             \n    unsigned int symbol_len = M + cp_len;\n    unsigned int num_samples = (3+num_symbols)*symbol_len;  \n    float nstd = powf(10.0f, noise_floor/20.0f);\n    float gamma = powf(10.0f, (SNRdB + noise_floor)/20.0f);\n    printf(""gamma : %f\\n"", gamma);\n    unsigned char p[M];\n    ofdmframe_init_default_sctype(M, p);\n    ofdmframegen fg = ofdmframegen_create(M, cp_len, taper_len, p);\n    ofdmframegen_print(fg);\n    int frame_detected;\n    ofdmframesync fs = ofdmframesync_create(M, cp_len, taper_len, p, callback, (int*)&frame_detected);\n    ofdmframesync_print(fs);\n    float complex X[M];                 \n    float complex frame[num_samples];   \n    float complex y[num_samples];       \n    unsigned int n=0;\n    ofdmframegen_write_S0a(fg, &frame[n]);  n += symbol_len;\n    ofdmframegen_write_S0b(fg, &frame[n]);  n += symbol_len;\n    ofdmframegen_write_S1( fg, &frame[n]);  n += symbol_len;\n    for (i=0; i<M; i++)\n        X[i] = rand() % 2 ? 1.0f : -1.0f;\n    ofdmframegen_writesymbol(fg, X, &frame[n]);\n    float nu_min = 0.0f;            \n    float nu_max = 0.9f*M_PI / (float)M; \n    float nu_step = (nu_max - nu_min) / (float)(num_steps-1);\n    unsigned int M_data  = 0;\n    unsigned int M_pilot = 0;\n    unsigned int M_null  = 0;\n    ofdmframe_validate_sctype(p, M, &M_null, &M_pilot, &M_data);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""# %s: auto-generated file\\n\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""#\\n"");\n    fprintf(fid,""#  M           = %u\\n"", M);\n    fprintf(fid,""#  M_data      = %u\\n"", M_data);\n    fprintf(fid,""#  M_pilot     = %u\\n"", M_pilot);\n    fprintf(fid,""#  M_null      = %u\\n"", M_null);\n    fprintf(fid,""#  cp_len      = %u\\n"", cp_len);\n    fprintf(fid,""#  num_samples = %u\\n"", num_samples);\n    fprintf(fid,""#  noise_floor = %f\\n"", noise_floor);\n    fprintf(fid,""#  SNRdB = %f\\n"", SNRdB);\n    fprintf(fid,""#\\n"");\n    fprintf(fid,""# %12s %12s %12s %12s %12s %12s\\n"",\n            ""id"", ""nu"", ""detected"", ""total"", ""bias"", ""rmse"");\n    for (n=0; n<num_steps; n++) {\n        float nu = nu_min + nu_step*n;\n        unsigned int t;\n        unsigned int num_frames_detected=0;\n        float nu_hat_bias = 0.0f;\n        float nu_hat_rmse = 0.0f;\n        for (t=0; t<num_trials; t++) {\n            ofdmframesync_reset(fs);\n            frame_detected = 0;\n            float phi = randf()*2*M_PI; \n            for (i=0; i<num_samples; i++) {\n                y[i] = gamma * frame[i] * cexpf(_Complex_I*(phi + nu*i));\n                y[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n            }\n            ofdmframesync_execute(fs,y,num_samples);\n            num_frames_detected += frame_detected;\n            float nu_hat = ofdmframesync_get_cfo(fs);\n            float nu_hat_error = nu - nu_hat;\n            nu_hat_bias += nu_hat_error;\n            nu_hat_rmse += nu_hat_error*nu_hat_error;\n        }\n        nu_hat_bias /= (float)num_trials;\n        nu_hat_rmse /= (float)num_trials;\n        nu_hat_rmse  = sqrtf(nu_hat_rmse);\n        printf(""%6u, nu=%12.8f"", n, nu);\n        printf("", frames: %6u / %6u"", num_frames_detected, num_trials);\n        printf("", bias: %12.8f"", nu_hat_bias);\n        printf("", rmse: %12.8f"", nu_hat_rmse);\n        printf(""\\n"");\n        fprintf(fid,""  %12u %12f %12u %12u %12.4e %12.4e\\n"",\n                n, nu, num_frames_detected, num_trials,\n                nu_hat_bias, nu_hat_rmse);\n    }\n    ofdmframegen_destroy(fg);\n    ofdmframesync_destroy(fs);\n    fclose(fid);\n    printf(""results written to %s\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}\nstatic int callback(float complex * _X,\n                    unsigned char * _p,\n                    unsigned int    _M,\n                    void *          _userdata)\n{\n    int * frame_detected = (int*)_userdata;\n    *frame_detected = 1;\n    return 0;\n}')
"
"('Prompt: . Please write a function that tests the period of a maximal-length sequence generated by a linear feedback shift register with a specific size. The function should create a default m-sequence with the given size, calculate the expected period based on the size, measure the actual period of the generated sequence, and then assert that the actual period matches the expected period. Finally, the function should destroy the m-sequence. Additionally, please create an automated test specifically for the case where the size is 13.","//...\nvoid msequence_test_period(unsigned int _m)\n{\n    msequence q = msequence_create_default(_m);\n    unsigned int n = (1U << _m) - 1;\n    unsigned int p = msequence_measure_period(q);\n    CONTEND_EQUALITY(p,n)\n    msequence_destroy(q);\n}\nvoid autotest_msequence_period_m13() { msequence_test_period(13); }\n//...')
"
"'Prompt: You are working on a low-level interface for communication between different processors in a system. I need a code snippet that includes functions for reading and writing data through a mailbox on a Raspberry Pi. The code should include macros for masking data and channel values, as well as functions to check if the mailbox is full or empty. Additionally, there should be functions for reading and writing data from/to the specified channel within the mailbox.","#define BCM2835_MBOX_DATA_MASK( data ) ( data & 0xFFFFFFF0U )\n#define BCM2835_MBOX_CHANNEL_MASK( data ) ( data & 0xFU )\nstatic inline bool bcm2835_mailbox_is_empty( void )\n{\n  return ( BCM2835_REG( BCM2835_MBOX_STATUS ) & BCM2835_MBOX_EMPTY );\n}\nstatic inline bool bcm2835_mailbox_is_full( void )\n{\n  return ( BCM2835_REG( BCM2835_MBOX_STATUS ) & BCM2835_MBOX_FULL );\n}\nunsigned int raspberrypi_mailbox_read( unsigned int channel )\n{\n  unsigned int raw;\n  unsigned int read_channel;\n  while ( 1 ) {\n    while ( bcm2835_mailbox_is_empty() ) ;\n    raw = BCM2835_REG( BCM2835_MBOX_READ );\n    read_channel = BCM2835_MBOX_CHANNEL_MASK( raw );\n    if ( read_channel == channel )\n      return BCM2835_MBOX_DATA_MASK( raw );\n  }\n}\nvoid raspberrypi_mailbox_write(\n  unsigned int channel,\n  unsigned int data\n)\n{\n  while ( bcm2835_mailbox_is_full() ) ;\n  BCM2835_REG( BCM2835_MBOX_WRITE ) =\n    BCM2835_MBOX_DATA_MASK( data ) |\n    BCM2835_MBOX_CHANNEL_MASK( channel );\n}'"
"'You could have prompted me with:. ""Write C code for initializing and managing an NXP i.MX RT series LPI2C bus communication interface. Include functions for software reset, setting clock, reinitialization, handling interrupts, waiting for not busy, transferring data, destroying the bus, and initializing the LPI2C interface. Make use of defined macros and struct for the LPI2C bus.""","#define LPI2C_MTDR_CMD_transmit                           LPI2C_MTDR_CMD(0)\n#define LPI2C_MTDR_CMD_receive                            LPI2C_MTDR_CMD(1)\n#define LPI2C_MTDR_CMD_stop                               LPI2C_MTDR_CMD(2)\n#define LPI2C_MTDR_CMD_receive_and_discard                LPI2C_MTDR_CMD(3)\n#define LPI2C_MTDR_CMD_start_and_transmit                 LPI2C_MTDR_CMD(4)\n#define LPI2C_MTDR_CMD_start_and_transmit_NACK            LPI2C_MTDR_CMD(5)\n#define LPI2C_MTDR_CMD_start_and_transmit_highspeed       LPI2C_MTDR_CMD(6)\n#define LPI2C_MTDR_CMD_start_and_transmit_highspeed_NACK  LPI2C_MTDR_CMD(7)\n#define LPI2C_INT_ERRORS_SERIOUS ( \\\n  LPI2C_MSR_FEF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_PLTF_MASK )\n#define LPI2C_INT_ERROR_NO_ACK (LPI2C_MSR_NDF_MASK)\n#define LPI2C_INT_ERRORS (LPI2C_INT_ERRORS_SERIOUS | LPI2C_INT_ERROR_NO_ACK)\n#define LPI2C_INT_ADDRESSED (LPI2C_INT_ERRORS | LPI2C_MSR_TDF_MASK)\n#define LPI2C_INT_STOP_SENT (LPI2C_INT_ERRORS | LPI2C_MSR_SDF_MASK)\n#define LPI2C_INT_RECEIVED (LPI2C_INT_ERRORS | LPI2C_MSR_RDF_MASK)\n#define LPI2C_INT_TRANSMITTED (LPI2C_INT_ERRORS | LPI2C_MSR_TDF_MASK)\nstruct imxrt_lpi2c_bus {\n  i2c_bus base;\n  volatile LPI2C_Type *regs;\n  rtems_vector_number irq;\n  uint32_t src_clock_hz;\n  clock_ip_name_t clock_ip;\n  unsigned long clock;\n  rtems_binary_semaphore sem;\n  int eno;\n  uint32_t msg_todo;\n  const i2c_msg *msg;\n  uint32_t chunk_todo;\n  uint16_t buf_todo;\n  uint8_t *buf;\n  bool stop;\n  bool read;\n};\nstatic void imxrt_lpi2c_sw_reset(volatile LPI2C_Type *regs)\n{\n  regs->MCR = LPI2C_MCR_RST_MASK | LPI2C_MCR_RRF_MASK | LPI2C_MCR_RTF_MASK;\n  regs->SCR = LPI2C_SCR_RST_MASK | LPI2C_SCR_RRF_MASK | LPI2C_SCR_RTF_MASK;\n  regs->MCR = 0;\n  regs->SCR = 0;\n}\nstatic int imxrt_lpi2c_set_clock(i2c_bus *base, unsigned long clock)\n{\n  struct imxrt_lpi2c_bus *bus;\n  volatile LPI2C_Type *regs;\n  bus = (struct imxrt_lpi2c_bus *) base;\n  regs = bus->regs;\n  bus->clock = clock;\n  LPI2C_MasterSetBaudRate((LPI2C_Type *)regs, bus->src_clock_hz, clock);\n  return 0;\n}\nstatic void imxrt_lpi2c_do_reinit(\n  struct imxrt_lpi2c_bus *bus,\n  volatile LPI2C_Type *regs\n)\n{\n  regs->MIER = 0;\n  imxrt_lpi2c_sw_reset(regs);\n  regs->MCFGR2 = LPI2C_MCFGR2_FILTSDA(0) | LPI2C_MCFGR2_FILTSCL(0) |\n    LPI2C_MCFGR2_BUSIDLE(0);\n  regs->MCFGR3 = LPI2C_MCFGR3_PINLOW(0);\n  regs->MFCR = LPI2C_MFCR_RXWATER(0) | LPI2C_MFCR_TXWATER(1);\n  imxrt_lpi2c_set_clock(&bus->base, bus->clock);\n}\nstatic void imxrt_lpi2c_done(\n  struct imxrt_lpi2c_bus *bus,\n  volatile LPI2C_Type *regs\n)\n{\n  regs->MIER = 0;\n  regs->MCR &= ~LPI2C_MCR_MEN_MASK;\n  rtems_binary_semaphore_post(&bus->sem);\n}\nstatic void imxrt_lpi2c_next_msg(\n  struct imxrt_lpi2c_bus *bus,\n  volatile LPI2C_Type *regs\n);\nstatic void imxrt_lpi2c_transmit_next(\n  struct imxrt_lpi2c_bus *bus,\n  volatile LPI2C_Type *regs\n)\n{\n  if (bus->chunk_todo == 0) {\n    if (bus->stop) {\n      regs->MTDR = LPI2C_MTDR_CMD_stop;\n      bus->stop = false;\n      regs->MIER = LPI2C_INT_STOP_SENT;\n    } else {\n      imxrt_lpi2c_next_msg(bus, regs);\n    }\n  } else {\n    if (bus->read) {\n      uint16_t to_read;\n      to_read = MIN(bus->chunk_todo, 256);\n      bus->chunk_todo -= to_read;\n      regs->MTDR = LPI2C_MTDR_CMD_receive | (to_read - 1);\n      regs->MIER = LPI2C_INT_RECEIVED;\n    } else {\n      regs->MTDR = LPI2C_MTDR_CMD_transmit | *bus->buf;\n      ++bus->buf;\n      --bus->buf_todo;\n      --bus->chunk_todo;\n      regs->MIER = LPI2C_INT_TRANSMITTED;\n    }\n  }\n}\nstatic void imxrt_lpi2c_next_msg(\n  struct imxrt_lpi2c_bus *bus,\n  volatile LPI2C_Type *regs\n)\n{\n  if (bus->msg_todo == 0) {\n    imxrt_lpi2c_done(bus, regs);\n  } else {\n    const i2c_msg *msg;\n    int flags;\n    bool start;\n    uint16_t addr;\n    msg = bus->msg;\n    flags = msg->flags;\n    addr = msg->addr;\n    start = (flags & I2C_M_NOSTART) == 0;\n    bus->read = (flags & I2C_M_RD) != 0;\n    bus->chunk_todo = msg->len;\n    bus->buf_todo = msg->len;\n    bus->buf = msg->buf;\n    bus->stop = (flags & I2C_M_STOP) != 0 || bus->msg_todo <= 1;\n    ++bus->msg;\n    --bus->msg_todo;\n    if (start) {\n      uint32_t mtdr;\n      mtdr = LPI2C_MTDR_CMD_start_and_transmit;\n      mtdr |= addr << 1;\n      if (bus->read) {\n        mtdr |= 1;\n      }\n      regs->MTDR = mtdr;\n      regs->MIER = LPI2C_INT_ADDRESSED;\n    } else {\n      imxrt_lpi2c_transmit_next(bus, regs);\n    }\n  }\n}\nstatic void imxrt_lpi2c_interrupt(void *arg)\n{\n  struct imxrt_lpi2c_bus *bus;\n  volatile LPI2C_Type *regs;\n  uint32_t msr;\n  bus = arg;\n  regs = bus->regs;\n  msr = regs->MSR;\n  regs->MSR = msr;\n  if ((msr & LPI2C_INT_ERROR_NO_ACK) != 0) {\n    bus->eno = EIO;\n    imxrt_lpi2c_done(bus, regs);\n  } else if ((msr & LPI2C_INT_ERRORS_SERIOUS) != 0) {\n    bus->eno = EIO;\n    imxrt_lpi2c_do_reinit(bus, regs);\n    imxrt_lpi2c_done(bus, regs);\n  } else {\n    uint32_t mrdr;\n    while (((mrdr = regs->MRDR) & LPI2C_MRDR_RXEMPTY_MASK) == 0) {\n      if (bus->read && bus->buf_todo > 0) {\n        *bus->buf = (mrdr & LPI2C_MRDR_DATA_MASK) >> LPI2C_MRDR_DATA_SHIFT;\n        ++bus->buf;\n        --bus->buf_todo;\n      }\n    }\n    if (\n      ((msr & LPI2C_MSR_TDF_MASK) != 0) &&\n      (!bus->read || bus->chunk_todo > 0 || bus->buf_todo == 0)\n    ) {\n      imxrt_lpi2c_transmit_next(bus, regs);\n    }\n  }\n}\nstatic int imxrt_lpi2c_wait_for_not_busy(volatile LPI2C_Type *regs)\n{\n  rtems_interval timeout;\n  bool before;\n  if ((regs->MSR & LPI2C_MSR_BBF_MASK) == 0) {\n    return 0;\n  }\n  timeout = rtems_clock_tick_later_usec(5000);\n  do {\n    before = rtems_clock_tick_before(timeout);\n    if ((regs->MSR & LPI2C_MSR_BBF_MASK) == 0) {\n      return 0;\n    }\n  } while (before);\n  return ETIMEDOUT;\n}\nstatic void imxrt_lpi2c_first_msg(\n  struct imxrt_lpi2c_bus *bus,\n  volatile LPI2C_Type *regs\n)\n{\n  if ((regs->MCR & LPI2C_MCR_MEN_MASK) == 0) {\n    regs->MCR |= LPI2C_MCR_MEN_MASK;\n  }\n  imxrt_lpi2c_next_msg(bus, regs);\n}\nstatic int imxrt_lpi2c_transfer(i2c_bus *base, i2c_msg *msgs, uint32_t n)\n{\n  struct imxrt_lpi2c_bus *bus;\n  volatile LPI2C_Type *regs;\n  int supported_flags;\n  int eno;\n  uint16_t i;\n  bus = (struct imxrt_lpi2c_bus *) base;\n  regs = bus->regs;\n  supported_flags = I2C_M_RD | I2C_M_STOP;\n  for (i = 0; i < n; ++i) {\n    if ((msgs[i].flags & ~supported_flags) != 0) {\n      return -EINVAL;\n    }\n    supported_flags |= I2C_M_NOSTART;\n  }\n  eno = imxrt_lpi2c_wait_for_not_busy(regs);\n  if (eno != 0) {\n    imxrt_lpi2c_do_reinit(bus, regs);\n    return -eno;\n  }\n  bus->msg_todo = n;\n  bus->msg = &msgs[0];\n  bus->eno = 0;\n  imxrt_lpi2c_first_msg(bus, regs);\n  eno = rtems_binary_semaphore_wait_timed_ticks(&bus->sem, bus->base.timeout);\n  if (eno != 0) {\n    imxrt_lpi2c_do_reinit(bus, regs);\n    rtems_binary_semaphore_try_wait(&bus->sem);\n    return -eno;\n  }\n  return -bus->eno;\n}\nstatic void imxrt_lpi2c_destroy(i2c_bus *base)\n{\n  struct imxrt_lpi2c_bus *bus;\n  volatile LPI2C_Type *regs;\n  bus = (struct imxrt_lpi2c_bus *) base;\n  regs = bus->regs;\n  imxrt_lpi2c_sw_reset(regs);\n  CLOCK_DisableClock(bus->clock_ip);\n  rtems_interrupt_handler_remove(bus->irq, imxrt_lpi2c_interrupt, bus);\n  i2c_bus_destroy_and_free(&bus->base);\n}\nstatic int imxrt_lpi2c_hw_init(struct imxrt_lpi2c_bus *bus)\n{\n  rtems_status_code sc;\n  volatile LPI2C_Type *regs;\n  regs = bus->regs;\n  CLOCK_EnableClock(bus->clock_ip);\n  bus->clock = I2C_BUS_CLOCK_DEFAULT;\n  imxrt_lpi2c_do_reinit(bus, regs);\n  sc = rtems_interrupt_handler_install(\n    bus->irq,\n    ""LPI2C"",\n    RTEMS_INTERRUPT_UNIQUE,\n    imxrt_lpi2c_interrupt,\n    bus\n  );\n  if (sc != RTEMS_SUCCESSFUL) {\n    return EAGAIN;\n  }\n  return 0;\n}\nstatic uint32_t imxrt_lpi2c_get_src_freq(clock_ip_name_t clock_ip)\n{\n  uint32_t freq;\n#if IMXRT_IS_MIMXRT10xx\n  uint32_t mux;\n  uint32_t divider;\n  (void) clock_ip; \n  mux = CLOCK_GetMux(kCLOCK_Lpi2cMux);\n  divider = 1;\n  switch (mux) {\n  case 0: \n    freq = CLOCK_GetFreq(kCLOCK_Usb1PllClk);\n    divider = 8;\n    break;\n  case 1: \n    freq = CLOCK_GetFreq(kCLOCK_OscClk);\n    break;\n  default:\n    freq = 0;\n  }\n  divider *= CLOCK_GetDiv(kCLOCK_Lpi2cDiv) + 1;\n  freq /= divider;\n#elif IMXRT_IS_MIMXRT11xx\n  clock_root_t clock_root = clock_ip + kCLOCK_Root_Lpi2c1 - kCLOCK_Lpi2c1;\n  freq = CLOCK_GetRootClockFreq(clock_root);\n#else\n  #error Getting I2C frequency is not implemented for this chip.\n#endif\n  return freq;\n}\nstatic clock_ip_name_t imxrt_lpi2c_clock_ip(volatile LPI2C_Type *regs)\n{\n  LPI2C_Type *const base_addresses[] = LPI2C_BASE_PTRS;\n  static const clock_ip_name_t lpi2c_clocks[] = LPI2C_CLOCKS;\n  size_t i;\n  for (i = 0; i < RTEMS_ARRAY_SIZE(base_addresses); ++i) {\n    if (base_addresses[i] == regs) {\n      return lpi2c_clocks[i];\n    }\n  }\n  return kCLOCK_IpInvalid;\n}\nvoid imxrt_lpi2c_init(void)\n{\n  const void *fdt;\n  int node;\n  fdt = bsp_fdt_get();\n  node = -1;\n  do {\n    node = fdt_node_offset_by_compatible(fdt, node, ""nxp,imxrt-lpi2c"");\n    if (node >= 0 && imxrt_fdt_node_is_enabled(fdt, node)) {\n      struct imxrt_lpi2c_bus *bus;\n      int eno;\n      const char *bus_path;\n      bus = (struct imxrt_lpi2c_bus*) i2c_bus_alloc_and_init(sizeof(*bus));\n      if (bus == NULL) {\n        bsp_fatal(IMXRT_FATAL_LPI2C_ALLOC_FAILED);\n      }\n      rtems_binary_semaphore_init(&bus->sem, ""LPI2C"");\n      bus->regs = imx_get_reg_of_node(fdt, node);\n      if (bus->regs == NULL) {\n        (*bus->base.destroy)(&bus->base);\n        bsp_fatal(IMXRT_FATAL_LPI2C_INVALID_FDT);\n      }\n      bus->irq = imx_get_irq_of_node(fdt, node, 0);\n      if (bus->irq == BSP_INTERRUPT_VECTOR_INVALID) {\n        (*bus->base.destroy)(&bus->base);\n        bsp_fatal(IMXRT_FATAL_LPI2C_INVALID_FDT);\n      }\n      bus_path = fdt_getprop(fdt, node, ""rtems,path"", NULL);\n      if (bus_path == NULL) {\n        (*bus->base.destroy)(&bus->base);\n        bsp_fatal(IMXRT_FATAL_LPI2C_INVALID_FDT);\n      }\n      bus->clock_ip = imxrt_lpi2c_clock_ip(bus->regs);\n      bus->src_clock_hz = imxrt_lpi2c_get_src_freq(bus->clock_ip);\n      eno = imxrt_lpi2c_hw_init(bus);\n      if (eno != 0) {\n        (*bus->base.destroy)(&bus->base);\n        bsp_fatal(IMXRT_FATAL_LPI2C_HW_INIT_FAILED);\n      }\n      bus->base.transfer = imxrt_lpi2c_transfer;\n      bus->base.set_clock = imxrt_lpi2c_set_clock;\n      bus->base.destroy = imxrt_lpi2c_destroy;\n      if ((1 << ((bus->regs->PARAM & LPI2C_PARAM_MTXFIFO_MASK) >>\n          LPI2C_PARAM_MTXFIFO_SHIFT)) < 3) {\n        bsp_fatal(IMXRT_FATAL_LPI2C_UNSUPPORTED_HARDWARE);\n      }\n      eno = i2c_bus_register(&bus->base, bus_path);\n      if (eno != 0) {\n        bsp_fatal(IMXRT_FATAL_LPI2C_REGISTER_FAILED);\n      }\n    }\n  } while (node >= 0);\n}'"
"'Hello, I need to set up the memory protection unit (MPU) configuration for ARM Cortex-M7 architecture on a LPC24xx microcontroller. I need to define MPU regions for different memory sections based on the specific memory chips being used in the system. Can you provide me with the configuration code for the MPU regions considering the memory chip options LPC24XX_EMC_IS42S32800D7, LPC24XX_EMC_IS42S32800B, LPC24XX_EMC_MT48LC4M16A2, LPC24XX_EMC_W9825G2JB75I, LPC24XX_EMC_M29W320E70, and LPC24XX_EMC_SST39VF3201?","#ifdef ARM_MULTILIB_ARCH_V7M\n  BSP_START_DATA_SECTION const ARMV7M_MPU_Region\n    lpc24xx_start_config_mpu_region [] = {\n      #if defined(LPC24XX_EMC_IS42S32800D7) \\\n        || defined(LPC24XX_EMC_IS42S32800B) \\\n        || defined(LPC24XX_EMC_MT48LC4M16A2) \\\n        || defined(LPC24XX_EMC_W9825G2JB75I)\n        ARMV7M_MPU_REGION_INITIALIZER(\n          0,\n          0x00000000,\n          ARMV7M_MPU_SIZE_512_KB,\n          ARMV7M_MPU_ATTR_RX\n        ),\n        ARMV7M_MPU_REGION_INITIALIZER(\n          1,\n          0x10000000,\n          ARMV7M_MPU_SIZE_64_KB,\n          ARMV7M_MPU_ATTR_RWX\n        ),\n        ARMV7M_MPU_REGION_INITIALIZER(\n          2,\n          0x20000000,\n          ARMV7M_MPU_SIZE_32_KB,\n          ARMV7M_MPU_ATTR_RWX\n        ),\n        ARMV7M_MPU_REGION_INITIALIZER(\n          3,\n          0xa0000000,\n          #if defined(LPC24XX_EMC_MT48LC4M16A2)\n            ARMV7M_MPU_SIZE_8_MB,\n          #else\n            ARMV7M_MPU_SIZE_32_MB,\n          #endif\n          ARMV7M_MPU_ATTR_RWX\n        ),\n        ARMV7M_MPU_REGION_INITIALIZER(\n          4,\n          0x20080000,\n          ARMV7M_MPU_SIZE_128_KB,\n          ARMV7M_MPU_ATTR_IO\n        ),\n        ARMV7M_MPU_REGION_INITIALIZER(\n          5,\n          0x40000000,\n          ARMV7M_MPU_SIZE_1_MB,\n          ARMV7M_MPU_ATTR_IO\n        ),\n        #if defined(LPC24XX_EMC_M29W320E70) \\\n          || defined(LPC24XX_EMC_SST39VF3201)\n          ARMV7M_MPU_REGION_INITIALIZER(\n            6,\n            0x80000000,\n            ARMV7M_MPU_SIZE_4_MB,\n            ARMV7M_MPU_ATTR_RWX\n          ),\n        #else\n          ARMV7M_MPU_REGION_DISABLED_INITIALIZER(6),\n        #endif\n        ARMV7M_MPU_REGION_DISABLED_INITIALIZER(7)\n     #endif\n  };\n  BSP_START_DATA_SECTION const size_t\n    lpc24xx_start_config_mpu_region_count =\n      sizeof(lpc24xx_start_config_mpu_region)\n        / sizeof(lpc24xx_start_config_mpu_region [0]);\n#endif'"
"'Prompt: You are working on a project that involves using FFmpeg with the LittlevGL graphics library. Write a code snippet that checks if FFmpeg is enabled in the build and depending on that, either display an image using FFmpeg or show a text message indicating that FFmpeg is not installed.","#if LV_BUILD_EXAMPLES\n#if LV_USE_FFMPEG\nvoid lv_example_ffmpeg_1(void)\n{\n    lv_obj_t * img = lv_image_create(lv_screen_active());\n    lv_image_set_src(img, ""./lvgl/examples/libs/ffmpeg/ffmpeg.png"");\n    lv_obj_center(img);\n}\n#else\nvoid lv_example_ffmpeg_1(void)\n{\n    lv_obj_t * label = lv_label_create(lv_screen_active());\n    lv_label_set_text(label, ""FFmpeg is not installed"");\n    lv_obj_center(label);\n}\n#endif\n#endif'"
"('Prompt: You need to create a C program that performs resampling using a multistage resampler with a decimation factor, stop-band attenuation, and number of input samples as user-defined parameters. The program should generate input samples based on a specified function and plot the frequency and time-domain results of resampling. The output should be written to a designated file. Provide the code snippet for this scenario.","#define OUTPUT_FILENAME ""msresamp_crcf_test.m""\nvoid usage()\n{\n    printf(""Usage: msresamp_crcf_test [OPTION]\\n"");\n    printf(""  h     : print help\\n"");\n    printf(""  r     : resampling rate (output/input), default: 0.117\\n"");\n    printf(""  s     : stop-band attenuation [dB], default: 60\\n"");\n    printf(""  n     : number of input samples, default: 500\\n"");\n}\nint main(int argc, char*argv[])\n{\n    float r=1.2f;           \n    float As=80.0f;         \n    unsigned int nx=400;    \n    float fc=0.40f;         \n    int dopt;\n    while ((dopt = getopt(argc,argv,""hr:s:n:"")) != EOF) {\n        switch (dopt) {\n        case \'h\':   usage();            return 0;\n        case \'r\':   r   = atof(optarg); break;\n        case \'s\':   As  = atof(optarg); break;\n        case \'n\':   nx  = atoi(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    if (nx == 0) {\n        fprintf(stderr,""error: %s, number of input samples must be greater than zero\\n"", argv[0]);\n        exit(1);\n    } else if (r <= 0.0f) {\n        fprintf(stderr,""error: %s, resampling rate must be greater than zero\\n"", argv[0]);\n        exit(1);\n    } else if ( fabsf(log2f(r)) > 10 ) {\n        fprintf(stderr,""error: %s, resampling rate unreasonable\\n"", argv[0]);\n        exit(1);\n    }\n    unsigned int i;\n    unsigned int ny_alloc = (unsigned int) (2*(float)nx * r);  \n    float complex x[nx];\n    float complex y[ny_alloc];\n    unsigned int window_len = (3*nx)/4;\n    for (i=0; i<nx; i++)\n        x[i] = i < window_len ? cexpf(_Complex_I*2*M_PI*fc*i) * liquid_kaiser(i,window_len,10.0f) : 0.0f;\n    msresamp_crcf q = msresamp_crcf_create(r,As);\n    msresamp_crcf_print(q);\n    float delay = msresamp_crcf_get_delay(q);\n    unsigned int ny;\n    msresamp_crcf_execute(q, x, nx, y, &ny);\n    printf(""input samples   : %u\\n"", nx);\n    printf(""output samples  : %u\\n"", ny);\n    printf(""delay           : %f samples\\n"", delay);\n    msresamp_crcf_destroy(q);\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s: auto-generated file\\n"",OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""\\n"");\n    fprintf(fid,""r=%12.8f;\\n"", r);\n    fprintf(fid,""delay = %f;\\n"", delay);\n    fprintf(fid,""nx = %u;\\n"", nx);\n    fprintf(fid,""x = zeros(1,nx);\\n"");\n    for (i=0; i<nx; i++)\n        fprintf(fid,""x(%6u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(x[i]), cimagf(x[i]));\n    fprintf(fid,""ny = %u;\\n"", ny);\n    fprintf(fid,""y = zeros(1,ny);\\n"");\n    for (i=0; i<ny; i++)\n        fprintf(fid,""y(%6u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(y[i]), cimagf(y[i]));\n    fprintf(fid,""\\n\\n"");\n    fprintf(fid,""%% plot frequency-domain result\\n"");\n    fprintf(fid,""nfft=1024;\\n"");\n    fprintf(fid,""%% estimate PSD, normalize by array length\\n"");\n    fprintf(fid,""X=20*log10(abs(fftshift(fft(x,nfft)/length(x))));\\n"");\n    fprintf(fid,""Y=20*log10(abs(fftshift(fft(y,nfft)/length(y))));\\n"");\n    fprintf(fid,""G = max(X);\\n"");\n    fprintf(fid,""X = X - G;\\n"");\n    fprintf(fid,""Y = Y - G;\\n"");\n    fprintf(fid,""f=[0:(nfft-1)]/nfft-0.5;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""if r>1, fx = f/r; fy = f;   %% interpolated\\n"");\n    fprintf(fid,""else,   fx = f;   fy = f*r; %% decimated\\n"");\n    fprintf(fid,""end;\\n"");\n    fprintf(fid,""plot(fx,X,\'Color\',[0.5 0.5 0.5],fy,Y,\'LineWidth\',2);\\n"");\n    fprintf(fid,""grid on;\\n\\n"");\n    fprintf(fid,""xlabel(\'normalized frequency\');\\n"");\n    fprintf(fid,""ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""legend(\'original\',\'resampled\',\'location\',\'northeast\');"");\n    fprintf(fid,""axis([-0.5 0.5 -120 10]);\\n"");\n    fprintf(fid,""\\n\\n"");\n    fprintf(fid,""%% plot time-domain result\\n"");\n    fprintf(fid,""tx=[0:(length(x)-1)];\\n"");\n    fprintf(fid,""ty=[0:(length(y)-1)]/r-delay;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(2,1,1);\\n"");\n    fprintf(fid,""  plot(tx,real(x),\'-s\',\'Color\',[0.5 0.5 0.5],\'MarkerSize\',1,...\\n"");\n    fprintf(fid,""       ty,real(y),\'-s\',\'Color\',[0.5 0 0],    \'MarkerSize\',1);\\n"");\n    fprintf(fid,""  legend(\'original\',\'resampled\',\'location\',\'northeast\');"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'real\');\\n"");\n    fprintf(fid,""  grid on;\\n\\n"");\n    fprintf(fid,""subplot(2,1,2);\\n"");\n    fprintf(fid,""  plot(tx,imag(x),\'-s\',\'Color\',[0.5 0.5 0.5],\'MarkerSize\',1,...\\n"");\n    fprintf(fid,""       ty,imag(y),\'-s\',\'Color\',[0 0.5 0],    \'MarkerSize\',1);\\n"");\n    fprintf(fid,""  legend(\'original\',\'resampled\',\'location\',\'northeast\');"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'imag\');\\n"");\n    fprintf(fid,""  grid on;\\n\\n"");\n    fclose(fid);\n    printf(""results written to %s\\n"",OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
('Prompt: You are developing a software application that uses an OFDM frame generator module written in C. The OFDM frame generator module needs a function to free up resources and memory allocated during its operation to prevent memory leaks. Please write a function in C that frees up all the memory allocated by the OFDM frame generator module.,"//...\nint ofdmframegen_destroy(ofdmframegen _q)\n{\n    free(_q->p);\n    FFT_FREE(_q->X);\n    FFT_FREE(_q->x);\n    FFT_DESTROY_PLAN(_q->ifft);\n    free(_q->taper);\n    free(_q->postfix);\n    free(_q->S0);\n    free(_q->s0);\n    free(_q->S1);\n    free(_q->s1);\n    msequence_destroy(_q->ms_pilot);\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
"('You could have prompted me to provide a code snippet for implementing a DSSS frame synchronization algorithm in a digital communication system. The code includes data structures and functions for detecting and synchronizing to DSSS frames, decoding headers and payloads, and manipulating complex signals using various processing blocks such as mixers, NCOs, and FIR filters.","//...\nstruct dsssframesync_s {\n    framesync_callback  callback;\n    void *              userdata;\n    framesyncstats_s    framesyncstats;\n    framedatastats_s    framedatastats;\n    unsigned int        k;\n    unsigned int        m;\n    float               beta;\n    qdetector_cccf      detector;\n    float               tau_hat;\n    float               dphi_hat;\n    float               phi_hat;\n    float               gamma_hat;\n    nco_crcf            mixer;\n    nco_crcf            pll;\n    firpfb_crcf         mf;\n    unsigned int        npfb;\n    int                 mf_counter;\n    unsigned int        pfb_index;\n    float complex *     preamble_pn;\n    float complex *     preamble_rx;\n    synth_crcf          header_synth;\n    synth_crcf          payload_synth;\n    int                 header_soft;\n    flexframegenprops_s header_props;\n    float complex *     header_spread;\n    unsigned int        header_spread_len;\n    qpacketmodem        header_decoder;\n    unsigned int        header_user_len;\n    unsigned int        header_dec_len;\n    unsigned char *     header_dec;\n    int                 header_valid;\n    int                 payload_soft;\n    float complex *     payload_spread;\n    unsigned int        payload_spread_len;\n    qpacketmodem        payload_decoder;\n    unsigned int        payload_dec_len;\n    unsigned char *     payload_dec;\n    int                 payload_valid;\n    unsigned int        preamble_counter;\n    unsigned int        symbol_counter;\n    enum state          state;\n};\nint dsssframesync_step(dsssframesync _q, float complex _x, float complex * _y)\n{\n    float complex v;\n    nco_crcf_mix_down(_q->mixer, _x, &v);\n    nco_crcf_step(_q->mixer);\n    firpfb_crcf_push(_q->mf, v);\n    firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);\n    _q->mf_counter++;\n    int sample_available = (_q->mf_counter >= 1) ? 1 : 0;\n    if (sample_available) {\n        *_y = v;\n        _q->mf_counter -= _q->k;\n    }\n    return sample_available;\n}\nint dsssframesync_execute_seekpn(dsssframesync _q, float complex _x)\n{\n    float complex * v = qdetector_cccf_execute(_q->detector, _x);\n    if (v == NULL)\n        return LIQUID_OK;\n    _q->tau_hat   = qdetector_cccf_get_tau(_q->detector);\n    _q->gamma_hat = qdetector_cccf_get_gamma(_q->detector);\n    _q->dphi_hat  = qdetector_cccf_get_dphi(_q->detector);\n    _q->phi_hat   = qdetector_cccf_get_phi(_q->detector);\n    if (_q->tau_hat > 0) {\n        _q->pfb_index  = (unsigned int)(_q->tau_hat * _q->npfb) % _q->npfb;\n        _q->mf_counter = 0;\n    } else {\n        _q->pfb_index  = (unsigned int)((1.0f + _q->tau_hat) * _q->npfb) % _q->npfb;\n        _q->mf_counter = 1;\n    }\n    firpfb_crcf_set_scale(_q->mf, 0.5f / _q->gamma_hat);\n    nco_crcf_set_frequency(_q->mixer, _q->dphi_hat);\n    nco_crcf_set_phase(_q->mixer, _q->phi_hat);\n    _q->state = DSSSFRAMESYNC_STATE_RXPREAMBLE;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q->detector);\n    return dsssframesync_execute(_q, v, buf_len);\n}\nint dsssframesync_decode_payload(dsssframesync _q)\n{\n    float complex prev_corr, corr, next_corr;\n    nco_crcf_mix_block_down(\n        _q->pll, _q->payload_spread, _q->payload_spread, synth_crcf_get_length(_q->payload_synth));\n    synth_crcf_despread_triple(\n        _q->payload_synth, _q->payload_spread, &prev_corr, &corr, &next_corr);\n    int   complete    = qpacketmodem_decode_soft_sym(_q->payload_decoder, corr);\n    float phase_error = qpacketmodem_get_demodulator_phase_error(_q->payload_decoder);\n    nco_crcf_pll_step(_q->pll, synth_crcf_get_length(_q->payload_synth) * phase_error);\n    if (!complete) {\n        return 0;\n    }\n    _q->payload_valid = qpacketmodem_decode_soft_payload(_q->payload_decoder, _q->payload_dec);\n    return 1;\n}\nint dsssframesync_configure_payload(dsssframesync _q)\n{\n    _q->header_valid = qpacketmodem_decode_soft_payload(_q->header_decoder, _q->header_dec);\n    if (!_q->header_valid)\n        return LIQUID_OK;\n    unsigned int n = _q->header_user_len;\n    unsigned int protocol = _q->header_dec[n + 0];\n    if (protocol != DSSSFRAME_PROTOCOL) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), invalid framing protocol %u (expected %u)\\n"",protocol,DSSSFRAME_PROTOCOL);\n    }\n    unsigned int payload_dec_len = (_q->header_dec[n + 1] << 8) | (_q->header_dec[n + 2]);\n    _q->payload_dec_len          = payload_dec_len;\n    unsigned int check = (_q->header_dec[n + 3] >> 5) & 0x07;\n    unsigned int fec0  = (_q->header_dec[n + 3]) & 0x1f;\n    unsigned int fec1  = (_q->header_dec[n + 4]) & 0x1f;\n    if (check == LIQUID_CRC_UNKNOWN || check >= LIQUID_CRC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded CRC exceeds available\\n"");\n    } else if (fec0 == LIQUID_FEC_UNKNOWN || fec0 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded FEC (inner) exceeds available\\n"");\n        return LIQUID_OK;\n    } else if (fec1 == LIQUID_FEC_UNKNOWN || fec1 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded FEC (outer) exceeds available\\n"");\n    }\n    _q->payload_dec\n        = (unsigned char *)realloc(_q->payload_dec, (_q->payload_dec_len) * sizeof(unsigned char));\n    qpacketmodem_configure(\n        _q->payload_decoder, _q->payload_dec_len, check, fec0, fec1, LIQUID_MODEM_BPSK);\n    synth_crcf_set_frequency(_q->payload_synth, synth_crcf_get_frequency(_q->header_synth));\n    return LIQUID_OK;\n}\nint dsssframesync_execute_rxpreamble(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.0f;\n    int           sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    unsigned int delay = _q->k * _q->m; \n    if (_q->preamble_counter >= delay) {\n        unsigned int index     = _q->preamble_counter - delay;\n        _q->preamble_rx[index] = mf_out;\n    }\n    _q->preamble_counter++;\n    if (_q->preamble_counter == 64 + delay)\n        _q->state = DSSSFRAMESYNC_STATE_RXHEADER;\n    return LIQUID_OK;\n}\nint dsssframesync_decode_header(dsssframesync _q)\n{\n    float complex prev_corr, corr, next_corr;\n    nco_crcf_mix_block_down(\n        _q->pll, _q->header_spread, _q->header_spread, synth_crcf_get_length(_q->header_synth));\n    synth_crcf_despread_triple(_q->header_synth, _q->header_spread, &prev_corr, &corr, &next_corr);\n    int   complete    = qpacketmodem_decode_soft_sym(_q->header_decoder, corr);\n    float phase_error = qpacketmodem_get_demodulator_phase_error(_q->header_decoder);\n    nco_crcf_pll_step(_q->pll, synth_crcf_get_length(_q->header_synth) * phase_error);\n    if (!complete) {\n        return 0;\n    }\n    dsssframesync_configure_payload(_q);\n    return 1;\n}\nint dsssframesync_execute_rxheader(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int           sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->header_spread[_q->symbol_counter % synth_crcf_get_length(_q->header_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->header_synth))\n        return LIQUID_OK;\n    int header_complete = dsssframesync_decode_header(_q);\n    if (!header_complete)\n        return LIQUID_OK;\n    if (_q->header_valid) {\n        _q->symbol_counter = 0;\n        _q->state = DSSSFRAMESYNC_STATE_RXPAYLOAD;\n        return LIQUID_OK;\n    }\n    ++_q->framedatastats.num_frames_detected;\n    if (_q->callback != NULL) {\n        _q->framesyncstats.evm           = 0.f;\n        _q->framesyncstats.rssi          = 20 * log10f(_q->gamma_hat);\n        _q->framesyncstats.cfo           = nco_crcf_get_frequency(_q->mixer);\n        _q->framesyncstats.framesyms     = NULL;\n        _q->framesyncstats.num_framesyms = 0;\n        _q->framesyncstats.check         = LIQUID_CRC_UNKNOWN;\n        _q->framesyncstats.fec0          = LIQUID_FEC_UNKNOWN;\n        _q->framesyncstats.fec1          = LIQUID_FEC_UNKNOWN;\n        _q->callback(\n            _q->header_dec, _q->header_valid, NULL, 0, 0, _q->framesyncstats, _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\nint dsssframesync_execute_rxpayload(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int                  sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->payload_spread[_q->symbol_counter % synth_crcf_get_length(_q->payload_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->payload_synth) != 0)\n        return LIQUID_OK;\n    int payload_complete = dsssframesync_decode_payload(_q);\n    if (!payload_complete)\n        return LIQUID_OK;\n    _q->framesyncstats.check = qpacketmodem_get_crc(_q->payload_decoder);\n    _q->framesyncstats.fec0  = qpacketmodem_get_fec0(_q->payload_decoder);\n    _q->framesyncstats.fec1  = qpacketmodem_get_fec1(_q->payload_decoder);\n    if (_q->callback != NULL) {\n        _q->callback(_q->header_dec,\n                     _q->header_valid,\n                     _q->payload_dec,\n                     _q->payload_dec_len,\n                     _q->payload_valid,\n                     _q->framesyncstats,\n                     _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\nint dsssframesync_execute(dsssframesync _q, float complex * _x, unsigned int _n)\n{\n    unsigned int i;\n    for (i = 0; i < _n; i++) {\n        switch (_q->state) {\n        case DSSSFRAMESYNC_STATE_DETECTFRAME:\n            dsssframesync_execute_seekpn(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPREAMBLE:\n            dsssframesync_execute_rxpreamble(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXHEADER:\n            dsssframesync_execute_rxheader(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPAYLOAD:\n            dsssframesync_execute_rxpayload(_q, _x[i]);\n            break;\n        default:\n            return liquid_error(LIQUID_EINT,""dsssframesync_execute(), invalid internal state"");\n        }\n    }\n    return LIQUID_OK;\n}\nint dsssframesync_reset(dsssframesync _q)\n{\n    qdetector_cccf_reset(_q->detector);\n    nco_crcf_reset(_q->mixer);\n    nco_crcf_reset(_q->pll);\n    firpfb_crcf_reset(_q->mf);\n    _q->state            = DSSSFRAMESYNC_STATE_DETECTFRAME;\n    _q->preamble_counter = 0;\n    _q->symbol_counter   = 0;\n    _q->framesyncstats.evm = 0.f;\n    return LIQUID_OK;\n}\nint dsssframesync_execute_rxpayload(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int                  sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->payload_spread[_q->symbol_counter % synth_crcf_get_length(_q->payload_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->payload_synth) != 0)\n        return LIQUID_OK;\n    int payload_complete = dsssframesync_decode_payload(_q);\n    if (!payload_complete)\n        return LIQUID_OK;\n    _q->framesyncstats.check = qpacketmodem_get_crc(_q->payload_decoder);\n    _q->framesyncstats.fec0  = qpacketmodem_get_fec0(_q->payload_decoder);\n    _q->framesyncstats.fec1  = qpacketmodem_get_fec1(_q->payload_decoder);\n    if (_q->callback != NULL) {\n        _q->callback(_q->header_dec,\n                     _q->header_valid,\n                     _q->payload_dec,\n                     _q->payload_dec_len,\n                     _q->payload_valid,\n                     _q->framesyncstats,\n                     _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\n//...')
"
"('Prompt: You need to implement a function in C that performs a one-dimensional search using tangent hyperbolic functions. The code should include a function `qs1dsearch_umin` that calculates the minimum value of a function, a function `qs1dsearch_umax` that calculates the maximum value using `qs1dsearch_umin`, and a test function `test_qs1dsearch` that iterates over the search process. Additionally, provide an automated test function `autotest_qs1dsearch_max_10` that tests the `qs1dsearch_umax` function with specific parameters.","//...\nfloat qs1dsearch_umin(float _v, void * _context)\n{\n    float v_opt = *(float*)(_context);\n    float v = _v - v_opt;\n    return tanhf(v)*tanhf(v);\n}\nvoid test_qs1dsearch(liquid_utility_1d _utility,\n                     float             _v_opt,\n                     float             _v_lo,\n                     float             _v_hi,\n                     int               _bounds,\n                     int               _direction)\n{\n    qs1dsearch q = qs1dsearch_create(_utility, &_v_opt, _direction);\n    if (_bounds) qs1dsearch_init_bounds(q, _v_lo, _v_hi);\n    else         qs1dsearch_init       (q, _v_lo);\n    unsigned int i;\n    for (i=0; i<32; i++) {\n        qs1dsearch_step(q);\n        if (liquid_autotest_verbose)\n            qs1dsearch_print(q);\n    }\n    CONTEND_DELTA( qs1dsearch_get_opt_v(q), _v_opt,                    1e-3f );\n    CONTEND_DELTA( qs1dsearch_get_opt_u(q), _utility(_v_opt, &_v_opt), 1e-3f );\n    if (liquid_autotest_verbose) {\n        printf(""%3u : u(%12.8f) = %12.4e, v_opt=%12.4e (error=%12.4e)\\n"",\n            i, qs1dsearch_get_opt_v(q), qs1dsearch_get_opt_u(q),\n            _v_opt, _v_opt - qs1dsearch_get_opt_v(q));\n    }\n    qs1dsearch_destroy(q);\n}\nfloat qs1dsearch_umax(float _v, void * _context)\n    { return -qs1dsearch_umin(_v, _context); }\nvoid autotest_qs1dsearch_max_10() { test_qs1dsearch(qs1dsearch_umax, 0, -30, 15, 1, LIQUID_OPTIM_MAXIMIZE); }\n//...')
"
"('Prompt: You are developing a data scrambling function in C that will be used in a digital communication system. The function takes in an array of unsigned characters `_x` and the length `_n` of the array. Describe how you would implement a data scrambling algorithm that XORs specific masks (e.g., `LIQUID_SCRAMBLE_MASK0`, `LIQUID_SCRAMBLE_MASK1`, `LIQUID_SCRAMBLE_MASK2`, `LIQUID_SCRAMBLE_MASK3`) with the values in the array in 4-byte blocks, handling the case where `_n` is not divisible by 4. Provide the C code for the `scramble_data` function.","//...\nvoid scramble_data(unsigned char * _x,\n                   unsigned int _n)\n{\n    unsigned int t = (_n>>2)<<2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        _x[i  ] ^= LIQUID_SCRAMBLE_MASK0;\n        _x[i+1] ^= LIQUID_SCRAMBLE_MASK1;\n        _x[i+2] ^= LIQUID_SCRAMBLE_MASK2;\n        _x[i+3] ^= LIQUID_SCRAMBLE_MASK3;\n    }\n    if ( (i+0) < _n ) _x[i+0] ^= LIQUID_SCRAMBLE_MASK0;\n    if ( (i+1) < _n ) _x[i+1] ^= LIQUID_SCRAMBLE_MASK1;\n    if ( (i+2) < _n ) _x[i+2] ^= LIQUID_SCRAMBLE_MASK2;\n    if ( (i+3) < _n ) _x[i+3] ^= LIQUID_SCRAMBLE_MASK3;\n}\n//...')
"
"('Please provide a prompt in a scenario where you need to test a digital filter implementation for a communication system. The filter specifications include the filter type, delay factor, filter length, beta value, and sampling interval. You also need to calculate metrics for the filter performance, such as cross-correlation, root mean square (rms) intersymbol interference (ISI), and energy spectral density (Es). The prompt should call a specific test function with parameters for a custom filter.","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\nvoid autotest_firfilt_rnyquist_4(){ testbench_firfilt_rnyquist(LIQUID_FIRFILT_ARKAISER, 4,12,0.20f,0.0f); }\n//...')
"
"('Prompt: Create a benchmark function that measures the performance of the dc blocker filter in the iirfilt_crcf library using the function `benchmark_iirfilt_crcf_dcblock`. The function should take in two `struct rusage` pointers for start and finish times, as well as an `unsigned long int` pointer for the number of iterations. Within the function, create a DC blocker filter with a pole at 0.1f, generate four random complex numbers, then iterate over them using the DC blocker filter. Measure the time taken for the iterations by calling `getrusage` before and after the loop. Remember to update the number of iterations by multiplying it by 4 at the end and destroy the DC blocker filter object.","//...\nvoid benchmark_iirfilt_crcf_8        I\nvoid benchmark_irfilt_crcf_dcblock(struct rusage *     _start,\n                                   struct rusage *     _finish,\n                                   unsigned long int * _num_iterations)\n{\n    unsigned long int i;\n    iirfilt_crcf q = iirfilt_crcf_create_dc_blocker(0.1f);\n    float complex x[4];\n    for (i=0; i<4; i++)\n        x[i] = randnf() + _Complex_I*randnf();\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        iirfilt_crcf_execute(q, x[0], &x[0]);\n        iirfilt_crcf_execute(q, x[1], &x[1]);\n        iirfilt_crcf_execute(q, x[2], &x[2]);\n        iirfilt_crcf_execute(q, x[3], &x[3]);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    iirfilt_crcf_destroy(q);\n}\n//...')
"
"('Prompt: You are working on a signal processing module that involves designing and testing half-band filters using the `liquid_firdespm_halfband_ft` function. Write a testbench function that takes in the filter order `_m` and the transition bandwidth `_ft`, generates the filter coefficients `h`, estimates the required stop-band attenuation `As`, and validates the filter response using PSD regions. Provide detailed test scenarios for a specific case, for example, `_m=80` and `_ft=0.010`. Ensure that the results are saved in a log file for further analysis.","//...\nvoid testbench_firdespm_halfband_ft(unsigned int _m,\n                                    float        _ft)\n{\n    unsigned int h_len = 4*_m + 1;\n    float h[h_len];\n    liquid_firdespm_halfband_ft(_m, _ft, h);\n    float As = estimate_req_filter_As(_ft, h_len);\n    float f0 = 0.25f - 0.5f*_ft;\n    float f1 = 0.25f + 0.5f*_ft;\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5, .fmax= -f1, .pmin= 0,   .pmax=-As,  .test_lo=0, .test_hi=1},\n      {.fmin=-f0,  .fmax=  f0, .pmin=-0.1, .pmax= 0.1, .test_lo=1, .test_hi=1},\n      {.fmin= f1,  .fmax= 0.5, .pmin= 0,   .pmax=-As,  .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/firdespm_halfband_m%u_ft%.3u.m"", _m, (int)(_ft*1000));\n    liquid_autotest_validate_psd_signalf(h, h_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\nvoid autotest_firdespm_halfband_m80_ft010() { testbench_firdespm_halfband_ft(80, 0.010f); }\n//...')
"
"('Prompt: Can you provide code for benchmarking the GMSK frame synchronization process with noise added?. Technical scenario: We want to measure the performance of GMSK frame synchronization process when noise is added to the received signal. The code should include functions to create and destroy GMSK frame synchronization objects, generate random noise, and execute the synchronization process with added noise. The code should also calculate the number of iterations for benchmarking based on input parameters.","void benchmark_gmskframesync(struct rusage *     _start,\n                             struct rusage *     _finish,\n                             unsigned long int * _num_iterations)\n{\n    *_num_iterations /= 128;\n    unsigned long int i;\n    unsigned int k = 2;                 \n    unsigned int m = 3;                 \n    float BT = 0.5f;                    \n    unsigned int payload_len = 8;       \n    float SNRdB = 30.0f;                \n    float nstd  = powf(10.0f, -SNRdB/20.0f);\n    gmskframegen fg = gmskframegen_create_set(k, m, BT);\n    gmskframegen_assemble(fg, NULL, NULL, payload_len,\n            LIQUID_CRC_NONE, LIQUID_FEC_NONE, LIQUID_FEC_NONE);\n    unsigned int frame_len = gmskframegen_getframelen(fg);\n    float complex frame[frame_len];\n    gmskframegen_write(fg, frame, frame_len);\n    for (i=0; i<frame_len; i++)\n        frame[i] += nstd*(randnf() + _Complex_I*randnf());\n    gmskframesync fs = gmskframesync_create_set(k, m, BT, NULL, NULL);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        gmskframesync_execute(fs, frame, frame_len);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n}\nvoid benchmark_gmskframesync_noise(struct rusage *     _start,\n                                   struct rusage *     _finish,\n                                   unsigned long int * _num_iterations)\n{\n    *_num_iterations /= 2000;\n    unsigned long int i;\n    gmskframesync fs = gmskframesync_create_set(2, 3, 0.5f, NULL, NULL);\n    unsigned int num_samples = 1024;\n    float complex y[num_samples];\n    for (i=0; i<num_samples; i++)\n        y[i] = 0.01f*(randnf() + randnf()*_Complex_I)*M_SQRT1_2;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        gmskframesync_execute(fs, y, num_samples);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= num_samples;\n    gmskframesync_destroy(fs);\n}')
"
"('Prompt: You are working on optimizing the performance of a function that calculates the dot product of two arrays of complex floating-point numbers. The function `dotprod_cccf_bench` takes in struct variables `_start` and `_finish` representing the start and end times of execution, an unsigned long int pointer `_num_iterations` representing the number of iterations to run, and an unsigned int `_n` representing the size of the arrays. The code inside the function initializes and populates two arrays `x` and `h` with random complex floating-point numbers, creates a dot product object `dp` using the `dotprod_cccf_create` function, and then executes the dot product calculations on the array `x` multiple times. After completion, the dot product object is destroyed and the total number of iterations is updated. The goal is to optimize the performance of this function.","//...\nvoid benchmark_dotprod_cccf_4      D\nvoid dotprod_cccf_bench(struct rusage *_start,\n                        struct rusage *_finish,\n                        unsigned long int *_num_iterations,\n                        unsigned int _n)\n{\n    *_num_iterations = *_num_iterations * 20 / _n;\n    if (*_num_iterations < 1) *_num_iterations = 1;\n    float complex x[_n];\n    float complex h[_n];\n    float complex y[8];\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        x[i] = randnf() + _Complex_I*randnf();\n        h[i] = randnf() + _Complex_I*randnf();\n    }\n    dotprod_cccf dp = dotprod_cccf_create(h,_n);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        dotprod_cccf_execute(dp, x, &y[0]);\n        dotprod_cccf_execute(dp, x, &y[1]);\n        dotprod_cccf_execute(dp, x, &y[2]);\n        dotprod_cccf_execute(dp, x, &y[3]);\n        dotprod_cccf_execute(dp, x, &y[4]);\n        dotprod_cccf_execute(dp, x, &y[5]);\n        dotprod_cccf_execute(dp, x, &y[6]);\n        dotprod_cccf_execute(dp, x, &y[7]);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 8;\n    dotprod_cccf_destroy(dp);\n}\n//...')
"
"('Prompt: Please write a function that performs automated testing (autotest) for a given FIR filter implemented on real-valued data. In this scenario, the FIR filter has a length of 7 and takes in a 16-element input signal. The function should test the FIR filter using predefined input data arrays firfilt_rrrf_data_h7x16_h, firfilt_rrrf_data_h7x16_x, and expected output array firfilt_rrrf_data_h7x16_y.","//...\nvoid autotest_firfilt_rrrf_data_h7x16()\n{\n    firfilt_rrrf_test(firfilt_rrrf_data_h7x16_h, 7,\n                      firfilt_rrrf_data_h7x16_x, 16,\n                      firfilt_rrrf_data_h7x16_y, 16);\n}\n//...')
"
"('Prompt: Please provide a function that performs an automated test for a lowpass filter design using the Parks-McClellan algorithm. The function should calculate the filter coefficients for a specified number of points, cutoff frequency, stopband attenuation, and beta value. Additionally, the function should validate the filter response against predefined frequency regions with corresponding power levels. The test results should be output to a log file if in verbose mode.","//...\nvoid autotest_firdespm_lowpass()\n{\n    unsigned int n  = 51;\n    float        fc = 0.2f;\n    float        As = 60.0f;\n    float        mu = 0.0f;\n    float        h[n];\n    firdespm_lowpass(n,fc,As,mu,h);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5,   .fmax=-0.25,  .pmin= 0,    .pmax=-60,   .test_lo=0, .test_hi=1},\n      {.fmin=-0.15,  .fmax=+0.15,  .pmin=-0.02, .pmax=+0.02, .test_lo=1, .test_hi=1},\n      {.fmin= 0.25,  .fmax=+0.5,   .pmin= 0,    .pmax=-60,   .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_psd_signalf(h, n, regions, 3,\n        liquid_autotest_verbose ? ""autotest/logs/firdespm_lowpass.m"" : NULL);\n}\n//...')
"
"('Prompt: You need to create a benchmark function for a Q detector with a specific size in a digital communication system using C language. The function should measure performance by executing a series of operations such as setting parameters, generating random complex numbers, and detecting signals. The benchmark function should take into account the number of iterations and the size of the Q detector.. . Response: Here is the code for the benchmark function for a Q detector with different sizes in a digital communication system:. . ```c. void qdetector_cccf_bench(struct rusage *     _start,.                           struct rusage *     _finish,.                           unsigned long int * _num_iterations,.                           unsigned int        _n). {.     *_num_iterations *= 4;.     *_num_iterations /= _n;.     float complex h[_n];.     unsigned long int i;.     for (i=0; i<_n; i++) {.         h[i] = (rand() % 2 ? 1.0f : -1","void qdetector_cccf_bench(struct rusage *     _start,\n                          struct rusage *     _finish,\n                          unsigned long int * _num_iterations,\n                          unsigned int        _n)\n{\n    *_num_iterations *= 4;\n    *_num_iterations /= _n;\n    float complex h[_n];\n    unsigned long int i;\n    for (i=0; i<_n; i++) {\n        h[i] = (rand() % 2 ? 1.0f : -1.0f) +\n               (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;\n    }\n    int          ftype        = LIQUID_FIRFILT_ARKAISER;\n    unsigned int k            =    2;   \n    unsigned int m            =    7;   \n    float        beta         = 0.3f;   \n    float        threshold    = 0.5f;   \n    float        range        = 0.05f;  \n    qdetector_cccf q = qdetector_cccf_create_linear(h, _n, ftype, k, m, beta);\n    qdetector_cccf_set_threshold(q,threshold);\n    qdetector_cccf_set_range    (q, range);\n    float complex x[7];\n    for (i=0; i<7; i++) {\n        x[i] = (rand() % 2 ? 1.0f : -1.0f) +\n               (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;\n    }\n    getrusage(RUSAGE_SELF, _start);\n    int detected = 0;\n    for (i=0; i<(*_num_iterations); i++) {\n        detected ^= qdetector_cccf_execute(q, x[0]) != NULL;\n        detected ^= qdetector_cccf_execute(q, x[1]) != NULL;\n        detected ^= qdetector_cccf_execute(q, x[2]) != NULL;\n        detected ^= qdetector_cccf_execute(q, x[3]) != NULL;\n        detected ^= qdetector_cccf_execute(q, x[4]) != NULL;\n        detected ^= qdetector_cccf_execute(q, x[5]) != NULL;\n        detected ^= qdetector_cccf_execute(q, x[6]) != NULL;\n        x[0] += detected > 2 ? -1e-3f : 1e-3f;\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 7;\n    qdetector_cccf_destroy(q);\n}\n#define QDETECTOR_CCCF_BENCHMARK_API(N)      \\\n(   struct rusage *     _start,             \\\n    struct rusage *     _finish,            \\\n    unsigned long int * _num_iterations)    \\\n{ qdetector_cccf_bench(_start, _finish, _num_iterations, N); }\nvoid benchmark_qdetector_cccf_16   QDETECTOR_CCCF_BENCHMARK_API(16);\nvoid benchmark_qdetector_cccf_32   QDETECTOR_CCCF_BENCHMARK_API(32);\nvoid benchmark_qdetector_cccf_64   QDETECTOR_CCCF_BENCHMARK_API(64);\nvoid benchmark_qdetector_cccf_128  QDETECTOR_CCCF_BENCHMARK_API(128);\nvoid benchmark_qdetector_cccf_256  QDETECTOR_CCCF_BENCHMARK_API(256);\nvoid benchmark_qdetector_cccf_512  QDETECTOR_CCCF_BENCHMARK_API(512);\nvoid benchmark_qdetector_cccf_1024 QDETECTOR_CCCF_BENCHMARK_API(1024);\nvoid benchmark_qdetector_cccf_2048 QDETECTOR_CCCF_BENCHMARK_API(2048);\nvoid benchmark_qdetector_cccf_4096 QDETECTOR_CCCF_BENCHMARK_API(4096);\nvoid benchmark_qdetector_cccf_8192 QDETECTOR_CCCF_BENCHMARK_API(8192);')
"
"('Prompt: You are building a function to benchmark a frequency shift keying demodulator in C. The function fskdem_bench takes in starting and finishing struct rusage pointers, a number of iterations, values for m, k, and bandwidth, and performs demodulation calculations. Could you provide me with the code for this function?","//...\nvoid benchmark_fskdem_norm_M256    F\nvoid fskdem_bench(struct rusage *     _start,\n                  struct rusage *     _finish,\n                  unsigned long int * _num_iterations,\n                  unsigned int        _m,\n                  unsigned int        _k,\n                  float               _bandwidth)\n{\n    *_num_iterations /= _k;\n    if (*_num_iterations < 1) *_num_iterations = 1;\n    fskdem dem = fskdem_create(_m,_k,_bandwidth);\n    unsigned long int i;\n    float complex buf[_k+10];\n    for (i=0; i<_k+10; i++)\n        buf[i] = 0.07 * i * cexpf(_Complex_I*2*M_PI*0.1*i);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        fskdem_demodulate(dem, &buf[0]);\n        fskdem_demodulate(dem, &buf[1]);\n        fskdem_demodulate(dem, &buf[2]);\n        fskdem_demodulate(dem, &buf[3]);\n        fskdem_demodulate(dem, &buf[4]);\n        fskdem_demodulate(dem, &buf[5]);\n        fskdem_demodulate(dem, &buf[6]);\n        fskdem_demodulate(dem, &buf[7]);\n        fskdem_demodulate(dem, &buf[8]);\n        fskdem_demodulate(dem, &buf[9]);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 10;\n    fskdem_destroy(dem);\n}\n//...')
"
"('Prompt: ""Develop a function to reset an OFDM framesync object, including resetting NCO, M-sequence, and various attributes. Also, create a function to initialize an OFDM framesync object with specified parameters such as number of subcarriers, cyclic prefix length, taper length, subcarrier allocation pattern, callback function, and user data. Make sure to perform necessary error checking and memory allocation within the function.""","//...\n    unsigned int M;         \n    unsigned int M2;        \n    unsigned int cp_len;    \n    unsigned char * p;      \n    unsigned int M_null;    \n    unsigned int M_pilot;   \n    unsigned int M_data;    \n    unsigned int M_S0;      \n    unsigned int M_S1;      \n    float g_data;           \n    float g_S0;             \n    float g_S1;             \n    FFT_PLAN fft;           \n    float complex * X;      \n    float complex * x;      \n    windowcf input_buffer;  \n    unsigned int M_S0;      \n    float complex * s0;     \n    unsigned int M_S1;      \n    float complex * s1;     \n    float g0;               \n    float complex * G0a;    \n    float complex * G0b;    \n    float complex * G;      \n    float complex * B;      \n    float complex * R;      \n    nco_crcf nco_rx;        \n    msequence ms_pilot;     \n#define DEBUG_OFDMFRAMESYNC             0\n    int squelch_enabled;\n    unsigned int backoff;       \n    ofdmframesync_callback callback;\n    void * userdata;\n#define DEBUG_OFDMFRAMESYNC             0\n    int debug_objects_created;\n    windowcf debug_x;\n    windowf  debug_rssi;\n    windowcf debug_framesyms;\n        float complex G_hat = 0.0f;\n    float * px;             \n    float * py;             \n    windowf debug_pilot_0;  \n    windowf debug_pilot_1;  \n    for (i=0; i<_q->M; i++)\n        _q->x[i] = (i < _ntaps) ? 1.0f : 0.0f;\n        float complex w;\n        for (j=0; j<_q->M; j++) {\nint ofdmframesync_reset(ofdmframesync _q)\n{\n#if 0\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        _q->G[i] = 1.0f;\n#endif\n    nco_crcf_reset(_q->nco_rx);\n    msequence_reset(_q->ms_pilot);\n    _q->timer = 0;\n    _q->num_symbols = 0;\n    _q->s_hat_0 = 0.0f;\n    _q->s_hat_1 = 0.0f;\n    _q->phi_prime = 0.0f;\n    _q->p1_prime = 0.0f;\n    _q->plcp_detect_thresh = (_q->M > 44) ? 0.35f : 0.35f + 0.01f*(44 - _q->M);\n    _q->plcp_sync_thresh   = (_q->M > 44) ? 0.30f : 0.30f + 0.01f*(44 - _q->M);\n    _q->state = OFDMFRAMESYNC_STATE_SEEKPLCP;\n    return LIQUID_OK;\n}\nofdmframesync ofdmframesync_create(unsigned int           _M,\n                                   unsigned int           _cp_len,\n                                   unsigned int           _taper_len,\n                                   unsigned char *        _p,\n                                   ofdmframesync_callback _callback,\n                                   void *                 _userdata)\n{\n    ofdmframesync q = (ofdmframesync) malloc(sizeof(struct ofdmframesync_s));\n    if (_M < 8)\n        return liquid_error_config(""ofdmframesync_create(), number of subcarriers must be at least 8"");\n    if (_M % 2)\n        return liquid_error_config(""ofdmframesync_create(), number of subcarriers must be even"");\n    if (_cp_len > _M)\n        return liquid_error_config(""ofdmframesync_create(), cyclic prefix length cannot exceed number of subcarriers"");\n    if (_taper_len > _cp_len)\n        return liquid_error_config(""ofdmframesync_create(), taper length cannot exceed cyclic prefix"");\n    q->M = _M;\n    q->cp_len = _cp_len;\n    q->M2 = _M/2;\n    q->p = (unsigned char*) malloc((q->M)*sizeof(unsigned char));\n    if (_p == NULL) {\n        ofdmframe_init_default_sctype(q->M, q->p);\n    } else {\n        memmove(q->p, _p, q->M*sizeof(unsigned char));\n    }\n    if (ofdmframe_validate_sctype(q->p, q->M, &q->M_null, &q->M_pilot, &q->M_data))\n        return liquid_error_config(""ofdmframesync_create(), invalid subcarrier allocation"");\n    q->X = (float complex*) FFT_MALLOC((q->M)*sizeof(float complex));\n    q->x = (float complex*) FFT_MALLOC((q->M)*sizeof(float complex));\n    q->fft = FFT_CREATE_PLAN(q->M, q->x, q->X, FFT_DIR_FORWARD, FFT_METHOD);\n    q->input_buffer = windowcf_create(q->M + q->cp_len);\n    q->S0 = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->s0 = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->S1 = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->s1 = (float complex*) malloc((q->M)*sizeof(float complex));\n    ofdmframe_init_S0(q->p, q->M, q->S0, q->s0, &q->M_S0);\n    ofdmframe_init_S1(q->p, q->M, q->S1, q->s1, &q->M_S1);\n    q->g_data = sqrtf(q->M) / sqrtf(q->M_pilot + q->M_data);\n    q->g_S0   = sqrtf(q->M) / sqrtf(q->M_S0);\n    q->g_S1   = sqrtf(q->M) / sqrtf(q->M_S1);\n    q->g0 = 1.0f;\n    q->G0a = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->G0b = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->G   = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->B   = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->R   = (float complex*) malloc((q->M)*sizeof(float complex));\n#if 1\n    memset(q->G0a, 0x00, q->M*sizeof(float complex));\n    memset(q->G0b, 0x00, q->M*sizeof(float complex));\n    memset(q->G ,  0x00, q->M*sizeof(float complex));\n    memset(q->B,   0x00, q->M*sizeof(float complex));\n#endif\n    q->backoff = q->cp_len < 2 ? q->cp_len : 2;\n    float phi = (float)(q->backoff)*2.0f*M_PI/(float)(q->M);\n    unsigned int i;\n    for (i=0; i<q->M; i++)\n        q->B[i] = liquid_cexpjf(i*phi);\n    q->callback = _callback;\n    q->userdata = _userdata;\n    q->nco_rx = nco_crcf_create(LIQUID_NCO);\n    q->ms_pilot = msequence_create_default(8);\n#if OFDMFRAMESYNC_ENABLE_SQUELCH\n    q->squelch_threshold = -25.0f;\n    q->squelch_enabled = 0;\n#endif\n    ofdmframesync_reset(q);\n#if DEBUG_OFDMFRAMESYNC\n    q->debug_enabled = 0;\n    q->debug_objects_created = 0;\n    q->debug_x =        NULL;\n    q->debug_rssi =     NULL;\n    q->debug_framesyms =NULL;\n    q->G_hat = NULL;\n    q->px    = NULL;\n    q->py    = NULL;\n    q->debug_pilot_0 = NULL;\n    q->debug_pilot_1 = NULL;\n#endif\n    return q;\n}\n//...')
"
('Prompt: Please provide a code snippet that demonstrates testing the modulation and demodulation functionality of a modem using the ASK64 modulation scheme. The test should ensure that the demodulated signal matches the original signal within a certain threshold and that the phase error and EVM are minimal. The test should also calculate the overall error rate and ensure it is within an acceptable range. The code should include the creation and destruction of modem objects for modulation and demodulation.,"//...\nvoid modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_ask64()     { modemcf_test_mod_demod(LIQUID_MODEM_ASK64);     }\n//...')
"
"('Prompt: You are conducting tests on a sequence generation function that you have implemented. Write a function that calculates auto-correlation between two binary sequences generated using a specific set of parameters. Your function should take an unsigned integer value as a parameter, create two binary sequences of the same length using sequences generated by a specified m-sequence, and calculate the auto-correlation between them. If the calculated auto-correlation matches a certain value or condition, the test should return a pass result. Also, write an additional function that runs this test using an m value of 11.","//...\nvoid msequence_test_autocorrelation(unsigned int _m)\n{\n    msequence ms = msequence_create_default(_m);\n    unsigned int n = msequence_get_length(ms);\n    bsequence bs1 = bsequence_create(n);\n    bsequence_init_msequence(bs1, ms);\n    bsequence bs2 = bsequence_create(n);\n    bsequence_init_msequence(bs2, ms);\n    CONTEND_EQUALITY( bsequence_get_length(bs1), n )\n    CONTEND_EQUALITY( bsequence_get_length(bs2), n )\n    signed int rxy;\n    rxy = bsequence_correlate(bs1, bs2);\n    CONTEND_EQUALITY( rxy, n )\n    unsigned int i;\n    for (i=0; i<n-1; i++) {\n        bsequence_push(bs2, msequence_advance(ms));\n        rxy = 2*bsequence_correlate(bs1, bs2) - n;\n        CONTEND_EQUALITY( rxy, -1 );\n    }\n    bsequence_destroy(bs1);\n    bsequence_destroy(bs2);\n    msequence_destroy(ms);\n}\nvoid autotest_msequence_xcorr_m11() { msequence_test_autocorrelation(11); }\n//...')
"
"('Prompt: Please provide a function that conducts a test on a real-value finite impulse response filter using a 23x256 dataset. The function should take in the filter coefficients, input data, and output data arrays as parameters for testing.","//...\nvoid autotest_fftfilt_rrrf_data_h23x256()\n{\n    fftfilt_rrrf_test(fftfilt_rrrf_data_h23x256_h, 23,\n                      fftfilt_rrrf_data_h23x256_x, 256,\n                      fftfilt_rrrf_data_h23x256_y, 256);\n}\n//...')
"
"('Prompt: ""You need to create a frequency-shift keying (FSK) modulator in C that can modulate input symbols with a specified number of bits per symbol, samples per symbol, and bandwidth. The modulator should also be able to copy itself, print its parameters, reset its internal state, and modulate input symbols. Can you provide me the C code for this FSK modulator with the necessary functions fskmod_create, fskmod_copy, fskmod_destroy, fskmod_print, fskmod_reset, and fskmod_modulate?""","struct fskmod_s {\n    unsigned int m;             \n    unsigned int k;             \n    float        bandwidth;     \n    unsigned int M;             \n    float        M2;            \n    nco_crcf     oscillator;    \n};\nfskmod fskmod_create(unsigned int _m,\n                     unsigned int _k,\n                     float        _bandwidth)\n{\n    if (_m == 0)\n        return liquid_error_config(""fskmod_create(), bits/symbol must be greater than 0"");\n    if (_k < 2 || _k > 2048)\n        return liquid_error_config(""fskmod_create(), samples/symbol must be in [2^_m, 2048]"");\n    if (_bandwidth <= 0.0f || _bandwidth >= 0.5f)\n        return liquid_error_config(""fskmod_create(), bandwidth must be in (0,0.5)"");\n    fskmod q = (fskmod) malloc(sizeof(struct fskmod_s));\n    q->m         = _m;              \n    q->k         = _k;              \n    q->bandwidth = _bandwidth;      \n    q->M  = 1 << q->m;              \n    q->M2 = 0.5f*(float)(q->M-1);   \n    q->oscillator = nco_crcf_create(LIQUID_VCO);\n    fskmod_reset(q);\n    return q;\n}\nfskmod fskmod_copy(fskmod q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""fskmod_copy(), object cannot be NULL"");\n    fskmod q_copy = (fskmod) malloc(sizeof(struct fskmod_s));\n    memmove(q_copy, q_orig, sizeof(struct fskmod_s));\n    q_copy->oscillator = nco_crcf_copy(q_orig->oscillator);\n    return q_copy;\n}\nint fskmod_destroy(fskmod _q)\n{\n    nco_crcf_destroy(_q->oscillator);\n    free(_q);\n    return LIQUID_OK;\n}\nint fskmod_print(fskmod _q)\n{\n    printf(""fskmod : frequency-shift keying modulator\\n"");\n    printf(""    bits/symbol     :   %u\\n"", _q->m);\n    printf(""    samples/symbol  :   %u\\n"", _q->k);\n    printf(""    bandwidth       :   %8.5f\\n"", _q->bandwidth);\n    return LIQUID_OK;\n}\nint fskmod_reset(fskmod _q)\n{\n    nco_crcf_reset(_q->oscillator);\n    return LIQUID_OK;\n}\nint fskmod_modulate(fskmod          _q,\n                    unsigned int    _s,\n                    float complex * _y)\n{\n    if (_s >= _q->M)\n        return liquid_error(LIQUID_EIRANGE,""fskmod_modulate(), input symbol (%u) exceeds maximum (%u)"",_s, _q->M);\n    float dphi = ((float)_s - _q->M2) * 2 * M_PI * _q->bandwidth / _q->M2;\n    nco_crcf_set_frequency(_q->oscillator, dphi);\n    unsigned int i;\n    for (i=0; i<_q->k; i++) {\n        nco_crcf_cexpf(_q->oscillator, &_y[i]);\n        nco_crcf_step(_q->oscillator);\n    }\n    return LIQUID_OK;\n}')
"
('Please provide a prompt that demonstrates the use case of comparing the performance of a dot product computation using a structure-based approach versus an ordinal approach for complex data. The prompt should include the following details:. - The need to compare the performance of structure-based and ordinal approaches for dot product computation for complex data.. - The requirement to test this comparison for dot product sizes ranging from 1 to 512.. . This prompt should highlight the importance of evaluating and comparing the efficiency and accuracy of different methods for computing dot products in complex data scenarios.,"void autotest_dotprod_crcf_rand01()\n{\n    float h[16] = {\n      5.5375e-02,  -6.5857e-01,  -1.7657e+00,   7.7444e-01, \n      8.0730e-01,  -5.1340e-01,  -9.3437e-02,  -5.6301e-01, \n     -6.6480e-01,  -2.1673e+00,   9.0269e-01,   3.5284e+00, \n     -9.7835e-01,  -6.9512e-01,  -1.2958e+00,   1.1628e+00\n    };\n    float complex x[16] = {\n      1.3164e+00+  5.4161e-01*_Complex_I,   1.8295e-01+ -9.0284e-02*_Complex_I, \n      1.3487e+00+ -1.8148e+00*_Complex_I,  -7.4696e-01+ -4.1792e-01*_Complex_I, \n     -9.0551e-01+ -4.4294e-01*_Complex_I,   6.0591e-01+ -1.5383e+00*_Complex_I, \n     -7.5393e-01+ -3.5691e-01*_Complex_I,  -4.5733e-01+  1.1926e-01*_Complex_I, \n     -1.4744e-01+ -4.7676e-02*_Complex_I,  -1.2422e+00+ -2.0213e+00*_Complex_I, \n      3.3208e-02+ -1.3756e+00*_Complex_I,  -4.8573e-01+  1.0977e+00*_Complex_I, \n      1.5053e+00+  2.1141e-01*_Complex_I,  -8.4062e-01+ -1.0211e+00*_Complex_I, \n     -1.3932e+00+ -4.8491e-01*_Complex_I,  -1.4234e+00+  2.0333e-01*_Complex_I\n    };\n    float complex y;\n    float complex test     = -3.35346556487224 + 11.78023318618137*_Complex_I;\n    float complex test_rev =  3.655541203500000 + 4.26531912591000*_Complex_I;\n    float tol = 1e-3f;\n    dotprod_crcf_run(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_run4(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf q = dotprod_crcf_create(h,16);\n    dotprod_crcf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    q = dotprod_crcf_recreate_rev(q,h,16);\n    dotprod_crcf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test_rev), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test_rev), tol);\n    q = dotprod_crcf_recreate(q,h,16);\n    dotprod_crcf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_destroy(q);\n}\nvoid autotest_dotprod_crcf_rand02()\n{\n    float h[16] = {\n      4.7622e-01,   7.1453e-01,  -7.1370e-01,  -1.6457e-01, \n     -1.1573e-01,   6.4114e-01,  -1.0688e+00,  -1.6761e+00, \n     -1.0376e+00,  -1.0991e+00,  -2.4161e-01,   4.6065e-01, \n     -1.0403e+00,  -1.1424e-01,  -1.2371e+00,  -7.9723e-01\n    };\n    float complex x[16] = {\n     -8.3558e-01+  3.0504e-01*_Complex_I,  -6.3004e-01+  2.4680e-01*_Complex_I, \n      9.6908e-01+  1.2978e+00*_Complex_I,  -2.0587e+00+  9.5385e-01*_Complex_I, \n      2.5692e-01+ -1.7314e+00*_Complex_I,  -1.2237e+00+ -6.2139e-02*_Complex_I, \n      5.0300e-02+ -9.2092e-01*_Complex_I,  -1.8816e-01+  7.0746e-02*_Complex_I, \n     -2.4177e+00+  8.3177e-01*_Complex_I,   1.6871e-01+ -8.5129e-02*_Complex_I, \n      6.5203e-01+  2.0739e-02*_Complex_I,  -1.2331e-01+ -9.7920e-01*_Complex_I, \n      8.2352e-01+  9.1093e-01*_Complex_I,   1.5161e+00+ -9.1865e-01*_Complex_I, \n     -2.0892e+00+  2.7759e-02*_Complex_I,  -2.5188e-01+  2.5568e-01*_Complex_I\n    };\n    float complex y;\n    float complex test = 2.11053363855085 - 2.04167493441477*_Complex_I;\n    float tol = 1e-3f;\n    dotprod_crcf_run(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_run4(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf q = dotprod_crcf_create(h,16);\n    dotprod_crcf_execute(q,x,&y);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod : %12.8f + j%12.8f (expected: %12.8f + j%12.8f)\\n"",\n                crealf(y), cimagf(y), crealf(test), cimagf(test));\n    }\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_destroy(q);\n}\nvoid runtest_dotprod_crcf(unsigned int _n)\n{\n    float tol = 1e-4;\n    float h[_n];\n    float complex x[_n];\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        h[i] = randnf();\n        x[i] = randnf() + randnf() * _Complex_I;\n    }\n    float complex y_test=0;\n    for (i=0; i<_n; i++)\n        y_test += h[i] * x[i];\n    float complex y_struct;\n    dotprod_crcf dp;\n    dp = dotprod_crcf_create(h,_n);\n    dotprod_crcf_execute(dp, x, &y_struct);\n    dotprod_crcf_destroy(dp);\n    float complex y_run, y_run4;\n    dotprod_crcf_run (h,x,_n,&y_run );\n    dotprod_crcf_run4(h,x,_n,&y_run4);\n    if (liquid_autotest_verbose) {\n        printf(""  dotprod-crcf-%-4u(struct) : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                _n, crealf(y_struct), cimagf(y_struct), crealf(y_test), cimagf(y_test));\n        printf(""  dotprod-crcf-%-4u(run   ) : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                _n, crealf(y_run   ), cimagf(y_run   ), crealf(y_test), cimagf(y_test));\n        printf(""  dotprod-crcf-%-4u(run4  ) : %12.8f + j%12.8f (expected %12.8f + j%12.8f)\\n"",\n                _n, crealf(y_run4  ), cimagf(y_run4  ), crealf(y_test), cimagf(y_test));\n    }\n    CONTEND_DELTA(crealf(y_struct), crealf(y_test), tol);\n    CONTEND_DELTA(cimagf(y_struct), cimagf(y_test), tol);\n    CONTEND_DELTA(crealf(y_run   ), crealf(y_test), tol);\n    CONTEND_DELTA(cimagf(y_run   ), cimagf(y_test), tol);\n    CONTEND_DELTA(crealf(y_run4  ), crealf(y_test), tol);\n    CONTEND_DELTA(cimagf(y_run4  ), cimagf(y_test), tol);\n}\nvoid autotest_dotprod_crcf_struct_vs_ordinal()\n{\n    unsigned int i;\n    for (i=1; i<=512; i++)\n        runtest_dotprod_crcf(i);\n}')
"
"('Prompt: You are working on a digital communication system and need a function that converts a soft bit to a hard decision, where the threshold for deciding between a 1 and 0 is defined by a constant value called LIQUID_SOFTBIT_ERASURE. The function should return either LIQUID_SOFTBIT_1 or LIQUID_SOFTBIT_0 based on the input soft bit. Write a C function that accomplishes this task.","//...\nunsigned int liquid_hard_decision(unsigned char _soft_bit)\n{\n    return _soft_bit > LIQUID_SOFTBIT_ERASURE ? LIQUID_SOFTBIT_1 : LIQUID_SOFTBIT_0;\n}\n//...')
"
"('Please provide a prompt detailing a scenario where you need a testbench function to test the mixing functionality of an Numerically Controlled Oscillator with carrier recovery digital implementation. The testbench should set the phase and frequency of the NCO, generate a random complex signal, mix the signal using the NCO, and then compare the results against the expected values with a tolerance value.. . Example Prompt:. ""I need a testbench function to verify the mixing functionality of a Numerically Controlled Oscillator with carrier recovery in a digital implementation. The testbench should set the phase and frequency, generate a random complex signal, mix the signal using the NCO, and compare the output against the expected values with a specified tolerance. Can you provide a function that performs these tasks and verifies the correctness of the mixing process?""","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_nco_0() { testbench_nco_crcf_mix(LIQUID_NCO,  0.000f,  0.000f); }\n//...')
"
"'Prompt: You are working on a project that involves converting colors from HSL (Hue, Saturation, Lightness) to RGB (Red, Green, Blue) values. Please write a function in C that takes a pointer to an HSL struct and returns an RGB struct in the RGB888 format, where each color component ranges from 0 to 255. The function should accurately convert the color values from HSL to RGB using the provided conversion algorithm.","rgb_t\nhsl_to_rgb888(hsl_t *hsl)\n{\n    rgb_t rgb;\n    float r, g, b, h, s, l;\n    float temp1, temp2, tempr, tempg, tempb;\n    h = hsl->h / 256.0;\n    s = hsl->s / 256.0;\n    l = hsl->l / 256.0;\n    if(s == 0) {\n        r = g = b = l;\n    } else {\n        if (l < 0.5) {\n            temp2 = l * (1 + s);\n        } else {\n            temp2 = (l + s) - (l * s);\n        }\n        temp1 = 2 * l - temp2;\n        tempr = h + 1.0 / 3.0;\n        if (tempr > 1) {\n            tempr--;\n        }\n        tempg = h;\n        tempb = h - 1.0 / 3.0;\n        if (tempb < 0) {\n            tempb++;\n        }\n        if (tempr < 1.0 / 6.0) {\n            r = temp1 + (temp2 - temp1) * 6.0 * tempr;\n        } else if (tempr < 0.5) {\n            r = temp2;\n        } else if (tempr < 2.0 / 3.0) {\n            r = temp1 + (temp2 - temp1) * ((2.0 / 3.0) - tempr) * 6.0;\n        } else {\n            r = temp1;\n        }\n        if (tempg < 1.0 / 6.0) {\n            g = temp1 + (temp2 - temp1) * 6.0 * tempg;\n        } else if (tempg < 0.5) {\n            g = temp2;\n        } else if (tempg < 2.0 / 3.0) {\n            g = temp1 + (temp2 - temp1) * ((2.0 / 3.0) - tempg) * 6.0;\n        } else {\n            g = temp1;\n        }\n        if (tempb < 1.0 / 6.0) {\n            b = temp1 + (temp2 - temp1) * 6.0 * tempb;\n        } else if (tempb < 0.5) {\n            b = temp2;\n        } else if (tempb < 2.0 / 3.0) {\n            b = temp1 + (temp2 - temp1) * ((2.0 / 3.0) - tempb) * 6.0;\n        } else {\n            b = temp1;\n        }\n    }\n    rgb.r = (uint8_t)(r * 255.0);\n    rgb.g = (uint8_t)(g * 255.0);\n    rgb.b = (uint8_t)(b * 255.0);\n    return rgb;\n}'"
"('You could have prompted me with: . ""In your software project, you need a function to create a complex dot product calculation object with specific optimizations. Write a code snippet where you define a function `dotprod_cccf_create_opt` that takes an array of complex numbers `_h`, the size of the array `_n`, and an integer `_rev` to determine if the elements need to be reversed. Inside this function, allocate memory for the object, initialize its fields `n`, `hi`, and `hq` with optimizations, and return the created object. Additionally, include a function `dotprod_cccf_create_rev` that calls `dotprod_cccf_create_opt` with `_rev` set to 1. Finally, include a simplified `dotprod_cccf_create` function that calls `dotprod_cccf_create_opt` with `_rev` set to 0. Please provide the required code.""","//...\ndotprod_cccf dotprod_cccf_create(float complex * _h,\n                                 unsigned int    _n)\n{\n    return dotprod_cccf_create_opt(_h, _n, 0);\n}\ndotprod_cccf dotprod_cccf_create_opt(float complex * _h,\n                                     unsigned int    _n,\n                                     int             _rev)\n{\n    dotprod_cccf q = (dotprod_cccf)malloc(sizeof(struct dotprod_cccf_s));\n    q->n = _n;\n    q->hi = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );\n    q->hq = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );\n    unsigned int i;\n    for (i=0; i<q->n; i++) {\n        unsigned int k = _rev ? q->n-i-1 : i;\n        q->hi[2*i+0] = crealf(_h[k]);\n        q->hi[2*i+1] = crealf(_h[k]);\n        q->hq[2*i+0] = cimagf(_h[k]);\n        q->hq[2*i+1] = cimagf(_h[k]);\n    }\n    return q;\n}\ndotprod_cccf dotprod_cccf_create_rev(float complex * _h,\n                                     unsigned int    _n)\n{\n    return dotprod_cccf_create_opt(_h, _n, 1);\n}\n//...')
"
"('Please provide the code to calculate the QR decomposition of the given complex matrices: matrixcf_data_qrdecomp_A, matrixcf_data_qrdecomp_Q, and matrixcf_data_qrdecomp_R.","float complex matrixcf_data_qrdecomp_A[] = {\n    2.114020000000 +  -0.576040000000*_Complex_I ,\n    0.417500000000 +   1.008330000000*_Complex_I ,\n   -0.962640000000 +  -3.621960000000*_Complex_I ,\n   -0.206790000000 +  -1.026680000000*_Complex_I ,\n    0.008540000000 +   1.616260000000*_Complex_I ,\n    0.846950000000 +  -0.327360000000*_Complex_I ,\n   -1.018620000000 +  -1.107860000000*_Complex_I ,\n   -1.788770000000 +   1.844560000000*_Complex_I ,\n   -2.979010000000 +  -1.303840000000*_Complex_I ,\n    0.522890000000 +   1.891100000000*_Complex_I ,\n    1.325760000000 +  -0.367370000000*_Complex_I ,\n    0.047170000000 +   0.206280000000*_Complex_I ,\n    0.289700000000 +   0.642470000000*_Complex_I ,\n   -0.559160000000 +   0.683020000000*_Complex_I ,\n    1.406150000000 +   0.623980000000*_Complex_I ,\n   -0.127670000000 +  -0.539970000000*_Complex_I };\nfloat complex matrixcf_data_qrdecomp_Q[] = {\n    0.491706158979 +  -0.133982845866*_Complex_I ,\n    0.429660711419 +   0.559833033911*_Complex_I ,\n   -0.309333641162 +  -0.278321211351*_Complex_I ,\n    0.215207397547 +  -0.150957196713*_Complex_I ,\n    0.001986343837 +   0.375930689639*_Complex_I ,\n    0.242768204454 +   0.009257007128*_Complex_I ,\n   -0.422306122793 +  -0.032511505165*_Complex_I ,\n   -0.503566009661 +   0.605534385769*_Complex_I ,\n   -0.692896739226 +  -0.303263998601*_Complex_I ,\n    0.054111560749 +   0.468071856237*_Complex_I ,\n   -0.082147488614 +   0.069653107384*_Complex_I ,\n    0.279669645547 +   0.340721083028*_Complex_I ,\n    0.067382179098 +   0.149433995875*_Complex_I ,\n   -0.270466351267 +   0.384428384950*_Complex_I ,\n   -0.285071449427 +   0.744704670261*_Complex_I ,\n   -0.173581995183 +  -0.293616086507*_Complex_I };\nfloat complex matrixcf_data_qrdecomp_R[] = {\n    4.299356356224 +   0.000000000000*_Complex_I ,\n   -0.922616273377 +  -0.789487259898*_Complex_I ,\n   -1.025768821795 +  -1.040664085433*_Complex_I ,\n    0.541217397816 +  -0.002345615451*_Complex_I ,\n    0.000000000000 +   0.000000000000*_Complex_I ,\n    2.273733268802 +   0.000000000000*_Complex_I ,\n   -2.939502710322 +  -2.626579524510*_Complex_I ,\n   -1.154743344912 +   0.323209860623*_Complex_I ,\n    0.000000000000 +   0.000000000000*_Complex_I ,\n    0.000000000000 +   0.000000000000*_Complex_I ,\n    1.701364174878 +   0.000000000000*_Complex_I ,\n    0.689923063328 +  -0.348316412767*_Complex_I ,\n    0.000000000000 +   0.000000000000*_Complex_I ,\n    0.000000000000 +   0.000000000000*_Complex_I ,\n    0.000000000000 +   0.000000000000*_Complex_I ,\n    2.392371328442 +   0.000000000000*_Complex_I };')
"
"'Please provide a prompt in which you need a function that can decode a Qt language code into ISO639-2T language code and also log messages based on different log levels using a message logging function. Additionally, you require functions to read from a stream, seek within a stream, get the current position of a stream, get the size of a stream, create a file stream object, and destroy a file stream object.","bool decodeQtLanguageCode( uint16_t i_language_code, char *psz_iso,\n                                  bool *b_mactables )\n{\n    static const char * psz_qt_to_iso639_2T_lower =\n            ""eng""    ""fra""    ""deu""    ""ita""    ""nld""\n            ""swe""    ""spa""    ""dan""    ""por""    ""nor"" \n            ""heb""    ""jpn""    ""ara""    ""fin""    ""gre""\n            ""isl""    ""mlt""    ""tur""    ""hrv""    ""zho"" \n            ""urd""    ""hin""    ""tha""    ""kor""    ""lit""\n            ""pol""    ""hun""    ""est""    ""lav""    ""sme"" \n            ""fao""    ""fas""    ""rus""    ""zho""    ""nld"" \n            ""gle""    ""sqi""    ""ron""    ""ces""    ""slk"" \n            ""slv""    ""yid""    ""srp""    ""mkd""    ""bul""\n            ""ukr""    ""bel""    ""uzb""    ""kaz""    ""aze"" \n            ""aze""    ""hye""    ""kat""    ""mol""    ""kir""\n            ""tgk""    ""tuk""    ""mon""    ""mon""    ""pus"" \n            ""kur""    ""kas""    ""snd""    ""bod""    ""nep""\n            ""san""    ""mar""    ""ben""    ""asm""    ""guj"" \n            ""pan""    ""ori""    ""mal""    ""kan""    ""tam""\n            ""tel""    ""sin""    ""mya""    ""khm""    ""lao"" \n            ""vie""    ""ind""    ""tgl""    ""msa""    ""msa""\n            ""amh""    ""tir""    ""orm""    ""som""    ""swa"" \n            ""kin""    ""run""    ""nya""    ""mlg""    ""epo"" \n            ;\n    static const char * psz_qt_to_iso639_2T_upper =\n            ""cym""    ""eus""    ""cat""    ""lat""    ""que"" \n            ""grn""    ""aym""    ""tat""    ""uig""    ""dzo""\n            ""jaw""    ""sun""    ""glg""    ""afr""    ""bre"" \n            ""iku""    ""gla""    ""glv""    ""gle""    ""ton""\n            ""gre""                                     \n            ;\n    unsigned i;\n    if ( i_language_code < 0x400 || i_language_code == 0x7FFF )\n    {\n        const void *p_data;\n        *b_mactables = true;\n        if ( i_language_code <= 94 )\n        {\n            p_data = psz_qt_to_iso639_2T_lower + i_language_code * 3;\n        }\n        else if ( i_language_code >= 128 && i_language_code <= 148 )\n        {\n            i_language_code -= 128;\n            p_data = psz_qt_to_iso639_2T_upper + i_language_code * 3;\n        }\n        else\n            return false;\n        memcpy( psz_iso, p_data, 3 );\n    }\n    else\n    {\n        *b_mactables = false;\n        if( i_language_code == 0x55C4 ) \n        {\n            memset( psz_iso, 0, 3 );\n            return false;\n        }\n        for( i = 0; i < 3; i++ )\n            psz_iso[i] = ( ( i_language_code >> ( (2-i)*5 ) )&0x1f ) + 0x60;\n    }\n    return true;\n}\nvoid msg_log(int log_lvl, const char *fmt, ...)\n{\n    va_list ap;\n    char buf[512] = {0};\n    va_start(ap, fmt);\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n    switch (log_lvl) {\n#ifdef MP4_VERBOSE\n    case MSG_DGB:\n        printf(""debug: %s\\n"", buf);\n        break;\n    case MSG_WARN:\n        printf(""warn: %s\\n"", buf);\n        break;\n#endif\n    case MSG_ERR:\n        printf(""err: %s\\n"", buf);\n        break;\n    default:\n        break;\n    }\n}\nint stream_Read(stream_t *s, void* buf, int size)\n{\n    return fread(buf, 1, size, s->fp);\n}\nuint64_t stream_Seek(stream_t *s, int64_t offset)\n{\n    return fseek(s->fp, offset, SEEK_SET);\n}\nint64_t stream_Tell(stream_t *s)\n{\n    return ftell(s->fp);\n}\nint stream_Peek(stream_t *s, const uint8_t **buf, int size)\n{\n    uint32_t offset = stream_Tell(s);\n    *buf = (uint8_t *)calloc(1, size);\n    s->priv_buf_num++;\n    s->priv_buf = (void **)realloc(s->priv_buf, s->priv_buf_num * sizeof(uint8_t*));\n    s->priv_buf[s->priv_buf_num-1] = (void *)*buf;\n    int ret = stream_Read(s, (void *)*buf, size);\n    stream_Seek(s, offset);\n    return ret;\n}\nint64_t stream_Size(stream_t *s)\n{\n    long size;\n    long tmp = ftell(s->fp);\n    fseek(s->fp, 0L, SEEK_END);\n    size = ftell(s->fp);\n    fseek(s->fp, tmp, SEEK_SET);\n    return (int64_t)size;\n}\nstream_t* create_file_stream(const char *filename)\n{\n    stream_t* s = (stream_t*)calloc(1, sizeof(stream_t));\n    s->priv_buf_num = 0;\n    s->priv_buf = (void **)calloc(1, sizeof(uint32_t));\n    s->fp = fopen(filename, ""rb"");\n    if (!s->fp) {\n        printf(""fopen %s failed!\\n"", filename);\n        free(s);\n        return NULL;\n    }\n    return s;\n}\nvoid destory_file_stream(stream_t* s)\n{\n    int i;\n    fclose(s->fp);\n    for (i = 0; i < s->priv_buf_num; i++) {\n        free(s->priv_buf[i]);\n    }\n    free(s->priv_buf);\n    free(s);\n}'"
"('Prompt: You are testing a resampling function that takes in a float input rate, a target stopband attenuation, and an integer identifier. The function creates a resampling structure and generates a pulse with a specified length and bandwidth. It then executes the resampling operation on a complex buffer and validates the output against predefined regions. Additionally, there is another function that tests the functionality of the `resamp_crcf_get_num_output` function with different input sizes and rate values. Write the code for these test functions.. . Technical Scenario: In a digital signal processing project, you are tasked with validating a resampling function designed to adjust the sampling rate of a signal. The first test function, `testbench_resamp_crcf`, creates a resampling structure based on the input rate, modulation factor, center frequency, stopband attenuation, and number of polyphase filterbank channels. It generates a pulse signal with specific characteristics, executes the resampling operation with the given input pulse, and validates the output power","//...\nvoid testbench_resamp_crcf(float r, float As, int _id)\n{\n    float        bw   = 0.25f;  \n    float        tol  = 0.5f;   \n    unsigned int m    = 20;     \n    unsigned int npfb = 2048;   \n    float        fc   = 0.45f;  \n    resamp_crcf resamp = resamp_crcf_create(r,m,fc,As,npfb);\n    unsigned int p = (unsigned int) (40.0f / r);\n    unsigned int pulse_len = 4*p + 1;\n    float        pulse[pulse_len];\n    liquid_firdes_kaiser(pulse_len, 0.5*r*bw, 120, 0, pulse);\n    unsigned int  num_input  = pulse_len + 2*m + 1;\n    unsigned int  num_output = resamp_crcf_get_num_output(resamp, num_input);\n    float complex buf_0[num_input];  \n    float complex buf_1[num_output]; \n    unsigned int i;\n    for (i=0; i<num_input; i++)\n        buf_0[i] = i < pulse_len ? pulse[i]*bw : 0;\n    unsigned int nw = 0;\n    resamp_crcf_execute_block(resamp, buf_0, num_input, buf_1, &nw);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/resamp_crcf_%.2d.m"", _id);\n    liquid_autotest_validate_psd_signal(buf_1, nw, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    resamp_crcf_destroy(resamp);\n}\nvoid testbench_resamp_crcf_num_output(float _rate, unsigned int _npfb)\n{\n    if (liquid_autotest_verbose)\n        printf(""testing resamp_crcf_get_num_output() with r=%g, npfb=%u\\n"", _rate, _npfb);\n    float fc = 0.4f;\n    float As = 60.0f;\n    unsigned int m = 20;\n    resamp_crcf q = resamp_crcf_create(_rate, m, fc, As, _npfb);\n    unsigned int sizes[10] = {1, 2, 3, 20, 7, 64, 4, 4, 4, 27};\n    unsigned int max_input = 64;\n    unsigned int max_output = 16 + (unsigned int)(4.0f * max_input * _rate);\n    printf(""max_input : %u, max_output : %u\\n"", max_input, max_output);\n    float complex buf_0[max_input];\n    float complex buf_1[max_output];\n    unsigned int i;\n    for (i=0; i<max_input; i++)\n        buf_0[i] = 0.0f;\n    unsigned int b;\n    for (b=0; b<8; b++) {\n        for (i=0; i<10; i++) {\n            unsigned int num_input  = sizes[i];\n            unsigned int num_output = resamp_crcf_get_num_output(q, num_input);\n            unsigned int num_written;\n            resamp_crcf_execute_block(q, buf_0, num_input, buf_1, &num_written);\n            if (liquid_autotest_verbose) {\n                printf("" b[%2u][%2u], num_input:%5u, num_output:%5u, num_written:%5u\\n"",\n                        b, i, num_input, num_output, num_written);\n            }\n            CONTEND_EQUALITY(num_output, num_written)\n        }\n    }\n    resamp_crcf_destroy(q);\n}\nvoid autotest_resamp_crcf_num_output_7(){ testbench_resamp_crcf_num_output(expf(-5.f),64); }\n//...')
"
"('Please provide a prompt where you need a code snippet to create a frame generator for a communication system that generates 64-symbol frames. The frame generator should include functions to create, copy, destroy, print information about the frame structure, and execute the frame generation process. The code should utilize structures and functions to handle the encoding, modulation, and generation of symbols for the frame, including pilot symbols and various configurations for the frame components.","struct framegen64_s {\n    qpacketmodem    enc;                \n    qpilotgen       pilotgen;           \n    float complex   pn_sequence[64];    \n    unsigned char   payload_dec[150];   \n    float complex   payload_sym[600];   \n    float complex   payload_tx[630];    \n    unsigned int    m;                  \n    float           beta;               \n    firinterp_crcf  interp;             \n};\nframegen64 framegen64_create()\n{\n    framegen64 q = (framegen64) malloc(sizeof(struct framegen64_s));\n    q->m    = 7;\n    q->beta = 0.3f;\n    unsigned int i;\n    msequence ms = msequence_create(7, 0x0089, 1);\n    for (i=0; i<64; i++) {\n        q->pn_sequence[i]  = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        q->pn_sequence[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2)*_Complex_I;\n    }\n    msequence_destroy(ms);\n    int check      = LIQUID_CRC_24;\n    int fec0       = LIQUID_FEC_NONE;\n    int fec1       = LIQUID_FEC_GOLAY2412;\n    int mod_scheme = LIQUID_MODEM_QPSK;\n    q->enc         = qpacketmodem_create();\n    qpacketmodem_configure(q->enc, 72, check, fec0, fec1, mod_scheme);\n    assert( qpacketmodem_get_frame_len(q->enc)==600 );\n    q->pilotgen = qpilotgen_create(600, 21);\n    assert( qpilotgen_get_frame_len(q->pilotgen)==630 );\n    q->interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,2,q->m,q->beta,0);\n    return q;\n}\nframegen64 framegen64_copy(framegen64 q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""framegen64_copy(), object cannot be NULL"");\n    return framegen64_create();\n}\nint framegen64_destroy(framegen64 _q)\n{\n    qpacketmodem_destroy(_q->enc);\n    qpilotgen_destroy(_q->pilotgen);\n    firinterp_crcf_destroy(_q->interp);\n    free(_q);\n    return LIQUID_OK;\n}\nint framegen64_print(framegen64 _q)\n{\n    float eta = (float) (8*(64 + 8)) / (float) (LIQUID_FRAME64_LEN/2);\n    printf(""framegen64 [m=%u, beta=%4.2f]:\\n"", _q->m, _q->beta);\n    printf(""  preamble/etc.\\n"");\n    printf(""    * ramp/up symbols       :   %3u\\n"", _q->m);\n    printf(""    * p/n symbols           :   %3u\\n"", 64);\n    printf(""    * ramp\\\\down symbols     :   %3u\\n"", _q->m);\n    printf(""    * zero padding          :   %3u\\n"", 12);\n    printf(""  payload\\n"");\n#if 0\n    printf(""    * payload crc           :   %s\\n"", crc_scheme_str[_q->check][1]);\n    printf(""    * fec (inner)           :   %s\\n"", fec_scheme_str[_q->fec0][1]);\n    printf(""    * fec (outer)           :   %s\\n"", fec_scheme_str[_q->fec1][1]);\n#endif\n    printf(""    * payload len, uncoded  :   %3u bytes\\n"", 64);\n    printf(""    * payload len, coded    :   %3u bytes\\n"", 150);\n    printf(""    * modulation scheme     :   %s\\n"", modulation_types[LIQUID_MODEM_QPSK].name);\n    printf(""    * payload symbols       :   %3u\\n"", 600);\n    printf(""    * pilot symbols         :   %3u\\n"", 30);\n    printf(""  summary\\n"");\n    printf(""    * total symbols         :   %3u\\n"", LIQUID_FRAME64_LEN/2);\n    printf(""    * spectral efficiency   :   %6.4f b/s/Hz\\n"", eta);\n    return LIQUID_OK;\n}\nint framegen64_execute(framegen64      _q,\n                       unsigned char * _header,\n                       unsigned char * _payload,\n                       float complex * _frame)\n{\n    unsigned int i;\n    for (i=0; i<8; i++)\n        _q->payload_dec[i] = _header==NULL ? rand() & 0xff : _header[i];\n    for (i=0; i<64; i++)\n        _q->payload_dec[i+8] = _payload==NULL ? rand() & 0xff : _payload[i];\n    qpacketmodem_encode(_q->enc, _q->payload_dec, _q->payload_sym);\n    qpilotgen_execute(_q->pilotgen, _q->payload_sym, _q->payload_tx);\n    unsigned int n=0;\n    firinterp_crcf_reset(_q->interp);\n    for (i=0; i<64; i++) {\n        firinterp_crcf_execute(_q->interp, _q->pn_sequence[i], &_frame[n]);\n        n+=2;\n    }\n    for (i=0; i<630; i++) {\n        firinterp_crcf_execute(_q->interp, _q->payload_tx[i], &_frame[n]);\n        n+=2;\n    }\n    for (i=0; i<2*_q->m + 2 + 10; i++) {\n        firinterp_crcf_execute(_q->interp, 0.0f, &_frame[n]);\n        n+=2;\n    }\n    assert(n==LIQUID_FRAME64_LEN);\n    return LIQUID_OK;\n}')
"
"('Prompt: You are working on a digital communications project where you need to generate pilots for a certain payload length and pilot spacing. Can you provide me with a code snippet in C that includes a function to calculate the number of pilots needed based on the payload length and pilot spacing, as well as functions to create and reset a pilot generator object? The pilot generator object should have attributes for payload length, pilot spacing, number of pilots, frame length, and an array of complex floats for the pilots themselves.","//...\nstruct qpilotgen_s {\n    unsigned int    payload_len;    \n    unsigned int    pilot_spacing;  \n    unsigned int    num_pilots;     \n    unsigned int    frame_len;      \n    float complex * pilots;         \n};\nunsigned int qpilot_num_pilots(unsigned int _payload_len,\n                               unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0 || _pilot_spacing < 2)\n        return 0;\n    div_t d = div(_payload_len,(_pilot_spacing - 1));\n    return d.quot + (d.rem ? 1 : 0);\n}\nint qpilotgen_reset(qpilotgen _q)\n{\n    return LIQUID_OK;\n}\nqpilotgen qpilotgen_create(unsigned int _payload_len,\n                           unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0)\n        return liquid_error_config(""qpilotgen_create(), frame length must be at least 1 symbol"");\n    if (_pilot_spacing < 2)\n        return liquid_error_config(""qpilotgen_create(), pilot spacing must be at least 2 symbols"");\n    unsigned int i;\n    qpilotgen q = (qpilotgen) malloc(sizeof(struct qpilotgen_s));\n    q->payload_len   = _payload_len;\n    q->pilot_spacing = _pilot_spacing;\n    q->num_pilots = qpilot_num_pilots(q->payload_len, q->pilot_spacing);\n    q->frame_len  = q->payload_len + q->num_pilots;\n    q->pilots = (float complex*) malloc(q->num_pilots*sizeof(float complex));\n    unsigned int m = liquid_nextpow2(q->num_pilots);\n    msequence seq = msequence_create_default(m);\n    for (i=0; i<q->num_pilots; i++) {\n        unsigned int s = msequence_generate_symbol(seq, 2);\n        float theta = (2 * M_PI * (float)s / 4.0f) + M_PI / 4.0f;\n        q->pilots[i] = cexpf(_Complex_I*theta);\n    }\n    msequence_destroy(seq);\n    qpilotgen_reset(q);\n    return q;\n}\n//...')
"
"('Please provide a prompt for testing an Elliptic bandpass filter design with certain specifications, such as the filter order, center frequency, bandwidth, passband ripple, stopband attenuation, tolerance, and number of FFT bins. The prompt should also mention the need to print the filter response if verbose output is enabled, calculate the power spectral density at different frequencies, and validate the filter response against predefined regions in the spectrum. Finally, indicate that the results should be logged to a file if verbose output is enabled, and the filter object should be destroyed after the test.","//...\nvoid autotest_iirdes_ellip_bandpass() {\n    unsigned int n  =    9;   \n    float        fc =  0.3;   \n    float        f0 =  0.35;  \n    float        Ap =  0.1;   \n    float        as = 60.0;   \n    float        tol  = 1e-3f;  \n    unsigned int nfft = 2400;   \n    iirfilt_crcf q = iirfilt_crcf_create_prototype(LIQUID_IIRDES_ELLIP,\n        LIQUID_IIRDES_BANDPASS, LIQUID_IIRDES_SOS,n,fc,f0,Ap,as);\n    if (liquid_autotest_verbose)\n        iirfilt_crcf_print(q);\n    unsigned int i;\n    float H[nfft]; \n    for (i=0; i<nfft; i++)\n        H[i] = iirfilt_crcf_get_psd(q, (float)i/(float)nfft-0.5f);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5,   .fmax=-0.396,.pmin=0,       .pmax=-as+tol, .test_lo=0, .test_hi=1},\n      {.fmin=-0.388, .fmax=-0.301,.pmin=-Ap-tol, .pmax=    tol, .test_lo=1, .test_hi=1},\n      {.fmin=-0.293, .fmax=+0.293,.pmin=0,       .pmax=-as+tol, .test_lo=0, .test_hi=1},\n      {.fmin=+0.301, .fmax=+0.388,.pmin=-Ap-tol, .pmax=    tol, .test_lo=1, .test_hi=1},\n      {.fmin=+0.396, .fmax=+0.5,  .pmin=0,       .pmax=-as+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(H, nfft, regions, 5,\n        liquid_autotest_verbose ? ""autotest/logs/iirdes_ellip_bandpass.m"" : NULL);\n    iirfilt_crcf_destroy(q);\n}\n//...')
"
('Create a prompt to test the `sumsqf_runtest` function using specific inputs and expected output validation. Provide the scenario where the `sumsqf_test_x15` array of size `15` and the expected output value `sumsqf_test_y15` are used. The prompt should specify that the tolerance for comparison is `1e-6`.,"//...\nfloat sumsqf_test_x3[3];    float sumsqf_test_y3;\nfloat sumsqf_test_y15 = 1.77074683901981f;\nvoid sumsqf_runtest(float *      _x,\n                    unsigned int _n,\n                    float        _y)\n{\n    float tol = 1e-6;   \n    float y = liquid_sumsqf(_x, _n);\n    CONTEND_DELTA( y, _y, tol );\n}\nvoid autotest_sumsqf_15()   {   sumsqf_runtest( sumsqf_test_x15, 15, sumsqf_test_y15 ); }\n//...')
"
"('Prompt: You are tasked with implementing LU decomposition algorithms using both Crout and Doolittle methods in a matrix library. The LU decomposition function needs to take in a matrix (_x) of type T, its dimensions (_rx, _cx), and output lower and upper triangular matrices (_l and _u) along with a permutation matrix (_p). The function should return an error if the input matrix is not square. In the Crout method, the algorithm should update _l and _u matrices accordingly, while in the Doolittle method, the algorithm should update them in a different order. Include necessary error handling and matrix access functions.","int MATRIX(_ludecomp_crout)(T *          _x,\n                            unsigned int _rx,\n                            unsigned int _cx,\n                            T *          _l,\n                            T *          _u,\n                            T *          _p)\n{\n    if (_rx != _cx)\n        return liquid_error(LIQUID_EICONFIG,""matrix_ludecomp_crout(), input matrix not square"");\n    unsigned int n = _rx;\n    unsigned int i;\n    for (i=0; i<n*n; i++) {\n        _l[i] = 0.0;\n        _u[i] = 0.0;\n        _p[i] = 0.0;\n    }\n    unsigned int j,k,t;\n    T l_ik, u_kj;\n    for (k=0; k<n; k++) {\n        for (i=k; i<n; i++) {\n            l_ik = matrix_access(_x,n,n,i,k);\n            for (t=0; t<k; t++) {\n                l_ik -= matrix_access(_l,n,n,i,t)*\n                        matrix_access(_u,n,n,t,k);\n            }\n            matrix_access(_l,n,n,i,k) = l_ik;\n        }\n        for (j=k; j<n; j++) {\n            if (j==k) {\n                matrix_access(_u,n,n,k,j) = 1.0f;\n                continue;\n            }\n            u_kj = matrix_access(_x,n,n,k,j);\n            for (t=0; t<k; t++) {\n                u_kj -= matrix_access(_l,n,n,k,t)*\n                        matrix_access(_u,n,n,t,j);\n            }\n            u_kj /= matrix_access(_l,n,n,k,k);\n            matrix_access(_u,n,n,k,j) = u_kj;\n        }\n    }\n    return MATRIX(_eye)(_p,n);\n}\nint MATRIX(_ludecomp_doolittle)(T *          _x,\n                                unsigned int _rx,\n                                unsigned int _cx,\n                                T *          _l,\n                                T *          _u,\n                                T *          _p)\n{\n    if (_rx != _cx)\n        return liquid_error(LIQUID_EICONFIG,""matrix_ludecomp_doolittle(), input matrix not square"");\n    unsigned int n = _rx;\n    unsigned int i;\n    for (i=0; i<n*n; i++) {\n        _l[i] = 0.0;\n        _u[i] = 0.0;\n        _p[i] = 0.0;\n    }\n    unsigned int j,k,t;\n    T u_kj, l_ik;\n    for (k=0; k<n; k++) {\n        for (j=k; j<n; j++) {\n            u_kj = matrix_access(_x,n,n,k,j);\n            for (t=0; t<k; t++) {\n                u_kj -= matrix_access(_l,n,n,k,t)*\n                        matrix_access(_u,n,n,t,j);\n            }\n            matrix_access(_u,n,n,k,j) = u_kj;\n        }\n        for (i=k; i<n; i++) {\n            if (i==k) {\n                matrix_access(_l,n,n,i,k) = 1.0f;\n                continue;\n            }\n            l_ik = matrix_access(_x,n,n,i,k);\n            for (t=0; t<k; t++) {\n                l_ik -= matrix_access(_l,n,n,i,t)*\n                        matrix_access(_u,n,n,t,k);\n            }\n            l_ik /= matrix_access(_u,n,n,k,k);\n            matrix_access(_l,n,n,i,k) = l_ik;\n        }\n    }\n    return MATRIX(_eye)(_p,n);\n}')
"
"('Prompt: You are tasked with creating a function that provides usage instructions for a command-line tool called ""fskframesync_example"". The function should include options for enabling debugging, adjusting signal-to-noise ratio, setting carrier frequency offset, carrier phase offset, and fractional sample timing offset. The default values for the options should be provided. Your function should print out these instructions with the corresponding options and their default values.","//...\nvoid usage()\n{\n    printf(""fskframesync_example [options]\\n"");\n    printf(""  h     : print usage\\n"");\n    printf(""  d     : enable debugging\\n"");\n    printf(""  S     : signal-to-noise ratio [dB], default: 20\\n"");\n    printf(""  F     : carrier frequency offset, default: 0\\n"");\n    printf(""  P     : carrier phase offset, default: 0\\n"");\n    printf(""  T     : fractional sample timing offset, default: 0.01\\n"");\n}\n//...')
"
'Prompt: Please provide a code snippet for implementing signal and broadcast functionality for a POSIX thread condition variable in a multi-threaded application. The code should handle scenarios where threads are waiting on the condition variable and need to be signaled or broadcasted.,"#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nstatic INLINE int\n__ptw32_cond_unblock (pthread_cond_t * cond, int unblockAll)\n{\n  int result;\n  pthread_cond_t cv;\n  int nSignalsToIssue;\n  if (cond == NULL || *cond == NULL)\n    {\n      return EINVAL;\n    }\n  cv = *cond;\n  if (cv == PTHREAD_COND_INITIALIZER)\n    {\n      return 0;\n    }\n  if ((result = pthread_mutex_lock (&(cv->mtxUnblockLock))) != 0)\n    {\n      return result;\n    }\n  if (0 != cv->nWaitersToUnblock)\n    {\n      if (0 == cv->nWaitersBlocked)\n\t{\n\t  return pthread_mutex_unlock (&(cv->mtxUnblockLock));\n\t}\n      if (unblockAll)\n\t{\n\t  cv->nWaitersToUnblock += (nSignalsToIssue = cv->nWaitersBlocked);\n\t  cv->nWaitersBlocked = 0;\n\t}\n      else\n\t{\n\t  nSignalsToIssue = 1;\n\t  cv->nWaitersToUnblock++;\n\t  cv->nWaitersBlocked--;\n\t}\n    }\n  else if (cv->nWaitersBlocked > cv->nWaitersGone)\n    {\n      if (__ptw32_semwait (&(cv->semBlockLock)) != 0)\n\t{\n\t  result =  __PTW32_GET_ERRNO();\n\t  (void) pthread_mutex_unlock (&(cv->mtxUnblockLock));\n\t  return result;\n\t}\n      if (0 != cv->nWaitersGone)\n\t{\n\t  cv->nWaitersBlocked -= cv->nWaitersGone;\n\t  cv->nWaitersGone = 0;\n\t}\n      if (unblockAll)\n\t{\n\t  nSignalsToIssue = cv->nWaitersToUnblock = cv->nWaitersBlocked;\n\t  cv->nWaitersBlocked = 0;\n\t}\n      else\n\t{\n\t  nSignalsToIssue = cv->nWaitersToUnblock = 1;\n\t  cv->nWaitersBlocked--;\n\t}\n    }\n  else\n    {\n      return pthread_mutex_unlock (&(cv->mtxUnblockLock));\n    }\n  if ((result = pthread_mutex_unlock (&(cv->mtxUnblockLock))) == 0)\n    {\n      if (sem_post_multiple (&(cv->semBlockQueue), nSignalsToIssue) != 0)\n\t{\n\t  result =  __PTW32_GET_ERRNO();\n\t}\n    }\n  return result;\n}\t\t\t\t\nint\npthread_cond_signal (pthread_cond_t * cond)\n{\n  return (__ptw32_cond_unblock (cond, 0));\n}\t\t\t\t\nint\npthread_cond_broadcast (pthread_cond_t * cond)\n{\n  return (__ptw32_cond_unblock (cond,  __PTW32_TRUE));\n}\t\t\t\t'"
"('Prompt: ""I need a function that runs a test for a Gaussian minimum shift keying (GMSK) detector. The test should generate a random binary sequence of a specified length, create a GMSK detector using this sequence, run the test, and then destroy the detector. The test should check if a frame is detected, calculate estimated parameters such as gamma, tau, dphi, and phi, compare them with actual parameters, and print the results. The test should also handle false positives and failures. Can you write this function?""","//...\nvoid qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    unsigned char sequence[_sequence_len];\n    unsigned int i;\n    for (i=0; i<_sequence_len; i++)\n        sequence[i] = rand() & 0x01;\n    qdetector_cccf q = qdetector_cccf_create_gmsk(sequence, _sequence_len, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_gmsk_n335()    { qdetector_cccf_runtest_gmsk  ( 335); }\n//...')
"
"""Prompt: I need a code snippet for creating a canvas with a specified width and height, filling it with a background color, centering it on the screen, and drawing a red, underlined 'Hello' text using the Montserrat font.","#if LV_USE_CANVAS && LV_FONT_MONTSERRAT_18 && LV_BUILD_EXAMPLES\n#define CANVAS_WIDTH  50\n#define CANVAS_HEIGHT  50\nvoid lv_example_canvas_4(void)\n{\n    LV_DRAW_BUF_DEFINE(draw_buf, CANVAS_WIDTH, CANVAS_HEIGHT, LV_COLOR_FORMAT_ARGB8888);\n    lv_obj_t * canvas = lv_canvas_create(lv_screen_active());\n    lv_canvas_set_draw_buf(canvas, &draw_buf);\n    lv_canvas_fill_bg(canvas, lv_color_hex3(0xccc), LV_OPA_COVER);\n    lv_obj_center(canvas);\n    lv_layer_t layer;\n    lv_canvas_init_layer(canvas, &layer);\n    lv_draw_label_dsc_t dsc;\n    lv_draw_label_dsc_init(&dsc);\n    dsc.color = lv_palette_main(LV_PALETTE_RED);\n    dsc.font = &lv_font_montserrat_18;\n    dsc.decor = LV_TEXT_DECOR_UNDERLINE;\n    dsc.text = ""Hello"";\n    lv_area_t coords = {10, 10, 30, 60};\n    lv_draw_label(&layer, &dsc, &coords);\n    lv_canvas_finish_layer(canvas, &layer);\n}\n#endif'"
"'Prompt: You want to time different operations in a hash table implementation in C. The code provided includes functions to measure the time it takes to initialize, add, lookup, and delete elements in a hash table. You also want to test the implementation with a specified number of keys.","//...\ndouble epoch_double()\n{\n    struct timeval t;\n    gettimeofday(&t, NULL);\n    return t.tv_sec + (t.tv_usec * 1.0) / 1000000.0;\n}\nint test(int argc, char * argv[])\n{\n    dict * d;\n    double t1, t2;\n    int i;\n    int nkeys;\n    char * buffer;\n    char * val;\n    nkeys = (argc>1) ? (int)atoi(argv[1]) : NKEYS;\n    printf(""%15s: %d\\n"", ""values"", nkeys);\n    buffer = (char *)malloc(9 * nkeys);\n    if (!buffer) {\n        printf(""malloc failed!\\n"");\n        return -1;\n    }\n    d = dict_new();\n    t1 = epoch_double();\n    for (i = 0; i < nkeys; i++) {\n        sprintf(buffer + i * 9, ""%08x"", i);\n    }\n    t2 = epoch_double();\n    printf(ALIGN, ""initialization"", t2 - t1);\n    t1 = epoch_double();\n    for(i = 0; i < nkeys; i++) {\n        dict_add(d, buffer + i*9, buffer +i*9);\n    }\n    t2 = epoch_double();\n    printf(ALIGN, ""adding"", t2 - t1);\n    t1 = epoch_double();\n    for(i = 0; i < nkeys; i++) {\n        val = dict_get(d, buffer + i*9, (char *)""UNDEF"");\n        if (0) {\n        printf(""hash_get: key=%p, val=%p\\n"", buffer + i*9, val);\n        }\n#if DEBUG>1\n        printf(""exp[%s] got[%s]\\n"", buffer+i*9, val);\n#endif\n        if (val && strcmp(val, buffer+i*9)) {\n            printf(""-> WRONG got[%s] exp[%s]\\n"", val, buffer+i*9);\n        }\n    }\n    t2 = epoch_double();\n    printf(ALIGN, ""lookup"", t2 - t1);\n    t1 = epoch_double();\n    for(i = 0; i < nkeys; i++) {\n        dict_del(d, buffer + i*9);\n    }\n    t2 = epoch_double();\n    printf(ALIGN, ""delete"", t2 - t1);\n    t1 = epoch_double();\n    for(i = 0; i < nkeys; i++) {\n        dict_add(d, buffer + i*9, buffer +i*9);\n    }\n    t2 = epoch_double();\n    printf(ALIGN, ""adding"", t2 - t1);\n    t1 = epoch_double();\n    dict_free(d);\n    t2 = epoch_double();\n    printf(ALIGN, ""free"", t2 - t1);\n    free(buffer);\n    return 0;\n}\n//...'"
"('Please provide a prompt to generate a testbench for a digital communication system using the liquid DSP library. The testbench should focus on analyzing the power spectral density (PSD) of a symbol stream generated by a linear modulator for a QPSK signal. The system parameters to be tested are a filter type of ARKAISER, a modulation scheme of QPSK, a symbol length of 4, a modulation depth of 0.20, and a total of 25 symbols. Please ensure that the PSD is analyzed using a periodogram with a specified number of FFT points and validate the spectrum against predefined regions. Additionally, generate an output file to log the results for further analysis.","//...\nvoid testbench_symstreamcf_psd(unsigned int _k,\n                               unsigned int _m,\n                               float        _beta)\n{\n    int ftype = LIQUID_FIRFILT_ARKAISER;\n    int ms    = LIQUID_MODEM_QPSK;\n    symstreamcf gen = symstreamcf_create_linear(ftype,_k,_m,_beta,ms);\n    symstreamcf_set_gain(gen, 1.0f/sqrtf(_k));\n    unsigned int nfft        =   2400;      \n    unsigned int num_samples = 192000*_k;   \n    spgramcf periodogram = spgramcf_create_default(nfft);\n    unsigned int buf_len = 1337;\n    float complex buf[buf_len];\n    unsigned int n = 0;\n    while (n < num_samples) {\n        symstreamcf_write_samples(gen, buf, buf_len);\n        n += buf_len;\n        spgramcf_write(periodogram, buf, buf_len);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(periodogram, psd);\n    symstreamcf_destroy(gen);\n    spgramcf_destroy(periodogram);\n    float f0 = 0.5 * (1.0f - _beta) / (float)_k;\n    float f1 = 0.5 * (1.0f + _beta) / (float)_k;\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5, .fmax=-f1,  .pmin=  0-0, .pmax=-80.0, .test_lo=0, .test_hi=1},\n      {.fmin=-f0,  .fmax= f0,  .pmin= -1.0, .pmax=  1.0, .test_lo=1, .test_hi=1},\n      {.fmin= f1,  .fmax= 0.5, .pmin=  0.0, .pmax=-80.0, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/symstreamcf_psd_k%u_m%u_b%.3u_autotest.m"",\n            _k, _m, (int)(_beta*100));\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\nvoid autotest_symstreamcf_psd_k4_m25_b020() { testbench_symstreamcf_psd(4, 25, 0.20f); }\n//...')
"
"('Prompts for the code response:. ""Please provide a testbench function that sets up a signal processing scenario for resampling with a specified rate, bandwidth, and oversampling factor. The function should generate a signal, resample it using a created resampler, apply a filter, and validate the output power spectral density. Also, create a separate testbench function to test the functionality of the resamp_crcf_get_num_output() method with different input sizes and verify the output size consistency. Output the maximum input and output sizes as well."". . ""Create a test scenario for a resampling operation using the resamp_crcf resampler with given rate, cutoff frequency, and stopband attenuation parameters. The testbench should generate a test signal, resample it using the resampler, apply a filter based on a Kaiser window design, and validate the output power spectral density within specified frequency regions. Additionally, design a separate testbench function to test the functionality of resamp_crcf_get_num_output() method","//...\nvoid testbench_resamp_crcf(float r, float As, int _id)\n{\n    float        bw   = 0.25f;  \n    float        tol  = 0.5f;   \n    unsigned int m    = 20;     \n    unsigned int npfb = 2048;   \n    float        fc   = 0.45f;  \n    resamp_crcf resamp = resamp_crcf_create(r,m,fc,As,npfb);\n    unsigned int p = (unsigned int) (40.0f / r);\n    unsigned int pulse_len = 4*p + 1;\n    float        pulse[pulse_len];\n    liquid_firdes_kaiser(pulse_len, 0.5*r*bw, 120, 0, pulse);\n    unsigned int  num_input  = pulse_len + 2*m + 1;\n    unsigned int  num_output = resamp_crcf_get_num_output(resamp, num_input);\n    float complex buf_0[num_input];  \n    float complex buf_1[num_output]; \n    unsigned int i;\n    for (i=0; i<num_input; i++)\n        buf_0[i] = i < pulse_len ? pulse[i]*bw : 0;\n    unsigned int nw = 0;\n    resamp_crcf_execute_block(resamp, buf_0, num_input, buf_1, &nw);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/resamp_crcf_%.2d.m"", _id);\n    liquid_autotest_validate_psd_signal(buf_1, nw, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    resamp_crcf_destroy(resamp);\n}\nvoid testbench_resamp_crcf_num_output(float _rate, unsigned int _npfb)\n{\n    if (liquid_autotest_verbose)\n        printf(""testing resamp_crcf_get_num_output() with r=%g, npfb=%u\\n"", _rate, _npfb);\n    float fc = 0.4f;\n    float As = 60.0f;\n    unsigned int m = 20;\n    resamp_crcf q = resamp_crcf_create(_rate, m, fc, As, _npfb);\n    unsigned int sizes[10] = {1, 2, 3, 20, 7, 64, 4, 4, 4, 27};\n    unsigned int max_input = 64;\n    unsigned int max_output = 16 + (unsigned int)(4.0f * max_input * _rate);\n    printf(""max_input : %u, max_output : %u\\n"", max_input, max_output);\n    float complex buf_0[max_input];\n    float complex buf_1[max_output];\n    unsigned int i;\n    for (i=0; i<max_input; i++)\n        buf_0[i] = 0.0f;\n    unsigned int b;\n    for (b=0; b<8; b++) {\n        for (i=0; i<10; i++) {\n            unsigned int num_input  = sizes[i];\n            unsigned int num_output = resamp_crcf_get_num_output(q, num_input);\n            unsigned int num_written;\n            resamp_crcf_execute_block(q, buf_0, num_input, buf_1, &num_written);\n            if (liquid_autotest_verbose) {\n                printf("" b[%2u][%2u], num_input:%5u, num_output:%5u, num_written:%5u\\n"",\n                        b, i, num_input, num_output, num_written);\n            }\n            CONTEND_EQUALITY(num_output, num_written)\n        }\n    }\n    resamp_crcf_destroy(q);\n}\nvoid autotest_resamp_crcf_num_output_1(){ testbench_resamp_crcf_num_output(1.00f,    256); }\n//...')
"
"('Prompt: You are working on a signal processing application and need to convert analog filter parameters (poles and zeros in complex form) to a discrete-time equivalent using bilinear transformation. Write a C function that takes in arrays of analog zeros (_za) and poles (_pa), their respective lengths (_nza and _npa), analog gain (_ka), mapping factor (_m), and outputs arrays of discrete-time zeros (_zd) and poles (_pd), as well as the discrete-time gain (_kd). Ensure the function also prints the resulting poles, zeros, and gain if debug print is enabled.","//...\nint bilinear_zpkf(float complex * _za,\n                  unsigned int    _nza,\n                  float complex * _pa,\n                  unsigned int    _npa,\n                  float complex   _ka,\n                  float           _m,\n                  float complex * _zd,\n                  float complex * _pd,\n                  float complex * _kd)\n{\n    unsigned int i;\n    unsigned int n = _npa;\n    float complex G = _ka;  \n    for (i=0; i<n; i++) {\n        if (i < _nza) {\n            float complex zm = _za[i] * _m;\n            _zd[i] = (1.0 + zm)/(1.0 - zm);\n        } else {\n            _zd[i] = -1.0;\n        }\n        float complex pm = _pa[i] * _m;\n        _pd[i] = (1.0 + pm)/(1.0 - pm);\n        G *= (1.0 - _pd[i])/(1.0 - _zd[i]);\n    }\n    *_kd = G;\n#if LIQUID_IIRDES_DEBUG_PRINT\n    printf(""zpk_a2df() poles (discrete):\\n"");\n    for (i=0; i<n; i++)\n        printf(""  pd[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(_pd[i]), cimagf(_pd[i]));\n    printf(""zpk_a2df() zeros (discrete):\\n"");\n    for (i=0; i<n; i++)\n        printf(""  zd[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(_zd[i]), cimagf(_zd[i]));\n    printf(""zpk_a2df() gain (discrete):\\n"");\n    printf(""  kd      = %12.8f + j*%12.8f\\n"", crealf(G), cimagf(G));\n#endif\n    return LIQUID_OK;\n}\n//...')
"
"'You could have given me the prompt: ""Develop a set of functions for managing the BEE (Bus Encryption Engine) hardware accelerator, including initialization, deinitialization, configuration setting, region key and nonce setting, status flags retrieval, and status flags clearing. Ensure proper alignment when copying memory in the aligned_memcpy function.""","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.bee""\n#endif\nstatic void aligned_memcpy(void *dst, const void *src, size_t size)\n{\n    register uint32_t *to32         = (uint32_t *)(uint32_t *)dst;\n    register const uint32_t *from32 = (const uint32_t *)(const uint32_t *)src;\n    while (size >= sizeof(uint32_t))\n    {\n        *to32 = *from32;\n        size -= sizeof(uint32_t);\n        to32++;\n        from32++;\n    }\n}\nvoid BEE_Init(BEE_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(kCLOCK_Bee);\n#endif\n    base->CTRL = BEE_CTRL_CTRL_SFTRST_N_MASK | BEE_CTRL_CTRL_CLK_EN_MASK;\n}\nvoid BEE_Deinit(BEE_Type *base)\n{\n    base->CTRL &=\n        ~(BEE_CTRL_BEE_ENABLE_MASK | BEE_CTRL_CTRL_SFTRST_N_MASK | BEE_CTRL_CTRL_CLK_EN_MASK | BEE_CTRL_KEY_VALID_MASK);\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_DisableClock(kCLOCK_Bee);\n#endif\n}\nvoid BEE_GetDefaultConfig(bee_region_config_t *config)\n{\n    assert(config);\n    (void)memset(config, 0, sizeof(*config));\n    config->region0Mode       = kBEE_AesCtrMode;\n    config->region1Mode       = kBEE_AesCtrMode;\n    config->region0AddrOffset = 0U;\n    config->region1AddrOffset = 0U;\n    config->region0SecLevel   = kBEE_SecurityLevel3;\n    config->region1SecLevel   = kBEE_SecurityLevel3;\n    config->region1Bot        = 0U;\n    config->region1Top        = 0U;\n    config->accessPermission  = kBEE_AccessProtDisabled;\n    config->endianSwapEn      = kBEE_EndianSwapEnabled;\n}\nvoid BEE_SetConfig(BEE_Type *base, const bee_region_config_t *config)\n{\n    uint32_t beeCtrlVal;\n    bool reenable = false;\n    while (0U == (BEE_GetStatusFlags(base) & (uint32_t)kBEE_IdleFlag))\n    {\n    }\n    if ((base->CTRL & BEE_CTRL_BEE_ENABLE_MASK) != 0U)\n    {\n        BEE_Disable(base);\n        reenable = true;\n    }\n    beeCtrlVal = base->CTRL & 0xFFFF0037U;\n    beeCtrlVal |= BEE_CTRL_AC_PROT_EN(config->accessPermission) | BEE_CTRL_LITTLE_ENDIAN(config->endianSwapEn) |\n                  BEE_CTRL_SECURITY_LEVEL_R0(config->region0SecLevel) | BEE_CTRL_CTRL_AES_MODE_R0(config->region0Mode) |\n                  BEE_CTRL_SECURITY_LEVEL_R1(config->region1SecLevel) | BEE_CTRL_CTRL_AES_MODE_R1(config->region1Mode);\n    base->CTRL         = beeCtrlVal;\n    base->ADDR_OFFSET0 = config->region0AddrOffset;\n    base->ADDR_OFFSET1 = config->region1AddrOffset;\n    base->REGION1_BOT  = config->region1Bot;\n    base->REGION1_TOP  = config->region1Top;\n    if (reenable)\n    {\n        BEE_Enable(base);\n    }\n}\nstatus_t BEE_SetRegionKey(BEE_Type *base, bee_region_t region, const uint8_t *key, size_t keySize)\n{\n    bool redisable = false;\n    if ((0U != ((uintptr_t)key & 0x3u)) || (keySize != 16U))\n    {\n        return kStatus_InvalidArgument;\n    }\n    while (0U == (BEE_GetStatusFlags(base) & (uint32_t)kBEE_IdleFlag))\n    {\n    }\n    base->CTRL &= ~BEE_CTRL_KEY_VALID_MASK;\n    aligned_memcpy((uint32_t *)(uint32_t)&base->AES_KEY0_W0, key, keySize);\n    if (0U == (base->CTRL & BEE_CTRL_BEE_ENABLE_MASK))\n    {\n        BEE_Enable(base);\n        redisable = true;\n    }\n    if (region == kBEE_Region0)\n    {\n        base->CTRL &= ~BEE_CTRL_KEY_REGION_SEL_MASK;\n    }\n    else if (region == kBEE_Region1)\n    {\n        base->CTRL |= BEE_CTRL_KEY_REGION_SEL_MASK;\n    }\n    else\n    {\n        return kStatus_InvalidArgument;\n    }\n    base->CTRL |= BEE_CTRL_KEY_VALID_MASK;\n    while (0U == (base->CTRL & BEE_CTRL_KEY_VALID_MASK))\n    {\n    }\n    if (redisable)\n    {\n        BEE_Disable(base);\n    }\n    return kStatus_Success;\n}\nstatus_t BEE_SetRegionNonce(BEE_Type *base, bee_region_t region, const uint8_t *nonce, size_t nonceSize)\n{\n    if ((0U != ((uintptr_t)nonce & 0x3u)) || (nonceSize != 16U))\n    {\n        return kStatus_InvalidArgument;\n    }\n    while (0U == (BEE_GetStatusFlags(base) & (uint32_t)kBEE_IdleFlag))\n    {\n    }\n    if (region == kBEE_Region0)\n    {\n        aligned_memcpy((uint32_t *)(uint32_t)&base->CTR_NONCE0_W0, nonce, nonceSize);\n    }\n    else if (region == kBEE_Region1)\n    {\n        aligned_memcpy((uint32_t *)(uint32_t)&base->CTR_NONCE1_W0, nonce, nonceSize);\n    }\n    else\n    {\n        return kStatus_InvalidArgument;\n    }\n    return kStatus_Success;\n}\nuint32_t BEE_GetStatusFlags(BEE_Type *base)\n{\n    return base->STATUS;\n}\nvoid BEE_ClearStatusFlags(BEE_Type *base, uint32_t mask)\n{\n    base->STATUS |= mask;\n}'"
"'Prompt: You are working on a C/C++ application that needs to remove a directory on a Windows platform. The code should handle different character encoding formats such as ANSI and UTF-8. Can you provide a function that takes a path as input and removes the directory using the appropriate encoding, with error handling included?","#define _CRT_SECURE_NO_WARNINGS 1 \n#define _UTF8_LIB_SOURCE \n#ifdef _WIN32\nint rmdirM(const char *path, UINT cp) {\n  int iErr;\n  BOOL bDone;\n  struct stat st;\n  WCHAR *pwszName;\n  DEBUG_ENTER((""rmdir(\\""%s\\"");\\n"", path));\n  iErr = lstat(path, &st);  \n  if (iErr) RETURN_INT(iErr);\n  if (!S_ISDIR(st.st_mode)) {\n    errno = ENOTDIR;\n    RETURN_INT_COMMENT(-1, (""Pathname exists, but is not a directory\\n""));\n  }\n  pwszName = MultiByteToNewWidePath(cp, path);\n  if (!pwszName) RETURN_INT_COMMENT(-1, (""errno=%d - %s\\n"", errno, strerror(errno)));\n  bDone = RemoveDirectoryW(pwszName);\n  free(pwszName);\n  if (bDone) {\n    RETURN_INT_COMMENT(0, (""Success\\n""));\n  } else {\n    errno = Win32ErrorToErrno();\n    RETURN_INT_COMMENT(-1, (""Failed\\n""));\n  }\n}\nint rmdirA(const char *path) {\n  return rmdirM(path, CP_ACP);\n}\nint rmdirU(const char *path) {\n  return rmdirM(path, CP_UTF8);\n}\n#endif '"
"'Prompt: In a scenario where you are working with a mixed codebase of POSIX threads and Win32 threads, you need to write a function that retrieves the Win32 thread handle associated with a pthread_t object in C. Please provide a code snippet to accomplish this task.",//...\nHANDLE\npthread_getw32threadhandle_np (pthread_t thread)\n{\n  return ((__ptw32_thread_t *)thread.p)->threadH;\n}\n//...'
"(""Prompt: Design a test scenario where you need to verify the functionality of creating spectrogram configurations with invalid parameters in a library. Your test should include creating spectrogram configurations with invalid window types, invalid window lengths, invalid nfft lengths, and negative sample rates. Additionally, make sure to use the testing framework's `CONTEND_ISNULL` and `CONTEND_INEQUALITY` macros to check for errors and warnings. Also, consider how the library reacts when running with strict exit enabled or error output suppression disabled.","//...\nvoid autotest_spgramcf_invalid_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping spgram config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(spgramcf_create(  0, LIQUID_WINDOW_HAMMING,       200, 200)); \n    CONTEND_ISNULL(spgramcf_create(  1, LIQUID_WINDOW_HAMMING,       200, 200)); \n    CONTEND_ISNULL(spgramcf_create(  2, LIQUID_WINDOW_HAMMING,       200, 200)); \n    CONTEND_ISNULL(spgramcf_create(400, LIQUID_WINDOW_HAMMING,         0, 200)); \n    CONTEND_ISNULL(spgramcf_create(400, LIQUID_WINDOW_UNKNOWN,       200, 200)); \n    CONTEND_ISNULL(spgramcf_create(400, LIQUID_WINDOW_NUM_FUNCTIONS, 200, 200)); \n    CONTEND_ISNULL(spgramcf_create(400, LIQUID_WINDOW_KBD,           201, 200)); \n    CONTEND_ISNULL(spgramcf_create(400, LIQUID_WINDOW_HAMMING,       200,   0)); \n    CONTEND_ISNULL(spgramcf_create_default(0)); \n    CONTEND_ISNULL(spgramcf_create_default(1)); \n    spgramcf q = spgramcf_create_default(540);\n    CONTEND_INEQUALITY(LIQUID_OK, spgramcf_set_rate(q, -10e6))\n    spgramcf_destroy(q);\n}\n//...')
"
"'Prompt: You are developing a multi-threaded application in C and need to implement a function that allows for timed exclusive writing access using a pthread read-write lock. Request the code for a function `pthread_rwlock_timedwrlock` that takes a pthread read-write lock and a timeout value as parameters, and attempts to acquire exclusive write access to the lock within the specified time. The function should return an integer indicating success or failure.","//...\nint\npthread_rwlock_timedwrlock (pthread_rwlock_t * rwlock,\n\t\t\t    const struct timespec *abstime)\n{\n  int result;\n  pthread_rwlock_t rwl;\n  if (rwlock == NULL || *rwlock == NULL)\n    {\n      return EINVAL;\n    }\n  if (*rwlock == PTHREAD_RWLOCK_INITIALIZER)\n    {\n      result = __ptw32_rwlock_check_need_init (rwlock);\n      if (result != 0 && result != EBUSY)\n\t{\n\t  return result;\n\t}\n    }\n  rwl = *rwlock;\n  if (rwl->nMagic !=  __PTW32_RWLOCK_MAGIC)\n    {\n      return EINVAL;\n    }\n  if ((result =\n       pthread_mutex_timedlock (&(rwl->mtxExclusiveAccess), abstime)) != 0)\n    {\n      return result;\n    }\n  if ((result =\n       pthread_mutex_timedlock (&(rwl->mtxSharedAccessCompleted),\n\t\t\t\tabstime)) != 0)\n    {\n      (void) pthread_mutex_unlock (&(rwl->mtxExclusiveAccess));\n      return result;\n    }\n  if (rwl->nExclusiveAccessCount == 0)\n    {\n      if (rwl->nCompletedSharedAccessCount > 0)\n\t{\n\t  rwl->nSharedAccessCount -= rwl->nCompletedSharedAccessCount;\n\t  rwl->nCompletedSharedAccessCount = 0;\n\t}\n      if (rwl->nSharedAccessCount > 0)\n\t{\n\t  rwl->nCompletedSharedAccessCount = -rwl->nSharedAccessCount;\n#if defined (__PTW32_CONFIG_MSVC7)\n#pragma inline_depth(0)\n#endif\n\t  pthread_cleanup_push (__ptw32_rwlock_cancelwrwait, (void *) rwl);\n\t  do\n\t    {\n\t      result =\n\t\tpthread_cond_timedwait (&(rwl->cndSharedAccessCompleted),\n\t\t\t\t\t&(rwl->mtxSharedAccessCompleted),\n\t\t\t\t\tabstime);\n\t    }\n\t  while (result == 0 && rwl->nCompletedSharedAccessCount < 0);\n\t  pthread_cleanup_pop ((result != 0) ? 1 : 0);\n#if defined (__PTW32_CONFIG_MSVC7)\n#pragma inline_depth()\n#endif\n\t  if (result == 0)\n\t    {\n\t      rwl->nSharedAccessCount = 0;\n\t    }\n\t}\n    }\n  if (result == 0)\n    {\n      rwl->nExclusiveAccessCount++;\n    }\n  return result;\n}\n//...'"
"('Prompt: You are working on testing a FIR filter implemented in C language for complex data type (cccf). You are asked to write a test function that applies the FIR filter to a specific test dataset. The dataset includes an impulse response array of size 4 (h4x8), an input data array of size 8 (x), and an expected output data array of size 8 (y). Write a function named `autotest_firfilt_cccf_data_h4x8` that calls the `firfilt_cccf_test` function with these arrays as parameters.","//...\nvoid autotest_firfilt_cccf_data_h4x8()\n{\n    firfilt_cccf_test(firfilt_cccf_data_h4x8_h, 4,\n                      firfilt_cccf_data_h4x8_x, 8,\n                      firfilt_cccf_data_h4x8_y, 8);\n}\n//...')
"
"'Prompt: Can you provide code for enabling, disabling, and configuring a Delay Block in an embedded system, with the condition that the SD module or QSPI module is enabled in the hardware abstraction layer?. . Technical Scenario: In an embedded system where the hardware abstraction layer defines either the SD module or QSPI module as enabled, we need to implement functions for enabling, disabling, and configuring a Delay Block. The provided code includes functions to enable, disable, and configure the Delay Block based on the specific hardware configuration.","#if defined(HAL_SD_MODULE_ENABLED) || defined(HAL_QSPI_MODULE_ENABLED)\n#define DLYB_TIMEOUT 0xFFU\nHAL_StatusTypeDef DelayBlock_Enable(DLYB_TypeDef *DLYBx)\n{\n  uint32_t unit = 0U;\n  uint32_t sel = 0U;\n  uint32_t sel_current;\n  uint32_t unit_current;\n  uint32_t tuning;\n  uint32_t lng_mask;\n  uint32_t tickstart;\n  DLYBx->CR = DLYB_CR_DEN | DLYB_CR_SEN;\n  for (sel_current = 0U; sel_current < DLYB_MAX_SELECT; sel_current++)\n  {\n    lng_mask = DLYB_CFGR_LNG_0 << sel_current;\n    tuning = 0U;\n    for (unit_current = 0U; unit_current < DLYB_MAX_UNIT; unit_current++)\n    {\n      DLYBx->CFGR = DLYB_MAX_SELECT | (unit_current << DLYB_CFGR_UNIT_Pos);\n      tickstart =  HAL_GetTick();\n      while ((DLYBx->CFGR & DLYB_CFGR_LNGF) == 0U)\n      {\n        if((HAL_GetTick() - tickstart) >=  DLYB_TIMEOUT)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n      if (tuning == 0U)\n      {\n        if ((DLYBx->CFGR & lng_mask) != 0U)\n        {\n          tuning = 1U;\n        }\n      }\n      else\n      {\n        if((DLYBx->CFGR & lng_mask ) == 0U)\n        {\n          if( unit == 0U )\n          {\n            unit = unit_current;\n            sel  = sel_current + 1U;\n          }\n          break;\n        }\n      }\n    }\n  }\n  DLYBx->CR   = 0U;\n  DLYBx->CR   = DLYB_CR_DEN | DLYB_CR_SEN;\n  DLYBx->CFGR = sel | (unit << DLYB_CFGR_UNIT_Pos);\n  DLYBx->CR   = DLYB_CR_DEN;\n  return HAL_OK;\n}\nHAL_StatusTypeDef DelayBlock_Disable(DLYB_TypeDef *DLYBx)\n{\n  DLYBx->CR = 0U;\n  return HAL_OK;\n}\nHAL_StatusTypeDef DelayBlock_Configure(DLYB_TypeDef *DLYBx,uint32_t PhaseSel, uint32_t Units )\n{\n  DLYBx->CR   = 0U;\n  DLYBx->CR   = DLYB_CR_DEN | DLYB_CR_SEN;\n  DLYBx->CFGR = PhaseSel | (Units << DLYB_CFGR_UNIT_Pos);\n  DLYBx->CR   = DLYB_CR_DEN;\n  return HAL_OK;\n}\n#endif '"
"('Prompt: You are tasked with implementing a function that performs a step in a 1-dimensional search algorithm. The function should take in a struct `qs1dsearch_s` object as input and update its state accordingly. The struct contains floating point variables `vn, va, v0, vb, vp`, as well as `un, ua, u0, ub, up`, an `init` flag, a function pointer `utility`, a `context` pointer, a `direction` flag, and a `num_steps` counter. . . The function should calculate new intermediate points (`va` and `vb`), evaluate the utility function at these points using the `utility` function pointer, and update the state of the struct based on the direction of optimization (minimize or maximize) and the utility values. The function should also increment the `num_steps` counter.. . Response:. ```C. struct qs1dsearch_s {.     float vn, va, v0, vb, vp","//...\nstruct qs1dsearch_s {\n    float vn, va, v0, vb, vp;   \n    float un, ua, u0, ub, up;   \n    int init;                   \n    liquid_utility_1d utility;   \n    void *            context;   \n    int               direction; \n    unsigned int      num_steps; \n};\nint qs1dsearch_step(qs1dsearch _q)\n{\n    if (!_q->init)\n        return liquid_error(LIQUID_ENOINIT,""qs1dsearch_step(), object has not be properly initialized"");\n    _q->va = 0.5f*(_q->vn + _q->v0);\n    _q->vb = 0.5f*(_q->v0 + _q->vp);\n    _q->ua = _q->utility(_q->va, _q->context);\n    _q->ub = _q->utility(_q->vb, _q->context);\n#if 0\n    printf("" %3u [%7.3f,%7.3f,%7.3f,%7.3f,%7.3f] : {%7.3f,%7.3f,%7.3f,%7.3f,%7.3f}\\n"",\n        _q->num_steps,\n        _q->vn, _q->va, _q->v0, _q->vb, _q->vp,\n        _q->un, _q->ua, _q->u0, _q->ub, _q->up);\n#endif\n    if ((_q->direction == LIQUID_OPTIM_MINIMIZE && _q->ua < _q->u0 && _q->ua < _q->ub) ||\n        (_q->direction == LIQUID_OPTIM_MAXIMIZE && _q->ua > _q->u0 && _q->ua > _q->ub))\n    {\n        _q->vp = _q->v0; _q->up = _q->u0;\n        _q->v0 = _q->va; _q->u0 = _q->ua;\n    } else\n    if ((_q->direction == LIQUID_OPTIM_MINIMIZE && _q->u0 < _q->ua && _q->u0 < _q->ub) ||\n        (_q->direction == LIQUID_OPTIM_MAXIMIZE && _q->u0 > _q->ua && _q->u0 > _q->ub))\n    {\n        _q->vn = _q->va; _q->un = _q->ua;\n        _q->vp = _q->vb; _q->up = _q->ub;\n    } else {\n        _q->vn = _q->v0; _q->un = _q->u0;\n        _q->v0 = _q->vb; _q->u0 = _q->ub;\n    }\n    _q->num_steps++;\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: ""I want to create a spinner on a screen in my LVGL application. The spinner should be of size 100x100 pixels and centered on the screen. Additionally, I want the spinner to have an animation with a duration of 10,000 milliseconds and a speed of 200 milliseconds. Can you provide me with the code snippet to achieve this?""","#if LV_USE_SPINNER && LV_BUILD_EXAMPLES\nvoid lv_example_spinner_1(void)\n{\n    lv_obj_t * spinner = lv_spinner_create(lv_screen_active());\n    lv_obj_set_size(spinner, 100, 100);\n    lv_obj_center(spinner);\n    lv_spinner_set_anim_params(spinner, 10000, 200);\n}\n#endif'"
"('Prompt: Develop a code snippet for a matrix factorization function using the Crout method. The function should decompose a given matrix into lower and upper triangular matrices. Verify the correctness of the decomposition by multiplying the resulting matrices and comparing the product with the original matrix. Also, ensure that the diagonal elements of the upper matrix are all 1, and the remaining elements are 0. Finally, test if the original matrix is equal to the product of the decomposed matrices within a given tolerance.","//...\nvoid autotest_matrixf_ludecomp_crout()\n{\n    float tol = 1e-6f;  \n    float L[64];\n    float U[64];\n    float P[64];\n    float LU_test[64];\n    matrixf_ludecomp_crout(matrixf_data_ludecomp_A, 8, 8, L, U, P);\n    matrixf_mul(L,       8, 8,\n                U,       8, 8,\n                LU_test, 8, 8);\n    if (liquid_autotest_verbose) {\n        printf(""ludecomp_crout:\\n"");\n        printf(""  A: "");        matrixf_print(matrixf_data_ludecomp_A,8,8);\n        printf(""  L: "");        matrixf_print(L,                      8,8);\n        printf(""  U: "");        matrixf_print(U,                      8,8);\n        printf(""  LU: "");       matrixf_print(LU_test,                8,8);\n    }\n    unsigned int r,c;\n    for (r=0; r<8; r++) {\n        for (c=0; c<8; c++) {\n            if (r < c) {\n                CONTEND_DELTA( matrix_access(L,8,8,r,c), 0.0f, tol );\n            } else if (r==c) {\n                CONTEND_DELTA( matrix_access(U,8,8,r,c), 1.0f, tol );\n            } else {\n                CONTEND_DELTA( matrix_access(U,8,8,r,c), 0.0f, tol );\n            }\n        }\n    }\n    unsigned int i;\n    for (i=0; i<64; i++)\n        CONTEND_DELTA( matrixf_data_ludecomp_A[i], LU_test[i], tol );\n}\n//...')
"
"('Prompt: You need to implement a function that calculates the minimum value of a function using one-dimensional search in a specific technical scenario. The function should take a float value and a void pointer as inputs and return a float value. Additionally, you need to create a test function that performs the one-dimensional search for a utility function, with specified values for optimization, bounds, and direction. The test function should iterate 32 times, print the details of the search if verbose mode is enabled, and then check the optimization values against expected values within a specified tolerance. Finally, you should create an automated test for the minimum value calculation function using the test function with specific arguments.","//...\nfloat qs1dsearch_umin(float _v, void * _context)\n{\n    float v_opt = *(float*)(_context);\n    float v = _v - v_opt;\n    return tanhf(v)*tanhf(v);\n}\nvoid test_qs1dsearch(liquid_utility_1d _utility,\n                     float             _v_opt,\n                     float             _v_lo,\n                     float             _v_hi,\n                     int               _bounds,\n                     int               _direction)\n{\n    qs1dsearch q = qs1dsearch_create(_utility, &_v_opt, _direction);\n    if (_bounds) qs1dsearch_init_bounds(q, _v_lo, _v_hi);\n    else         qs1dsearch_init       (q, _v_lo);\n    unsigned int i;\n    for (i=0; i<32; i++) {\n        qs1dsearch_step(q);\n        if (liquid_autotest_verbose)\n            qs1dsearch_print(q);\n    }\n    CONTEND_DELTA( qs1dsearch_get_opt_v(q), _v_opt,                    1e-3f );\n    CONTEND_DELTA( qs1dsearch_get_opt_u(q), _utility(_v_opt, &_v_opt), 1e-3f );\n    if (liquid_autotest_verbose) {\n        printf(""%3u : u(%12.8f) = %12.4e, v_opt=%12.4e (error=%12.4e)\\n"",\n            i, qs1dsearch_get_opt_v(q), qs1dsearch_get_opt_u(q),\n            _v_opt, _v_opt - qs1dsearch_get_opt_v(q));\n    }\n    qs1dsearch_destroy(q);\n}\nvoid autotest_qs1dsearch_min_07() { test_qs1dsearch(qs1dsearch_umin, 0,  20,  0, 0, LIQUID_OPTIM_MINIMIZE); }\n//...')
"
"('Prompt: Please provide code to calculate the elliptic integrals K and K prime for a given input value of k, number of iterations n, and store the results in the variables _K and _Kp. The algorithm should use Landen transformations and handle special cases for small k values. Make sure to include necessary definitions and imports.. . Response: . ```c. int landenf(float        _k,.             unsigned int _n,.             float *      _v). {.     unsigned int i;.     float k = _k;       .     float kp;           .     for (i=0; i<_n; i++) {.         kp = sqrtf(1 - k*k);.         k  = (1 - kp)/(1 + kp);.         _v[i] = k;.     }.     return LIQUID_OK;. }. . int ellipkf(float         _k,.              unsigned int _n,.              float *      _K,.              float *      _Kp","//...\n    for (i=0; i<_n; i++) {\n    for (i=_n; i>0; i--) {\n    for (i=_n; i>0; i--) {\n#define LIQUID_DEBUG_ELLIP_PRINT   0\n    float K, Kp;\n    unsigned int n=7;\n#define LIQUID_DEBUG_ELLIP_PRINT   0\n    for (i=0; i<L; i++) {\n    unsigned int r = ((unsigned int)N) % 2;\n    unsigned int t=0;\n    return LIQUID_OK;\nint landenf(float        _k,\n            unsigned int _n,\n            float *      _v)\n{\n    unsigned int i;\n    float k = _k;       \n    float kp;           \n    for (i=0; i<_n; i++) {\n        kp = sqrtf(1 - k*k);\n        k  = (1 - kp)/(1 + kp);\n        _v[i] = k;\n    }\n    return LIQUID_OK;\n}\nint ellipkf(float         _k,\n             unsigned int _n,\n             float *      _K,\n             float *      _Kp)\n{\n    float kmin = 4e-4f;\n    float kmax = sqrtf(1-kmin*kmin);\n    float K;\n    float Kp;\n    float kp = sqrtf(1-_k*_k);\n    if (_k > kmax) {\n        float L = -logf(0.25f*kp);\n        K = L + 0.25f*(L-1)*kp*kp;\n    } else {\n        float v[_n];\n        landenf(_k,_n,v);\n        K = M_PI * 0.5f;\n        unsigned int i;\n        for (i=0; i<_n; i++)\n            K *= (1 + v[i]);\n    }\n    if (_k < kmin) {\n        float L = -logf(_k*0.25f);\n        Kp = L + 0.25f*(L-1)*_k*_k;\n    } else {\n        float vp[_n];\n        landenf(kp,_n,vp);\n        Kp = M_PI * 0.5f;\n        unsigned int i;\n        for (i=0; i<_n; i++)\n            Kp *= (1 + vp[i]);\n    }\n    *_K  = K;\n    *_Kp = Kp;\n    return LIQUID_OK;\n}\n//...')
"
"('Provide a prompt requesting a code snippet that demonstrates the usage of a finite impulse response polyphase filter bank for a real, real, real valued signal processing operation. The code should include initialization, processing, and output generation.","#define OUTPUT_FILENAME ""firpfb_rrrf_example.m""\nint main(int argc, char*argv[]) {\n    unsigned int M           = 16;  \n    unsigned int m           =  4;  \n    unsigned int num_samples = 40;  \n    firpfb_rrrf pfb = firpfb_rrrf_create_default(M, m);\n    float buf_0[  num_samples];\n    float buf_1[M*num_samples];\n    unsigned int i, j;\n    for (i=0; i<num_samples; i++) {\n        buf_0[i] = rand() & 1 ? 1. : -1.;\n        firpfb_rrrf_push(pfb, buf_0[i]);\n        for (j=0; j<M; j++)\n            firpfb_rrrf_execute(pfb, j, buf_1 + i*M + j);\n    }\n    firpfb_rrrf_destroy(pfb);\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s: auto-generated file\\n\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all; close all;\\n\\n"");\n    fprintf(fid,""M = %u; m = %u; num_samples = %u\\n"", M, m, num_samples);\n    fprintf(fid,""x = zeros(1,  num_samples);\\n"");\n    fprintf(fid,""y = zeros(1,M*num_samples);\\n"");\n    for (i=0; i<  num_samples; i++) { fprintf(fid,""x(%3u) = %12.4e;\\n"", i+1, buf_0[i]); }\n    for (i=0; i<M*num_samples; i++) { fprintf(fid,""y(%3u) = %12.4e;\\n"", i+1, buf_1[i]); }\n    fprintf(fid,""tx = [0:(  num_samples-1)];\\n"");\n    fprintf(fid,""ty = [0:(M*num_samples-1)]/M - m;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""plot(ty,y,\'-k\',tx,x,\'ob\',\'MarkerSize\',2);\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""xlabel(\'Input Sample Index\');\\n"");\n    fprintf(fid,""ylabel(\'Signal\');\\n"");\n    fprintf(fid,""legend(\'Output\',\'Input\');\\n"");\n    fclose(fid);\n    printf(""results written to %s\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
('Prompt: Develop a C++ code that initializes a float array named `matrixf_data_ludecomp_A` with the provided elements representing a matrix for LU decomposition.,"float matrixf_data_ludecomp_A[] = {\n    0.936903119087 ,\n    1.048182249069 ,\n    0.464600890875 ,\n    1.122355699539 ,\n   -0.661124527454 ,\n   -0.953127145767 ,\n   -0.759313285351 ,\n    1.418183445930 ,\n   -0.272643178701 ,\n   -1.166662335396 ,\n    1.556591391563 ,\n   -0.323065608740 ,\n   -0.267991930246 ,\n    0.396302074194 ,\n    0.238355115056 ,\n   -0.437593698502 ,\n    0.431114047766 ,\n   -0.916567981243 ,\n    0.108782351017 ,\n   -0.714223206043 ,\n    0.197309300303 ,\n    1.105972766876 ,\n   -0.014590717852 ,\n    0.288964867592 ,\n    1.536642432213 ,\n    1.810190558434 ,\n    0.722570478916 ,\n    0.184841006994 ,\n   -0.239855647087 ,\n    0.494688391685 ,\n   -0.372100114822 ,\n   -0.754012823105 ,\n    0.139140784740 ,\n   -0.755531311035 ,\n    1.567769289017 ,\n   -0.774845600128 ,\n    1.536481976509 ,\n   -1.498587012291 ,\n    0.262655615807 ,\n   -1.045227766037 ,\n    0.445236086845 ,\n   -0.573900520802 ,\n    0.550646543503 ,\n    0.073093712330 ,\n    0.700358152390 ,\n    0.659417688847 ,\n    0.990632474422 ,\n   -0.596979260445 ,\n   -1.469601035118 ,\n   -1.366319775581 ,\n   -1.536668300629 ,\n    0.301474511623 ,\n    0.205486327410 ,\n    1.184612751007 ,\n    1.984294533730 ,\n    0.846946001053 ,\n   -0.780786097050 ,\n   -1.778358221054 ,\n   -0.621561229229 ,\n    0.809134125710 ,\n   -0.395780056715 ,\n    0.095775716007 ,\n    1.116999864578 ,\n   -0.937837302685 };')
"
"('Prompt: In a signal processing application, you are working on implementing a phase synchronization algorithm for a communication system. You need to write a function that retrieves the estimated phase offset stored in the `dphi_hat` attribute of a `qpilotsync` data structure. How would you write a C function that returns the value of `dphi_hat` from the given `qpilotsync` object?","//...\nfloat qpilotsync_get_dphi(qpilotsync _q)\n{\n    return _q->dphi_hat;\n}\n//...')
"
"'To receive information on how to create a set of functions to handle transfers in a FlexIO I2S driver using eDMA, you could have asked:. ""Can you provide me with a set of C functions that use eDMA to handle transfers in a FlexIO I2S driver, including initialization, callbacks, sending, receiving, and aborting transfer operations?"". . And the code provided would have been the appropriate response to this prompt.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.flexio_i2s_edma""\n#endif\n#define STCD_ADDR(address) (edma_tcd_t *)(((uint32_t)(address) + 32U) & ~0x1FU)\ntypedef struct _flexio_i2s_edma_private_handle\n{\n    FLEXIO_I2S_Type *base;\n    flexio_i2s_edma_handle_t *handle;\n} flexio_i2s_edma_private_handle_t;\nenum\n{\n    kFLEXIO_I2S_Busy = 0x0U, \n    kFLEXIO_I2S_Idle,        \n};\nstatic flexio_i2s_edma_private_handle_t s_edmaPrivateHandle[2];\nstatic void FLEXIO_I2S_TxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds);\nstatic void FLEXIO_I2S_RxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds);\nstatic void FLEXIO_I2S_TxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds)\n{\n    flexio_i2s_edma_private_handle_t *privHandle = (flexio_i2s_edma_private_handle_t *)userData;\n    flexio_i2s_edma_handle_t *flexio_i2sHandle   = privHandle->handle;\n    (void)memset(&flexio_i2sHandle->queue[flexio_i2sHandle->queueDriver], 0, sizeof(flexio_i2s_transfer_t));\n    flexio_i2sHandle->queueDriver = (flexio_i2sHandle->queueDriver + 1U) % FLEXIO_I2S_XFER_QUEUE_SIZE;\n    if (flexio_i2sHandle->callback != NULL)\n    {\n        (flexio_i2sHandle->callback)(privHandle->base, flexio_i2sHandle, kStatus_Success, flexio_i2sHandle->userData);\n    }\n    if (flexio_i2sHandle->queue[flexio_i2sHandle->queueDriver].data == NULL)\n    {\n        FLEXIO_I2S_TransferAbortSendEDMA(privHandle->base, flexio_i2sHandle);\n    }\n}\nstatic void FLEXIO_I2S_RxEDMACallback(edma_handle_t *handle, void *userData, bool done, uint32_t tcds)\n{\n    flexio_i2s_edma_private_handle_t *privHandle = (flexio_i2s_edma_private_handle_t *)userData;\n    flexio_i2s_edma_handle_t *flexio_i2sHandle   = privHandle->handle;\n    (void)memset(&flexio_i2sHandle->queue[flexio_i2sHandle->queueDriver], 0, sizeof(flexio_i2s_transfer_t));\n    flexio_i2sHandle->queueDriver = (flexio_i2sHandle->queueDriver + 1U) % FLEXIO_I2S_XFER_QUEUE_SIZE;\n    if (flexio_i2sHandle->callback != NULL)\n    {\n        (flexio_i2sHandle->callback)(privHandle->base, flexio_i2sHandle, kStatus_Success, flexio_i2sHandle->userData);\n    }\n    if (flexio_i2sHandle->queue[flexio_i2sHandle->queueDriver].data == NULL)\n    {\n        FLEXIO_I2S_TransferAbortReceiveEDMA(privHandle->base, flexio_i2sHandle);\n    }\n}\nvoid FLEXIO_I2S_TransferTxCreateHandleEDMA(FLEXIO_I2S_Type *base,\n                                           flexio_i2s_edma_handle_t *handle,\n                                           flexio_i2s_edma_callback_t callback,\n                                           void *userData,\n                                           edma_handle_t *dmaHandle)\n{\n    assert((handle != NULL) && (dmaHandle != NULL));\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->dmaHandle = dmaHandle;\n    handle->callback  = callback;\n    handle->userData  = userData;\n    handle->state = (uint32_t)kFLEXIO_I2S_Idle;\n    s_edmaPrivateHandle[0].base   = base;\n    s_edmaPrivateHandle[0].handle = handle;\n    EDMA_InstallTCDMemory(dmaHandle, STCD_ADDR(handle->tcd), FLEXIO_I2S_XFER_QUEUE_SIZE);\n    EDMA_SetCallback(dmaHandle, FLEXIO_I2S_TxEDMACallback, &s_edmaPrivateHandle[0]);\n}\nvoid FLEXIO_I2S_TransferRxCreateHandleEDMA(FLEXIO_I2S_Type *base,\n                                           flexio_i2s_edma_handle_t *handle,\n                                           flexio_i2s_edma_callback_t callback,\n                                           void *userData,\n                                           edma_handle_t *dmaHandle)\n{\n    assert((handle != NULL) && (dmaHandle != NULL));\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->dmaHandle = dmaHandle;\n    handle->callback  = callback;\n    handle->userData  = userData;\n    handle->state = (uint32_t)kFLEXIO_I2S_Idle;\n    s_edmaPrivateHandle[1].base   = base;\n    s_edmaPrivateHandle[1].handle = handle;\n    EDMA_InstallTCDMemory(dmaHandle, STCD_ADDR(handle->tcd), FLEXIO_I2S_XFER_QUEUE_SIZE);\n    EDMA_SetCallback(dmaHandle, FLEXIO_I2S_RxEDMACallback, &s_edmaPrivateHandle[1]);\n}\nvoid FLEXIO_I2S_TransferSetFormatEDMA(FLEXIO_I2S_Type *base,\n                                      flexio_i2s_edma_handle_t *handle,\n                                      flexio_i2s_format_t *format,\n                                      uint32_t srcClock_Hz)\n{\n    assert((handle != NULL) && (format != NULL));\n    if (srcClock_Hz != 0UL)\n    {\n        FLEXIO_I2S_MasterSetFormat(base, format, srcClock_Hz);\n    }\n    else\n    {\n        FLEXIO_I2S_SlaveSetFormat(base, format);\n    }\n    handle->bytesPerFrame = format->bitWidth / 8U;\n}\nstatus_t FLEXIO_I2S_TransferSendEDMA(FLEXIO_I2S_Type *base,\n                                     flexio_i2s_edma_handle_t *handle,\n                                     flexio_i2s_transfer_t *xfer)\n{\n    assert((handle != NULL) && (xfer != NULL));\n    edma_transfer_config_t config = {0};\n    uint32_t destAddr             = FLEXIO_I2S_TxGetDataRegisterAddress(base) + (4UL - handle->bytesPerFrame);\n    if ((xfer->data == NULL) || (xfer->dataSize == 0U))\n    {\n        return kStatus_InvalidArgument;\n    }\n    if (handle->queue[handle->queueUser].data != NULL)\n    {\n        return kStatus_FLEXIO_I2S_QueueFull;\n    }\n    handle->state = (uint32_t)kFLEXIO_I2S_Busy;\n    handle->queue[handle->queueUser].data     = xfer->data;\n    handle->queue[handle->queueUser].dataSize = xfer->dataSize;\n    handle->transferSize[handle->queueUser]   = xfer->dataSize;\n    handle->queueUser                         = (handle->queueUser + 1U) % FLEXIO_I2S_XFER_QUEUE_SIZE;\n    EDMA_PrepareTransfer(&config, xfer->data, handle->bytesPerFrame, (uint32_t *)destAddr, handle->bytesPerFrame,\n                         handle->bytesPerFrame, xfer->dataSize, kEDMA_MemoryToPeripheral);\n    handle->nbytes = handle->bytesPerFrame;\n    (void)EDMA_SubmitTransfer(handle->dmaHandle, &config);\n    EDMA_StartTransfer(handle->dmaHandle);\n    FLEXIO_I2S_TxEnableDMA(base, true);\n    FLEXIO_I2S_Enable(base, true);\n    return kStatus_Success;\n}\nstatus_t FLEXIO_I2S_TransferReceiveEDMA(FLEXIO_I2S_Type *base,\n                                        flexio_i2s_edma_handle_t *handle,\n                                        flexio_i2s_transfer_t *xfer)\n{\n    assert((handle != NULL) && (xfer != NULL));\n    edma_transfer_config_t config = {0};\n    uint32_t srcAddr              = FLEXIO_I2S_RxGetDataRegisterAddress(base);\n    if ((xfer->data == NULL) || (xfer->dataSize == 0U))\n    {\n        return kStatus_InvalidArgument;\n    }\n    if (handle->queue[handle->queueUser].data != NULL)\n    {\n        return kStatus_FLEXIO_I2S_QueueFull;\n    }\n    handle->state = (uint32_t)kFLEXIO_I2S_Busy;\n    handle->queue[handle->queueUser].data     = xfer->data;\n    handle->queue[handle->queueUser].dataSize = xfer->dataSize;\n    handle->transferSize[handle->queueUser]   = xfer->dataSize;\n    handle->queueUser                         = (handle->queueUser + 1U) % FLEXIO_I2S_XFER_QUEUE_SIZE;\n    EDMA_PrepareTransfer(&config, (uint32_t *)srcAddr, handle->bytesPerFrame, xfer->data, handle->bytesPerFrame,\n                         handle->bytesPerFrame, xfer->dataSize, kEDMA_PeripheralToMemory);\n    handle->nbytes = handle->bytesPerFrame;\n    (void)EDMA_SubmitTransfer(handle->dmaHandle, &config);\n    EDMA_StartTransfer(handle->dmaHandle);\n    FLEXIO_I2S_RxEnableDMA(base, true);\n    FLEXIO_I2S_Enable(base, true);\n    return kStatus_Success;\n}\nvoid FLEXIO_I2S_TransferAbortSendEDMA(FLEXIO_I2S_Type *base, flexio_i2s_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    EDMA_AbortTransfer(handle->dmaHandle);\n    FLEXIO_I2S_TxEnableDMA(base, false);\n    handle->state = (uint32_t)kFLEXIO_I2S_Idle;\n}\nvoid FLEXIO_I2S_TransferAbortReceiveEDMA(FLEXIO_I2S_Type *base, flexio_i2s_edma_handle_t *handle)\n{\n    assert(handle != NULL);\n    EDMA_AbortTransfer(handle->dmaHandle);\n    FLEXIO_I2S_RxEnableDMA(base, false);\n    handle->state = (uint32_t)kFLEXIO_I2S_Idle;\n}\nstatus_t FLEXIO_I2S_TransferGetSendCountEDMA(FLEXIO_I2S_Type *base, flexio_i2s_edma_handle_t *handle, size_t *count)\n{\n    assert(handle != NULL);\n    status_t status = kStatus_Success;\n    if (handle->state != (uint32_t)kFLEXIO_I2S_Busy)\n    {\n        status = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        *count = handle->transferSize[handle->queueDriver] -\n                 (uint32_t)handle->nbytes *\n                     EDMA_GetRemainingMajorLoopCount(handle->dmaHandle->base, handle->dmaHandle->channel);\n    }\n    return status;\n}\nstatus_t FLEXIO_I2S_TransferGetReceiveCountEDMA(FLEXIO_I2S_Type *base, flexio_i2s_edma_handle_t *handle, size_t *count)\n{\n    assert(handle != NULL);\n    status_t status = kStatus_Success;\n    if (handle->state != (uint32_t)kFLEXIO_I2S_Busy)\n    {\n        status = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        *count = handle->transferSize[handle->queueDriver] -\n                 (uint32_t)handle->nbytes *\n                     EDMA_GetRemainingMajorLoopCount(handle->dmaHandle->base, handle->dmaHandle->channel);\n    }\n    return status;\n}'"
"('The prompt for the code snippet you provided could be:. . ""You are working on a project that involves performing forward error correction using a sum-product algorithm. You need a function that implements the sum-product step of the algorithm. The function should take in various parameters including matrix dimensions, a sparse matrix, LLR values, and other necessary data structures. The function should iterate through the matrix, perform the necessary calculations, update the LLR values, and determine the parity of the data. Additionally, you need a higher-level function that calls the sum-product step function iteratively until a certain condition is met. Can you provide me with the code for both functions?""","//...\nint fec_sumproduct_step(unsigned int    _m,\n                        unsigned int    _n,\n                        smatrixb        _H,\n                        unsigned char * _c_hat,\n                        float *         _Lq,\n                        float *         _Lr,\n                        float *         _Lc,\n                        float *         _LQ,\n                        unsigned char * _parity)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int ip;\n    unsigned int jp;\n    float alpha_prod;\n    float phi_sum;\n    int parity_pass;\n    for (i=0; i<_n; i++) {\n        for (j=0; j<_m; j++) {\n            alpha_prod = 1.0f;\n            phi_sum    = 0.0f;\n            for (ip=0; ip<_n; ip++) {\n                if (smatrixb_get(_H,j,ip)==1 && i != ip) {\n                    float alpha = _Lq[j*_n+ip] > 0.0f ? 1.0f : -1.0f;\n                    float beta  = fabsf(_Lq[j*_n+ip]);\n                    phi_sum += sumproduct_phi(beta);\n                    alpha_prod *= alpha;\n                }\n            }\n            _Lr[j*_n+i] = alpha_prod * sumproduct_phi(phi_sum);\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(_Lq,_m,_n);\n    matrixf_print(_Lr,_m,_n);\n#endif\n    for (i=0; i<_n; i++) {\n        for (j=0; j<_m; j++) {\n            _Lq[j*_n+i] = _Lc[i];\n            for (jp=0; jp<_m; jp++) {\n                if (smatrixb_get(_H,jp,i)==1 && j != jp)\n                    _Lq[j*_n+i] += _Lr[jp*_n+i];\n            }\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(_Lq,_m,_n);\n#endif\n    for (i=0; i<_n; i++) {\n        _LQ[i] = _Lc[i];  \n        for (j=0; j<_m; j++) {\n            if (smatrixb_get(_H,j,i)==1)\n                _LQ[i] += _Lr[j*_n+i];\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(_LQ,1,_n);\n#endif\n    for (i=0; i<_n; i++)\n        _c_hat[i] = _LQ[i] < 0.0f ? 1 : 0;\n    smatrixb_vmul(_H, _c_hat, _parity);\n    parity_pass = 1;\n    for (j=0; j<_m; j++) {\n        if (_parity[j]) parity_pass = 0;\n    }\n#if DEBUG_SUMPRODUCT\n    printf(""    : c hat = ["");\n    for (i=0; i<_n; i++)\n        printf("" %1u"", _c_hat[i]);\n    printf("" ],  "");\n    printf(""parity = ["");\n    for (j=0; j<_m; j++)\n        printf("" %1u"", _parity[j]);\n    printf("" ],  "");\n    printf("" (%s)\\n"", parity_pass ? ""pass"" : ""FAIL"");\n#endif\n    return parity_pass;\n}\nfloat sumproduct_phi(float _x) {\n    return -logf(tanhf(_x/2.0f + 1e-12));\n}\nint fec_sumproduct(unsigned int    _m,\n                   unsigned int    _n,\n                   smatrixb        _H,\n                   float *         _LLR,\n                   unsigned char * _c_hat,\n                   unsigned int    _max_steps)\n{\n    if (_n == 0 || _m == 0)\n        return liquid_error(LIQUID_EICONFIG,""fec_sumproduct(), matrix dimensions cannot be zero"");\n    unsigned int num_iterations = 0;\n    float Lq[_m*_n];\n    float Lr[_m*_n];\n    float Lc[_n];\n    float LQ[_n];\n    unsigned char parity[_m];\n    unsigned int i;\n    unsigned int j;\n    int parity_pass;\n    int continue_running = 1;\n    for (i=0; i<_n; i++)\n        Lc[i] = _LLR[i];\n    for (j=0; j<_m; j++) {\n        for (i=0; i<_n; i++) {\n            Lq[j*_n+i] = smatrixb_get(_H,j,i) ? Lc[i] : 0.0f;\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(Lc,1,_n);\n#endif\n    while (continue_running) {\n#if DEBUG_SUMPRODUCT\n        printf(""\\n"");\n        printf(""************* iteration %u ****************\\n"", num_iterations);\n#endif\n        parity_pass = fec_sumproduct_step(_m,_n,_H,_c_hat,Lq,Lr,Lc,LQ,parity);\n        num_iterations++;\n        if (parity_pass || num_iterations == _max_steps)\n            continue_running = 0;\n    }\n    return parity_pass;\n}\nint fec_sumproduct_step(unsigned int    _m,\n                        unsigned int    _n,\n                        smatrixb        _H,\n                        unsigned char * _c_hat,\n                        float *         _Lq,\n                        float *         _Lr,\n                        float *         _Lc,\n                        float *         _LQ,\n                        unsigned char * _parity)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int ip;\n    unsigned int jp;\n    float alpha_prod;\n    float phi_sum;\n    int parity_pass;\n    for (i=0; i<_n; i++) {\n        for (j=0; j<_m; j++) {\n            alpha_prod = 1.0f;\n            phi_sum    = 0.0f;\n            for (ip=0; ip<_n; ip++) {\n                if (smatrixb_get(_H,j,ip)==1 && i != ip) {\n                    float alpha = _Lq[j*_n+ip] > 0.0f ? 1.0f : -1.0f;\n                    float beta  = fabsf(_Lq[j*_n+ip]);\n                    phi_sum += sumproduct_phi(beta);\n                    alpha_prod *= alpha;\n                }\n            }\n            _Lr[j*_n+i] = alpha_prod * sumproduct_phi(phi_sum);\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(_Lq,_m,_n);\n    matrixf_print(_Lr,_m,_n);\n#endif\n    for (i=0; i<_n; i++) {\n        for (j=0; j<_m; j++) {\n            _Lq[j*_n+i] = _Lc[i];\n            for (jp=0; jp<_m; jp++) {\n                if (smatrixb_get(_H,jp,i)==1 && j != jp)\n                    _Lq[j*_n+i] += _Lr[jp*_n+i];\n            }\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(_Lq,_m,_n);\n#endif\n    for (i=0; i<_n; i++) {\n        _LQ[i] = _Lc[i];  \n        for (j=0; j<_m; j++) {\n            if (smatrixb_get(_H,j,i)==1)\n                _LQ[i] += _Lr[j*_n+i];\n        }\n    }\n#if DEBUG_SUMPRODUCT\n    matrixf_print(_LQ,1,_n);\n#endif\n    for (i=0; i<_n; i++)\n        _c_hat[i] = _LQ[i] < 0.0f ? 1 : 0;\n    smatrixb_vmul(_H, _c_hat, _parity);\n    parity_pass = 1;\n    for (j=0; j<_m; j++) {\n        if (_parity[j]) parity_pass = 0;\n    }\n#if DEBUG_SUMPRODUCT\n    printf(""    : c hat = ["");\n    for (i=0; i<_n; i++)\n        printf("" %1u"", _c_hat[i]);\n    printf("" ],  "");\n    printf(""parity = ["");\n    for (j=0; j<_m; j++)\n        printf("" %1u"", _parity[j]);\n    printf("" ],  "");\n    printf("" (%s)\\n"", parity_pass ? ""pass"" : ""FAIL"");\n#endif\n    return parity_pass;\n}\n//...')
"
"('Prompt: Can you provide code that sets the header length for an OFDM flexible frame generator in a software-defined radio application? The function should update various parameters related to the header length, including creating/modifying certain objects and calculating symbol lengths based on the modulation scheme used.","//...\n    unsigned int M;         \n    unsigned char * p;      \n    unsigned int M_data;    \n    float complex * X;          \n    unsigned int num_symbols_header;    \n    modemcf mod_header;           \n    packetizer p_header;          \n    unsigned int num_symbols_header;    \n    unsigned char * header_enc;   \n    unsigned char * header_mod;   \n    unsigned int header_user_len; \n    unsigned int header_dec_len;  \n    unsigned int header_enc_len;  \n    unsigned int header_sym_len;  \n    ofdmflexframegenprops_s props;\n    ofdmflexframegenprops_s header_props;\nint ofdmflexframegen_set_header_len(ofdmflexframegen _q,\n                                    unsigned int     _len)\n{\n    _q->header_user_len = _len;\n    _q->header_dec_len = OFDMFLEXFRAME_H_DEC + _q->header_user_len;\n    _q->header = realloc(_q->header, _q->header_dec_len*sizeof(unsigned char));\n    if (_q->p_header) {\n        packetizer_destroy(_q->p_header);\n    }\n    _q->p_header = packetizer_create(_q->header_dec_len,\n                                     _q->header_props.check,\n                                     _q->header_props.fec0,\n                                     _q->header_props.fec1);\n    _q->header_enc_len = packetizer_get_enc_msg_len(_q->p_header);\n    _q->header_enc = realloc(_q->header_enc, _q->header_enc_len*sizeof(unsigned char));\n    unsigned int bps = modulation_types[_q->header_props.mod_scheme].bps;\n    div_t bps_d = div(_q->header_enc_len*8, bps);\n    _q->header_sym_len = bps_d.quot + (bps_d.rem ? 1 : 0);\n    _q->header_mod = realloc(_q->header_mod, _q->header_sym_len*sizeof(unsigned char));\n    if (_q->mod_header) {\n        modemcf_destroy(_q->mod_header);\n    }\n    _q->mod_header = modemcf_create(_q->header_props.mod_scheme);\n    div_t d = div(_q->header_sym_len, _q->M_data);\n    _q->num_symbols_header = d.quot + (d.rem ? 1 : 0);\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You need to implement a one-dimensional quasi-sequential search algorithm in C for optimization. The algorithm should have functions to create, copy, destroy, reset, initialize, set bounds, take a step, execute, and get information about the optimization process. The algorithm will rely on a utility callback function provided by the user to evaluate the objective function at different points. The optimization can either minimize or maximize the objective function based on the specified direction. You should structure the code such that it can handle the initialization and optimization process efficiently.","struct qs1dsearch_s {\n    float vn, va, v0, vb, vp;   \n    float un, ua, u0, ub, up;   \n    int init;                   \n    liquid_utility_1d utility;   \n    void *            context;   \n    int               direction; \n    unsigned int      num_steps; \n};\nqs1dsearch qs1dsearch_create(liquid_utility_1d _utility,\n                             void *            _context,\n                             int               _direction)\n{\n    if (_utility == NULL)\n        return liquid_error_config(""qs1dsearch_create(), utility callback cannot be NULL"");\n    qs1dsearch q = (qs1dsearch) malloc( sizeof(struct qs1dsearch_s) );\n    q->utility   = _utility;\n    q->context   = _context;\n    q->direction = _direction;\n    qs1dsearch_reset(q);\n    return q;\n}\nqs1dsearch qs1dsearch_copy(qs1dsearch _q)\n{\n    return NULL;\n}\nint qs1dsearch_destroy(qs1dsearch _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\nint qs1dsearch_print(qs1dsearch _q)\n{\n    printf(""<liquid.qs1dsearch{%12g,%12g,%12g}{%12g,%12g,%12g}>\\n"",\n        _q->vn, _q->v0, _q->vp, _q->un, _q->u0, _q->up);\n    return LIQUID_OK;\n}\nint qs1dsearch_reset(qs1dsearch _q)\n{\n    _q->init = 0;\n    _q->num_steps = 0;\n    return LIQUID_OK;\n}\nint qs1dsearch_init(qs1dsearch _q,\n                    float      _v)\n{\n    float step = 1e-16f;\n    if ( qs1dsearch_init_direction(_q, _v, step)==LIQUID_OK )\n        return LIQUID_OK;\n    if ( qs1dsearch_init_direction(_q, _v, -step)==LIQUID_OK )\n        return LIQUID_OK;\n    _q->vn = _v - step; _q->un =_q->utility(_q->vn, _q->context);\n    _q->v0 = _v;        _q->u0 =_q->utility(_q->v0, _q->context);\n    _q->vp = _v + step; _q->up =_q->utility(_q->vp, _q->context);\n    if ( (_q->direction == LIQUID_OPTIM_MINIMIZE && (_q->u0 < _q->un && _q->u0 < _q->up)) ||\n         (_q->direction == LIQUID_OPTIM_MAXIMIZE && (_q->u0 > _q->un && _q->u0 > _q->up)) )\n    {\n        _q->init = 1;\n        return LIQUID_OK;\n    }\n    return LIQUID_EIVAL;\n}\nint qs1dsearch_init_direction(qs1dsearch _q,\n                              float      _v_init,\n                              float      _step)\n{\n    float vn = _v_init;              float un = 0.0f;\n    float v0 = _v_init;              float u0 = _q->utility(v0, _q->context);\n    float vp = _v_init + _step*0.5f; float up = _q->utility(vp, _q->context);\n    unsigned int i;\n    for (i=0; i<180; i++) {\n        vn = v0; v0 = vp;\n        un = u0; u0 = up;\n        vp = v0 + _step;\n        up = _q->utility(vp, _q->context);\n        if ( (_q->direction == LIQUID_OPTIM_MINIMIZE && (u0 < un && u0 < up)) ||\n             (_q->direction == LIQUID_OPTIM_MAXIMIZE && (u0 > un && u0 > up)) )\n        {\n            int swap = (_step < 0);\n            _q->vn = swap ? vp : vn;\n            _q->v0 = v0;\n            _q->vp = swap ? vn : vp;\n            _q->un = swap ? up : un;\n            _q->u0 = u0;\n            _q->up = swap ? un : up;\n            _q->init = 1;\n            return LIQUID_OK;\n        } else\n        if ( (_q->direction == LIQUID_OPTIM_MINIMIZE && (u0 >= un && up > u0)) ||\n             (_q->direction == LIQUID_OPTIM_MAXIMIZE && (u0 <= un && up < u0)) )\n        {\n            break;\n        }\n        _step *= 1.5; \n    }\n    return LIQUID_EIVAL;\n}\nint qs1dsearch_init_bounds(qs1dsearch _q,\n                           float      _vn,\n                           float      _vp)\n{\n    _q->vn = _vn < _vp ? _vn : _vp;\n    _q->vp = _vn < _vp ? _vp : _vn;\n    _q->v0 = 0.5f*(_vn + _vp);\n    _q->un = _q->utility(_q->vn, _q->context);\n    _q->u0 = _q->utility(_q->v0, _q->context);\n    _q->up = _q->utility(_q->vp, _q->context);\n    _q->init = 1;\n    return LIQUID_OK;\n}\nint qs1dsearch_step(qs1dsearch _q)\n{\n    if (!_q->init)\n        return liquid_error(LIQUID_ENOINIT,""qs1dsearch_step(), object has not be properly initialized"");\n    _q->va = 0.5f*(_q->vn + _q->v0);\n    _q->vb = 0.5f*(_q->v0 + _q->vp);\n    _q->ua = _q->utility(_q->va, _q->context);\n    _q->ub = _q->utility(_q->vb, _q->context);\n#if 0\n    printf("" %3u [%7.3f,%7.3f,%7.3f,%7.3f,%7.3f] : {%7.3f,%7.3f,%7.3f,%7.3f,%7.3f}\\n"",\n        _q->num_steps,\n        _q->vn, _q->va, _q->v0, _q->vb, _q->vp,\n        _q->un, _q->ua, _q->u0, _q->ub, _q->up);\n#endif\n    if ((_q->direction == LIQUID_OPTIM_MINIMIZE && _q->ua < _q->u0 && _q->ua < _q->ub) ||\n        (_q->direction == LIQUID_OPTIM_MAXIMIZE && _q->ua > _q->u0 && _q->ua > _q->ub))\n    {\n        _q->vp = _q->v0; _q->up = _q->u0;\n        _q->v0 = _q->va; _q->u0 = _q->ua;\n    } else\n    if ((_q->direction == LIQUID_OPTIM_MINIMIZE && _q->u0 < _q->ua && _q->u0 < _q->ub) ||\n        (_q->direction == LIQUID_OPTIM_MAXIMIZE && _q->u0 > _q->ua && _q->u0 > _q->ub))\n    {\n        _q->vn = _q->va; _q->un = _q->ua;\n        _q->vp = _q->vb; _q->up = _q->ub;\n    } else {\n        _q->vn = _q->v0; _q->un = _q->u0;\n        _q->v0 = _q->vb; _q->u0 = _q->ub;\n    }\n    _q->num_steps++;\n    return LIQUID_OK;\n}\nint qs1dsearch_execute(qs1dsearch _q)\n{\n    return LIQUID_OK;\n}\nunsigned int qs1dsearch_get_num_steps(qs1dsearch _q)\n{\n    return _q->num_steps;\n}\nfloat qs1dsearch_get_opt_v(qs1dsearch _q)\n{\n    return _q->v0;\n}\nfloat qs1dsearch_get_opt_u(qs1dsearch _q)\n{\n    return _q->u0;\n}')
"
"'Prompt: ""A scenario where you need to initialize a pthread barrier attribute in a multi-threaded program using C. The program should allow for setting the shared mode of the barrier attribute to PTHREAD_PROCESS_PRIVATE. Please provide code for initializing the pthread barrier attribute in this scenario.""","//...\nint\npthread_barrierattr_init (pthread_barrierattr_t * attr)\n{\n  pthread_barrierattr_t ba;\n  int result = 0;\n  ba = (pthread_barrierattr_t) calloc (1, sizeof (*ba));\n  if (ba == NULL)\n    {\n      result = ENOMEM;\n    }\n  else\n    {\n      ba->pshared = PTHREAD_PROCESS_PRIVATE;\n    }\n  *attr = ba;\n  return (result);\n}\n//...'"
"('Please write a prompt for me where you need to write a function that tests the greatest common divisor (GCD) calculation functionality with specific inputs. The function should take three unsigned integer arguments - `_gcd`, `_p`, and `_q`. Inside the function, you need to calculate `P = _p * _gcd` and `Q = _q * _gcd`, then find the GCD of `P` and `Q` using the `liquid_gcd` function. Display the results with a message including the calculated GCD and the expected GCD.. . Scanario: A scenario where you need to test the functionality of calculating the greatest common divisor (GCD) of two numbers. You should write a testbench function that takes inputs for `_p`, `_q`, and the expected `_gcd`. Inside the testbench function, calculate `P = _p * _gcd` and `Q = _q * _gcd`, then determine the GCD of `P` and `","//...\nvoid testbench_gcd(unsigned int _gcd,\n                   unsigned int _p,\n                   unsigned int _q)\n{\n\tunsigned int P = _p * _gcd;\n\tunsigned int Q = _q * _gcd;\n\tunsigned int gcd_test = liquid_gcd(P,Q);\n    if (liquid_autotest_verbose)\n        printf(""  gcd(%12u,%12u) = %12u (expected %u)\\n"", P, Q, gcd_test, _gcd);\n    CONTEND_EQUALITY(gcd_test, _gcd);\n}\nvoid autotest_gcd_one()\n{\n    testbench_gcd( 1,  2,  3);\n    testbench_gcd( 1,  2,  5);\n    testbench_gcd( 1,  2,  7);\n    testbench_gcd( 1,  7,  2);\n    testbench_gcd( 1, 17, 19);\n    testbench_gcd( 1, 23, 31);\n    testbench_gcd( 1, 2*2*2*2*2, 3*5*7*19);\n}\n//...')
"
"('Prompt: Can you write a function that tests the copy functionality of a modem using the APSK4 modulation scheme?. Scenario: You are developing a communication system that involves multiple modems with different modulation schemes. You want to ensure that the copy functionality of a modem works correctly by creating two modems, copying one, and comparing the modulation and demodulation results between the original and copied modems using the APSK4 modulation scheme.","//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_apsk4()     { modemcf_test_copy(LIQUID_MODEM_APSK4);     }\n//...')
"
"('Prompt: You are working on a software to calculate Marcum Q-function values for a specific technical scenario where you need to handle two different cases based on the values of parameters. . . Response:. You can use the following code snippet to calculate Marcum Q-function values based on the given criteria in the technical scenario:. . ```c. float liquid_MarcumQf(int _M, float _alpha, float _beta). {.     float sigma = (float)(_M) + 2.0f*_alpha;.     float x = (_beta - _alpha - (float)_M) / (sigma*sigma);.     return erfcf(x);. }. . float liquid_MarcumQ1f(float _alpha, float _beta). {.     float t0 = expf(-0.5f*(_alpha*_alpha + _beta*_beta));.     float t1 = 1.0f;.     float a_div_b = _alpha / _beta;.     float a_mul_b","//...\nfloat liquid_MarcumQf(int _M,\n                      float _alpha,\n                      float _beta)\n{\n#if 0\n    return 0.0f\n#else\n    float sigma = (float)(_M) + 2.0f*_alpha;\n    float x = (_beta - _alpha - (float)_M) / (sigma*sigma);\n    return erfcf(x);\n#endif\n}\nfloat liquid_MarcumQ1f(float _alpha,\n                       float _beta)\n{\n#if 1\n    float t0 = expf( -0.5f*(_alpha*_alpha + _beta*_beta) );\n    float t1 = 1.0f;\n    float a_div_b = _alpha / _beta;\n    float a_mul_b = _alpha * _beta;\n    float y = 0.0f;\n    unsigned int k;\n    for (k=0; k<NUM_MARCUMQ1_ITERATIONS; k++) {\n        y += t1 * liquid_besselif((float)k, a_mul_b);\n        t1 *= a_div_b;\n    }\n    return t0 * y;\n#else\n    return liquid_MarcumQf(1, _alpha, _beta);\n#endif\n}\n//...')
"
"(""Prompt: Design and implement a testbench function to evaluate the performance of an equalizer using the NLMS algorithm in a communication system. The equalizer should be initialized differently based on a parameter 'init', and should adaptively update its coefficients based on a specified method. The testbench should take into account channel distortion and noise, and calculate the root mean square error (RMSE) for a given number of symbols. Use a QPSK modem with specific parameters.","//...\nvoid testbench_eqlms(unsigned int k, unsigned int m, float beta, int init,\n                     unsigned int p, float mu, unsigned int num_symbols,\n                     int update, int ms)\n{\n    unsigned int   i;\n    modemcf        mod    = modemcf_create(ms);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,k,m,beta,0);\n    float complex h[5] = {\n         1.00f +  0.00f*_Complex_I,\n         0.00f + -0.01f*_Complex_I,\n        -0.11f +  0.02f*_Complex_I,\n         0.02f +  0.01f*_Complex_I,\n        -0.09f + -0.04f*_Complex_I };\n    firfilt_cccf fchannel = firfilt_cccf_create(h,5);\n    float complex hp[2*k*p+1];\n    for (i=0; i<2*k*p+1; i++)\n        hp[i] = sincf( (float)i/(float)k - p) * liquid_hamming(i,2*k*p+1) / k;\n    eqlms_cccf eq;\n    switch (init) {\n    case 0: eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER,k,p,beta,0); break;\n    case 1: eq = eqlms_cccf_create_lowpass (2*k*p+1, 0.5f/(float)k); break;\n    case 2: eq = eqlms_cccf_create         (hp, 2*k*p+1); break; \n    default:eq = eqlms_cccf_create         (NULL, 2*k*p+1); break; \n    }\n    eqlms_cccf_set_bw(eq, mu);\n    float complex buf[k];                   \n    float complex sym_in, sym_out;          \n    wdelaycf buf_sym = wdelaycf_create(m+p);\n    float rmse = 0.0f; \n    for (i=0; i<2*num_symbols; i++) {\n        unsigned int sym = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod, sym, &sym_in);\n        wdelaycf_push(buf_sym, sym_in);\n        firinterp_crcf_execute(interp, sym_in, buf);\n        firfilt_cccf_execute_block(fchannel, buf, k, buf);\n        eqlms_cccf_decim_execute(eq, buf, &sym_out, k);\n        if (i < m + p) continue;\n        wdelaycf_read(buf_sym, &sym_in);\n        if (i < num_symbols) {\n            float complex d_hat;\n            unsigned int  index;\n            switch (update) {\n            case 0: eqlms_cccf_step(eq, sym_in, sym_out); break; \n            case 1: eqlms_cccf_step_blind(eq, sym_out);   break; \n            case 2:\n                modemcf_demodulate(mod, sym_out, &index);\n                modemcf_get_demodulator_sample(mod, &d_hat);\n                eqlms_cccf_step(eq, d_hat, sym_out);\n                break;\n            default:;\n            }\n            continue;\n        }\n        float error = cabsf(sym_in-sym_out);\n        rmse += error * error;\n#if 0\n        if (liquid_autotest_verbose) {\n            printf(""%3u : x = {%12.8f,%12.8f}, y = {%12.8f,%12.8f}, error=%12.8f %s\\n"",\n                    i, crealf(sym_in ), cimagf(sym_in ), crealf(sym_out), cimagf(sym_out),\n                    error, error > tol ? ""*"" : """");\n        }\n#endif\n    }\n    rmse = 10*log10f( rmse/num_symbols );\n    printf(""rmse : %.3f dB\\n"", rmse);\n    CONTEND_LESS_THAN(rmse, -20.0f);\n    wdelaycf_destroy(buf_sym);\n    firfilt_cccf_destroy(fchannel);\n    firinterp_crcf_destroy(interp);\n    eqlms_cccf_destroy(eq);\n    modemcf_destroy(mod);\n}\nvoid autotest_eqlms_01() { testbench_eqlms(2,7, 0.3,   0,7,0.3,800,     1,LIQUID_MODEM_QPSK); }\n//...')
"
"('You are working on developing a frame synchronization example utilizing frequency shift keying modulation. To continue with the development, share a prompt that includes the necessary options for modifying settings related to signal-to-noise ratio, carrier frequency offset, carrier phase offset, and fractional sample timing offset. This prompt should also provide an option to enable debugging.","#define OUTPUT_FILENAME  ""fskframesync_example.m""\nvoid usage()\n{\n    printf(""fskframesync_example [options]\\n"");\n    printf(""  h     : print usage\\n"");\n    printf(""  d     : enable debugging\\n"");\n    printf(""  S     : signal-to-noise ratio [dB], default: 20\\n"");\n    printf(""  F     : carrier frequency offset, default: 0\\n"");\n    printf(""  P     : carrier phase offset, default: 0\\n"");\n    printf(""  T     : fractional sample timing offset, default: 0.01\\n"");\n}\nstatic int callback(unsigned char *  _header,\n                    int              _header_valid,\n                    unsigned char *  _payload,\n                    unsigned int     _payload_len,\n                    int              _payload_valid,\n                    framesyncstats_s _stats,\n                    void *           _userdata);\nunsigned char header[8];\nunsigned char payload[200];\nint main(int argc, char*argv[])\n{\n    srand( time(NULL) );\n    float SNRdB       =  20.0f; \n    float noise_floor = -20.0f; \n    float dphi        =  0.01f; \n    float theta       =  0.0f;  \n    float dt          =  -0.2f;  \n    crc_scheme check         =  LIQUID_CRC_32;     \n    fec_scheme fec0          =  LIQUID_FEC_NONE;   \n    fec_scheme fec1          =  LIQUID_FEC_NONE;   \n    unsigned int payload_len =  200;               \n    int debug_enabled = 0;\n    int dopt;\n    while((dopt = getopt(argc,argv,""hdS:F:P:T:"")) != EOF){\n        switch (dopt) {\n        case \'h\': usage();              return 0;\n        case \'d\': debug_enabled = 1;    break;\n        case \'S\': SNRdB = atof(optarg); break;\n        case \'F\': dphi  = atof(optarg); break;\n        case \'P\': theta = atof(optarg); break;\n        case \'T\': dt    = atof(optarg); break;\n        default:\n            exit(-1);\n        }\n    }\n    printf(""channel offsets: dt=%.3f, dphi=%.3f, theta=%.3f\\n"", dt, dphi, theta);\n    float nstd  = powf(10.0f, noise_floor/20.0f);         \n    float gamma = powf(10.0f, (SNRdB+noise_floor)/20.0f); \n    fskframegen fg = fskframegen_create();\n    fskframegen_print(fg);\n    fskframesync fs = fskframesync_create(callback,NULL);\n    fskframesync_print(fs);\n    if (debug_enabled)\n        fskframesync_debug_enable(fs);\n    unsigned int i;\n    for (i=0; i<8; i++)\n        header[i] = i;\n    for (i=0; i<200; i++)\n        payload[i] = rand() & 0xff;\n    unsigned int  buf_len = 64;\n    float complex buf_tx[buf_len];  \n    float complex buf_rx[buf_len];  \n    fskframegen_assemble(fg, header, payload, payload_len, check, fec0, fec1);\n    unsigned int nfft  = 4200;\n    spgramcf periodogram = spgramcf_create_default(nfft);\n    int frame_complete = 0;\n    while (!frame_complete)\n    {\n        frame_complete = fskframegen_write_samples(fg, buf_tx, buf_len);\n        for (i=0; i<buf_len; i++)\n            buf_rx[i] = buf_tx[i]*gamma + nstd*(randnf() + randnf()*_Complex_I)*M_SQRT1_2;\n        fskframesync_execute_block(fs, buf_rx, buf_len);\n        spgramcf_write(periodogram, buf_rx, buf_len);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(periodogram, psd);\n    spgramcf_destroy(periodogram);\n    fskframegen_destroy(fg);\n    fskframesync_destroy(fs);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""nfft        = %u;\\n"", nfft);\n    fprintf(fid,""psd = zeros(1,nfft);\\n"");\n    for (i=0; i<nfft; i++)\n        fprintf(fid,""psd(%4u) = %12.8f;\\n"", i+1, psd[i]);\n    fprintf(fid,""figure(\'Color\',\'white\');\\n"");\n    fprintf(fid,""f = [0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""plot(f,psd,\'LineWidth\',1.5,\'Color\',[0.5 0 0]);\\n"");\n    fprintf(fid,""axis([-0.5 0.5 -30 30]);\\n"");\n    fprintf(fid,""xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}\nstatic int callback(unsigned char *  _header,\n                    int              _header_valid,\n                    unsigned char *  _payload,\n                    unsigned int     _payload_len,\n                    int              _payload_valid,\n                    framesyncstats_s _stats,\n                    void *           _userdata)\n{\n    printf(""*** callback invoked ***\\n"");\n    printf(""    error vector mag.   : %12.8f dB\\n"", _stats.evm);\n    printf(""    rssi                : %12.8f dB\\n"", _stats.rssi);\n    printf(""    carrier offset      : %12.8f\\n"", _stats.cfo);\n    printf(""    mod. scheme         : %s\\n"", modulation_types[_stats.mod_scheme].fullname);\n    printf(""    mod. depth          : %u\\n"", _stats.mod_bps);\n    printf(""    payload CRC         : %s\\n"", crc_scheme_str[_stats.check][1]);\n    printf(""    payload fec (inner) : %s\\n"", fec_scheme_str[_stats.fec0][1]);\n    printf(""    payload fec (outer) : %s\\n"", fec_scheme_str[_stats.fec1][1]);\n    printf(""    header crc          : %s\\n"", _header_valid ? ""pass"" : ""FAIL"");\n    printf(""    header data         : %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\\n"",\n            _header[0], _header[1], _header[2], _header[3],\n            _header[4], _header[5], _header[6], _header[7]);\n    printf(""    num header errors   : %u / %u\\n"",\n            count_bit_errors_array(_header, header, 8),\n            8*8);\n    printf(""    payload crc         : %s\\n"", _payload_valid ? ""pass"" : ""FAIL"");\n    printf(""    num payload errors  : %u / %u\\n"",\n            count_bit_errors_array(_payload, payload, 64),\n            64*8);\n    return 0;\n}')
"
"'Please provide a detailed technical scenario where you need to implement input device handling for a Windows platform using LVGL (Light and Versatile Graphics Library).. . In this scenario, you are developing a desktop application in Windows using LVGL for GUI. Your application requires handling different input devices such as a pointer (mouse), keypad, and encoder. You need to create functions to acquire and release these input devices for interaction with your LVGL-based GUI components.. . You need to implement functions to acquire a pointer, keypad, and encoder input devices for a specified display. These functions will create the necessary input devices and set up their callbacks for reading input data. The pointer device will handle mouse movements and clicks, the keypad device will handle key presses, and the encoder device will handle scroll wheel events.. . Additionally, you need to implement event callbacks for releasing each input device when it is no longer needed. These callbacks will reset the state of the input device and free any resources associated with it.. . Furthermore, you need to handle Windows","#if LV_USE_WINDOWS\nstatic void lv_windows_pointer_driver_read_callback(\n    lv_indev_t * indev,\n    lv_indev_data_t * data);\nstatic void lv_windows_release_pointer_device_event_callback(lv_event_t * e);\nstatic void lv_windows_keypad_driver_read_callback(\n    lv_indev_t * indev,\n    lv_indev_data_t * data);\nstatic void lv_windows_release_keypad_device_event_callback(lv_event_t * e);\nstatic void lv_windows_encoder_driver_read_callback(\n    lv_indev_t * indev,\n    lv_indev_data_t * data);\nstatic void lv_windows_release_encoder_device_event_callback(lv_event_t * e);\nHWND lv_windows_get_indev_window_handle(lv_indev_t * indev)\n{\n    return lv_windows_get_display_window_handle(lv_indev_get_display(indev));\n}\nlv_indev_t * lv_windows_acquire_pointer_indev(lv_display_t * display)\n{\n    HWND window_handle = lv_windows_get_display_window_handle(display);\n    if(!window_handle) {\n        return NULL;\n    }\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                window_handle);\n    if(!context) {\n        return NULL;\n    }\n    if(!context->pointer.indev) {\n        context->pointer.state = LV_INDEV_STATE_RELEASED;\n        context->pointer.point.x = 0;\n        context->pointer.point.y = 0;\n        context->pointer.indev = lv_indev_create();\n        if(context->pointer.indev) {\n            lv_indev_set_type(\n                context->pointer.indev,\n                LV_INDEV_TYPE_POINTER);\n            lv_indev_set_read_cb(\n                context->pointer.indev,\n                lv_windows_pointer_driver_read_callback);\n            lv_indev_set_display(\n                context->pointer.indev,\n                context->display_device_object);\n            lv_indev_add_event_cb(\n                context->pointer.indev,\n                lv_windows_release_pointer_device_event_callback,\n                LV_EVENT_DELETE,\n                context->pointer.indev);\n            lv_indev_set_group(\n                context->pointer.indev,\n                lv_group_get_default());\n        }\n    }\n    return context->pointer.indev;\n}\nlv_indev_t * lv_windows_acquire_keypad_indev(lv_display_t * display)\n{\n    HWND window_handle = lv_windows_get_display_window_handle(display);\n    if(!window_handle) {\n        return NULL;\n    }\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                window_handle);\n    if(!context) {\n        return NULL;\n    }\n    if(!context->keypad.indev) {\n        InitializeCriticalSection(&context->keypad.mutex);\n        _lv_ll_init(\n            &context->keypad.queue,\n            sizeof(lv_windows_keypad_queue_item_t));\n        context->keypad.utf16_high_surrogate = 0;\n        context->keypad.utf16_low_surrogate = 0;\n        context->keypad.indev = lv_indev_create();\n        if(context->keypad.indev) {\n            lv_indev_set_type(\n                context->keypad.indev,\n                LV_INDEV_TYPE_KEYPAD);\n            lv_indev_set_read_cb(\n                context->keypad.indev,\n                lv_windows_keypad_driver_read_callback);\n            lv_indev_set_display(\n                context->keypad.indev,\n                context->display_device_object);\n            lv_indev_add_event_cb(\n                context->keypad.indev,\n                lv_windows_release_keypad_device_event_callback,\n                LV_EVENT_DELETE,\n                context->keypad.indev);\n            lv_indev_set_group(\n                context->keypad.indev,\n                lv_group_get_default());\n        }\n    }\n    return context->keypad.indev;\n}\nlv_indev_t * lv_windows_acquire_encoder_indev(lv_display_t * display)\n{\n    HWND window_handle = lv_windows_get_display_window_handle(display);\n    if(!window_handle) {\n        return NULL;\n    }\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                window_handle);\n    if(!context) {\n        return NULL;\n    }\n    if(!context->encoder.indev) {\n        context->encoder.state = LV_INDEV_STATE_RELEASED;\n        context->encoder.enc_diff = 0;\n        context->encoder.indev = lv_indev_create();\n        if(context->encoder.indev) {\n            lv_indev_set_type(\n                context->encoder.indev,\n                LV_INDEV_TYPE_ENCODER);\n            lv_indev_set_read_cb(\n                context->encoder.indev,\n                lv_windows_encoder_driver_read_callback);\n            lv_indev_set_display(\n                context->encoder.indev,\n                context->display_device_object);\n            lv_indev_add_event_cb(\n                context->encoder.indev,\n                lv_windows_release_encoder_device_event_callback,\n                LV_EVENT_DELETE,\n                context->encoder.indev);\n            lv_indev_set_group(\n                context->encoder.indev,\n                lv_group_get_default());\n        }\n    }\n    return context->encoder.indev;\n}\nstatic void lv_windows_pointer_driver_read_callback(\n    lv_indev_t * indev,\n    lv_indev_data_t * data)\n{\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                lv_windows_get_indev_window_handle(indev));\n    if(!context) {\n        return;\n    }\n    data->state = context->pointer.state;\n    data->point = context->pointer.point;\n}\nstatic void lv_windows_release_pointer_device_event_callback(lv_event_t * e)\n{\n    lv_indev_t * indev = (lv_indev_t *)lv_event_get_user_data(e);\n    if(!indev) {\n        return;\n    }\n    HWND window_handle = lv_windows_get_indev_window_handle(indev);\n    if(!window_handle) {\n        return;\n    }\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                window_handle);\n    if(!context) {\n        return;\n    }\n    context->pointer.state = LV_INDEV_STATE_RELEASED;\n    context->pointer.point.x = 0;\n    context->pointer.point.y = 0;\n    context->pointer.indev = NULL;\n}\nstatic BOOL lv_windows_get_touch_input_info(\n    HTOUCHINPUT touch_input_handle,\n    UINT input_count,\n    PTOUCHINPUT inputs,\n    int item_size)\n{\n    HMODULE module_handle = GetModuleHandleW(L""user32.dll"");\n    if(!module_handle) {\n        return FALSE;\n    }\n    typedef BOOL(WINAPI * function_type)(HTOUCHINPUT, UINT, PTOUCHINPUT, int);\n    function_type function = (function_type)(\n                                 GetProcAddress(module_handle, ""GetTouchInputInfo""));\n    if(!function) {\n        return FALSE;\n    }\n    return function(touch_input_handle, input_count, inputs, item_size);\n}\nstatic BOOL lv_windows_close_touch_input_handle(\n    HTOUCHINPUT touch_input_handle)\n{\n    HMODULE module_handle = GetModuleHandleW(L""user32.dll"");\n    if(!module_handle) {\n        return FALSE;\n    }\n    typedef BOOL(WINAPI * function_type)(HTOUCHINPUT);\n    function_type function = (function_type)(\n                                 GetProcAddress(module_handle, ""CloseTouchInputHandle""));\n    if(!function) {\n        return FALSE;\n    }\n    return function(touch_input_handle);\n}\nbool lv_windows_pointer_device_window_message_handler(\n    HWND hWnd,\n    UINT uMsg,\n    WPARAM wParam,\n    LPARAM lParam,\n    LRESULT * plResult)\n{\n    switch(uMsg) {\n        case WM_MOUSEMOVE: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    int32_t hor_res = lv_display_get_horizontal_resolution(\n                                          context->display_device_object);\n                    int32_t ver_res = lv_display_get_vertical_resolution(\n                                          context->display_device_object);\n                    context->pointer.point.x = lv_windows_zoom_to_logical(\n                                                   GET_X_LPARAM(lParam),\n                                                   context->zoom_level);\n                    context->pointer.point.y = lv_windows_zoom_to_logical(\n                                                   GET_Y_LPARAM(lParam),\n                                                   context->zoom_level);\n                    if(context->simulator_mode) {\n                        context->pointer.point.x = lv_windows_dpi_to_logical(\n                                                       context->pointer.point.x,\n                                                       context->window_dpi);\n                        context->pointer.point.y = lv_windows_dpi_to_logical(\n                                                       context->pointer.point.y,\n                                                       context->window_dpi);\n                    }\n                    if(context->pointer.point.x < 0) {\n                        context->pointer.point.x = 0;\n                    }\n                    if(context->pointer.point.x > hor_res - 1) {\n                        context->pointer.point.x = hor_res - 1;\n                    }\n                    if(context->pointer.point.y < 0) {\n                        context->pointer.point.y = 0;\n                    }\n                    if(context->pointer.point.y > ver_res - 1) {\n                        context->pointer.point.y = ver_res - 1;\n                    }\n                }\n                break;\n            }\n        case WM_LBUTTONDOWN:\n        case WM_LBUTTONUP: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    context->pointer.state = (\n                                                 uMsg == WM_LBUTTONDOWN\n                                                 ? LV_INDEV_STATE_PRESSED\n                                                 : LV_INDEV_STATE_RELEASED);\n                }\n                break;\n            }\n        case WM_TOUCH: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    UINT input_count = LOWORD(wParam);\n                    HTOUCHINPUT touch_input_handle = (HTOUCHINPUT)(lParam);\n                    PTOUCHINPUT inputs = malloc(input_count * sizeof(TOUCHINPUT));\n                    if(inputs) {\n                        if(lv_windows_get_touch_input_info(\n                               touch_input_handle,\n                               input_count,\n                               inputs,\n                               sizeof(TOUCHINPUT))) {\n                            for(UINT i = 0; i < input_count; ++i) {\n                                POINT Point;\n                                Point.x = TOUCH_COORD_TO_PIXEL(inputs[i].x);\n                                Point.y = TOUCH_COORD_TO_PIXEL(inputs[i].y);\n                                if(!ScreenToClient(hWnd, &Point)) {\n                                    continue;\n                                }\n                                context->pointer.point.x = lv_windows_zoom_to_logical(\n                                                               Point.x,\n                                                               context->zoom_level);\n                                context->pointer.point.y = lv_windows_zoom_to_logical(\n                                                               Point.y,\n                                                               context->zoom_level);\n                                if(context->simulator_mode) {\n                                    context->pointer.point.x = lv_windows_dpi_to_logical(\n                                                                   context->pointer.point.x,\n                                                                   context->window_dpi);\n                                    context->pointer.point.y = lv_windows_dpi_to_logical(\n                                                                   context->pointer.point.y,\n                                                                   context->window_dpi);\n                                }\n                                DWORD MousePressedMask =\n                                    TOUCHEVENTF_MOVE | TOUCHEVENTF_DOWN;\n                                context->pointer.state = (\n                                                             inputs[i].dwFlags & MousePressedMask\n                                                             ? LV_INDEV_STATE_PRESSED\n                                                             : LV_INDEV_STATE_RELEASED);\n                            }\n                        }\n                        free(inputs);\n                    }\n                    lv_windows_close_touch_input_handle(touch_input_handle);\n                }\n                break;\n            }\n        default:\n            return false;\n    }\n    *plResult = 0;\n    return true;\n}\nstatic void lv_windows_keypad_driver_read_callback(\n    lv_indev_t * indev,\n    lv_indev_data_t * data)\n{\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                lv_windows_get_indev_window_handle(indev));\n    if(!context) {\n        return;\n    }\n    EnterCriticalSection(&context->keypad.mutex);\n    lv_windows_keypad_queue_item_t * current = (lv_windows_keypad_queue_item_t *)(\n                                                   _lv_ll_get_head(&context->keypad.queue));\n    if(current) {\n        data->key = current->key;\n        data->state = current->state;\n        _lv_ll_remove(&context->keypad.queue, current);\n        lv_free(current);\n        data->continue_reading = true;\n    }\n    LeaveCriticalSection(&context->keypad.mutex);\n}\nstatic void lv_windows_release_keypad_device_event_callback(lv_event_t * e)\n{\n    lv_indev_t * indev = (lv_indev_t *)lv_event_get_user_data(e);\n    if(!indev) {\n        return;\n    }\n    HWND window_handle = lv_windows_get_indev_window_handle(indev);\n    if(!window_handle) {\n        return;\n    }\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                window_handle);\n    if(!context) {\n        return;\n    }\n    DeleteCriticalSection(&context->keypad.mutex);\n    _lv_ll_clear(&context->keypad.queue);\n    context->keypad.utf16_high_surrogate = 0;\n    context->keypad.utf16_low_surrogate = 0;\n    context->keypad.indev = NULL;\n}\nstatic void lv_windows_push_key_to_keyboard_queue(\n    lv_windows_window_context_t * context,\n    uint32_t key,\n    lv_indev_state_t state)\n{\n    lv_windows_keypad_queue_item_t * current = (lv_windows_keypad_queue_item_t *)(\n                                                   _lv_ll_ins_tail(&context->keypad.queue));\n    if(current) {\n        current->key = key;\n        current->state = state;\n    }\n}\nstatic HIMC lv_windows_imm_get_context(\n    HWND window_handle)\n{\n    HMODULE module_handle = GetModuleHandleW(L""imm32.dll"");\n    if(!module_handle) {\n        return FALSE;\n    }\n    typedef HIMC(WINAPI * function_type)(HWND);\n    function_type function = (function_type)(\n                                 GetProcAddress(module_handle, ""ImmGetContext""));\n    if(!function) {\n        return FALSE;\n    }\n    return function(window_handle);\n}\nstatic BOOL lv_windows_imm_release_context(\n    HWND window_handle,\n    HIMC imm_context_handle)\n{\n    HMODULE module_handle = GetModuleHandleW(L""imm32.dll"");\n    if(!module_handle) {\n        return FALSE;\n    }\n    typedef BOOL(WINAPI * function_type)(HWND, HIMC);\n    function_type function = (function_type)(\n                                 GetProcAddress(module_handle, ""ImmReleaseContext""));\n    if(!function) {\n        return FALSE;\n    }\n    return function(window_handle, imm_context_handle);\n}\nstatic HIMC lv_windows_imm_associate_context(\n    HWND window_handle,\n    HIMC imm_context_handle)\n{\n    HMODULE module_handle = GetModuleHandleW(L""imm32.dll"");\n    if(!module_handle) {\n        return FALSE;\n    }\n    typedef HIMC(WINAPI * function_type)(HWND, HIMC);\n    function_type function = (function_type)(\n                                 GetProcAddress(module_handle, ""ImmAssociateContext""));\n    if(!function) {\n        return FALSE;\n    }\n    return function(window_handle, imm_context_handle);\n}\nstatic BOOL lv_windows_imm_set_composition_window(\n    HIMC imm_context_handle,\n    LPCOMPOSITIONFORM composition_form)\n{\n    HMODULE module_handle = GetModuleHandleW(L""imm32.dll"");\n    if(!module_handle) {\n        return FALSE;\n    }\n    typedef BOOL(WINAPI * function_type)(HIMC, LPCOMPOSITIONFORM);\n    function_type function = (function_type)(\n                                 GetProcAddress(module_handle, ""ImmSetCompositionWindow""));\n    if(!function) {\n        return FALSE;\n    }\n    return function(imm_context_handle, composition_form);\n}\nbool lv_windows_keypad_device_window_message_handler(\n    HWND hWnd,\n    UINT uMsg,\n    WPARAM wParam,\n    LPARAM lParam,\n    LRESULT * plResult)\n{\n    switch(uMsg) {\n        case WM_KEYDOWN:\n        case WM_KEYUP: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    EnterCriticalSection(&context->keypad.mutex);\n                    bool skip_translation = false;\n                    uint32_t translated_key = 0;\n                    switch(wParam) {\n                        case VK_UP:\n                            translated_key = LV_KEY_UP;\n                            break;\n                        case VK_DOWN:\n                            translated_key = LV_KEY_DOWN;\n                            break;\n                        case VK_LEFT:\n                            translated_key = LV_KEY_LEFT;\n                            break;\n                        case VK_RIGHT:\n                            translated_key = LV_KEY_RIGHT;\n                            break;\n                        case VK_ESCAPE:\n                            translated_key = LV_KEY_ESC;\n                            break;\n                        case VK_DELETE:\n                            translated_key = LV_KEY_DEL;\n                            break;\n                        case VK_BACK:\n                            translated_key = LV_KEY_BACKSPACE;\n                            break;\n                        case VK_RETURN:\n                            translated_key = LV_KEY_ENTER;\n                            break;\n                        case VK_TAB:\n                        case VK_NEXT:\n                            translated_key = LV_KEY_NEXT;\n                            break;\n                        case VK_PRIOR:\n                            translated_key = LV_KEY_PREV;\n                            break;\n                        case VK_HOME:\n                            translated_key = LV_KEY_HOME;\n                            break;\n                        case VK_END:\n                            translated_key = LV_KEY_END;\n                            break;\n                        default:\n                            skip_translation = true;\n                            break;\n                    }\n                    if(!skip_translation) {\n                        lv_windows_push_key_to_keyboard_queue(\n                            context,\n                            translated_key,\n                            ((uMsg == WM_KEYUP)\n                             ? LV_INDEV_STATE_RELEASED\n                             : LV_INDEV_STATE_PRESSED));\n                    }\n                    LeaveCriticalSection(&context->keypad.mutex);\n                }\n                break;\n            }\n        case WM_CHAR: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    EnterCriticalSection(&context->keypad.mutex);\n                    uint16_t raw_code_point = (uint16_t)(wParam);\n                    if(raw_code_point >= 0x20 && raw_code_point != 0x7F) {\n                        if(IS_HIGH_SURROGATE(raw_code_point)) {\n                            context->keypad.utf16_high_surrogate = raw_code_point;\n                        }\n                        else if(IS_LOW_SURROGATE(raw_code_point)) {\n                            context->keypad.utf16_low_surrogate = raw_code_point;\n                        }\n                        uint32_t code_point = raw_code_point;\n                        if(context->keypad.utf16_high_surrogate &&\n                           context->keypad.utf16_low_surrogate) {\n                            uint16_t high_surrogate =\n                                context->keypad.utf16_high_surrogate;\n                            uint16_t low_surrogate =\n                                context->keypad.utf16_low_surrogate;\n                            code_point = (low_surrogate & 0x03FF);\n                            code_point += (((high_surrogate & 0x03FF) + 0x40) << 10);\n                            context->keypad.utf16_high_surrogate = 0;\n                            context->keypad.utf16_low_surrogate = 0;\n                        }\n                        uint32_t lvgl_code_point =\n                            _lv_text_unicode_to_encoded(code_point);\n                        lv_windows_push_key_to_keyboard_queue(\n                            context,\n                            lvgl_code_point,\n                            LV_INDEV_STATE_PRESSED);\n                        lv_windows_push_key_to_keyboard_queue(\n                            context,\n                            lvgl_code_point,\n                            LV_INDEV_STATE_RELEASED);\n                    }\n                    LeaveCriticalSection(&context->keypad.mutex);\n                }\n                break;\n            }\n        case WM_IME_SETCONTEXT: {\n                if(wParam == TRUE) {\n                    HIMC imm_context_handle = lv_windows_imm_get_context(hWnd);\n                    if(imm_context_handle) {\n                        lv_windows_imm_associate_context(\n                            hWnd,\n                            imm_context_handle);\n                        lv_windows_imm_release_context(\n                            hWnd,\n                            imm_context_handle);\n                    }\n                }\n                *plResult = DefWindowProcW(hWnd, uMsg, wParam, wParam);\n                break;\n            }\n        case WM_IME_STARTCOMPOSITION: {\n                HIMC imm_context_handle = lv_windows_imm_get_context(hWnd);\n                if(imm_context_handle) {\n                    lv_obj_t * textarea_object = NULL;\n                    lv_obj_t * focused_object = lv_group_get_focused(\n                                                    lv_group_get_default());\n                    if(focused_object) {\n                        const lv_obj_class_t * object_class = lv_obj_get_class(\n                                                                  focused_object);\n                        if(object_class == &lv_textarea_class) {\n                            textarea_object = focused_object;\n                        }\n                        else if(object_class == &lv_keyboard_class) {\n                            textarea_object = lv_keyboard_get_textarea(focused_object);\n                        }\n                    }\n                    COMPOSITIONFORM composition_form;\n                    composition_form.dwStyle = CFS_POINT;\n                    composition_form.ptCurrentPos.x = 0;\n                    composition_form.ptCurrentPos.y = 0;\n                    if(textarea_object) {\n                        lv_textarea_t * textarea = (lv_textarea_t *)(textarea_object);\n                        lv_obj_t * label_object = lv_textarea_get_label(textarea_object);\n                        composition_form.ptCurrentPos.x =\n                            label_object->coords.x1 + textarea->cursor.area.x1;\n                        composition_form.ptCurrentPos.y =\n                            label_object->coords.y1 + textarea->cursor.area.y1;\n                    }\n                    lv_windows_imm_set_composition_window(\n                        imm_context_handle,\n                        &composition_form);\n                    lv_windows_imm_release_context(\n                        hWnd,\n                        imm_context_handle);\n                }\n                *plResult = DefWindowProcW(hWnd, uMsg, wParam, wParam);\n                break;\n            }\n        default:\n            return false;\n    }\n    *plResult = 0;\n    return true;\n}\nstatic void lv_windows_encoder_driver_read_callback(\n    lv_indev_t * indev,\n    lv_indev_data_t * data)\n{\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                lv_windows_get_indev_window_handle(indev));\n    if(!context) {\n        return;\n    }\n    data->state = context->encoder.state;\n    data->enc_diff = context->encoder.enc_diff;\n    context->encoder.enc_diff = 0;\n}\nstatic void lv_windows_release_encoder_device_event_callback(lv_event_t * e)\n{\n    lv_indev_t * indev = (lv_indev_t *)lv_event_get_user_data(e);\n    if(!indev) {\n        return;\n    }\n    HWND window_handle = lv_windows_get_indev_window_handle(indev);\n    if(!window_handle) {\n        return;\n    }\n    lv_windows_window_context_t * context = lv_windows_get_window_context(\n                                                window_handle);\n    if(!context) {\n        return;\n    }\n    context->encoder.state = LV_INDEV_STATE_RELEASED;\n    context->encoder.enc_diff = 0;\n    context->encoder.indev = NULL;\n}\nbool lv_windows_encoder_device_window_message_handler(\n    HWND hWnd,\n    UINT uMsg,\n    WPARAM wParam,\n    LPARAM lParam,\n    LRESULT * plResult)\n{\n    switch(uMsg) {\n        case WM_MBUTTONDOWN:\n        case WM_MBUTTONUP: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    context->encoder.state = (\n                                                 uMsg == WM_MBUTTONDOWN\n                                                 ? LV_INDEV_STATE_PRESSED\n                                                 : LV_INDEV_STATE_RELEASED);\n                }\n                break;\n            }\n        case WM_MOUSEWHEEL: {\n                lv_windows_window_context_t * context = (lv_windows_window_context_t *)(\n                                                            lv_windows_get_window_context(hWnd));\n                if(context) {\n                    context->encoder.enc_diff =\n                        -(GET_WHEEL_DELTA_WPARAM(wParam) / WHEEL_DELTA);\n                }\n                break;\n            }\n        default:\n            return false;\n    }\n    *plResult = 0;\n    return true;\n}\n#endif '"
('Create a prompt to obtain the code that initializes memory allocations for a struct used in an IIR filter implementation. The prompt should specify that the code need to allocate memory for various parameters of the IIR filter structure and initialize them to appropriate values.,"//...\n        q_copy->b = (TC *) malloc((q_copy->nb)*sizeof(TC));\n        q_copy->a = (TC *) malloc(3*(q_copy->nsos)*sizeof(TC));\n    _q->v[0] = v0;\n    unsigned int n;     \n        q_copy->dpb = DOTPROD(_copy)(q_orig->dpb);\n        q_copy->dpa = DOTPROD(_copy)(q_orig->dpa);\n        q_copy->qsos = (IIRFILTSOS()*) malloc( (q_copy->nsos)*sizeof(IIRFILTSOS()) );\n    unsigned int nsos;      \n    return q;\n    for (i=0; i<q->nb; i++)\n    unsigned int N = _order; \n    unsigned int L = (N-r)/2;   \n    for (i=0; i<q->nb; i++)\nvoid IIRFILT(_init)(IIRFILT() _q)\n{\n    _q->b    = NULL;\n    _q->a    = NULL;\n    _q->v    = NULL;\n    _q->qsos = NULL;\n    _q->nsos = 0;\n#if LIQUID_IIRFILT_USE_DOTPROD\n    _q->dpb  = NULL;\n    _q->dpa  = NULL;\n#endif\n}\n//...')
"
"('Prompt: You are developing a C code that involves a complex digital filter implementation. Please provide functions to evaluate the filter response and print out the zeros, poles, gain, and utility values for the filter. Make sure to implement the `gs_evaluate` function that calculates the utility value of the filter response based on certain criteria. Additionally, include the `gs_print` function to display the digital zeros, poles, gain, and utility values in a readable format.","//...\ntypedef struct gs_s * gs;\na = [1.00000000   0.06440119   0.31432679];\nb = [0.30749798   0.61379653   0.30749798];\nfloat gs_evaluate(gs _q, int _debug)\n{\n    float u = 0.0f;\n    unsigned int n;\n    for (n=0; n<_q->nfft; n++) {\n        float f = 0.5f * (float)n / (float)_q->nfft;\n        float D = 0.0f;\n        float W = 1.0f;\n        if (f < _q->fp) { \n            D = 1.0f; W = 1.0f;\n        } else if (f > _q->fs) { \n            D = 0.0f; W = 1.0f;\n        } else { \n            D = 0.0f; W = 0.0f;\n        }\n        float complex H = 1.0f;\n        unsigned int i;\n        for (i=0; i<_q->nsos; i++) {\n            float complex Hb =  _q->B[3*i+0] * cexpf(_Complex_I*2*M_PI*f*0) +\n                                _q->B[3*i+1] * cexpf(_Complex_I*2*M_PI*f*1) +\n                                _q->B[3*i+2] * cexpf(_Complex_I*2*M_PI*f*2);\n            float complex Ha =  _q->A[3*i+0] * cexpf(_Complex_I*2*M_PI*f*0) +\n                                _q->A[3*i+1] * cexpf(_Complex_I*2*M_PI*f*1) +\n                                _q->A[3*i+2] * cexpf(_Complex_I*2*M_PI*f*2);\n            H *= Hb / Ha;\n        }\n        float H_abs = crealf(H)*crealf(H) + cimagf(H)*cimagf(H);\n        float e = W * (D-H_abs)*(D-H_abs);\n        if (_debug)\n            printf("" %5u %8.6f %5.3f %16.13f %16.13f\\n"", n, f, D, H_abs, e);\n        u += e*e;\n        _q->H[n] = H_abs; \n    }\n    if (_debug) printf(""u = %12.8f\\n"", u);\n    _q->utility = u;\n    return _q->utility;\n}\nvoid gs_print(gs _q, int _debug)\n{\n    unsigned int i;\n    printf(""zeros (digital):\\n"");\n    for (i=0; i<_q->n; i++)\n        printf(""  zd[%3u] = %12.4e + j*%12.4e;\\n"", i, crealf(_q->zd[i]), cimagf(_q->zd[i]));\n    printf(""poles (digital):\\n"");\n    for (i=0; i<_q->n; i++)\n        printf(""  pd[%3u] = %12.4e + j*%12.4e;\\n"", i, crealf(_q->pd[i]), cimagf(_q->pd[i]));\n    printf(""gain (digital):\\n"");\n    printf(""  kd : %12.8f + j*%12.8f\\n"", crealf(_q->kd), cimagf(_q->kd));\n    printf(""  u  : %12.8f\\n"", _q->utility);\n    gs_evaluate(_q, 1);\n}\n//...')
"
"('Prompt: Can you provide me with functions to generate random numbers from a Weibull distribution and calculate the probability density function (PDF) and cumulative distribution function (CDF) for a Weibull distribution with given parameters alpha, beta, and gamma? Additionally, please include error handling for invalid input values of alpha and beta.","float randweibf(float _alpha,\n                float _beta,\n                float _gamma)\n{\n    if (_alpha <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf(), alpha must be greater than zero"");\n        return 0.0f;\n    } else if (_beta <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf(), beta must be greater than zero"");\n        return 0.0f;\n    }\n    float u;\n    do {\n        u = randf();\n    } while (u==0.0f);\n    return _gamma + _beta*powf( -logf(u), 1.0f/_alpha );\n}\nfloat randweibf_pdf(float _x,\n                    float _alpha,\n                    float _beta,\n                    float _gamma)\n{\n#ifdef LIQUID_VALIDATE_INPUT\n    if (_alpha <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf_pdf(), alpha must be greater than zero"");\n        return 0.0f;\n    } else if (_beta <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf_pdf(), beta must be greater than zero"");\n        return 0.0f;\n    }\n#endif\n    if (_x < _gamma)\n        return 0.0f;\n    float t = _x - _gamma;\n    return (_alpha/_beta) * powf(t/_beta, _alpha-1.0f) * expf( -powf(t/_beta, _alpha) );\n}\nfloat randweibf_cdf(float _x,\n                    float _alpha,\n                    float _beta,\n                    float _gamma)\n{\n#ifdef LIQUID_VALIDATE_INPUT\n    if (_alpha <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf_cdf(), alpha must be greater than zero"");\n        return 0.0f;\n    } else if (_beta <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf_cdf(), beta must be greater than zero"");\n        return 0.0f;\n    }\n#endif\n    if (_x <= _gamma)\n        return 0.0f;\n    return 1.0f - expf( -powf((_x-_gamma)/_beta, _alpha) );\n}')
"
"('Prompt: Imagine a scenario where you need to test the demodulation statistics of a 64-point arbitrary optimized modem. Write a function in C that performs this test by creating a modem with the specified modulation scheme, modulating and demodulating symbols, and checking the demodulator phase error. The function should verify that the output symbols match the input symbols and that the demodulator phase error is within certain bounds.","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_arb64opt() { modemcf_test_demodstats(LIQUID_MODEM_ARB64OPT); }\n//...')
"
"('Prompt: Design an infinite impulse response filter using different filter types and transformations. You need to specify the filter type, filter transformation, order, passband ripple, stopband attenuation, passband cut-off, center frequency, and output format. Your program should output the poles, zeros, gain, and group delay for the designed filter in both analog and digital forms.. . Response:Below is the code for the inifinite impulse response filter design based on the user-specified filter parameters:. ```c. #define OUTPUT_FILENAME ""iirdes_test.m"". void usage(). {.     printf(""iirdes_example -- infinite impulse response filter design\\n"");.     printf(""options (default values in []):\\n"");.     printf(""  -h          : print usage/help\\n"");.     printf(""  -t <type>   : filter type: [butter], cheby1, cheby2, ellip, bessel\\n"");.     printf(""  -b <type>   : filter transformation","#define OUTPUT_FILENAME ""iirdes_test.m""\nvoid usage()\n{\n    printf(""iirdes_example -- infinite impulse response filter design\\n"");\n    printf(""options (default values in []):\\n"");\n    printf(""  -h          : print usage/help\\n"");\n    printf(""  -t <type>   : filter type: [butter], cheby1, cheby2, ellip, bessel\\n"");\n    printf(""  -b <type>   : filter transformation: [LP], HP, BP, BS\\n"");\n    printf(""  -n <order>  : filter order, n > 0 [5]\\n"");\n    printf(""  -r <ripple> : passband ripple in dB (cheby1, ellip), r > 0 [1.0]\\n"");\n    printf(""  -s <atten>  : stopband attenuation in dB (cheby2, ellip), s > 0 [60.0]\\n"");\n    printf(""  -f <freq>   : passband cut-off, 0 < f < 0.5 [0.2]\\n"");\n    printf(""  -c <freq>   : center frequency (BP, BS cases), 0 < c < 0.5 [0.25]\\n"");\n    printf(""  -o <format> : format [sos], tf\\n"");\n    printf(""      sos - second-order sections form\\n"");\n    printf(""      tf  - regular transfer function form (potentially\\n"");\n    printf(""            unstable for large orders\\n"");\n}\nint main(int argc, char*argv[]) {\n    unsigned int n=5;       \n    float fc = 0.20f;       \n    float f0 = 0.25f;       \n    float As = 60.0f;       \n    float ripple = 1.0f;    \n    liquid_iirdes_filtertype ftype = LIQUID_IIRDES_BUTTER;\n    liquid_iirdes_bandtype btype = LIQUID_IIRDES_LOWPASS;\n    liquid_iirdes_format format = LIQUID_IIRDES_SOS;\n    int dopt;\n    while ((dopt = getopt(argc,argv,""uht:b:n:r:s:f:c:o:"")) != EOF) {\n        switch (dopt) {\n        case \'u\':\n        case \'h\':\n            usage();\n            return 0;\n        case \'t\':\n            if (strcmp(optarg,""butter"")==0) {\n                ftype = LIQUID_IIRDES_BUTTER;\n            } else if (strcmp(optarg,""cheby1"")==0) {\n                ftype = LIQUID_IIRDES_CHEBY1;\n            } else if (strcmp(optarg,""cheby2"")==0) {\n                ftype = LIQUID_IIRDES_CHEBY2;\n            } else if (strcmp(optarg,""ellip"")==0) {\n                ftype = LIQUID_IIRDES_ELLIP;\n            } else if (strcmp(optarg,""bessel"")==0) {\n                ftype = LIQUID_IIRDES_BESSEL;\n            } else {\n                fprintf(stderr,""error: iirdes_example, unknown filter type \\""%s\\""\\n"", optarg);\n                usage();\n                exit(1);\n            }\n            break;\n        case \'b\':\n            if (strcmp(optarg,""LP"")==0) {\n                btype = LIQUID_IIRDES_LOWPASS;\n            } else if (strcmp(optarg,""HP"")==0) {\n                btype = LIQUID_IIRDES_HIGHPASS;\n            } else if (strcmp(optarg,""BP"")==0) {\n                btype = LIQUID_IIRDES_BANDPASS;\n            } else if (strcmp(optarg,""BS"")==0) {\n                btype = LIQUID_IIRDES_BANDSTOP;\n            } else {\n                fprintf(stderr,""error: iirdes_example, unknown band type \\""%s\\""\\n"", optarg);\n                usage();\n                exit(1);\n            }\n            break;\n        case \'n\': n = atoi(optarg);         break;\n        case \'r\': ripple = atof(optarg);    break;\n        case \'s\': As = atof(optarg);        break;\n        case \'f\': fc = atof(optarg);        break;\n        case \'c\': f0 = atof(optarg);        break;\n        case \'o\':\n            if (strcmp(optarg,""sos"")==0) {\n                format = LIQUID_IIRDES_SOS;\n            } else if (strcmp(optarg,""tf"")==0) {\n                format = LIQUID_IIRDES_TF;\n            } else {\n                fprintf(stderr,""error: iirdes_example, unknown output format \\""%s\\""\\n"", optarg);\n                usage();\n                exit(1);\n            }\n            break;\n        default:\n            exit(1);\n        }\n    }\n    if (fc <= 0 || fc >= 0.5) {\n        fprintf(stderr,""error: %s, cutoff frequency out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    } else if (f0 < 0 || f0 > 0.5) {\n        fprintf(stderr,""error: %s, center frequency out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    } else if (ripple <= 0) {\n        fprintf(stderr,""error: %s, pass-band ripple out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    } else if (As <= 0) {\n        fprintf(stderr,""error: %s, stop-band ripple out of range\\n"", argv[0]);\n        usage();\n        exit(1);\n    }\n    unsigned int npa = n;\n    unsigned int nza;\n    float complex pa[n];\n    float complex za[n];\n    float complex ka;\n    float complex k0;\n    unsigned int r = n%2;\n    unsigned int L = (n-r)/2;\n    unsigned int i;\n    float epsilon, Gp, Gs, ep, es;\n    switch (ftype) {\n    case LIQUID_IIRDES_BUTTER:\n        printf(""Butterworth filter design:\\n"");\n        nza = 0;\n        k0 = 1.0f;\n        butter_azpkf(n,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_CHEBY1:\n        printf(""Cheby-I filter design:\\n"");\n        nza = 0;\n        epsilon = sqrtf( powf(10.0f, ripple / 10.0f) - 1.0f );\n        k0 = r ? 1.0f : 1.0f / sqrtf(1.0f + epsilon*epsilon);\n        cheby1_azpkf(n,epsilon,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_CHEBY2:\n        printf(""Cheby-II filter design:\\n"");\n        nza = 2*L;\n        epsilon = powf(10.0f, -As/20.0f);\n        k0 = 1.0f;\n        cheby2_azpkf(n,epsilon,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_ELLIP:\n        printf(""elliptic filter design:\\n"");\n        nza = 2*L;\n        Gp = powf(10.0f, -ripple  / 20.0f);\n        Gs = powf(10.0f, -As      / 20.0f);\n        printf(""  Gp = %12.8f\\n"", Gp);\n        printf(""  Gs = %12.8f\\n"", Gs);\n        ep = sqrtf(1.0f/(Gp*Gp) - 1.0f);\n        es = sqrtf(1.0f/(Gs*Gs) - 1.0f);\n        k0 = r ? 1.0f : 1.0f / sqrtf(1.0f + ep*ep);\n        ellip_azpkf(n,ep,es,za,pa,&ka);\n        break;\n    case LIQUID_IIRDES_BESSEL:\n        printf(""Bessel filter design:\\n"");\n        bessel_azpkf(n,za,pa,&ka);\n        k0 = 1.0f;\n        nza = 0;\n        break;\n    default:\n        fprintf(stderr,""error: iirdes_example: unknown filter type\\n"");\n        exit(1);\n    }\n    printf(""poles (analog):\\n"");\n    for (i=0; i<npa; i++)\n        printf(""  pa[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(pa[i]), cimagf(pa[i]));\n    printf(""zeros (analog):\\n"");\n    for (i=0; i<nza; i++)\n        printf(""  za[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(za[i]), cimagf(za[i]));\n    printf(""gain (analog):\\n"");\n    printf(""  ka : %12.8f + j*%12.8f\\n"", crealf(ka), cimagf(ka));\n    float complex zd[2*n];\n    float complex pd[2*n];\n    float complex kd;\n    float m = iirdes_freqprewarp(btype,fc,f0);\n    printf(""m : %12.8f\\n"", m);\n    bilinear_zpkf(za,    nza,\n                  pa,    npa,\n                  k0,    m,\n                  zd, pd, &kd);\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""nza = %u;\\n"", nza);\n    fprintf(fid,""npa = %u;\\n"", npa);\n    fprintf(fid,""za = zeros(1,nza);\\n"");\n    for (i=0; i<nza; i++)\n        fprintf(fid,""  za(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(za[i]), cimagf(za[i]));\n    fprintf(fid,""pa = zeros(1,npa);\\n"");\n    for (i=0; i<npa; i++)\n        fprintf(fid,""  pa(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(pa[i]), cimagf(pa[i]));\n    printf(""zeros (digital, low-pass prototype):\\n"");\n    for (i=0; i<n; i++)\n        printf(""  zd[%3u] = %12.4e + j*%12.4e;\\n"", i, crealf(zd[i]), cimagf(zd[i]));\n    printf(""poles (digital, low-pass prototype):\\n"");\n    for (i=0; i<n; i++)\n        printf(""  pd[%3u] = %12.4e + j*%12.4e;\\n"", i, crealf(pd[i]), cimagf(pd[i]));\n    printf(""gain (digital):\\n"");\n    printf(""  kd : %12.8f + j*%12.8f\\n"", crealf(kd), cimagf(kd));\n    if (btype == LIQUID_IIRDES_HIGHPASS ||\n        btype == LIQUID_IIRDES_BANDSTOP)\n    {\n        for (i=0; i<n; i++) {\n            zd[i] = -zd[i];\n            pd[i] = -pd[i];\n        }\n    }\n    if (btype == LIQUID_IIRDES_BANDPASS ||\n        btype == LIQUID_IIRDES_BANDSTOP)\n    {\n        float complex zd1[2*n];\n        float complex pd1[2*n];\n        iirdes_dzpk_lp2bp(zd, pd,   \n                          n,        \n                          f0,       \n                          zd1,pd1); \n        memmove(zd, zd1, 2*n*sizeof(float complex));\n        memmove(pd, pd1, 2*n*sizeof(float complex));\n        r = 0;\n        L = n;\n        n = 2*n;\n    }\n    fprintf(fid,""n=%u;\\n"", n);\n    fprintf(fid,""r=%u;\\n"", r);\n    fprintf(fid,""L=%u;\\n"", L);\n    fprintf(fid,""nfft=1024;\\n"");\n    fprintf(fid,""zd = zeros(1,n);\\n"");\n    fprintf(fid,""pd = zeros(1,n);\\n"");\n    for (i=0; i<n; i++) {\n        fprintf(fid,""  zd(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(zd[i]), cimagf(zd[i]));\n        fprintf(fid,""  pd(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(pd[i]), cimagf(pd[i]));\n    }\n    if (format == LIQUID_IIRDES_TF) {\n        float b[n+1];       \n        float a[n+1];       \n        iirdes_dzpk2tff(zd,pd,n,kd,b,a);\n        for (i=0; i<=n; i++) printf(""a[%3u] = %12.8f;\\n"", i, a[i]);\n        for (i=0; i<=n; i++) printf(""b[%3u] = %12.8f;\\n"", i, b[i]);\n        fprintf(fid,""a = zeros(1,n+1);\\n"");\n        fprintf(fid,""b = zeros(1,n+1);\\n"");\n        for (i=0; i<=n; i++) {\n            fprintf(fid,""a(%3u) = %12.4e;\\n"", i+1, a[i]);\n            fprintf(fid,""b(%3u) = %12.4e;\\n"", i+1, b[i]);\n        }\n        fprintf(fid,""\\n"");\n        fprintf(fid,""H = fft(b,nfft)./fft(a,nfft);\\n"");\n        fprintf(fid,""H = fftshift(H);\\n"");\n        fprintf(fid,""%% group delay\\n"");\n        fprintf(fid,""c = conv(b,fliplr(conj(a)));\\n"");\n        fprintf(fid,""cr = c.*[0:(length(c)-1)];\\n"");\n        fprintf(fid,""t0 = fftshift(fft(cr,nfft));\\n"");\n        fprintf(fid,""t1 = fftshift(fft(c, nfft));\\n"");\n        fprintf(fid,""polebins = find(abs(t1)<1e-6);\\n"");\n        fprintf(fid,""t0(polebins)=0;\\n"");\n        fprintf(fid,""t1(polebins)=1;\\n"");\n        fprintf(fid,""gd = real(t0./t1) - length(a) + 1;\\n"");\n    } else {\n        float A[3*(L+r)];\n        float B[3*(L+r)];\n        iirdes_dzpk2sosf(zd,pd,n,kd,B,A);\n        printf(""B [%u x 3] :\\n"", L+r);\n        for (i=0; i<L+r; i++)\n            printf(""  %12.8f %12.8f %12.8f\\n"", B[3*i+0], B[3*i+1], B[3*i+2]);\n        printf(""A [%u x 3] :\\n"", L+r);\n        for (i=0; i<L+r; i++)\n            printf(""  %12.8f %12.8f %12.8f\\n"", A[3*i+0], A[3*i+1], A[3*i+2]);\n        unsigned int j;\n        for (i=0; i<L+r; i++) {\n            for (j=0; j<3; j++) {\n                fprintf(fid,""B(%3u,%3u) = %16.8e;\\n"", i+1, j+1, B[3*i+j]);\n                fprintf(fid,""A(%3u,%3u) = %16.8e;\\n"", i+1, j+1, A[3*i+j]);\n            }\n        }\n        fprintf(fid,""\\n"");\n        fprintf(fid,""H = ones(1,nfft);\\n"");\n        fprintf(fid,""gd = zeros(1,nfft);\\n"");\n        fprintf(fid,""t0 = zeros(1,nfft);\\n"");\n        fprintf(fid,""t1 = zeros(1,nfft);\\n"");\n        fprintf(fid,""for i=1:(L+r),\\n"");\n        fprintf(fid,""    H = H .* fft(B(i,:),nfft)./fft(A(i,:),nfft);\\n"");\n        fprintf(fid,""    %% group delay\\n"");\n        fprintf(fid,""    c = conv(B(i,:),fliplr(conj(A(i,:))));\\n"");\n        fprintf(fid,""    cr = c.*[0:4];\\n"");\n        fprintf(fid,""    t0 = fftshift(fft(cr,nfft));\\n"");\n        fprintf(fid,""    t1 = fftshift(fft(c, nfft));\\n"");\n        fprintf(fid,""    polebins = find(abs(t1)<1e-6);\\n"");\n        fprintf(fid,""    t0(polebins)=0;\\n"");\n        fprintf(fid,""    t1(polebins)=1;\\n"");\n        fprintf(fid,""    gd = gd + real(t0./t1) - 2;\\n"");\n        fprintf(fid,""end;\\n"");\n        fprintf(fid,""H = fftshift(H);\\n"");\n    }\n    fprintf(fid,""\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""k=0:0.01:1;\\n"");\n    fprintf(fid,""ti = cos(2*pi*k);\\n"");\n    fprintf(fid,""tq = sin(2*pi*k);\\n"");\n    fprintf(fid,""plot(ti,tq,\'-\',\'LineWidth\',1,\'Color\',[1 1 1]*0.7,...\\n"");\n    fprintf(fid,""     real(zd),imag(zd),\'o\',\'LineWidth\',2,\'Color\',[0.5 0   0],\'MarkerSize\',2,...\\n"");\n    fprintf(fid,""     real(pd),imag(pd),\'x\',\'LineWidth\',2,\'Color\',[0   0.5 0],\'MarkerSize\',2);\\n"");\n    fprintf(fid,""xlabel(\'real\');\\n"");\n    fprintf(fid,""ylabel(\'imag\');\\n"");\n    fprintf(fid,""title(\'z-plane\');\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""axis([-1 1 -1 1]*1.2);\\n"");\n    fprintf(fid,""axis square;\\n"");\n    fprintf(fid,""f = [0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""  plot(f,gd,\'-\',\'Color\',[0 0.5 0],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  axis([0.0 0.5 0 ceil(1.1*max(gd))]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency\');\\n"");\n    fprintf(fid,""  ylabel(\'Group delay [samples]\');\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(2,1,1),\\n"");\n    fprintf(fid,""  plot(f,20*log10(abs(H)),\'-\',\'Color\',[0.5 0 0],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  axis([0.0 0.5 -4 1]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency\');\\n"");\n    fprintf(fid,""  ylabel(\'Filter PSD [dB]\');\\n"");\n    fprintf(fid,""subplot(2,1,2),\\n"");\n    fprintf(fid,""  plot(f,20*log10(abs(H)),\'-\',\'Color\',[0.5 0 0],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  axis([0.0 0.5 -100 10]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency\');\\n"");\n    fprintf(fid,""  ylabel(\'Filter PSD [dB]\');\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: Imagine you are implementing a testing framework for a digital communication system that involves demodulation. You need a function that tests the demodulation statistics for different modulation schemes. Write a test function that takes in a modulation scheme as an argument and performs demodulation on a set of symbols to calculate and check the demodulator phase error. Additionally, provide test functions for DPSK2 and DPSK256 schemes.","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_dpsk2()    { modemcf_test_demodstats(LIQUID_MODEM_DPSK2);    }\nvoid autotest_demodstats_dpsk256()  { modemcf_test_demodstats(LIQUID_MODEM_DPSK256);  }\n//...')
"
"(""Prompt: In a scenario where you need to test a GMSK detector for a sequence length of 256 bits, write a C code snippet that includes functions for running the test, creating, and destroying the GMSK detector. The test function should simulate the detector's operation, calculate various parameters, and check for detection accuracy.","//...\nvoid qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    unsigned char sequence[_sequence_len];\n    unsigned int i;\n    for (i=0; i<_sequence_len; i++)\n        sequence[i] = rand() & 0x01;\n    qdetector_cccf q = qdetector_cccf_create_gmsk(sequence, _sequence_len, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_gmsk_n256()    { qdetector_cccf_runtest_gmsk  ( 256); }\n//...')
"
"('Prompt: ""You need to test a digital communications library function that calculates the delay of a root-raised cosine filter. The function takes in the bandwidth and the filter order as parameters, creates the filter, writes samples to it, calculates the delay, and then measures the delay using the samples. You also need to perform an FFT on the samples to calculate a complex value \'p\'. Finally, compare the expected delay with the measured delay with a tolerance of 0.05. Can you write the test bench code for this scenario?""","//...\nvoid testbench_symstreamrcf_delay(float        _bw,\n                                  unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamrcf gen    = symstreamrcf_create_linear(ftype,_bw,_m,beta,ms);\n    float        delay  = symstreamrcf_get_delay(gen);\n    float        tol    = 0.05; \n    unsigned int  nfft = 2*(120 + (unsigned int)(delay/sqrtf(_bw)));\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    symstreamrcf_write_samples(gen, buf_time, 1);\n    symstreamrcf_set_gain(gen, 0.0f);\n    symstreamrcf_write_samples(gen, buf_time+1, nfft-1);\n    symstreamrcf_destroy(gen);\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    unsigned int m = 0.4 * _bw * nfft; \n    float complex p = 0.0f;\n    int i;\n    for (i=-(int)m; i<(int)m; i++)\n        p += buf_freq[(nfft+i)%nfft] * conjf(buf_freq[(nfft+i+1)%nfft]);\n    float delay_meas = cargf(p) * nfft / (2*M_PI);\n    if (liquid_autotest_verbose) {\n        printf(""expected delay: %.6f, measured: %.6f, err: %.6f (tol= %.3f)\\n"",\n                delay, delay_meas, delay-delay_meas,tol);\n    }\n    CONTEND_DELTA(delay, delay_meas, tol);\n}\nvoid autotest_symstreamrcf_delay_03() { testbench_symstreamrcf_delay(0.500f, 7); }\n//...')
"
"('Prompt: You are developing a signal processing application and need to implement a finite impulse response (FIR) filter with decimation. Provide C code that initializes three arrays `firdecim_rrrf_data_M3h7x30_h`, `firdecim_rrrf_data_M3h7x30_x`, and `firdecim_rrrf_data_M3h7x30_y` representing the filter coefficients, input signal, and output signal respectively. The filter coefficients are of length 7, input signal of length 30, and output signal of length 10. The values for the arrays are provided.","float firdecim_rrrf_data_M3h7x30_h[] = {\n   -0.074705344704,\n    0.020538592337,\n   -0.020061495576,\n    0.096703320953,\n    0.100160540368,\n    0.097166994081,\n    0.083888510566};\nfloat firdecim_rrrf_data_M3h7x30_x[] = {\n   -0.077089593357,\n    0.032375219181,\n    0.141488397385,\n    0.034405467968,\n   -0.138389144841,\n    0.154646756715,\n    0.086331166522,\n    0.041332691838,\n    0.091791117954,\n   -0.065105465675,\n    0.075745848821,\n    0.012475523017,\n   -0.107768670583,\n    0.233864631918,\n   -0.110944430251,\n   -0.060308141718,\n   -0.251948448147,\n    0.153274083486,\n   -0.114102376762,\n   -0.183548035449,\n   -0.152968693185,\n    0.049660839590,\n   -0.056844064619,\n   -0.153304122180,\n    0.018994945270,\n    0.000201893929,\n   -0.055497296237,\n    0.101173781919,\n   -0.050453255942,\n   -0.019320758294};\nfloat firdecim_rrrf_data_M3h7x30_y[] = {\n    0.005759004645,\n   -0.007768614835,\n    0.013680669269,\n    0.019197170461,\n    0.020943849985,\n   -0.009738613503,\n    0.013465672357,\n   -0.028391740957,\n   -0.041353046024,\n   -0.023577651344};')
"
"'To receive the provided code as a response, you could have prompted me with the following technical scenario:. . ""You are working on integrating a vector graphics library (ThorVG) with LittlevGL (LVGL) in a project. The project requires converting LVGL data structures to ThorVG data structures for drawing vector graphics. You need to implement functions for converting LVGL area structures to ThorVG rectangle structures, LVGL color structures to ThorVG color structures, and LVGL matrix structures to ThorVG matrix structures. Additionally, you need to handle setting up paint properties, shapes, gradients, strokes, fills, and blend modes for drawing vector graphics. Lastly, you need to create a function to draw vector graphics using a software canvas in the LVGL layer\'s draw buffer.""","#if LV_USE_VECTOR_GRAPHIC && LV_USE_THORVG\n#if LV_USE_THORVG_EXTERNAL\n#else\n#endif\ntypedef struct {\n    float x;\n    float y;\n    float w;\n    float h;\n} _tvg_rect;\ntypedef struct {\n    uint8_t r;\n    uint8_t g;\n    uint8_t b;\n    uint8_t a;\n} _tvg_color;\nstatic void _lv_area_to_tvg(_tvg_rect * rect, const lv_area_t * area)\n{\n    rect->x = area->x1;\n    rect->y = area->y1;\n    rect->w = lv_area_get_width(area);\n    rect->h = lv_area_get_height(area);\n}\nstatic void _lv_color_to_tvg(_tvg_color * color, const lv_color32_t * c, lv_opa_t opa)\n{\n    color->r = c->red;\n    color->g = c->green;\n    color->b = c->blue;\n    color->a = LV_OPA_MIX2(c->alpha, opa);\n}\nstatic void _lv_matrix_to_tvg(Tvg_Matrix * tm, const lv_matrix_t * m)\n{\n    tm->e11 = m->m[0][0];\n    tm->e12 = m->m[0][1];\n    tm->e13 = m->m[0][2];\n    tm->e21 = m->m[1][0];\n    tm->e22 = m->m[1][1];\n    tm->e23 = m->m[1][2];\n    tm->e31 = m->m[2][0];\n    tm->e32 = m->m[2][1];\n    tm->e33 = m->m[2][2];\n}\nstatic void _set_paint_matrix(Tvg_Paint * obj, const Tvg_Matrix * m)\n{\n    tvg_paint_set_transform(obj, m);\n}\nstatic void _set_paint_shape(Tvg_Paint * obj, const lv_vector_path_t * p)\n{\n    uint32_t pidx = 0;\n    lv_vector_path_op_t * op = lv_array_front(&p->ops);\n    uint32_t size = lv_array_size(&p->ops);\n    for(uint32_t i = 0; i < size; i++) {\n        switch(op[i]) {\n            case LV_VECTOR_PATH_OP_MOVE_TO: {\n                    lv_fpoint_t * pt = lv_array_at(&p->points, pidx);\n                    tvg_shape_move_to(obj, pt->x, pt->y);\n                    pidx += 1;\n                }\n                break;\n            case LV_VECTOR_PATH_OP_LINE_TO: {\n                    lv_fpoint_t * pt = lv_array_at(&p->points, pidx);\n                    tvg_shape_line_to(obj, pt->x, pt->y);\n                    pidx += 1;\n                }\n                break;\n            case LV_VECTOR_PATH_OP_QUAD_TO: {\n                    lv_fpoint_t * pt1 = lv_array_at(&p->points, pidx);\n                    lv_fpoint_t * pt2 = lv_array_at(&p->points, pidx + 1);\n                    lv_fpoint_t * last_pt = lv_array_at(&p->points, pidx - 1);\n                    lv_fpoint_t cp[2];\n                    cp[0].x = (last_pt->x + 2 * pt1->x) * (1.0f / 3.0f);\n                    cp[0].y = (last_pt->y + 2 * pt1->y) * (1.0f / 3.0f);\n                    cp[1].x = (pt2->x + 2 * pt1->x) * (1.0f / 3.0f);\n                    cp[1].y = (pt2->y + 2 * pt1->y) * (1.0f / 3.0f);\n                    tvg_shape_cubic_to(obj, cp[0].x, cp[0].y, cp[1].x, cp[1].y, pt2->x, pt2->y);\n                    pidx += 2;\n                }\n                break;\n            case LV_VECTOR_PATH_OP_CUBIC_TO: {\n                    lv_fpoint_t * pt1 = lv_array_at(&p->points, pidx);\n                    lv_fpoint_t * pt2 = lv_array_at(&p->points, pidx + 1);\n                    lv_fpoint_t * pt3 = lv_array_at(&p->points, pidx + 2);\n                    tvg_shape_cubic_to(obj, pt1->x, pt1->y, pt2->x, pt2->y, pt3->x, pt3->y);\n                    pidx += 3;\n                }\n                break;\n            case LV_VECTOR_PATH_OP_CLOSE: {\n                    tvg_shape_close(obj);\n                }\n                break;\n        }\n    }\n}\nstatic Tvg_Stroke_Cap _lv_stroke_cap_to_tvg(lv_vector_stroke_cap_t cap)\n{\n    switch(cap) {\n        case LV_VECTOR_STROKE_CAP_SQUARE:\n            return TVG_STROKE_CAP_SQUARE;\n        case LV_VECTOR_STROKE_CAP_ROUND:\n            return TVG_STROKE_CAP_ROUND;\n        case LV_VECTOR_STROKE_CAP_BUTT:\n            return TVG_STROKE_CAP_BUTT;\n        default:\n            return TVG_STROKE_CAP_SQUARE;\n    }\n}\nstatic Tvg_Stroke_Join _lv_stroke_join_to_tvg(lv_vector_stroke_join_t join)\n{\n    switch(join) {\n        case LV_VECTOR_STROKE_JOIN_BEVEL:\n            return TVG_STROKE_JOIN_BEVEL;\n        case LV_VECTOR_STROKE_JOIN_ROUND:\n            return TVG_STROKE_JOIN_ROUND;\n        case LV_VECTOR_STROKE_JOIN_MITER:\n            return TVG_STROKE_JOIN_MITER;\n        default:\n            return TVG_STROKE_JOIN_BEVEL;\n    }\n}\nstatic Tvg_Stroke_Fill _lv_spread_to_tvg(lv_vector_gradient_spread_t sp)\n{\n    switch(sp) {\n        case LV_VECTOR_GRADIENT_SPREAD_PAD:\n            return TVG_STROKE_FILL_PAD;\n        case LV_VECTOR_GRADIENT_SPREAD_REPEAT:\n            return TVG_STROKE_FILL_REPEAT;\n        case LV_VECTOR_GRADIENT_SPREAD_REFLECT:\n            return TVG_STROKE_FILL_REFLECT;\n        default:\n            return TVG_STROKE_FILL_PAD;\n    }\n}\nstatic void _setup_gradient(Tvg_Gradient * gradient, const lv_vector_gradient_t * grad,\n                            const lv_matrix_t * matrix)\n{\n    const lv_grad_dsc_t * g = &grad->grad;\n    Tvg_Color_Stop * stops = (Tvg_Color_Stop *)lv_malloc(sizeof(Tvg_Color_Stop) * g->stops_count);\n    for(uint8_t i = 0; i < g->stops_count; i++) {\n        const lv_gradient_stop_t * s = &(g->stops[i]);\n        stops[i].offset = s->frac / 255.0f;\n        stops[i].r = s->color.red;\n        stops[i].g = s->color.green;\n        stops[i].b = s->color.blue;\n        stops[i].a = s->opa;\n    }\n    tvg_gradient_set_color_stops(gradient, stops, g->stops_count);\n    tvg_gradient_set_spread(gradient, _lv_spread_to_tvg(grad->spread));\n    Tvg_Matrix mtx;\n    _lv_matrix_to_tvg(&mtx, matrix);\n    tvg_gradient_set_transform(gradient, &mtx);\n    lv_free(stops);\n}\nstatic void _set_paint_stroke_gradient(Tvg_Paint * obj, const lv_vector_gradient_t * g, const lv_matrix_t * m)\n{\n    float x, y, w, h;\n    tvg_paint_get_bounds(obj, &x, &y, &w, &h, false);\n    Tvg_Gradient * grad = NULL;\n    if(g->style == LV_VECTOR_GRADIENT_STYLE_RADIAL) {\n        grad = tvg_radial_gradient_new();\n        tvg_radial_gradient_set(grad, g->cx + x, g->cy + y, g->cr);\n        _setup_gradient(grad, g, m);\n        tvg_shape_set_stroke_radial_gradient(obj, grad);\n    }\n    else {\n        grad = tvg_linear_gradient_new();\n        if(g->grad.dir == LV_GRAD_DIR_VER) {\n            tvg_linear_gradient_set(grad, x, y, x, y + h);\n        }\n        else {\n            tvg_linear_gradient_set(grad, x, y, x + w, y);\n        }\n        _setup_gradient(grad, g, m);\n        tvg_shape_set_stroke_linear_gradient(obj, grad);\n    }\n}\nstatic void _set_paint_stroke(Tvg_Paint * obj, const lv_vector_stroke_dsc_t * dsc)\n{\n    if(dsc->style == LV_VECTOR_DRAW_STYLE_SOLID) {\n        _tvg_color c;\n        _lv_color_to_tvg(&c, &dsc->color, dsc->opa);\n        tvg_shape_set_stroke_color(obj, c.r, c.g, c.b, c.a);\n    }\n    else {   \n        _set_paint_stroke_gradient(obj, &dsc->gradient, &dsc->matrix);\n    }\n    tvg_shape_set_stroke_width(obj, dsc->width);\n    tvg_shape_set_stroke_miterlimit(obj, dsc->miter_limit);\n    tvg_shape_set_stroke_cap(obj, _lv_stroke_cap_to_tvg(dsc->cap));\n    tvg_shape_set_stroke_join(obj, _lv_stroke_join_to_tvg(dsc->join));\n    if(!lv_array_is_empty(&dsc->dash_pattern)) {\n        float * dash_array = lv_array_front(&dsc->dash_pattern);\n        tvg_shape_set_stroke_dash(obj, dash_array, dsc->dash_pattern.size);\n    }\n}\nstatic Tvg_Fill_Rule _lv_fill_rule_to_tvg(lv_vector_fill_t rule)\n{\n    switch(rule) {\n        case LV_VECTOR_FILL_NONZERO:\n            return TVG_FILL_RULE_WINDING;\n        case LV_VECTOR_FILL_EVENODD:\n            return TVG_FILL_RULE_EVEN_ODD;\n        default:\n            return TVG_FILL_RULE_WINDING;\n    }\n}\nstatic void _set_paint_fill_gradient(Tvg_Paint * obj, const lv_vector_gradient_t * g, const lv_matrix_t * m)\n{\n    float x, y, w, h;\n    tvg_paint_get_bounds(obj, &x, &y, &w, &h, false);\n    Tvg_Gradient * grad = NULL;\n    if(g->style == LV_VECTOR_GRADIENT_STYLE_RADIAL) {\n        grad = tvg_radial_gradient_new();\n        tvg_radial_gradient_set(grad, g->cx + x, g->cy + y, g->cr);\n        _setup_gradient(grad, g, m);\n        tvg_shape_set_radial_gradient(obj, grad);\n    }\n    else {\n        grad = tvg_linear_gradient_new();\n        if(g->grad.dir == LV_GRAD_DIR_VER) {\n            tvg_linear_gradient_set(grad, x, y, x, y + h);\n        }\n        else {\n            tvg_linear_gradient_set(grad, x, y, x + w, y);\n        }\n        _setup_gradient(grad, g, m);\n        tvg_shape_set_linear_gradient(obj, grad);\n    }\n}\nstatic void _set_paint_fill_pattern(Tvg_Paint * obj, Tvg_Canvas * canvas, const lv_draw_image_dsc_t * p,\n                                    const lv_matrix_t * m)\n{\n    lv_image_decoder_dsc_t decoder_dsc;\n    lv_image_decoder_args_t args = { 0 };\n    lv_result_t res = lv_image_decoder_open(&decoder_dsc, p->src, &args);\n    if(res != LV_RESULT_OK) {\n        LV_LOG_ERROR(""Failed to open image"");\n        return;\n    }\n    if(!decoder_dsc.decoded) {\n        lv_image_decoder_close(&decoder_dsc);\n        LV_LOG_ERROR(""Image not ready"");\n        return;\n    }\n    const uint8_t * src_buf = decoder_dsc.decoded->data;\n    const lv_image_header_t * header = &decoder_dsc.decoded->header;\n    lv_color_format_t cf = header->cf;\n    if(cf != LV_COLOR_FORMAT_ARGB8888) {\n        lv_image_decoder_close(&decoder_dsc);\n        LV_LOG_ERROR(""Not support image format"");\n        return;\n    }\n    Tvg_Paint * img = tvg_picture_new();\n    tvg_picture_load_raw(img, (uint32_t *)src_buf, header->w, header->h, true);\n    Tvg_Paint * clip_path = tvg_paint_duplicate(obj);\n    tvg_paint_set_composite_method(img, clip_path, TVG_COMPOSITE_METHOD_CLIP_PATH);\n    tvg_paint_set_opacity(img, p->opa);\n    Tvg_Matrix mtx;\n    _lv_matrix_to_tvg(&mtx, m);\n    tvg_paint_set_transform(img, &mtx);\n    tvg_canvas_push(canvas, img);\n    lv_image_decoder_close(&decoder_dsc);\n}\nstatic void _set_paint_fill(Tvg_Paint * obj, Tvg_Canvas * canvas, const lv_vector_fill_dsc_t * dsc,\n                            const lv_matrix_t * matrix)\n{\n    tvg_shape_set_fill_rule(obj, _lv_fill_rule_to_tvg(dsc->fill_rule));\n    if(dsc->style == LV_VECTOR_DRAW_STYLE_SOLID) {\n        _tvg_color c;\n        _lv_color_to_tvg(&c, &dsc->color, dsc->opa);\n        tvg_shape_set_fill_color(obj, c.r, c.g, c.b, c.a);\n    }\n    else if(dsc->style == LV_VECTOR_DRAW_STYLE_PATTERN) {\n        float x, y, w, h;\n        tvg_paint_get_bounds(obj, &x, &y, &w, &h, false);\n        lv_matrix_t imx;\n        lv_memcpy(&imx, matrix, sizeof(lv_matrix_t));\n        lv_matrix_translate(&imx, x, y);\n        lv_matrix_multiply(&imx, &dsc->matrix);\n        _set_paint_fill_pattern(obj, canvas, &dsc->img_dsc, &imx);\n    }\n    else if(dsc->style == LV_VECTOR_DRAW_STYLE_GRADIENT) {\n        _set_paint_fill_gradient(obj, &dsc->gradient, &dsc->matrix);\n    }\n}\nstatic Tvg_Blend_Method _lv_blend_to_tvg(lv_vector_blend_t blend)\n{\n    switch(blend) {\n        case LV_VECTOR_BLEND_SRC_OVER:\n            return TVG_BLEND_METHOD_NORMAL;\n        case LV_VECTOR_BLEND_SCREEN:\n            return TVG_BLEND_METHOD_SCREEN;\n        case LV_VECTOR_BLEND_MULTIPLY:\n            return TVG_BLEND_METHOD_MULTIPLY;\n        case LV_VECTOR_BLEND_NONE:\n            return TVG_BLEND_METHOD_SRCOVER;\n        case LV_VECTOR_BLEND_ADDITIVE:\n            return TVG_BLEND_METHOD_ADD;\n        case LV_VECTOR_BLEND_SRC_IN:\n        case LV_VECTOR_BLEND_DST_OVER:\n        case LV_VECTOR_BLEND_DST_IN:\n        case LV_VECTOR_BLEND_SUBTRACTIVE:\n        default:\n            return TVG_BLEND_METHOD_NORMAL;\n    }\n}\nstatic void _set_paint_blend_mode(Tvg_Paint * obj, lv_vector_blend_t blend)\n{\n    tvg_paint_set_blend_method(obj, _lv_blend_to_tvg(blend));\n}\nstatic void _task_draw_cb(void * ctx, const lv_vector_path_t * path, const lv_vector_draw_dsc_t * dsc)\n{\n    Tvg_Canvas * canvas = (Tvg_Canvas *)ctx;\n    Tvg_Paint * obj = tvg_shape_new();\n    if(!path) {  \n        _tvg_rect rc;\n        _lv_area_to_tvg(&rc, &dsc->scissor_area);\n        _tvg_color c;\n        _lv_color_to_tvg(&c, &dsc->fill_dsc.color, dsc->fill_dsc.opa);\n        Tvg_Matrix mtx = {\n            1.0f, 0.0f, 0.0f,\n            0.0f, 1.0f, 0.0f,\n            0.0f, 0.0f, 1.0f,\n        };\n        _set_paint_matrix(obj, &mtx);\n        tvg_shape_append_rect(obj, rc.x, rc.y, rc.w, rc.h, 0, 0);\n        tvg_shape_set_fill_color(obj, c.r, c.g, c.b, c.a);\n    }\n    else {\n        Tvg_Matrix mtx;\n        _lv_matrix_to_tvg(&mtx, &dsc->matrix);\n        _set_paint_matrix(obj, &mtx);\n        _set_paint_shape(obj, path);\n        _set_paint_fill(obj, canvas, &dsc->fill_dsc, &dsc->matrix);\n        _set_paint_stroke(obj, &dsc->stroke_dsc);\n        _set_paint_blend_mode(obj, dsc->blend_mode);\n    }\n    tvg_canvas_push(canvas, obj);\n}\nvoid lv_draw_sw_vector(lv_draw_unit_t * draw_unit, const lv_draw_vector_task_dsc_t * dsc)\n{\n    LV_UNUSED(draw_unit);\n    if(dsc->task_list == NULL)\n        return;\n    lv_layer_t * layer = dsc->base.layer;\n    lv_draw_buf_t * draw_buf = layer->draw_buf;\n    if(draw_buf == NULL)\n        return;\n    lv_color_format_t cf = draw_buf->header.cf;\n    if(cf != LV_COLOR_FORMAT_ARGB8888 && \\\n       cf != LV_COLOR_FORMAT_XRGB8888) {\n        LV_LOG_ERROR(""unsupported layer color: %d"", cf);\n        return;\n    }\n    void * buf = draw_buf->data;\n    int32_t width = lv_area_get_width(&layer->buf_area);\n    int32_t height = lv_area_get_height(&layer->buf_area);\n    uint32_t stride = draw_buf->header.stride;\n    Tvg_Canvas * canvas = tvg_swcanvas_create();\n    tvg_swcanvas_set_target(canvas, buf, stride / 4, width, height, TVG_COLORSPACE_ARGB8888);\n    lv_ll_t * task_list = dsc->task_list;\n    _lv_vector_for_each_destroy_tasks(task_list, _task_draw_cb, canvas);\n    if(tvg_canvas_draw(canvas) == TVG_RESULT_SUCCESS) {\n        tvg_canvas_sync(canvas);\n    }\n    tvg_canvas_destroy(canvas);\n}\n#endif '"
('Please provide a technical scenario where you need to create an analysis example for a polyphase filter bank using the Finite Impulse Response analysis filter within a specific programming language.,"#define OUTPUT_FILENAME ""firpfbch_crcf_analysis_example.m""\nint main() {\n    unsigned int num_channels =  8;     \n    unsigned int m            =  4;     \n    float        As           = 60;     \n    unsigned int num_frames   = 25;     \n    unsigned int i;\n    unsigned int k;\n    unsigned int num_samples = num_frames * num_channels;\n    float complex x[num_samples];  \n    float complex y[num_samples];  \n    for (i=0; i<num_samples; i++)\n        x[i] = 0.0f;\n    unsigned int num_signals = 4;\n    float fc[4] = {0.0f,   0.25f,  0.375f, -0.375f}; \n    float bw[4] = {0.035f, 0.035f, 0.035f,  0.035f}; \n    unsigned int pulse_len = 137;\n    float pulse[pulse_len];\n    for (i=0; i<num_signals; i++) {\n        liquid_firdes_kaiser(pulse_len, bw[i], 50.0f, 0.0f, pulse);\n        for (k=0; k<pulse_len; k++)\n            x[k] += pulse[k] * cexpf(_Complex_I*2*M_PI*fc[i]*k) * bw[i];\n    }\n    unsigned int h_len = 2*num_channels*m + 1;\n    float h[h_len];\n    liquid_firdes_kaiser(h_len, 0.5f/(float)num_channels, As, 0.0f, h);\n#if 0\n    firpfbch_crcf q = firpfbch_crcf_create_kaiser(LIQUID_ANALYZER, num_channels, m, As);\n#else\n    firpfbch_crcf q = firpfbch_crcf_create(LIQUID_ANALYZER, num_channels, 2*m, h);\n#endif\n    for (i=0; i<num_frames; i++) {\n        firpfbch_crcf_analyzer_execute(q, &x[i*num_channels], &y[i*num_channels]);\n    }\n    firpfbch_crcf_destroy(q);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s: auto-generated file\\n\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""num_channels = %u;\\n"", num_channels);\n    fprintf(fid,""m            = %u;\\n"", m);\n    fprintf(fid,""num_frames   = %u;\\n"", num_frames);\n    fprintf(fid,""h_len        = 2*num_channels*m+1;\\n"");\n    fprintf(fid,""num_samples  = num_frames*num_channels;\\n"");\n    fprintf(fid,""h = zeros(1,h_len);\\n"");\n    fprintf(fid,""x = zeros(1,num_samples);\\n"");\n    fprintf(fid,""y = zeros(num_channels, num_frames);\\n"");\n    for (i=0; i<h_len; i++)\n        fprintf(fid,""  h(%6u) = %12.4e;\\n"", i+1, h[i]);\n    for (i=0; i<num_samples; i++)\n        fprintf(fid,""  x(%6u) = %12.4e + 1i*%12.4e;\\n"", i+1, crealf(x[i]), cimagf(x[i]));\n    for (i=0; i<num_frames; i++) {\n        for (k=0; k<num_channels; k++) {\n            float complex v = y[i*num_channels + k];\n            fprintf(fid,""  y(%3u,%6u) = %12.4e + 1i*%12.4e;\\n"", k+1, i+1, crealf(v), cimagf(v));\n        }\n    }\n    fprintf(fid,""\\n"");\n    fprintf(fid,""nfft = 1024;\\n""); \n    fprintf(fid,""f = [0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""H = 20*log10(abs(fftshift(fft(h/num_channels,nfft))));\\n"");\n    fprintf(fid,""X = 20*log10(abs(fftshift(fft(x,nfft))));\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(2,1,1);\\n"");\n    fprintf(fid,""  plot(f, H, \'Color\', [0 0.5 0.25], \'LineWidth\', 2);\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -100 10]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""  ylabel(\'Prototype Filter PSD\');\\n"");\n    fprintf(fid,""subplot(2,1,2);\\n"");\n    fprintf(fid,""  plot(f, X, \'Color\', [0 0.25 0.5], \'LineWidth\', 2);\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -100 0]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""  ylabel(\'Input PSD\');\\n"");\n    fprintf(fid,""n = ceil(sqrt(num_channels));\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""for i=1:num_channels,\\n"");\n    fprintf(fid,""  Y = 20*log10(abs(fftshift(fft(y(i,:),nfft))));\\n"");\n    fprintf(fid,""  subplot(n,n,i);\\n"");\n    fprintf(fid,""  plot(f, Y, \'Color\', [0.25 0 0.25], \'LineWidth\', 1.5);\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -120 20]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  title(num2str(i-1));\\n"");\n    fprintf(fid,""end;\\n"");\n    fclose(fid);\n    printf(""results written to %s\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"'Prompt: You are tasked with implementing a function in C that deletes a file or symbolic link at the given filepath. This function should support both ANSI and Unicode characters in the filepath. Additionally, the function should handle different code pages for Unicode conversion. How would you write the code to achieve this functionality?","#define _CRT_SECURE_NO_WARNINGS 1 \n#define _UTF8_LIB_SOURCE \n#ifdef _WIN32\nint unlinkM(const char *path, UINT cp) {\n  int iErr;\n  BOOL bDone;\n  struct stat st;\n  WCHAR *pwszName;\n  DEBUG_ENTER((""unlink(\\""%s\\"");\\n"", path));\n  iErr = lstat(path, &st); \n  if (iErr) RETURN_INT(iErr);\n  if ((!S_ISREG(st.st_mode)) && (!S_ISLNK(st.st_mode))) {\n    errno = ENOENT;\n    RETURN_INT_COMMENT(-1, (""Pathname exists, but is not a file or a link\\n""));\n  }\n  pwszName = MultiByteToNewWidePath(cp, path);\n  if (!pwszName) RETURN_INT_COMMENT(-1, (""errno=%d - %s\\n"", errno, strerror(errno)));\n#if _MSVCLIBX_STAT_DEFINED\n  if (S_ISLNK(st.st_mode) && (st.st_Win32Attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n    bDone = RemoveDirectoryW(pwszName);\n  } else\n#endif\n  bDone = DeleteFileW(pwszName);\n  free(pwszName);\n  if (bDone) {\n    RETURN_INT_COMMENT(0, (""Success\\n""));\n  } else {\n    errno = Win32ErrorToErrno();\n    RETURN_INT_COMMENT(-1, (""Failed\\n""));\n  }\n}\nint unlinkA(const char *path) {\n  return unlinkM(path, CP_ACP);\n}\nint unlinkU(const char *path) {\n  return unlinkM(path, CP_UTF8);\n}\n#endif '"
"'You are working on a project that involves logging messages at different severity levels for debugging purposes. You are asked to implement a function (test) that takes a string argument and logs error, warning, info, debug, and verbose messages with the provided string and iterates 100 times. Additionally, you need to create a test function (test_rsyslog) that logs messages using a different logging method (RSYSLOG) for a smaller iteration count (10). You will need to initialize and deinitialize the logging system appropriately in each function.","//...\nstatic void *test(void *arg)\n{\n    int i;\n    char *tmp = (char *)arg;\n    log_init(LOG_FILE, NULL);\n    for (i = 0; i < 100; i++) {\n        loge(""%s:%s:%d: error msg %s %d\\n"", __FILE__, __func__, __LINE__, tmp, i);\n        logw(""%s:%s:%d: warn msg %s %d\\n"", __FILE__, __func__, __LINE__, tmp, i);\n        logi(""%s:%s:%d: info msg %s %d\\n"", __FILE__, __func__, __LINE__, tmp, i);\n        logd(""%s:%s:%d: debug msg %s %d\\n"", __FILE__, __func__, __LINE__, tmp, i);\n        logv(""%s:%s:%d: verbose msg %s %d\\n"", __FILE__, __func__, __LINE__, tmp, i);\n    }\n    return NULL;\n}\nstatic void test_rsyslog(void)\n{\n    int i;\n    char tmp[32] = ""abcd"";\n    log_deinit();\n    log_init(LOG_RSYSLOG, ""test_log"");\n    for (i = 0; i < 10; i++) {\n        loge(""test rsyslog\\n"");\n        logw(""debug msg %d, %s\\n"", i, tmp);\n        logd(""debug msg %d, %s\\n"", i, tmp);\n        logi(""debug msg %d, %s\\n"", i, tmp);\n        logv(""debug msg %d, %s\\n"", i, tmp);\n    }\n    log_deinit();\n}\n//...'"
('Prompt: You are working on a software-defined radio application using the ofdmflexframesync library for frame synchronization. You need to implement a function to disable debug output specifically for the ofdmflexframesync module. Write a code snippet that accomplishes this by calling the ofdmframesync_debug_disable function on the internal fs object of the ofdmflexframesync structure.,"//...\n    ofdmframesync fs;                   \nint ofdmflexframesync_debug_disable(ofdmflexframesync _q)\n{\n    return ofdmframesync_debug_disable(_q->fs);\n}\n//...')
"
"('Prompt: You are working on a project that involves packetizing data and transmitting it over a network. You need to implement a function that decodes the received packets and retrieves the original message. Can you provide me with two functions in C that decode the packetized data? The functions should be named ""packetizer_decode"" and ""packetizer_decode_soft"" respectively. The ""packetizer_decode"" function should decode the data with regular error correction techniques, while the ""packetizer_decode_soft"" function should use soft-decision error correction techniques. The functions should take a packetizer struct, a received packet, and a buffer to store the decoded message as input parameters.","//...\nint packetizer_decode(packetizer            _p,\n                      const unsigned char * _pkt,\n                      unsigned char *       _msg)\n{\n    memmove(_p->buffer_0, _pkt, _p->packet_len);\n    unsigned int i;\n    for (i=_p->plan_len; i>0; i--) {\n        interleaver_decode(_p->plan[i-1].q,\n                           _p->buffer_0,\n                           _p->buffer_1);\n        fec_decode(_p->plan[i-1].f,\n                   _p->plan[i-1].dec_msg_len,\n                   _p->buffer_1,\n                   _p->buffer_0);\n    }\n    unscramble_data(_p->buffer_0, _p->msg_len + _p->crc_length);\n    unsigned int key = 0;\n    for (i=0; i<_p->crc_length; i++) {\n        key <<= 8;\n        key |= _p->buffer_0[_p->msg_len+i];\n    }\n    memmove(_msg, _p->buffer_0, _p->msg_len);\n    return crc_validate_message(_p->check,\n                                _p->buffer_0,\n                                _p->msg_len,\n                                key);\n}\nint packetizer_decode_soft(packetizer            _p,\n                           const unsigned char * _pkt,\n                           unsigned char *       _msg)\n{\n    memmove(_p->buffer_0, _pkt, 8*_p->packet_len);\n    interleaver_decode_soft(_p->plan[1].q,\n                            _p->buffer_0,\n                            _p->buffer_1);\n    fec_decode_soft(_p->plan[1].f,\n                    _p->plan[1].dec_msg_len,\n                    _p->buffer_1,\n                    _p->buffer_0);\n    interleaver_decode(_p->plan[0].q,\n                       _p->buffer_0,\n                       _p->buffer_1);\n    fec_decode(_p->plan[0].f,\n               _p->plan[0].dec_msg_len,\n               _p->buffer_1,\n               _p->buffer_0);\n    unscramble_data(_p->buffer_0, _p->msg_len + _p->crc_length);\n    unsigned int key = 0;\n    unsigned int i;\n    for (i=0; i<_p->crc_length; i++) {\n        key <<= 8;\n        key |= _p->buffer_0[_p->msg_len+i];\n    }\n    memmove(_msg, _p->buffer_0, _p->msg_len);\n    return crc_validate_message(_p->check,\n                                _p->buffer_0,\n                                _p->msg_len,\n                                key);\n}\n//...')
"
"('Prompt: Your task is to create a testbench function that utilizes a Numerically Controlled Oscillator (NCO) with a specific type, phase, and frequency. The testbench should generate signal samples, mix them using the NCO, and compare the results with the expected values. Additionally, you need to handle phase wrap-around when updating the phase offset. Finally, implement an autotest function that calls the testbench with specific parameters (LIQUID_NCO type, phase 0.000f, frequency M_PI) and verify the functionality.","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_nco_5() { testbench_nco_crcf_mix(LIQUID_NCO,  0.000f,    M_PI); }\n//...')
"
"('Prompt: ""Please provide a code snippet for testing the delay calculation of a square root raised cosine (RCR) filter in a digital communication system. The test should involve creating a linear RCR filter with specific parameters, calculating the delay, performing signal processing operations, and comparing the expected delay with the measured delay within a certain tolerance. Can you demonstrate this using a test case with a normalized bandwidth of 0.5 and 4 taps in the filter?""","//...\nvoid testbench_symstreamrcf_delay(float        _bw,\n                                  unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamrcf gen    = symstreamrcf_create_linear(ftype,_bw,_m,beta,ms);\n    float        delay  = symstreamrcf_get_delay(gen);\n    float        tol    = 0.05; \n    unsigned int  nfft = 2*(120 + (unsigned int)(delay/sqrtf(_bw)));\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    symstreamrcf_write_samples(gen, buf_time, 1);\n    symstreamrcf_set_gain(gen, 0.0f);\n    symstreamrcf_write_samples(gen, buf_time+1, nfft-1);\n    symstreamrcf_destroy(gen);\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    unsigned int m = 0.4 * _bw * nfft; \n    float complex p = 0.0f;\n    int i;\n    for (i=-(int)m; i<(int)m; i++)\n        p += buf_freq[(nfft+i)%nfft] * conjf(buf_freq[(nfft+i+1)%nfft]);\n    float delay_meas = cargf(p) * nfft / (2*M_PI);\n    if (liquid_autotest_verbose) {\n        printf(""expected delay: %.6f, measured: %.6f, err: %.6f (tol= %.3f)\\n"",\n                delay, delay_meas, delay-delay_meas,tol);\n    }\n    CONTEND_DELTA(delay, delay_meas, tol);\n}\nvoid autotest_symstreamrcf_delay_00() { testbench_symstreamrcf_delay(0.500f, 4); }\n//...')
"
"('Prompt: You are implementing an automated test for a GMSK detector in a digital communication system. The test function `qdetector_cccf_runtest_gmsk` takes an input sequence length as a parameter and generates a random binary sequence of that length. The function then creates a GMSK detector with certain parameters, runs the test using the generated sequence, and destroys the detector. This test function calls another function `qdetector_cccf_runtest` that performs the actual detection test.. . In the detection test function, various parameters related to the GMSK detector like `gamma`, `tau`, `dphi`, and `phi` are initialized. The function processes a received buffer of samples and attempts to detect a frame using the GMSK detector. If a frame is detected, the estimated values of parameters are compared with the actual values and errors are calculated. The function checks for false positives, frame detection, and asserts based on certain conditions.. . The test setup includes an automated test function","//...\nvoid qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    unsigned char sequence[_sequence_len];\n    unsigned int i;\n    for (i=0; i<_sequence_len; i++)\n        sequence[i] = rand() & 0x01;\n    qdetector_cccf q = qdetector_cccf_create_gmsk(sequence, _sequence_len, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_gmsk_n1341()   { qdetector_cccf_runtest_gmsk  (1341); }\n//...')
"
"('Prompt: You need to create a testbench function for a resampler with specific parameters using the library `liquid-dsp`. The resampler will have a decimation rate of 0.127115323, stopband attenuation of 60.0, and an ID of 0. The resampler will have a transition bandwidth of 0.25, tolerance of 0.5, filter length of 20, number of points per filter bank of 2048, and a center frequency of 0.45. The testbench function should generate input signals, execute the resampler, and validate the output power spectral density (PSD) against specific regions. The final PSD plot should be saved in a log file named ""resamp_crcf_00.m"". You can use the given `testbench_resamp_crcf` code as a reference to implement this scenario.","//...\nvoid testbench_resamp_crcf(float r, float As, int _id)\n{\n    float        bw   = 0.25f;  \n    float        tol  = 0.5f;   \n    unsigned int m    = 20;     \n    unsigned int npfb = 2048;   \n    float        fc   = 0.45f;  \n    resamp_crcf resamp = resamp_crcf_create(r,m,fc,As,npfb);\n    unsigned int p = (unsigned int) (40.0f / r);\n    unsigned int pulse_len = 4*p + 1;\n    float        pulse[pulse_len];\n    liquid_firdes_kaiser(pulse_len, 0.5*r*bw, 120, 0, pulse);\n    unsigned int  num_input  = pulse_len + 2*m + 1;\n    unsigned int  num_output = resamp_crcf_get_num_output(resamp, num_input);\n    float complex buf_0[num_input];  \n    float complex buf_1[num_output]; \n    unsigned int i;\n    for (i=0; i<num_input; i++)\n        buf_0[i] = i < pulse_len ? pulse[i]*bw : 0;\n    unsigned int nw = 0;\n    resamp_crcf_execute_block(resamp, buf_0, num_input, buf_1, &nw);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/resamp_crcf_%.2d.m"", _id);\n    liquid_autotest_validate_psd_signal(buf_1, nw, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    resamp_crcf_destroy(resamp);\n}\nvoid autotest_resamp_crcf_00() { testbench_resamp_crcf(0.127115323f, 60.0f,  0); }\n//...')
"
"('Please provide a prompt that details a technical scenario where you need to decode packets of data that have undergone interleaving, forward error correction, scrambling, and cyclic redundancy check validation. The prompt should require a function that can decode packets using these techniques and return the validated message.","//...\nint packetizer_decode(packetizer            _p,\n                      const unsigned char * _pkt,\n                      unsigned char *       _msg)\n{\n    memmove(_p->buffer_0, _pkt, _p->packet_len);\n    unsigned int i;\n    for (i=_p->plan_len; i>0; i--) {\n        interleaver_decode(_p->plan[i-1].q,\n                           _p->buffer_0,\n                           _p->buffer_1);\n        fec_decode(_p->plan[i-1].f,\n                   _p->plan[i-1].dec_msg_len,\n                   _p->buffer_1,\n                   _p->buffer_0);\n    }\n    unscramble_data(_p->buffer_0, _p->msg_len + _p->crc_length);\n    unsigned int key = 0;\n    for (i=0; i<_p->crc_length; i++) {\n        key <<= 8;\n        key |= _p->buffer_0[_p->msg_len+i];\n    }\n    memmove(_msg, _p->buffer_0, _p->msg_len);\n    return crc_validate_message(_p->check,\n                                _p->buffer_0,\n                                _p->msg_len,\n                                key);\n}\n//...')
"
"('Prompt: You are working on a digital signal processing project that involves pre-demodulation synchronization. You need to create a function that will display usage information for a test program. The information should include options for setting parameters such as samples/symbol, filter delay, number of data symbols, bandwidth-time product, fractional sample offset, frequency offset, phase offset, and SNR. The default values for each parameter should also be provided. Please write a C function that prints out this usage information.","//...\nvoid usage()\n{\n    printf(""predemod_sync_test -- test pre-demodulation synchronization\\n"");\n    printf(""options:\\n"");\n    printf(""  h     : print usage/help\\n"");\n    printf(""  k     : samples/symbol, default: 2\\n"");\n    printf(""  m     : filter delay [symbols], default: 4\\n"");\n    printf(""  n     : number of data symbols, default: 64\\n"");\n    printf(""  b     : bandwidth-time product, (0,1), default: 0.3\\n"");\n    printf(""  t     : fractional sample offset, (-0.5,0.5), default: 0\\n"");\n    printf(""  F     : frequency offset, default: 0\\n"");\n    printf(""  P     : phase offset, default: 0\\n"");\n    printf(""  s     : SNR [dB], default: 30\\n"");\n}\n//...')
"
"('Please provide code for creating a Finite Impulse Response (FIR) Hilbert Transformer filter with the following specifications:. - The filter has a semi-length of at least 2 (_m >= 2).. - The filter has a stopband attenuation value of ""_as"".. . Include functions to create a new FIR Hilbert Transformer filter, copy an existing one, destroy a filter, print the filter details, reset the filter state, and execute the filter in real-to-complex, complex-to-real, decimated, and interpolated modes.. . Also, the filter implementation should handle toggling between different window functions and dot product calculations.. . You can assume that the filter implementation supports complex numbers and utilizes related mathematical functions appropriately.","struct FIRHILB(_s) {\n    T * h;                  \n    T complex * hc;         \n    unsigned int h_len;     \n    float as;               \n    unsigned int m;         \n    T * hq;                 \n    unsigned int hq_len;    \n    WINDOW() w0;            \n    WINDOW() w1;            \n    WINDOW() w2;\n    WINDOW() w3;\n    DOTPROD() dpq;\n    unsigned int toggle;\n};\nFIRHILB() FIRHILB(_create)(unsigned int _m,\n                           float        _as)\n{\n    if (_m < 2)\n        return liquid_error_config(""firhilb_create(), filter semi-length (m) must be at least 2"");\n    FIRHILB() q = (FIRHILB()) malloc(sizeof(struct FIRHILB(_s)));\n    q->m  = _m;         \n    q->as = fabsf(_as); \n    q->h_len = 4*(q->m) + 1;\n    q->h     = (T *)         malloc((q->h_len)*sizeof(T));\n    q->hc    = (T complex *) malloc((q->h_len)*sizeof(T complex));\n    q->hq_len = 2*(q->m);\n    q->hq     = (T *) malloc((q->hq_len)*sizeof(T));\n    liquid_firdes_kaiser(q->h_len, 0.25f, q->as, 0.0f, q->h);\n    unsigned int i;\n    for (i=0; i<q->h_len; i++) {\n        float t = (float)i - (float)(q->h_len-1)/2.0f;\n        q->hc[i] = q->h[i] * cexpf(_Complex_I*0.5f*M_PI*t);\n        q->h[i]  = cimagf(q->hc[i]);\n    }\n    unsigned int j=0;\n    for (i=1; i<q->h_len; i+=2)\n        q->hq[j++] = q->h[q->h_len - i - 1];\n    q->w0 = WINDOW(_create)(2*(q->m));\n    q->w1 = WINDOW(_create)(2*(q->m));\n    q->w2 = WINDOW(_create)(2*(q->m));\n    q->w3 = WINDOW(_create)(2*(q->m));\n    q->dpq = DOTPROD(_create)(q->hq, q->hq_len);\n    FIRHILB(_reset)(q);\n    return q;\n}\nFIRHILB() FIRHILB(_copy)(FIRHILB() q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""firhilb%s_copy(), object cannot be NULL"", EXTENSION_SHORT);\n    FIRHILB() q_copy = (FIRHILB()) malloc(sizeof(struct FIRHILB(_s)));\n    memmove(q_copy, q_orig, sizeof(struct FIRHILB(_s)));\n    q_copy->h  = (T *)        liquid_malloc_copy(q_orig->h,  q_orig->h_len,  sizeof(T));\n    q_copy->hc = (T complex*) liquid_malloc_copy(q_orig->hc, q_orig->h_len,  sizeof(T complex));\n    q_copy->hq = (T *)        liquid_malloc_copy(q_orig->hq, q_orig->hq_len, sizeof(T));\n    q_copy->w0  = WINDOW (_copy)(q_orig->w0 );\n    q_copy->w1  = WINDOW (_copy)(q_orig->w1 );\n    q_copy->w2  = WINDOW (_copy)(q_orig->w2 );\n    q_copy->w3  = WINDOW (_copy)(q_orig->w3 );\n    q_copy->dpq = DOTPROD(_copy)(q_orig->dpq);\n    return q_copy;\n}\nint FIRHILB(_destroy)(FIRHILB() _q)\n{\n    WINDOW(_destroy)(_q->w0);\n    WINDOW(_destroy)(_q->w1);\n    WINDOW(_destroy)(_q->w2);\n    WINDOW(_destroy)(_q->w3);\n    DOTPROD(_destroy)(_q->dpq);\n    free(_q->h);\n    free(_q->hc);\n    free(_q->hq);\n    free(_q);\n    return LIQUID_OK;\n}\nint FIRHILB(_print)(FIRHILB() _q)\n{\n    printf(""fir hilbert transform: [%u]\\n"", _q->h_len);\n    unsigned int i;\n    for (i=0; i<_q->h_len; i++) {\n        printf(""  hc(%4u) = %8.4f + j*%8.4f;\\n"", i+1, crealf(_q->hc[i]), cimagf(_q->hc[i]));\n    }\n    printf(""---\\n"");\n    for (i=0; i<_q->h_len; i++) {\n        printf(""  h(%4u) = %8.4f;\\n"", i+1, _q->h[i]);\n    }\n    printf(""---\\n"");\n    for (i=0; i<_q->hq_len; i++) {\n        printf(""  hq(%4u) = %8.4f;\\n"", i+1, _q->hq[i]);\n    }\n    return LIQUID_OK;\n}\nint FIRHILB(_reset)(FIRHILB() _q)\n{\n    WINDOW(_reset)(_q->w0);\n    WINDOW(_reset)(_q->w1);\n    WINDOW(_reset)(_q->w2);\n    WINDOW(_reset)(_q->w3);\n    _q->toggle = 0;\n    return LIQUID_OK;\n}\nint FIRHILB(_r2c_execute)(FIRHILB()   _q,\n                          T           _x,\n                          T complex * _y)\n{\n    T * r;  \n    T yi;   \n    T yq;   \n    if ( _q->toggle == 0 ) {\n        WINDOW(_push)(_q->w0, _x);\n        WINDOW(_index)(_q->w0, _q->m-1, &yi);\n        WINDOW(_read)(_q->w1, &r);\n        DOTPROD(_execute)(_q->dpq, r, &yq);\n    } else {\n        WINDOW(_push)(_q->w1, _x);\n        WINDOW(_index)(_q->w1, _q->m-1, &yi);\n        WINDOW(_read)(_q->w0, &r);\n        DOTPROD(_execute)(_q->dpq, r, &yq);\n    }\n    _q->toggle = 1 - _q->toggle;\n    *_y = yi + _Complex_I * yq;\n    return LIQUID_OK;\n}\nint FIRHILB(_c2r_execute)(FIRHILB() _q,\n                          T complex _x,\n                          T *       _y0,\n                          T *       _y1)\n{\n    T * r;  \n    T yi;   \n    T yq;   \n    if (_q->toggle == 0) {\n        WINDOW(_push)(_q->w0, crealf(_x));\n        WINDOW(_push)(_q->w1, cimagf(_x));\n        WINDOW(_index)(_q->w0, _q->m-1, &yi);\n        WINDOW(_read)(_q->w3, &r);\n        DOTPROD(_execute)(_q->dpq, r, &yq);\n    } else {\n        WINDOW(_push)(_q->w2, crealf(_x));\n        WINDOW(_push)(_q->w3, cimagf(_x));\n        WINDOW(_index)(_q->w2, _q->m-1, &yi);\n        WINDOW(_read)(_q->w1, &r);\n        DOTPROD(_execute)(_q->dpq, r, &yq);\n    }\n    _q->toggle = 1 - _q->toggle;\n    *_y0 = yi + yq; \n    *_y1 = yi - yq; \n    return LIQUID_OK;\n}\nint FIRHILB(_decim_execute)(FIRHILB()   _q,\n                            T *         _x,\n                            T complex * _y)\n{\n    T * r;  \n    T yi;   \n    T yq;   \n    WINDOW(_push)(_q->w1, _x[0]);\n    WINDOW(_read)(_q->w1, &r);\n    DOTPROD(_execute)(_q->dpq, r, &yq);\n    WINDOW(_push)(_q->w0, _x[1]);\n    WINDOW(_index)(_q->w0, _q->m-1, &yi);\n    T complex v = yi + _Complex_I * yq;\n    *_y = _q->toggle ? -v : v;\n    _q->toggle = 1 - _q->toggle;\n    return LIQUID_OK;\n}\nint FIRHILB(_decim_execute_block)(FIRHILB()    _q,\n                                  T *          _x,\n                                  unsigned int _n,\n                                  T complex *  _y)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        FIRHILB(_decim_execute)(_q, &_x[2*i], &_y[i]);\n    }\n    return LIQUID_OK;\n}\nint FIRHILB(_interp_execute)(FIRHILB() _q,\n                             T complex _x,\n                             T *       _y)\n{\n    T * r;  \n    T vi = _q->toggle ? -crealf(_x) : crealf(_x);\n    T vq = _q->toggle ? -cimagf(_x) : cimagf(_x);\n    WINDOW(_push)(_q->w0, vq);\n    WINDOW(_index)(_q->w0, _q->m-1, &_y[0]);\n    WINDOW(_push)(_q->w1, vi);\n    WINDOW(_read)(_q->w1, &r);\n    DOTPROD(_execute)(_q->dpq, r, &_y[1]);\n    _q->toggle = 1 - _q->toggle;\n    return LIQUID_OK;\n}\nint FIRHILB(_interp_execute_block)(FIRHILB()    _q,\n                                   T complex *  _x,\n                                   unsigned int _n,\n                                   T *          _y)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        FIRHILB(_interp_execute)(_q, _x[i], &_y[2*i]);\n    }\n    return LIQUID_OK;\n}')
"
('Prompt: Design and implement a test function to measure the period of a Maximum Length Sequence generator with a specified register length. Write a test case for when the register length is 17.,"//...\nvoid msequence_test_period(unsigned int _m)\n{\n    msequence q = msequence_create_default(_m);\n    unsigned int n = (1U << _m) - 1;\n    unsigned int p = msequence_measure_period(q);\n    CONTEND_EQUALITY(p,n)\n    msequence_destroy(q);\n}\nvoid autotest_msequence_period_m17() { msequence_test_period(17); }\n//...')
"
"'Prompt: You are working on a software project that involves multithreading functionalities, and you need to implement a function in C that retrieves a unique identifier for a pthread_t thread. Please write a code snippet that includes the necessary preprocessor directives and function definition to achieve this using the __ptw32_thread_t data structure.",#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nunsigned __int64\npthread_getunique_np (pthread_t thread)\n{\n  return ((__ptw32_thread_t*)thread.p)->seqNumber;\n}'
"('Prompt:. You are testing a modem communication framework that involves modulating and demodulating signals using different modulation schemes. Write a function that conducts a test for modulating and demodulating signals under APSK64 modulation scheme. The test should include modulating a signal, demodulating it, and checking for certain equality and delta conditions. Finally, calculate the error rate and test if it falls within a certain range. Remember to clean up resources after the test is done.","//...\nvoid modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_apsk64()    { modemcf_test_mod_demod(LIQUID_MODEM_APSK64);    }\n//...')
"
"'Prompt: You are working on a graphical display system and need to implement a function that redraws objects within a layer. The function should handle different layer types and ensure proper clipping areas for drawing. Can you provide a code snippet that demonstrates how to redraw an object within a layer while considering layer types, clipping, and child objects?","//...\n    info.area = area_p;\n    for(i = child_cnt - 1; i >= 0; i--) {\n    int32_t child_cnt = lv_obj_get_child_count(obj);\n    for(i = child_cnt - 1; i >= 0; i--) {\n        lv_obj_t * child = obj->spec_attr->children[i];\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)\n{\n    if(!_lv_area_is_on(area, &obj->coords)) return true;\n    lv_cover_check_info_t info;\n    info.res = LV_COVER_RES_COVER;\n    info.area = area;\n    lv_obj_send_event(obj, LV_EVENT_COVER_CHECK, &info);\n    if(info.res == LV_COVER_RES_COVER) return false;\n    else return true;\n}\nvoid refr_obj(lv_layer_t * layer, lv_obj_t * obj)\n{\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;\n    lv_layer_type_t layer_type = _lv_obj_get_layer_type(obj);\n    if(layer_type == LV_LAYER_TYPE_NONE) {\n        lv_obj_redraw(layer, obj);\n    }\n    else {\n        lv_opa_t opa = lv_obj_get_style_opa_layered(obj, 0);\n        if(opa < LV_OPA_MIN) return;\n        lv_area_t layer_area_full;\n        lv_area_t obj_draw_size;\n        lv_result_t res = layer_get_area(layer, obj, layer_type, &layer_area_full, &obj_draw_size);\n        if(res != LV_RESULT_OK) return;\n        uint32_t max_rgb_row_height = lv_area_get_height(&layer_area_full);\n        uint32_t max_argb_row_height = lv_area_get_height(&layer_area_full);\n        if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n            int32_t w = lv_area_get_width(&layer_area_full);\n            uint8_t px_size = lv_color_format_get_size(disp_refr->color_format);\n            max_rgb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / px_size;\n            max_argb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / sizeof(lv_color32_t);\n        }\n        lv_area_t layer_area_act;\n        layer_area_act.x1 = layer_area_full.x1;\n        layer_area_act.x2 = layer_area_full.x2;\n        layer_area_act.y1 = layer_area_full.y1;\n        layer_area_act.y2 = layer_area_full.y1;\n        while(layer_area_act.y2 < layer_area_full.y2) {\n            layer_area_act.y2 = layer_area_act.y1 + max_rgb_row_height - 1;\n            if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            bool area_need_alpha = alpha_test_area_on_obj(obj, &layer_area_act);\n            if(area_need_alpha) {\n                layer_area_act.y2 = layer_area_act.y1 + max_argb_row_height - 1;\n                if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            }\n            lv_layer_t * new_layer = lv_draw_layer_create(layer,\n                                                          area_need_alpha ? LV_COLOR_FORMAT_ARGB8888 : LV_COLOR_FORMAT_NATIVE, &layer_area_act);\n            lv_obj_redraw(new_layer, obj);\n            lv_draw_image_dsc_t layer_draw_dsc;\n            lv_draw_image_dsc_init(&layer_draw_dsc);\n            layer_draw_dsc.pivot.x = obj->coords.x1 + lv_obj_get_style_transform_pivot_x(obj, 0) - new_layer->buf_area.x1;\n            layer_draw_dsc.pivot.y = obj->coords.y1 + lv_obj_get_style_transform_pivot_y(obj, 0) - new_layer->buf_area.y1;\n            layer_draw_dsc.opa = opa;\n            layer_draw_dsc.rotation = lv_obj_get_style_transform_rotation(obj, 0);\n            while(layer_draw_dsc.rotation > 3600) layer_draw_dsc.rotation -= 3600;\n            while(layer_draw_dsc.rotation < 0) layer_draw_dsc.rotation += 3600;\n            layer_draw_dsc.scale_x = lv_obj_get_style_transform_scale_x(obj, 0);\n            layer_draw_dsc.scale_y = lv_obj_get_style_transform_scale_y(obj, 0);\n            layer_draw_dsc.skew_x = lv_obj_get_style_transform_skew_x(obj, 0);\n            layer_draw_dsc.skew_y = lv_obj_get_style_transform_skew_y(obj, 0);\n            layer_draw_dsc.blend_mode = lv_obj_get_style_blend_mode(obj, 0);\n            layer_draw_dsc.antialias = disp_refr->antialiasing;\n            layer_draw_dsc.bitmap_mask_src = lv_obj_get_style_bitmap_mask_src(obj, 0);\n            layer_draw_dsc.original_area = obj_draw_size;\n            layer_draw_dsc.src = new_layer;\n            lv_draw_layer(layer, &layer_draw_dsc, &layer_area_act);\n            layer_area_act.y1 = layer_area_act.y2 + 1;\n        }\n    }\n}\nstatic lv_result_t layer_get_area(lv_layer_t * layer, lv_obj_t * obj, lv_layer_type_t layer_type,\n                                  lv_area_t * layer_area_out, lv_area_t * obj_draw_size_out)\n{\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_obj_get_coords(obj, obj_draw_size_out);\n    lv_area_increase(obj_draw_size_out, ext_draw_size, ext_draw_size);\n    if(layer_type == LV_LAYER_TYPE_TRANSFORM) {\n        lv_area_t clip_coords_for_obj;\n        lv_area_t tranf_coords = *obj_draw_size_out;\n        lv_obj_get_transformed_area(obj, &tranf_coords, false, false);\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, &tranf_coords)) {\n            return LV_RESULT_INVALID;\n        }\n        lv_area_t inverse_clip_coords_for_obj = clip_coords_for_obj;\n        lv_obj_get_transformed_area(obj, &inverse_clip_coords_for_obj, false, true);\n        if(!_lv_area_intersect(&inverse_clip_coords_for_obj, &inverse_clip_coords_for_obj, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = inverse_clip_coords_for_obj;\n        lv_area_increase(layer_area_out, 5, 5); \n    }\n    else if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n        lv_area_t clip_coords_for_obj;\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = clip_coords_for_obj;\n    }\n    else {\n        LV_LOG_WARN(""Unhandled layer type"");\n        return LV_RESULT_INVALID;\n    }\n    return LV_RESULT_OK;\n}\nvoid lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)\n{\n    lv_area_t clip_area_ori = layer->_clip_area;\n    lv_area_t clip_coords_for_obj;\n    lv_area_t obj_coords_ext;\n    lv_obj_get_coords(obj, &obj_coords_ext);\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_increase(&obj_coords_ext, ext_draw_size, ext_draw_size);\n    if(!_lv_area_intersect(&clip_coords_for_obj, &clip_area_ori, &obj_coords_ext)) return;\n    layer->_clip_area = clip_coords_for_obj;\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_BEGIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_END, layer);\n#if LV_USE_REFR_DEBUG\n    lv_color_t debug_color = lv_color_make(lv_rand(0, 0xFF), lv_rand(0, 0xFF), lv_rand(0, 0xFF));\n    lv_draw_rect_dsc_t draw_dsc;\n    lv_draw_rect_dsc_init(&draw_dsc);\n    draw_dsc.bg_color = debug_color;\n    draw_dsc.bg_opa = LV_OPA_20;\n    draw_dsc.border_width = 1;\n    draw_dsc.border_opa = LV_OPA_30;\n    draw_dsc.border_color = debug_color;\n    lv_draw_rect(layer, &draw_dsc, &obj_coords_ext);\n#endif\n    const lv_area_t * obj_coords;\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_OVERFLOW_VISIBLE)) {\n        obj_coords = &obj_coords_ext;\n    }\n    else {\n        obj_coords = &obj->coords;\n    }\n    lv_area_t clip_coords_for_children;\n    bool refr_children = true;\n    if(!_lv_area_intersect(&clip_coords_for_children, &clip_area_ori, obj_coords)) {\n        refr_children = false;\n    }\n    if(refr_children) {\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(obj);\n        if(child_cnt == 0) {\n            layer->_clip_area = clip_coords_for_obj;\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n        }\n        else {\n            layer->_clip_area = clip_coords_for_children;\n            bool clip_corner = lv_obj_get_style_clip_corner(obj, LV_PART_MAIN);\n            int32_t radius = 0;\n            if(clip_corner) {\n                radius = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n                if(radius == 0) clip_corner = false;\n            }\n            if(clip_corner == false) {\n                for(i = 0; i < child_cnt; i++) {\n                    lv_obj_t * child = obj->spec_attr->children[i];\n                    refr_obj(layer, child);\n                }\n                layer->_clip_area = clip_coords_for_obj;\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n            }\n            else {\n                lv_layer_t * layer_children;\n                lv_draw_mask_rect_dsc_t mask_draw_dsc;\n                lv_draw_mask_rect_dsc_init(&mask_draw_dsc);\n                mask_draw_dsc.radius = radius;\n                mask_draw_dsc.area = obj->coords;\n                lv_draw_image_dsc_t img_draw_dsc;\n                lv_draw_image_dsc_init(&img_draw_dsc);\n                int32_t short_side = LV_MIN(lv_area_get_width(&obj->coords), lv_area_get_height(&obj->coords));\n                int32_t rout = LV_MIN(radius, short_side >> 1);\n                lv_area_t bottom = obj->coords;\n                bottom.y1 = bottom.y2 - rout + 1;\n                if(_lv_area_intersect(&bottom, &bottom, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &bottom);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &bottom);\n                }\n                lv_area_t top = obj->coords;\n                top.y2 = top.y1 + rout - 1;\n                if(_lv_area_intersect(&top, &top, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &top);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &top);\n                }\n                lv_area_t mid = obj->coords;\n                mid.y1 += rout;\n                mid.y2 -= rout;\n                if(_lv_area_intersect(&mid, &mid, &clip_area_ori)) {\n                    layer->_clip_area = mid;\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n                }\n            }\n        }\n    }\n    layer->_clip_area = clip_area_ori;\n}\nvoid lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)\n{\n    lv_area_t clip_area_ori = layer->_clip_area;\n    lv_area_t clip_coords_for_obj;\n    lv_area_t obj_coords_ext;\n    lv_obj_get_coords(obj, &obj_coords_ext);\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_increase(&obj_coords_ext, ext_draw_size, ext_draw_size);\n    if(!_lv_area_intersect(&clip_coords_for_obj, &clip_area_ori, &obj_coords_ext)) return;\n    layer->_clip_area = clip_coords_for_obj;\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_BEGIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_END, layer);\n#if LV_USE_REFR_DEBUG\n    lv_color_t debug_color = lv_color_make(lv_rand(0, 0xFF), lv_rand(0, 0xFF), lv_rand(0, 0xFF));\n    lv_draw_rect_dsc_t draw_dsc;\n    lv_draw_rect_dsc_init(&draw_dsc);\n    draw_dsc.bg_color = debug_color;\n    draw_dsc.bg_opa = LV_OPA_20;\n    draw_dsc.border_width = 1;\n    draw_dsc.border_opa = LV_OPA_30;\n    draw_dsc.border_color = debug_color;\n    lv_draw_rect(layer, &draw_dsc, &obj_coords_ext);\n#endif\n    const lv_area_t * obj_coords;\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_OVERFLOW_VISIBLE)) {\n        obj_coords = &obj_coords_ext;\n    }\n    else {\n        obj_coords = &obj->coords;\n    }\n    lv_area_t clip_coords_for_children;\n    bool refr_children = true;\n    if(!_lv_area_intersect(&clip_coords_for_children, &clip_area_ori, obj_coords)) {\n        refr_children = false;\n    }\n    if(refr_children) {\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(obj);\n        if(child_cnt == 0) {\n            layer->_clip_area = clip_coords_for_obj;\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n        }\n        else {\n            layer->_clip_area = clip_coords_for_children;\n            bool clip_corner = lv_obj_get_style_clip_corner(obj, LV_PART_MAIN);\n            int32_t radius = 0;\n            if(clip_corner) {\n                radius = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n                if(radius == 0) clip_corner = false;\n            }\n            if(clip_corner == false) {\n                for(i = 0; i < child_cnt; i++) {\n                    lv_obj_t * child = obj->spec_attr->children[i];\n                    refr_obj(layer, child);\n                }\n                layer->_clip_area = clip_coords_for_obj;\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n            }\n            else {\n                lv_layer_t * layer_children;\n                lv_draw_mask_rect_dsc_t mask_draw_dsc;\n                lv_draw_mask_rect_dsc_init(&mask_draw_dsc);\n                mask_draw_dsc.radius = radius;\n                mask_draw_dsc.area = obj->coords;\n                lv_draw_image_dsc_t img_draw_dsc;\n                lv_draw_image_dsc_init(&img_draw_dsc);\n                int32_t short_side = LV_MIN(lv_area_get_width(&obj->coords), lv_area_get_height(&obj->coords));\n                int32_t rout = LV_MIN(radius, short_side >> 1);\n                lv_area_t bottom = obj->coords;\n                bottom.y1 = bottom.y2 - rout + 1;\n                if(_lv_area_intersect(&bottom, &bottom, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &bottom);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &bottom);\n                }\n                lv_area_t top = obj->coords;\n                top.y2 = top.y1 + rout - 1;\n                if(_lv_area_intersect(&top, &top, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &top);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &top);\n                }\n                lv_area_t mid = obj->coords;\n                mid.y1 += rout;\n                mid.y2 -= rout;\n                if(_lv_area_intersect(&mid, &mid, &clip_area_ori)) {\n                    layer->_clip_area = mid;\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n                }\n            }\n        }\n    }\n    layer->_clip_area = clip_area_ori;\n}\n//...'"
"'Prompt: You are working on a graphical user interface project and need to create a flex container with a row wrap layout that contains 9 child elements. Each child element is a label displaying a number from 0 to 8. Additionally, you need to create animations for adjusting the row and column gaps within the flex container. Please provide code for handling these animations using the LittlevGL library if the example feature is enabled and the library is set to build examples.","#if LV_USE_FLEX && LV_BUILD_EXAMPLES\nstatic void row_gap_anim(void * obj, int32_t v)\n{\n    lv_obj_set_style_pad_row(obj, v, 0);\n}\nstatic void column_gap_anim(void * obj, int32_t v)\n{\n    lv_obj_set_style_pad_column(obj, v, 0);\n}\nvoid lv_example_flex_5(void)\n{\n    lv_obj_t * cont = lv_obj_create(lv_screen_active());\n    lv_obj_set_size(cont, 300, 220);\n    lv_obj_center(cont);\n    lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW_WRAP);\n    uint32_t i;\n    for(i = 0; i < 9; i++) {\n        lv_obj_t * obj = lv_obj_create(cont);\n        lv_obj_set_size(obj, 70, LV_SIZE_CONTENT);\n        lv_obj_t * label = lv_label_create(obj);\n        lv_label_set_text_fmt(label, ""%""LV_PRIu32, i);\n        lv_obj_center(label);\n    }\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, cont);\n    lv_anim_set_values(&a, 0, 10);\n    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n    lv_anim_set_exec_cb(&a, row_gap_anim);\n    lv_anim_set_duration(&a, 500);\n    lv_anim_set_playback_duration(&a, 500);\n    lv_anim_start(&a);\n    lv_anim_set_exec_cb(&a, column_gap_anim);\n    lv_anim_set_duration(&a, 3000);\n    lv_anim_set_playback_duration(&a, 3000);\n    lv_anim_start(&a);\n}\n#endif'"
"(""Prompt: You are working on testing a frequency-shift keying (FSK) modem implementation that includes modulation and demodulation functions. The functions are created using the specified parameters - _m, _k, and _bandwidth. These functions handle the modulation and demodulation processes for FSK signals. To ensure the correct operation of the modem, you need to implement a test function that checks if the modulation and demodulation processes work as expected. Could you write a function that tests the FSK modem's modulation and demodulation with M=64 (6-bit), k=100, and a specified bandwidth of 0.3721451? The test should create FSK modulators and demodulators, modulate data, demodulate it back, and compare the input and output symbols to verify correctness.","//...\nvoid fskmodem_test_mod_demod(unsigned int _m,\n                             unsigned int _k,\n                             float        _bandwidth)\n{\n    if (liquid_autotest_verbose)\n        printf(""fskmodem_test_mod_demod(m=%u, k=%u, bandwidth=%g)\\n"", _m, _k, _bandwidth);\n    fskmod mod = fskmod_create(_m,_k,_bandwidth);\n    fskdem dem = fskdem_create(_m,_k,_bandwidth);\n    unsigned int M = 1 << _m;   \n    float complex buf[_k];      \n    unsigned int i;\n    for (i=0; i<M; i++) {\n        unsigned int sym_in = i;\n        fskmod_modulate(mod, sym_in, buf);\n        unsigned int sym_out = fskdem_demodulate(dem, buf);\n        CONTEND_EQUALITY(sym_in, sym_out);\n    }\n    fskmod_destroy(mod);\n    fskdem_destroy(dem);\n}\nvoid autotest_fskmodem_misc_M64()   { fskmodem_test_mod_demod( 6,  100, 0.3721451); }\n//...')
"
"('Prompt: Write a function in C that compares the real and imaginary parts of two elements of an array of complex numbers and sorts them in descending order based on their real parts. If two elements have the same real part, then sort based on their imaginary parts in ascending order. The function should return -1 if the first element should go before the second in the sorted array, 1 if the second element should go before the first, and 0 if they are equal. Use the ""qsort"" function from the C library to sort the array.","//...\nint liquid_poly_sort_roots_compare(const void * _a,\n                                   const void * _b)\n{\n    double ar = (double) creal( *((double complex*)_a) );\n    double br = (double) creal( *((double complex*)_b) );\n    double ai = (double) cimag( *((double complex*)_a) );\n    double bi = (double) cimag( *((double complex*)_b) );\n    return ar == br ? (ai > bi ? -1 : 1) : (ar > br ? 1 : -1);\n}\n//...')
"
"'Prompt: You are tasked with writing a function in C that returns the current monotonic time in microseconds. The function should make use of the `clock_gettime` function with the `CLOCK_MONOTONIC` clock ID to retrieve the time in seconds and nanoseconds, then transform it into microseconds before returning it as a `gint64` value. Ensure that the function handles any potential errors from `clock_gettime` by printing a failure message and returning -1.","//...\ngint64 g_get_monotonic_time()\n{\n    int ret;\n    struct timespec ts;\n    ret = clock_gettime(CLOCK_MONOTONIC, &ts);\n    if (ret != 0) {\n        printf(""clock_gettime failed!\\n"");\n        return -1;\n    }\n    return (((int64_t) ts.tv_sec) * 1000000) + (ts.tv_nsec / 1000);\n}\n//...'"
"('Prompt: You want to implement polynomial interpolation using Lagrange basis for a given set of data points. The goal is to fit a polynomial function to the data points and then evaluate the interpolated value at a specific input value. Additionally, you want to calculate and utilize barycentric weights for efficient computation in the Lagrange interpolation method.","int POLY(_fit_lagrange)(T *          _x,\n                        T *          _y,\n                        unsigned int _n,\n                        T *          _p)\n{\n    unsigned int k=_n-1;    \n    unsigned int i;\n    for (i=0; i<_n; i++)\n        _p[i] = 0.;\n    T roots[k];     \n    T c[_n];        \n    T g;            \n    unsigned int j;\n    unsigned int n;\n    for (i=0; i<_n; i++) {\n        n=0;\n        g=1.0f;\n        for (j=0; j<_n; j++) {\n            if (j!=i) {\n                roots[n++] =  _x[j];\n                g *= (_x[i] - _x[j]);\n            }\n        }\n        g = _y[i] / g;\n        POLY(_expandroots)(roots, k, c);\n        for (j=0; j<_n; j++) {\n            _p[j] += g * c[j];\n        }\n#if 0\n        printf(""****** %3u : **********************\\n"", i);\n        printf(""  g : %12.8f\\n"", crealf(g));\n        printf(""  roots:\\n"");\n        for (j=0; j<k; j++)\n            printf(""  r[%3u] = %12.8f\\n"", j, crealf(roots[j]));\n        printf(""  expanded roots:\\n"");\n        for (j=0; j<_n; j++)\n            printf(""  c[%3u] = %16.6f > %16.6f\\n"", j, crealf(c[j]), crealf(g*c[j]));\n#endif\n    }\n    return LIQUID_OK;\n}\nT POLY(_interp_lagrange)(T * _x,\n                         T * _y,\n                         unsigned int _n,\n                         T   _x0)\n{\n    T y0 = 0.0;     \n    T g;            \n    unsigned int i, j;\n    for (i=0; i<_n; i++) {\n        g=1.0f;\n        for (j=0; j<_n; j++) {\n            if (j!=i) {\n                g *= (_x0 - _x[j])/(_x[i] - _x[j]);\n            }\n        }\n        y0 += _y[i] * g;\n    }\n    return y0;\n}\nint POLY(_fit_lagrange_barycentric)(T *         _x,\n                                   unsigned int _n,\n                                   T *          _w)\n{\n    unsigned int j, k;\n    for (j=0; j<_n; j++) {\n        _w[j] = 1.;\n        for (k=0; k<_n; k++) {\n            if (j==k)   continue;\n            else        _w[j] *= (_x[j] - _x[k]);\n        }\n        if (_w[j] == 0.0f) _w[j] += 1.0e-9f;\n        _w[j] = 1. / _w[j];\n    }\n    T w0 = _w[0] + 1.0e-9f;\n    for (j=0; j<_n; j++)\n        _w[j] /= w0;\n    return LIQUID_OK;\n}\nT POLY(_val_lagrange_barycentric)(T *          _x,\n                                  T *          _y,\n                                  T *          _w,\n                                  T            _x0,\n                                  unsigned int _n)\n{\n    T t0 = 0.;  \n    T t1 = 0.;  \n    T g;        \n    float tol = 1e-6f;\n    unsigned int j;\n    for (j=0; j<_n; j++) {\n        g = _x0 - _x[j];\n        if (T_ABS(g) < tol)\n            return _y[j];\n        t0 += _w[j] * _y[j] / g;\n        t1 += _w[j] / g;\n    }\n    return t0 / t1;\n}')
"
"('Prompt: You are developing a software module for a digital communication system that utilizes packet modulation techniques. The module has functions to modulate and demodulate packets using different modulation schemes such as BPSK, QPSK, PSK8, QAM16, QAM64, SQAM32, SQAM128, and QAM256. Additionally, the module supports encoding and decoding with error correction codes and provides functions to measure EVM (Error Vector Magnitude) and copy the modem configuration. Can you provide a code snippet that demonstrates the testing of the packet modulation and demodulation functionalities using BPSK modulation scheme?","void qpacketmodem_modulated(unsigned int _payload_len,\n                            int          _check,\n                            int          _fec0,\n                            int          _fec1,\n                            int          _ms)\n{\n    unsigned int i;\n    qpacketmodem q = qpacketmodem_create();\n    qpacketmodem_configure(q, _payload_len, _check, _fec0, _fec1, _ms);\n    if (liquid_autotest_verbose)\n        qpacketmodem_print(q);\n    unsigned char payload_tx[_payload_len];\n    unsigned char payload_rx[_payload_len];\n    for (i=0; i<_payload_len; i++) {\n        payload_tx[i] = rand() & 0xff;\n        payload_rx[i] = rand() & 0xff;\n    }\n    unsigned int frame_len = qpacketmodem_get_frame_len(q);\n    float complex frame[frame_len];\n    qpacketmodem_encode(q, payload_tx, frame);\n    int crc_pass = qpacketmodem_decode_soft(q, frame, payload_rx);\n    qpacketmodem_destroy(q);\n    CONTEND_EQUALITY( crc_pass, 1 );\n    CONTEND_SAME_DATA( payload_tx, payload_rx, _payload_len );\n}\nvoid autotest_qpacketmodem_bpsk()   { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QPSK);    }\nvoid autotest_qpacketmodem_qpsk()   { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QPSK);    }\nvoid autotest_qpacketmodem_psk8()   { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_PSK8);    }\nvoid autotest_qpacketmodem_qam16()  { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM16);   }\nvoid autotest_qpacketmodem_sqam32() { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_SQAM32);  }\nvoid autotest_qpacketmodem_qam64()  { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM64);   }\nvoid autotest_qpacketmodem_sqam128(){ qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_SQAM128); }\nvoid autotest_qpacketmodem_qam256() { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM256);  }\nvoid autotest_qpacketmodem_evm()\n{\n    unsigned int payload_len = 800;\n    int          check       = LIQUID_CRC_32;\n    int          fec0        = LIQUID_FEC_NONE;\n    int          fec1        = LIQUID_FEC_NONE;\n    int          ms          = LIQUID_MODEM_QPSK;\n    float        SNRdB       = 25.0f;\n    qpacketmodem q = qpacketmodem_create();\n    qpacketmodem_configure(q, payload_len, check, fec0, fec1, ms);\n    unsigned char payload_rx[payload_len];\n    unsigned int frame_len = qpacketmodem_get_frame_len(q);\n    float complex frame[frame_len];\n    qpacketmodem_encode(q, NULL, frame);\n    float nstd  = powf(10.0f, -SNRdB/20.0f);\n    unsigned int i;\n    for (i=0; i<frame_len; i++)\n        frame[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;\n    qpacketmodem_decode_soft(q, frame, payload_rx);\n    float evm = qpacketmodem_get_demodulator_evm(q);\n    if (liquid_autotest_verbose)\n        printf(""  EVM: %.3f dB, SNR: %.3f dB\\n"", evm, SNRdB);\n    qpacketmodem_destroy(q);\n    CONTEND_DELTA( -evm, SNRdB, 0.5f );\n#if 0\n    FILE * fid = fopen(""qpacketmodem_evm.txt"",""a"");\n    fprintf(fid,""%12.4e\\n"", SNRdB+evm);\n    fclose(fid);\n#endif\n}\nvoid qpacketmodem_unmodulated(unsigned int _payload_len,\n                              int          _check,\n                              int          _fec0,\n                              int          _fec1,\n                              int          _ms)\n{\n    unsigned int i;\n    qpacketmodem q = qpacketmodem_create();\n    qpacketmodem_configure(q, _payload_len, _check, _fec0, _fec1, _ms);\n    if (liquid_autotest_verbose)\n        qpacketmodem_print(q);\n    unsigned char payload_tx[_payload_len];\n    unsigned char payload_rx[_payload_len];\n    for (i=0; i<_payload_len; i++) {\n        payload_tx[i] = rand() & 0xff;\n        payload_rx[i] = rand() & 0xff;\n    }\n    unsigned int frame_len = qpacketmodem_get_frame_len(q);\n    unsigned char frame_syms[frame_len];\n    qpacketmodem_encode_syms(q, payload_tx, frame_syms);\n    int crc_pass = qpacketmodem_decode_syms(q, frame_syms, payload_rx);\n    qpacketmodem_destroy(q);\n    CONTEND_EQUALITY( crc_pass, 1 );\n    CONTEND_SAME_DATA( payload_tx, payload_rx, _payload_len );\n}\nvoid autotest_qpacketmodem_unmod_bpsk()   { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QPSK);    }\nvoid autotest_qpacketmodem_unmod_qpsk()   { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QPSK);    }\nvoid autotest_qpacketmodem_unmod_psk8()   { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_PSK8);    }\nvoid autotest_qpacketmodem_unmod_qam16()  { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM16);   }\nvoid autotest_qpacketmodem_unmod_sqam32() { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_SQAM32);  }\nvoid autotest_qpacketmodem_unmod_qam64()  { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM64);   }\nvoid autotest_qpacketmodem_unmod_sqam128(){ qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_SQAM128); }\nvoid autotest_qpacketmodem_unmod_qam256() { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM256);  }\nvoid autotest_qpacketmodem_copy()\n{\n    unsigned int i;\n    unsigned int payload_len = 400;\n    crc_scheme   check       = LIQUID_CRC_24;\n    fec_scheme   fec0        = LIQUID_FEC_SECDED7264;\n    fec_scheme   fec1        = LIQUID_FEC_HAMMING128;\n    int          ms          = LIQUID_MODEM_PI4DQPSK;\n    qpacketmodem q0 = qpacketmodem_create();\n    qpacketmodem_configure(q0, payload_len, check, fec0, fec1, ms);\n    unsigned int frame_len = qpacketmodem_get_frame_len(q0);\n    unsigned char payload_tx  [payload_len];\n    float complex frame_syms_0[frame_len];\n    float complex frame_syms_1[frame_len];\n    unsigned char payload_rx_0[payload_len];\n    unsigned char payload_rx_1[payload_len];\n    for (i=0; i<payload_len; i++)\n        payload_tx[i] = rand() & 0xff;\n    qpacketmodem_encode(q0, payload_tx, frame_syms_0);\n    qpacketmodem q1 = qpacketmodem_copy(q0);\n    qpacketmodem_encode(q1, payload_tx, frame_syms_1);\n    CONTEND_SAME_DATA( frame_syms_0, frame_syms_1, frame_len );\n    for (i=0; i<payload_len; i++) {\n        frame_syms_0[i] = randnf() + _Complex_I*randnf();\n        frame_syms_1[i] =  frame_syms_0[i];\n    }\n    int crc_pass_0 = qpacketmodem_decode(q0, frame_syms_0, payload_rx_0);\n    int crc_pass_1 = qpacketmodem_decode(q1, frame_syms_1, payload_rx_1);\n    CONTEND_SAME_DATA( payload_rx_0, payload_rx_1, payload_len );\n    CONTEND_EQUALITY( crc_pass_0, crc_pass_1 );\n    qpacketmodem_destroy(q0);\n    qpacketmodem_destroy(q1);\n}')
"
"'Give a C code snippet where you are creating a function named `on_shell_help` that takes a `struct rpc_session` pointer `r`, an input buffer `ibuf`, its length `ilen`, output buffer `obuf`, length of output buffer `olen`, as parameters. . . In this function, you are allocating memory for the output buffer, printing the command received, setting the output buffer to 0, calling a function `system_with_result` which populates the output buffer based on the input buffer command received, and if the return code is positive, updating the length of the output buffer accordingly before returning 0.","//...\n    int i;\n    ss = calloc(cnt, sizeof(struct rpc_session));\n    return 0;\n    char res[1024] = {0};\n    char cmd[512];\n    struct rpc *r = (struct rpc *)arg;\n    for (i = 0; i < len; i++) {\n        ch = getchar();\n    char *buf = (char *)calloc(1, len);\n    struct rpc *rpc = rpc_client_create(ip, port);\n    int loop = 1;\nstatic int on_shell_help(struct rpc_session *r, void *ibuf, size_t ilen, void **obuf, size_t *olen)\n{\n    int ret;\n    char *cmd = (char *)ibuf;\n    *obuf = calloc(1, 1024);\n    *olen = 1024;\n    printf(""on_shell_help cmd = %s\\n"", cmd);\n    memset(*obuf, 0, 1024);\n    ret = system_with_result(cmd, *obuf, 1024);\n    if (ret > 0) {\n        *olen = ret;\n    }\n    return 0;\n}\n//...'"
"('Prompt: You are working on testing an FIR filter implementation using the Kaiser window method, with a length of 51 coefficients, a beta value of 0.2, a passband ripple of 0.0 dB, and a stopband attenuation of 60 dB. You need to create an automated test that checks the output of two FIR filters with the same configuration but different input methods. One filter takes input through individual push operations, and the other takes input through a buffer write operation. The test should run for 20 trials, each time providing a different number of samples to compare the outputs. The test should verify that the outputs of both filters are equal using a test assertion method called CONTEND_EQUALITY. Please implement the autotest_firfilt_push_write function to automate this test scenario.","//...\nvoid autotest_firfilt_push_write()\n{\n    firfilt_rrrf q0 = firfilt_rrrf_create_kaiser(51, 0.2f, 60.0f, 0.0f);\n    firfilt_rrrf q1 = firfilt_rrrf_create_kaiser(51, 0.2f, 60.0f, 0.0f);\n    float buf[8] = {-1,3,5,-3,5,1,-3,-4};\n    unsigned int trial, i;\n    for (trial=0; trial<20; trial++) {\n        unsigned int n = trial % 8;\n        for (i=0; i<n; i++)\n            firfilt_rrrf_push(q0, buf[i]);\n        firfilt_rrrf_write(q1, buf, n);\n        float v0, v1;\n        firfilt_rrrf_execute(q0, &v0);\n        firfilt_rrrf_execute(q1, &v1);\n        CONTEND_EQUALITY(v0, v1);\n    }\n    firfilt_rrrf_destroy(q0);\n    firfilt_rrrf_destroy(q1);\n}\n//...')
"
"('Prompt: Implement a 1-dimensional search algorithm that finds the minimum value of a given function using gradient descent. Provide a function to test this algorithm with specific parameters and output the results. Also, include a function to find the maximum value of the same function by simply negating the minimum function. Lastly, create an automated test function to test the algorithm for maximizing a utility function in the range of -10 to 15 with the optimization direction set to maximize.","//...\nfloat qs1dsearch_umin(float _v, void * _context)\n{\n    float v_opt = *(float*)(_context);\n    float v = _v - v_opt;\n    return tanhf(v)*tanhf(v);\n}\nvoid test_qs1dsearch(liquid_utility_1d _utility,\n                     float             _v_opt,\n                     float             _v_lo,\n                     float             _v_hi,\n                     int               _bounds,\n                     int               _direction)\n{\n    qs1dsearch q = qs1dsearch_create(_utility, &_v_opt, _direction);\n    if (_bounds) qs1dsearch_init_bounds(q, _v_lo, _v_hi);\n    else         qs1dsearch_init       (q, _v_lo);\n    unsigned int i;\n    for (i=0; i<32; i++) {\n        qs1dsearch_step(q);\n        if (liquid_autotest_verbose)\n            qs1dsearch_print(q);\n    }\n    CONTEND_DELTA( qs1dsearch_get_opt_v(q), _v_opt,                    1e-3f );\n    CONTEND_DELTA( qs1dsearch_get_opt_u(q), _utility(_v_opt, &_v_opt), 1e-3f );\n    if (liquid_autotest_verbose) {\n        printf(""%3u : u(%12.8f) = %12.4e, v_opt=%12.4e (error=%12.4e)\\n"",\n            i, qs1dsearch_get_opt_v(q), qs1dsearch_get_opt_u(q),\n            _v_opt, _v_opt - qs1dsearch_get_opt_v(q));\n    }\n    qs1dsearch_destroy(q);\n}\nfloat qs1dsearch_umax(float _v, void * _context)\n    { return -qs1dsearch_umin(_v, _context); }\nvoid autotest_qs1dsearch_max_12() { test_qs1dsearch(qs1dsearch_umax, 0, -10, 15, 1, LIQUID_OPTIM_MAXIMIZE); }\n//...')
"
"('Prompt: . You are working on testing a software module that involves generating pseudo-random sequences using a linear feedback shift register. To automate testing, you need to write a function that tests the period of the generated sequence for a specific value of m. Write a function that takes an integer m as input, creates a default m-sequence generator, measures its period, and then asserts that the period is equal to 2^m - 1. Finally, destroy the generator. As an example, create a specific test function called autotest_msequence_period_m12 that tests the period for m = 12.","//...\nvoid msequence_test_period(unsigned int _m)\n{\n    msequence q = msequence_create_default(_m);\n    unsigned int n = (1U << _m) - 1;\n    unsigned int p = msequence_measure_period(q);\n    CONTEND_EQUALITY(p,n)\n    msequence_destroy(q);\n}\nvoid autotest_msequence_period_m12() { msequence_test_period(12); }\n//...')
"
"'Prompt: In a firmware development scenario for an LPC176x microcontroller, you need assistance with implementing watchdog functionality to monitor system integrity and trigger reset actions if necessary. The watchdog should be configured to reset the system if it detects a fault, and optionally be able to trigger an interrupt for further error handling. Additionally, you want to set the watchdog timeout period in microseconds. Can you provide code snippets for configuring the LPC176x watchdog, enabling clock selection, and setting up a watchdog interrupt handler if needed?","inline bool lpc176x_been_reset_by_watchdog( void )\n{\n  return ( ( LPC176X_WDMOD & LPC176X_WWDT_MOD_WDTOF ) ==\n           LPC176X_WWDT_MOD_WDTOF );\n}\ninline void lpc176x_watchdog_reset( void )\n{\n  LPC176X_WDFEED = LPC176X_WDFEED_CON;\n  LPC176X_WDFEED = LPC176X_WDFEED_CFG;\n}\nstatic inline rtems_status_code enable_module_and_set_clocksel(\n  const lpc176x_microseconds tcount )\n{\n  rtems_status_code status_code;\n  LPC176X_WDCLKSEL = LPC176X_WWDT_CLKSEL_WDSEL_PCLK;\n  status_code = lpc176x_module_enable( LPC176X_MODULE_WD,\n    LPC176X_MODULE_PCLK_DEFAULT );\n  RTEMS_CHECK_SC( status_code, ""Enabling the watchdog module."" );\n  LPC176X_WDTC = ( LPC176X_CCLK / LPC176X_WD_PRESCALER_DIVISOR ) * tcount;\n  return status_code;\n}\nrtems_status_code lpc176x_watchdog_config( const lpc176x_microseconds tcount )\n{\n  rtems_status_code status_code = enable_module_and_set_clocksel( tcount );\n  LPC176X_WDMOD = LPC176X_WWDT_MOD_WDEN | LPC176X_WWDT_MOD_WDRESET;\n  lpc176x_watchdog_reset();\n  return status_code;\n}\nrtems_status_code lpc176x_watchdog_config_with_interrupt(\n  const lpc176x_wd_isr_funct interrupt,\n  const lpc176x_microseconds tcount\n)\n{\n  rtems_status_code status_code = enable_module_and_set_clocksel( tcount );\n  LPC176X_WDMOD = LPC176X_WWDT_MOD_WDEN | LPC176X_WWDT_MOD_WDINT;\n  status_code = rtems_interrupt_handler_install(\n    LPC176X_WD_INTERRUPT_VECTOR_NUMBER,\n    ""watchdog_interrupt"",\n    RTEMS_INTERRUPT_UNIQUE,\n    interrupt,\n    NULL );\n  lpc176x_watchdog_reset();\n  return status_code;\n}'"
"('Write a prompt asking for a function that creates and tests a modem for a specified modulation scheme using APSK64, including modulating, demodulating, and testing soft bits to ensure correctness.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_apsk64()    { modemcf_test_demodsoft(LIQUID_MODEM_APSK64);    }\n//...')
"
"('Prompt: You are developing a software library that implements a pilot generator for a digital communication system. The pilot generator creates a certain number of complex symbols to insert into the transmitted signal for channel estimation at the receiver. Write a function that creates a new pilot generator object according to the specified payload length and pilot spacing. The payload length must be at least 1 symbol and the pilot spacing must be at least 2 symbols to generate valid pilots. The function should also calculate the total frame length based on the payload and pilot count, generate the pilot symbols, and initialize the pilot generator object. The pilot symbols should be generated using a pseudo-random sequence with a specific phase offset. Additionally, provide a function to reset the pilot generator object and a function to create a deep copy of a pilot generator object. The pilot generator object should store the payload length, pilot spacing, total frame length, number of pilots, and the pilot symbols.","//...\nqpilotgen qpilotgen_create(unsigned int _payload_len,\n                           unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0)\n        return liquid_error_config(""qpilotgen_create(), frame length must be at least 1 symbol"");\n    if (_pilot_spacing < 2)\n        return liquid_error_config(""qpilotgen_create(), pilot spacing must be at least 2 symbols"");\n    unsigned int i;\n    qpilotgen q = (qpilotgen) malloc(sizeof(struct qpilotgen_s));\n    q->payload_len   = _payload_len;\n    q->pilot_spacing = _pilot_spacing;\n    q->num_pilots = qpilot_num_pilots(q->payload_len, q->pilot_spacing);\n    q->frame_len  = q->payload_len + q->num_pilots;\n    q->pilots = (float complex*) malloc(q->num_pilots*sizeof(float complex));\n    unsigned int m = liquid_nextpow2(q->num_pilots);\n    msequence seq = msequence_create_default(m);\n    for (i=0; i<q->num_pilots; i++) {\n        unsigned int s = msequence_generate_symbol(seq, 2);\n        float theta = (2 * M_PI * (float)s / 4.0f) + M_PI / 4.0f;\n        q->pilots[i] = cexpf(_Complex_I*theta);\n    }\n    msequence_destroy(seq);\n    qpilotgen_reset(q);\n    return q;\n}\nunsigned int qpilot_num_pilots(unsigned int _payload_len,\n                               unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0 || _pilot_spacing < 2)\n        return 0;\n    div_t d = div(_payload_len,(_pilot_spacing - 1));\n    return d.quot + (d.rem ? 1 : 0);\n}\nint qpilotgen_reset(qpilotgen _q)\n{\n    return LIQUID_OK;\n}\nqpilotgen qpilotgen_copy(qpilotgen q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""qpilotgen_copy(), object cannot be NULL"");\n    return qpilotgen_create(q_orig->payload_len, q_orig->pilot_spacing);\n}\n//...')
"
"'Prompt: ""Given a scenario where you have a C program with a macro defined for a debug mode (LOGA_DEBUG), and a function that calculates the elapsed time in milliseconds since a specified start time using gettimeofday and timersub. Can you provide me with the code snippet for the timeval struct, gettimeofday function, timersub function, and the elapsed function implementation?""","//...\n#define LOGA_DEBUG 0\n    return 1;\nlong elapsed(START_TIME_TYPE start_time)\n{\n    struct timeval now, res;\n    gettimeofday(&now, NULL);\n    timersub(&now, &start_time, &res);\n    return (res.tv_sec)*1000 + (res.tv_usec)/1000;\n}\n//...'"
"('Prompt: You are working on an OFDM transceiver and need to validate the subcarriers in an OFDM frame. You need to write a C function that takes in a pointer to an array of unsigned chars representing the subcarrier types, the total number of subcarriers, and pointers to variables to store the counts of null, pilot, and data subcarriers. The function should ensure that there is at least one pilot and data subcarrier enabled and at least two pilot subcarriers. If there are any errors, the function should return a specific error code. If there are no errors, the counts of null, pilot, and data subcarriers should be stored in the respective pointers and the function should return a success code.","//...\nint ofdmframe_validate_sctype(unsigned char * _p,\n                              unsigned int    _M,\n                              unsigned int *  _M_null,\n                              unsigned int *  _M_pilot,\n                              unsigned int *  _M_data)\n{\n    unsigned int M_null  = 0;\n    unsigned int M_pilot = 0;\n    unsigned int M_data  = 0;\n    unsigned int i;\n    for (i=0; i<_M; i++) {\n        if (_p[i] == OFDMFRAME_SCTYPE_NULL)\n            M_null++;\n        else if (_p[i] == OFDMFRAME_SCTYPE_PILOT)\n            M_pilot++;\n        else if (_p[i] == OFDMFRAME_SCTYPE_DATA)\n            M_data++;\n        else {\n            return liquid_error(LIQUID_EICONFIG,""ofdmframe_validate_sctype(), invalid subcarrier type (%u)"", _p[i]);\n        }\n    }\n    if ( (M_pilot + M_data) == 0)\n        return liquid_error(LIQUID_EICONFIG,""ofdmframe_validate_sctype(), must have at least one enabled subcarrier"");\n    if (M_data == 0)\n        return liquid_error(LIQUID_EICONFIG,""ofdmframe_validate_sctype(), must have at least one data subcarrier"");\n    if (M_pilot < 2)\n        return liquid_error(LIQUID_EICONFIG,""ofdmframe_validate_sctype(), must have at least two pilot subcarriers"");\n    if (_M_null  != NULL) *_M_null  = M_null;\n    if (_M_pilot != NULL) *_M_pilot = M_pilot;\n    if (_M_data  != NULL) *_M_data  = M_data;\n    return LIQUID_OK;\n}\n//...')
"
"'Please provide a technical scenario in which you need a function that uses STUN (Session Traversal Utilities for NAT) to establish communication between two peers behind NAT. You want to create a function that initializes STUN, opens a socket, and performs communication tasks such as sending and receiving messages. The function should handle events using epoll to monitor incoming messages and maintain the connection alive with a keep-alive thread.","//...\n    int fd = tmp->fd;\n    char *ip = tmp->ip;\n#define MAX_EPOLL_EVENT 16\nstatic char stun_server_ip[64] = {0};\n    char buf[1024] = {0};\n    int ret, i;\n#define MAX_EPOLL_EVENT 16\n    return NULL;\nstatic void *keep_alive(void *args)\n{\n    while (1) {\n        sleep(30);\n    }\n    return NULL;\n}\nstatic void recv_msg(int fd)\n{\n    int ret;\n    char buf[1024] = {0};\n#if 0\n    ret = recv(fd, buf, sizeof(buf), 0);\n    if (ret == -1) {\n        printf(""%s:%d: errno = %d: %s\\n"", __func__, __LINE__, errno, strerror(errno));\n    }\n#endif\n    struct sockaddr_in si, si2;\n    socklen_t si_len = sizeof(si);\n    memset(&si, 0, sizeof(si));\n    memset(&si2, 0, sizeof(si));\n    ret = recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr *)&si, &si_len);\n    if (ret == -1) {\n        printf(""%s:%d: errno = %d: %s\\n"", __func__, __LINE__, errno, strerror(errno));\n    }\n    if (-1 == getsockname(fd, (struct sockaddr *)&si2, &si_len)) {\n        perror(""getsockname failed!\\n"");\n    }\n    printf(""\\nrecv from ip = %s port = %d to ip = %s port = %d msg > %s\\n"", inet_ntoa(si.sin_addr), ntohs(si.sin_port), inet_ntoa(si2.sin_addr), ntohs(si2.sin_port), buf);\n}\nstatic int test(const char *local_ip, uint16_t local_port)\n{\n    int i;\n    int ret;\n    int epfd, fd;\n    struct in_addr sa;\n    struct sockaddr_in si;\n    socklen_t si_len;\n    struct epoll_event event;\n    struct epoll_event evbuf[MAX_EPOLL_EVENT];\n    stun_addr mapped;\n    pthread_t tid;\n    struct addr_info args;\n    char ip[64] = {0};\n    uint16_t port;\n    struct stun_t stun;\n    if (0 != stun_init(&stun, stun_server_ip)) {\n        printf(""stun init failed!\\n"");\n        return -1;\n    }\n    printf(""stun init ok!\\n"");\n    printf(""stun_socket %s:%d\\n"", local_ip, local_port);\n    fd = stun_socket(&stun, local_ip, local_port, &mapped);\n    if (fd == -1) {\n        printf(""stun open socket failed!\\n"");\n        return -1;\n    }\n    memset(&si, 0, sizeof(si));\n    if (-1 == getsockname(fd, (struct sockaddr *)&si, &si_len)) {\n        perror(""getsockname failed!\\n"");\n    }\n    printf(""ip = %s port = %d\\n"", inet_ntoa(si.sin_addr), ntohs(si.sin_port));\n    stun_nat_type(&stun);\n    pthread_create(&tid, NULL, keep_alive, (void *)&fd);\n    sa.s_addr = ntohl(mapped.addr);\n    printf(""mapped ip = %s, port = %d\\n"", inet_ntoa(sa), mapped.port);\n    printf(""input peer ip: "");\n    scanf(""%s"", ip);\n    printf(""input peer port: "");\n    scanf(""%hd"", &port);\n    if (-1 == (epfd = epoll_create(1))) {\n        perror(""epoll_create"");\n        return -1;\n    }\n    memset(&event, 0, sizeof(event));\n    event.data.fd = fd;\n    event.events = EPOLLIN | EPOLLET;\n    if (-1 == epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event)) {\n        perror(""epoll_ctl"");\n        close(epfd);\n        return -1;\n    }\n    args.fd = fd;\n    args.port = port;\n    strcpy(args.ip, ip);\n    pthread_create(&tid, NULL, send_msg, (void *)&args);\n    while (1) {\n        ret = epoll_wait(epfd, evbuf, MAX_EPOLL_EVENT, -1);\n        if (ret == -1) {\n            perror(""epoll_wait"");\n            continue;\n        }\n        for (i = 0; i < ret; i++) {\n            if (evbuf[i].data.fd == -1)\n                continue;\n            if (evbuf[i].events & (EPOLLERR | EPOLLHUP)) {\n                perror(""epoll error"");\n            }\n            if (evbuf[i].events & EPOLLOUT) {\n                perror(""epoll out"");\n            }\n            if (evbuf[i].events & EPOLLIN) {\n                recv_msg(evbuf[i].data.fd);\n            }\n        }\n    }\n}\n//...'"
"('Prompt: Can you write a function in C that takes in a fec_scheme enum as input and returns 1 if the scheme is a convolutional code (specifically LIQUID_FEC_CONV_V27, LIQUID_FEC_CONV_V29, LIQUID_FEC_CONV_V39, LIQUID_FEC_CONV_V615, LIQUID_FEC_CONV_V27P23, LIQUID_FEC_CONV_V27P34, LIQUID_FEC_CONV_V27P45, LIQUID_FEC_CONV_V27P56, LIQUID_FEC_CONV_V27P67, LIQUID_FEC_CONV_V27P78, LIQUID_FEC_CONV_V29P23, LIQUID_FEC_CONV_V29P34, LIQUID_FEC_CONV_V29P45, LIQUID_FEC_CONV_V29P56, LIQUID_FEC_CONV_V29P67, or LIQUID_FEC_CONV_V29P","//...\nint fec_scheme_is_convolutional(fec_scheme _scheme)\n{\n    switch (_scheme) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n        return 1;\n    default:;\n    }\n    return 0;\n}\n//...')
"
"('Prompt: You are designing a test scenario for a linear quadrature detector (qdetector_cccf) implementation that operates on a given sequence of complex values and runs a test on it. The test scenario involves generating a random sequence of complex numbers, creating the detector with specific parameters, running the test on the generated sequence, and checking for frame detection and parameter estimation accuracy. Provide a function that carries out this test scenario for a sequence length of 256.","//...\nvoid qdetector_cccf_runtest_linear(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    int          ftype = LIQUID_FIRFILT_ARKAISER; \n    unsigned int i;\n    float complex sequence[_sequence_len];\n    for (i=0; i<_sequence_len; i++) {\n        sequence[i] = (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 +\n                      (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 * _Complex_I;\n    }\n    qdetector_cccf q = qdetector_cccf_create_linear(sequence, _sequence_len, ftype, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_linear_n256()  { qdetector_cccf_runtest_linear( 256); }\n//...')
"
"'Please provide the code for interacting with the Real-Time Clock (RTC) on a device running on the AM335X processor, including functions for setting and getting time, initializing the RTC, enabling/disabling write access, and debugging functionalities. Ensure that the code properly handles time conversions and RTC configuration on the AM335X platform.","#if IS_AM335X\n#define setbit(a,x) (a | (1<<x))\n#define bcd(a) ((a & 0x0f)+ (((a & 0xf0) >> 4 )*10))\n#define dec(a) (((a / 10) << 4) | (a % 10))\n#define WRITE_WAIT_MAX_COUNT 10000\nsize_t RTC_Count = 1;\nstatic void rtc_write_enable(void);\nstatic void rtc_write_disable(void);\nstatic int rtc_write_wait(void);\nstatic void rtc_clk_init(void);\nvoid rtc_init(int minor);\nvoid print_time(void);\nint am335x_rtc_gettime(int minor,rtems_time_of_day *t);\nint am335x_rtc_settime(int minor, const rtems_time_of_day *t);\nvoid am335x_rtc_debug(void);\nstatic bool am335x_rtc_probe (int minor)\n{\n  return true;\n}\nstatic void rtc_write_enable(void)\n{\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_KICK0,AM335X_RTC_KICK0_KEY);\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_KICK1,AM335X_RTC_KICK1_KEY);\n}\nstatic void rtc_write_disable(void)\n{\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_KICK0,0x11111111);\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_KICK1,0x11111111);\n}\nstatic int rtc_write_wait(void)\n{\n  int i = WRITE_WAIT_MAX_COUNT;\n  while((mmio_read(AM335X_RTC_BASE+AM335X_RTC_STATUS_REG) & 0x1) && (i--));\n  if(i == 0)\n      return RTEMS_RESOURCE_IN_USE;\n  else\n      return RTEMS_SUCCESSFUL;\n}\nstatic void rtc_clk_init(void)\n{\n  uint32_t a = 0x0;\n  a = setbit(a,1);\n  mmio_write(CM_RTC_BASE+CM_RTC_RTC_CLKCTRL,a);\n  a = 0x0;\n  a = setbit(a,9);\n  a = setbit(a,8);\n  mmio_write(CM_RTC_BASE+CM_RTC_CLKSTCTRL,a);\n}\nvoid rtc_init(int minor)\n{\n  uint32_t a = 0x0;\n  rtc_clk_init();\n  rtc_write_enable();\n  a = setbit(a,0);\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_SYSCONFIG,a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_OSC_CLOCK);\n  a = setbit(a,6);\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_OSC_CLOCK,a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_CTRL_REG);\n  a = setbit(a,0);\n  mmio_write(AM335X_RTC_BASE+AM335X_RTC_CTRL_REG,a);\n  rtc_write_disable();\n}\nint am335x_rtc_gettime(int minor,rtems_time_of_day *t)\n{\n  uint32_t a = 0x0;\n  if(minor != 0)\n    return RTEMS_INVALID_NUMBER;\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_SECS);\n  t->second = bcd(a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_MINS);\n  t->minute = bcd(a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_HOURS);\n  t->hour = bcd(a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_DAYS);\n  t->day = bcd(a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_MONTHS);\n  t->month = bcd(a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_YEARS);\n  t->year = bcd(a)+2000;\n  t->ticks=0;\n  return RTEMS_SUCCESSFUL;\n}\nint am335x_rtc_settime(int minor,const rtems_time_of_day *t)\n{\n  uint32_t a=0x0;\n  int rv;\n  if(minor != 0)\n    return RTEMS_INVALID_NUMBER;\n  rtc_write_enable();\n  a = t->second;\n  rv=rtc_write_wait();\n  if(rv != RTEMS_SUCCESSFUL)\n      return rv;\n  a = mmio_write(AM335X_RTC_BASE+AM335X_RTC_SECS,dec(a) & 0x7f);\n  a = t->minute;\n  rv=rtc_write_wait();\n  if(rv != RTEMS_SUCCESSFUL)\n      return rv;\n  a = mmio_write(AM335X_RTC_BASE+AM335X_RTC_MINS,dec(a) & 0x7f);\n  a = t->hour;\n  rv=rtc_write_wait();\n  if(rv != RTEMS_SUCCESSFUL)\n      return rv;\n  a = mmio_write(AM335X_RTC_BASE+AM335X_RTC_HOURS,dec(a) & 0x3f);\n  a = t->day;\n  rv=rtc_write_wait();\n  if(rv != RTEMS_SUCCESSFUL)\n      return rv;\n  a = mmio_write(AM335X_RTC_BASE+AM335X_RTC_DAYS,dec(a) & 0x3f);\n  a = t->month;\n  rv=rtc_write_wait();\n  if(rv != RTEMS_SUCCESSFUL)\n      return rv;\n  a = mmio_write(AM335X_RTC_BASE+AM335X_RTC_MONTHS,dec(a) & 0x1f);\n  a = t->year;\n  rv=rtc_write_wait();\n  if(rv != RTEMS_SUCCESSFUL)\n      return rv;\n  a = mmio_write(AM335X_RTC_BASE+AM335X_RTC_YEARS,(dec(a)%100) & 0xff);\n  rtc_write_disable();\n  return rv;\n}\n#if BBB_DEBUG\nvoid print_time(void)\n{\n  uint32_t a = 0x0;\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_SECS);\n  printk(""\\n\\rSecs %x"",a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_MINS);\n  printk(""\\n\\rMins %x"",a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_HOURS);\n  printk(""\\n\\rHours %x"",a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_DAYS);\n  printk(""\\n\\rDays %x"",a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_MONTHS);\n  printk(""\\n\\r Months %x"",a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_YEARS);\n  printk(""\\n\\rYears %x"",a);\n  a = mmio_read(AM335X_RTC_BASE+AM335X_RTC_WEEKS);\n  printk(""\\n\\rWeeks %x"",a);\n}\nvoid am335x_rtc_debug(void)\n{\n  int i;\n  rtems_time_of_day t,r;\n  t.second = 1;\n  t.minute = 1;\n  t.hour = 1;\n  t.day = 7;\n  t.month = 3;\n  t. year = 2015;\n  am335x_rtc_settime(0,&t);\n  am335x_rtc_gettime(0,&r);\n  printk(""Secs %x"",r.second);\n  printk(""Mins %x"",r.minute);\n  printk(""Hours %x"",r.hour);\n  printk(""Days %x"",r.day);\n  printk(""Months %x"",r.month);\n  printk(""Years %x"",r.year);\n}\n#endif\nrtc_fns am335x_rtc_fns = {\n  rtc_init,\n  am335x_rtc_gettime,\n  am335x_rtc_settime\n};\nrtc_tbl RTC_Table[] = {\n  {\n   ""/dev/rtc"",                  \n   RTC_CUSTOM,                  \n   &am335x_rtc_fns,             \n   am335x_rtc_probe,            \n   NULL,                        \n   0,                           \n   0,                           \n   NULL,                        \n   NULL                         \n   }\n};\n#endif'"
"(""Prompt: You are tasked with writing a function to test the autocorrelation of a binary sequence generated by a Maximum Length Sequence (MLS) generator with a specific order. The function should create two binary sequences initialized with the same MLS generator, calculate the autocorrelation between them, and then iterate over advancing one of the sequences to compare against the expected results. Your function should handle a specific order, let's say 9, and perform tests on it. Provide the code for this scenario.","//...\nvoid msequence_test_autocorrelation(unsigned int _m)\n{\n    msequence ms = msequence_create_default(_m);\n    unsigned int n = msequence_get_length(ms);\n    bsequence bs1 = bsequence_create(n);\n    bsequence_init_msequence(bs1, ms);\n    bsequence bs2 = bsequence_create(n);\n    bsequence_init_msequence(bs2, ms);\n    CONTEND_EQUALITY( bsequence_get_length(bs1), n )\n    CONTEND_EQUALITY( bsequence_get_length(bs2), n )\n    signed int rxy;\n    rxy = bsequence_correlate(bs1, bs2);\n    CONTEND_EQUALITY( rxy, n )\n    unsigned int i;\n    for (i=0; i<n-1; i++) {\n        bsequence_push(bs2, msequence_advance(ms));\n        rxy = 2*bsequence_correlate(bs1, bs2) - n;\n        CONTEND_EQUALITY( rxy, -1 );\n    }\n    bsequence_destroy(bs1);\n    bsequence_destroy(bs2);\n    msequence_destroy(ms);\n}\nvoid autotest_msequence_xcorr_m9()  { msequence_test_autocorrelation(9);  }\n//...')
"
"'Please write a function that uses the eDMA peripheral to transfer data in the context of flexspi (FlexSPI) driver. The function should handle setting up the eDMA transfers for both TX and RX directions, calculating power, handling transfer completion, aborting transfers if necessary, and providing a way to get the transfer count in progress. The driver should include necessary data structures and helper functions to support this functionality.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.flexspi_edma""\n#endif\ntypedef struct _flexspi_edma_private_handle\n{\n    FLEXSPI_Type *base;\n    flexspi_edma_handle_t *handle;\n} flexspi_edma_private_handle_t;\nenum\n{\n    kFLEXSPI_Idle, \n    kFLEXSPI_Busy  \n};\nstatic FLEXSPI_Type *const s_flexspiBases[] = FLEXSPI_BASE_PTRS;\nstatic flexspi_edma_private_handle_t s_edmaPrivateHandle[ARRAY_SIZE(s_flexspiBases)];\nstatic void FLEXSPI_TransferEDMACallback(edma_handle_t *handle, void *param, bool transferDone, uint32_t tcds);\nstatic uint8_t FLEXSPI_CalculatePower(uint8_t value)\n{\n    uint8_t power = 0;\n    while (value >> 1 != 0U)\n    {\n        power++;\n        value = value >> 1;\n    }\n    return power;\n}\nstatic void FLEXSPI_TransferEDMACallback(edma_handle_t *handle, void *param, bool transferDone, uint32_t tcds)\n{\n    flexspi_edma_private_handle_t *flexspiPrivateHandle = (flexspi_edma_private_handle_t *)param;\n    handle = handle;\n    tcds   = tcds;\n    if (transferDone)\n    {\n        while (!FLEXSPI_GetBusIdleStatus(flexspiPrivateHandle->base))\n        {\n        }\n        FLEXSPI_TransferAbortEDMA(flexspiPrivateHandle->base, flexspiPrivateHandle->handle);\n        if (flexspiPrivateHandle->handle->completionCallback != NULL)\n        {\n            flexspiPrivateHandle->handle->completionCallback(flexspiPrivateHandle->base, flexspiPrivateHandle->handle,\n                                                             kStatus_Success, flexspiPrivateHandle->handle->userData);\n        }\n    }\n}\nvoid FLEXSPI_TransferCreateHandleEDMA(FLEXSPI_Type *base,\n                                      flexspi_edma_handle_t *handle,\n                                      flexspi_edma_callback_t callback,\n                                      void *userData,\n                                      edma_handle_t *txDmaHandle,\n                                      edma_handle_t *rxDmaHandle)\n{\n    assert(handle);\n    uint32_t instance = FLEXSPI_GetInstance(base);\n    s_edmaPrivateHandle[instance].base   = base;\n    s_edmaPrivateHandle[instance].handle = handle;\n    (void)memset(handle, 0, sizeof(*handle));\n    handle->state       = kFLEXSPI_Idle;\n    handle->txDmaHandle = txDmaHandle;\n    handle->rxDmaHandle = rxDmaHandle;\n    handle->nsize       = kFLEXPSI_EDMAnSize1Bytes;\n    handle->completionCallback = callback;\n    handle->userData           = userData;\n}\nvoid FLEXSPI_TransferUpdateSizeEDMA(FLEXSPI_Type *base,\n                                    flexspi_edma_handle_t *handle,\n                                    flexspi_edma_transfer_nsize_t nsize)\n{\n    handle->nsize = nsize;\n}\nstatus_t FLEXSPI_TransferEDMA(FLEXSPI_Type *base, flexspi_edma_handle_t *handle, flexspi_transfer_t *xfer)\n{\n    uint32_t configValue = 0;\n    status_t result      = kStatus_Success;\n    edma_transfer_config_t xferConfig;\n    uint32_t instance = FLEXSPI_GetInstance(base);\n    uint8_t power     = 0;\n    assert(handle);\n    assert(xfer);\n    if (handle->state != (uint32_t)kFLEXSPI_Idle)\n    {\n        result = kStatus_FLEXSPI_Busy;\n    }\n    else\n    {\n        handle->transferSize = xfer->dataSize;\n        handle->state        = kFLEXSPI_Busy;\n        base->FLSHCR2[xfer->port] |= FLEXSPI_FLSHCR2_CLRINSTRPTR_MASK;\n        base->INTR |= FLEXSPI_INTR_AHBCMDERR_MASK | FLEXSPI_INTR_IPCMDERR_MASK | FLEXSPI_INTR_AHBCMDGE_MASK |\n                      FLEXSPI_INTR_IPCMDGE_MASK;\n        base->IPCR0 = xfer->deviceAddress;\n        base->IPTXFCR |= FLEXSPI_IPTXFCR_CLRIPTXF_MASK;\n        base->IPRXFCR |= FLEXSPI_IPRXFCR_CLRIPRXF_MASK;\n        if ((xfer->cmdType == kFLEXSPI_Read) || (xfer->cmdType == kFLEXSPI_Write))\n        {\n            configValue = FLEXSPI_IPCR1_IDATSZ(xfer->dataSize);\n        }\n        configValue |= FLEXSPI_IPCR1_ISEQID(xfer->seqIndex) | FLEXSPI_IPCR1_ISEQNUM((uint32_t)xfer->SeqNumber - 1U);\n        base->IPCR1 = configValue;\n    }\n    if ((xfer->cmdType == kFLEXSPI_Write) || (xfer->cmdType == kFLEXSPI_Config))\n    {\n        handle->count = (uint8_t)((base->IPTXFCR & FLEXSPI_IPTXFCR_TXWMRK_MASK) >> FLEXSPI_IPTXFCR_TXWMRK_SHIFT) + 1U;\n        if (xfer->dataSize < 8U * (uint32_t)handle->count)\n        {\n            handle->nbytes = (uint8_t)xfer->dataSize;\n        }\n        else\n        {\n            if (((handle->count) & (handle->count - 1U)) != 0U)\n            {\n                return kStatus_InvalidArgument;\n            }\n            handle->nbytes = (8U * handle->count);\n        }\n        power = FLEXSPI_CalculatePower(8U * handle->count);\n        EDMA_PrepareTransfer(&xferConfig, xfer->data, (uint32_t)handle->nsize,\n                             (void *)(uint32_t *)FLEXSPI_GetTxFifoAddress(base), (uint32_t)handle->nsize,\n                             (uint32_t)handle->nbytes, xfer->dataSize, kEDMA_MemoryToMemory);\n        (void)EDMA_SubmitTransfer(handle->txDmaHandle, &xferConfig);\n        EDMA_SetModulo(handle->txDmaHandle->base, handle->txDmaHandle->channel, kEDMA_ModuloDisable,\n                       (edma_modulo_t)power);\n        EDMA_SetCallback(handle->txDmaHandle, FLEXSPI_TransferEDMACallback,\n                         &s_edmaPrivateHandle[FLEXSPI_GetInstance(base)]);\n        EDMA_StartTransfer(handle->txDmaHandle);\n        FLEXSPI_EnableTxDMA(base, true);\n        base->IPCMD |= FLEXSPI_IPCMD_TRG_MASK;\n    }\n    else if (xfer->cmdType == kFLEXSPI_Read)\n    {\n        handle->count = (uint8_t)((base->IPRXFCR & FLEXSPI_IPRXFCR_RXWMRK_MASK) >> FLEXSPI_IPRXFCR_RXWMRK_SHIFT) + 1U;\n        if (xfer->dataSize < 8U * (uint32_t)handle->count)\n        {\n            handle->nbytes = (uint8_t)xfer->dataSize;\n        }\n        else\n        {\n            if (((handle->count) & (handle->count - 1U)) != 0U)\n            {\n                return kStatus_InvalidArgument;\n            }\n            handle->nbytes = (8U * handle->count);\n        }\n        power = FLEXSPI_CalculatePower(8U * handle->count);\n        EDMA_PrepareTransfer(&xferConfig, (void *)(uint32_t *)FLEXSPI_GetRxFifoAddress(base), (uint32_t)handle->nsize,\n                             xfer->data, (uint32_t)handle->nsize, (uint32_t)handle->nbytes, xfer->dataSize,\n                             kEDMA_MemoryToMemory);\n        (void)EDMA_SubmitTransfer(handle->rxDmaHandle, &xferConfig);\n        EDMA_SetModulo(handle->txDmaHandle->base, handle->txDmaHandle->channel, (edma_modulo_t)power,\n                       kEDMA_ModuloDisable);\n        EDMA_SetCallback(handle->rxDmaHandle, FLEXSPI_TransferEDMACallback, &s_edmaPrivateHandle[instance]);\n        EDMA_StartTransfer(handle->rxDmaHandle);\n        FLEXSPI_EnableRxDMA(base, true);\n        base->IPCMD |= FLEXSPI_IPCMD_TRG_MASK;\n    }\n    else\n    {\n        base->IPCMD |= FLEXSPI_IPCMD_TRG_MASK;\n        while (!FLEXSPI_GetBusIdleStatus(base))\n        {\n        }\n        result = FLEXSPI_CheckAndClearError(base, base->INTR);\n        handle->state = kFLEXSPI_Idle;\n        if (handle->completionCallback != NULL)\n        {\n            handle->completionCallback(base, handle, result, handle->userData);\n        }\n    }\n    return result;\n}\nvoid FLEXSPI_TransferAbortEDMA(FLEXSPI_Type *base, flexspi_edma_handle_t *handle)\n{\n    assert(handle);\n    if ((base->IPTXFCR & FLEXSPI_IPTXFCR_TXDMAEN_MASK) != 0x00U)\n    {\n        FLEXSPI_EnableTxDMA(base, false);\n        EDMA_AbortTransfer(handle->txDmaHandle);\n    }\n    if ((base->IPRXFCR & FLEXSPI_IPRXFCR_RXDMAEN_MASK) != 0x00U)\n    {\n        FLEXSPI_EnableRxDMA(base, false);\n        EDMA_AbortTransfer(handle->rxDmaHandle);\n    }\n    handle->state = kFLEXSPI_Idle;\n}\nstatus_t FLEXSPI_TransferGetTransferCountEDMA(FLEXSPI_Type *base, flexspi_edma_handle_t *handle, size_t *count)\n{\n    assert(handle);\n    assert(count);\n    status_t result = kStatus_Success;\n    if (handle->state != (uint32_t)kFLEXSPI_Busy)\n    {\n        result = kStatus_NoTransferInProgress;\n    }\n    else\n    {\n        if ((base->IPRXFCR & FLEXSPI_IPRXFCR_RXDMAEN_MASK) != 0x00U)\n        {\n            *count = (handle->transferSize -\n                      (uint32_t)handle->nbytes *\n                          EDMA_GetRemainingMajorLoopCount(handle->rxDmaHandle->base, handle->rxDmaHandle->channel));\n        }\n        else if ((base->IPTXFCR & FLEXSPI_IPTXFCR_TXDMAEN_MASK) != 0x00U)\n        {\n            *count = (handle->transferSize -\n                      (uint32_t)handle->nbytes *\n                          EDMA_GetRemainingMajorLoopCount(handle->txDmaHandle->base, handle->txDmaHandle->channel));\n        }\n        else\n        {\n            ; \n        }\n    }\n    return result;\n}'"
"('Please provide the prompt that describes a scenario where you are testing a linear qdetector_cccf function with a given sequence length of 167, using specific coefficients and parameters.","//...\nvoid qdetector_cccf_runtest_linear(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    int          ftype = LIQUID_FIRFILT_ARKAISER; \n    unsigned int i;\n    float complex sequence[_sequence_len];\n    for (i=0; i<_sequence_len; i++) {\n        sequence[i] = (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 +\n                      (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 * _Complex_I;\n    }\n    qdetector_cccf q = qdetector_cccf_create_linear(sequence, _sequence_len, ftype, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_linear_n167()  { qdetector_cccf_runtest_linear( 167); }\n//...')
"
"('Prompt: You need to write a function that tests the recreation of a finite impulse response (FIR) filter in a digital signal processing library. The scenario involves creating an FIR filter using a set of coefficients, setting a scale factor, copying the coefficients to a new set, scaling the new coefficients, recreating the FIR filter with the new coefficients, retrieving the filter scale and coefficients, pushing samples through the filter, and verifying that the output matches the expected values.","//...\nvoid autotest_firfilt_recreate()\n{\n    unsigned int i, n = 21;\n    float h0[n], h1[n];\n    for (i=0; i<n; i++)\n        h0[i] = cosf(0.3*i) + sinf(sqrtf(2.0f)*i);\n    firfilt_crcf q = firfilt_crcf_create(h0, n);\n    CONTEND_EQUALITY(LIQUID_OK, firfilt_crcf_print(q))\n    CONTEND_EQUALITY(LIQUID_OK, firfilt_crcf_set_scale(q, 3.0f))\n    CONTEND_EQUALITY(LIQUID_OK, firfilt_crcf_copy_coefficients(q, h1))\n    for (i=0; i<n; i++)\n        h1[i] *= 7.1f;\n    q = firfilt_crcf_recreate(q, h1, n);\n    float scale;\n    firfilt_crcf_get_scale(q, &scale);\n    CONTEND_EQUALITY(scale, 3.0f)\n    const float * h = firfilt_crcf_get_coefficients(q);\n    for (i=0; i<n; i++)\n        CONTEND_EQUALITY(h[n-i-1], h0[i]*7.1f);\n    float h2[2*n+1]; \n    for (i=0; i<2*n+1; i++)\n        h2[i] = cosf(0.2*i+1) + sinf(logf(2.0f)*i);\n    q = firfilt_crcf_recreate(q, h2, 2*n+1);\n    for (i=0; i<2*n+1; i++) {\n        firfilt_crcf_push(q, i==0 ? 1 : 0);\n        float complex v;\n        firfilt_crcf_execute(q, &v);\n        CONTEND_EQUALITY(v, h2[i]*scale);\n    }\n    firfilt_crcf_destroy(q);\n}\n//...')
"
"('Prompt: . You need to test a GMSK detector for a specific sequence length of 167. The detector takes in a sequence of bits and parameters such as k, m, and beta. The test involves running the detector with input data and checking for frame detection using specific expected values for parameters like gamma, tau, dphi, and phi. Additionally, you need to handle cases for false positives and failures in detecting the frame. The test should also ensure that the estimated values for parameters are within certain tolerance limits compared to the expected values.","//...\nvoid qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)\n{\n    unsigned int k     =     2;     \n    unsigned int m     =     7;     \n    float        beta  =  0.3f;     \n    unsigned char sequence[_sequence_len];\n    unsigned int i;\n    for (i=0; i<_sequence_len; i++)\n        sequence[i] = rand() & 0x01;\n    qdetector_cccf q = qdetector_cccf_create_gmsk(sequence, _sequence_len, k, m, beta);\n    qdetector_cccf_runtest(q);\n    qdetector_cccf_destroy(q);\n}\nvoid qdetector_cccf_runtest(qdetector_cccf _q)\n{\n    if (liquid_autotest_verbose)\n        qdetector_cccf_print(_q);\n    float gamma =  1.0f;    \n    float tau   =  0.0f;    \n    float dphi  = -0.000f;  \n    float phi   =  0.5f;    \n    float complex * seq = (float complex*)qdetector_cccf_get_sequence(_q);\n    unsigned int sequence_len = qdetector_cccf_get_seq_len(_q);\n    unsigned int num_samples = 8*sequence_len;\n    float complex buf_rx[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        buf_rx[i] = i < sequence_len ? seq[i] : 0.0f;\n        buf_rx[i] *= gamma;\n        buf_rx[i] *= cexpf(_Complex_I*(dphi*i + phi));\n    }\n    float tau_hat   = 0.0f;\n    float gamma_hat = 0.0f;\n    float dphi_hat  = 0.0f;\n    float phi_hat   = 0.0f;\n    int   frame_detected = 0;\n    int   false_positive = 0;\n    float complex * v = NULL;\n    for (i=0; i<num_samples; i++) {\n        if (frame_detected)\n            break;\n        v = qdetector_cccf_execute(_q,buf_rx[i]);\n        if (v != NULL) {\n            frame_detected = 1;\n            tau_hat   = qdetector_cccf_get_tau(_q);\n            gamma_hat = qdetector_cccf_get_gamma(_q);\n            dphi_hat  = qdetector_cccf_get_dphi(_q);\n            phi_hat   = qdetector_cccf_get_phi(_q);\n            break;\n        }\n    }\n    unsigned int sample_index = i;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q);\n    if (liquid_autotest_verbose) {\n        printf(""\\n"");\n        printf(""frame detected  :   %s\\n"", frame_detected ? ""yes"" : ""no"");\n        printf(""  sample index  : %8u, actual=%8u (error=%8d)\\n"", sample_index, buf_len, (int)sample_index - (int)buf_len);\n        printf(""  gamma hat     : %8.3f, actual=%8.3f (error=%8.3f)\\n"",            gamma_hat, gamma, gamma_hat - gamma);\n        printf(""  tau hat       : %8.3f, actual=%8.3f (error=%8.3f) samples\\n"",    tau_hat,   tau,   tau_hat   - tau  );\n        printf(""  dphi hat      : %8.5f, actual=%8.5f (error=%8.5f) rad/sample\\n"", dphi_hat,  dphi,  dphi_hat  - dphi );\n        printf(""  phi hat       : %8.5f, actual=%8.5f (error=%8.5f) radians\\n"",    phi_hat,   phi,   phi_hat   - phi  );\n        printf(""\\n"");\n    }\n    if (false_positive)\n        AUTOTEST_FAIL(""false positive detected"");\n    else if (!frame_detected)\n        AUTOTEST_FAIL(""frame not detected"");\n    else {\n        CONTEND_DELTA( tau_hat, tau, 0.05f );\n        CONTEND_DELTA( dphi_hat, dphi, 0.01f );\n        CONTEND_DELTA( phi_hat, phi, 0.1f );\n    }\n}\nvoid autotest_qdetector_cccf_gmsk_n167()    { qdetector_cccf_runtest_gmsk  ( 167); }\n//...')
"
"('Prompt: You are working on a project that involves benchmarking the performance of a GMSK modem modulation function. You need a function that can modulate a symbol multiple times using a GMSK modem and then measure the CPU time consumed for a given number of iterations. The function should take the starting and finishing time measurements using the `struct rusage` data structure, as well as the number of iterations as input parameters. Additionally, it should create a GMSK modem with specific parameters (k=2, m=3, BT=0.3f), modulate the symbol multiple times, and then destroy the modem. Can you provide a C function that accomplishes this task?","//...\nvoid benchmark_gmskmodem_modulate(struct rusage *_start,\n                                  struct rusage *_finish,\n                                  unsigned long int *_num_iterations)\n{\n    unsigned int k=2;   \n    unsigned int m=3;   \n    float BT=0.3f;      \n    gmskmod mod   = gmskmod_create(k, m, BT);\n    float complex x[k];\n    unsigned int symbol_in = 0;\n    unsigned long int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        gmskmod_modulate(mod, symbol_in, x);\n        gmskmod_modulate(mod, symbol_in, x);\n        gmskmod_modulate(mod, symbol_in, x);\n        gmskmod_modulate(mod, symbol_in, x);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    gmskmod_destroy(mod);\n}\n//...')
"
"('Prompt: I need you to write a function that tests the demodulation of soft bits for an arbitrary 32-state optimized modem using Liquid DSP library. The function should create a modulator and demodulator with the specified modulation scheme, then iterate over all symbols and verify the soft bit demodulation results. Finally, the function should clean up by destroying the modulator and demodulator instances.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_arb32opt()  { modemcf_test_demodsoft(LIQUID_MODEM_ARB32OPT);  }\n//...')
"
"('Prompt: You are designing a communication system using a software-defined radio platform and need to set a user-defined data structure to be used within the OFDM frame synchronization module. Write a function in C that allows the user to set this user data structure within the OFDM frame synchronization object. . . Code Response:. ```c. void * userdata;                    . . int ofdmflexframesync_set_userdata(ofdmflexframesync _q,.                                    void *            _userdata). {.     _q->userdata = _userdata;.     return LIQUID_OK;. }. ```","//...\n    void * userdata;                    \nint ofdmflexframesync_set_userdata(ofdmflexframesync _q,\n                                   void *            _userdata)\n{\n    _q->userdata = _userdata;\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are developing a program that performs frequency modulation and demodulation on a set of samples. You need to implement a command-line interface that allows the user to specify certain parameters such as the number of samples, signal-to-noise ratio, and modulation factor. Can you write a C program that reads these options from the command line, processes the samples using frequency modulation and demodulation techniques, calculates the root mean square error, and outputs the results to a file named ""freqmodem_example.m""?","#define OUTPUT_FILENAME ""freqmodem_example.m""\nvoid usage()\n{\n    printf(""freqmodem_example [options]\\n"");\n    printf(""  h     : print usage\\n"");\n    printf(""  n     : number of samples, default: 1024\\n"");\n    printf(""  S     : SNR [dB], default: 30\\n"");\n    printf(""  k     : FM modulation factor, default: 0.1\\n"");\n}\nint main(int argc, char*argv[])\n{\n    float        kf          = 0.1f;    \n    unsigned int num_samples = 1024;    \n    float        SNRdB       = 30.0f;   \n    int dopt;\n    while ((dopt = getopt(argc,argv,""hn:S:k:"")) != EOF) {\n        switch (dopt) {\n        case \'h\':   usage();                    return 0;\n        case \'n\':   num_samples = atoi(optarg); break;\n        case \'S\':   SNRdB       = atof(optarg); break;\n        case \'k\':   kf          = atof(optarg); break;\n        default:\n            exit(1);\n        }\n    }\n    freqmod mod = freqmod_create(kf);   \n    freqdem dem = freqdem_create(kf);   \n    freqmod_print(mod);\n    unsigned int i;\n    float         m[num_samples];       \n    float complex r[num_samples];       \n    float         y[num_samples];       \n    for (i=0; i<num_samples; i++) {\n        m[i] = 0.3f*cosf(2*M_PI*0.013f*i + 0.0f) +\n               0.2f*cosf(2*M_PI*0.021f*i + 0.4f) +\n               0.4f*cosf(2*M_PI*0.037f*i + 1.7f);\n    }\n    freqmod_modulate_block(mod, m, num_samples, r);\n    float nstd = powf(10.0f,-SNRdB/20.0f);\n    for (i=0; i<num_samples; i++)\n        r[i] += nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2;\n    freqdem_demodulate_block(dem, r, num_samples, y);\n    freqmod_destroy(mod);\n    freqdem_destroy(dem);\n    float rmse = 0.0;\n    for (i=1; i<num_samples; i++) {\n        float err = y[i] - m[i];\n        rmse += err*err;\n    }\n    rmse = sqrtf( rmse / (float)(num_samples-1) );\n    printf(""rmse = %12.4e\\n"", rmse);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""n=%u;\\n"",num_samples);\n    for (i=0; i<num_samples; i++) {\n        fprintf(fid,""m(%3u) = %12.4e;\\n"", i+1, m[i]);\n        fprintf(fid,""r(%3u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(r[i]), cimagf(r[i]));\n        fprintf(fid,""y(%3u) = %12.4e;\\n"", i+1, y[i]);\n    }\n    fprintf(fid,""t=0:(n-1);\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(3,1,1);\\n"");\n    fprintf(fid,""  plot(t,m,\'LineWidth\',1,\'Color\',[0 0.2 0.5],...);\\n"");\n    fprintf(fid,""       t,y,\'LineWidth\',1,\'Color\',[0 0.5 0.2]);\\n"");\n    fprintf(fid,""  axis([0 n -1.2 1.2]);\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Time [t/T_s]\');\\n"");\n    fprintf(fid,""  ylabel(\'m(t), y(t)\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""nfft=2^(1+nextpow2(n));\\n"");\n    fprintf(fid,""f=[0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""w = hamming(n)\';\\n"");\n    fprintf(fid,""g = 1 / (mean(w) * n);\\n"");\n    fprintf(fid,""M = 20*log10(abs(fftshift(fft(m.*w*g,nfft))));\\n"");\n    fprintf(fid,""R = 20*log10(abs(fftshift(fft(r.*w*g,nfft))));\\n"");\n    fprintf(fid,""Y = 20*log10(abs(fftshift(fft(y.*w*g,nfft))));\\n"");\n    fprintf(fid,""subplot(3,1,2);\\n"");\n    fprintf(fid,""  plot(f,M,\'LineWidth\',1.2,\'Color\',[0 0.2 0.5],...\\n"");\n    fprintf(fid,""       f,Y,\'LineWidth\',1.2,\'Color\',[0 0.5 0.2]);\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -80 20]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""  ylabel(\'Audio PSD [dB]\');\\n"");\n    fprintf(fid,""subplot(3,1,3);\\n"");\n    fprintf(fid,""  plot(f,R,\'LineWidth\',1.2,\'Color\',[0.5 0 0]);\\n"");\n    fprintf(fid,""  axis([-0.5 0.5 -80 20]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""  ylabel(\'RF PSD [dB]\');\\n"");\n    fclose(fid);\n    printf(""results written to %s\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
"('Prompt: Can you provide benchmark functions for three different operations using the NCO (Numerically Controlled Oscillator) functionality in a C library? The first function should benchmark the operation of calculating sine and cosine values using the NCO, the second function should benchmark mixing up complex values using the NCO, and the third function should benchmark mixing up blocks of complex values using the NCO. The benchmark functions should measure the resource usage before and after the operations and update the number of iterations accordingly.","void benchmark_nco_sincos(struct rusage *_start,\n                          struct rusage *_finish,\n                          unsigned long int *_num_iterations)\n{\n    float s, c;\n    nco_crcf p = nco_crcf_create(LIQUID_NCO);\n    nco_crcf_set_phase(p, 0.0f);\n    nco_crcf_set_frequency(p, 0.1f);\n    unsigned int i;\n    *_num_iterations *= 100;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        nco_crcf_sincos(p, &s, &c);\n        nco_crcf_step(p);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    nco_crcf_destroy(p);\n}\nvoid benchmark_nco_mix_up(struct rusage *_start,\n                          struct rusage *_finish,\n                          unsigned long int *_num_iterations)\n{\n    float complex x[16],  y[16];\n    memset(x, 0, 16*sizeof(float complex));\n    nco_crcf p = nco_crcf_create(LIQUID_NCO);\n    nco_crcf_set_phase(p, 0.0f);\n    nco_crcf_set_frequency(p, 0.1f);\n    unsigned int i, j;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        for (j=0; j<16; j++) {\n            nco_crcf_mix_up(p, x[j], &y[j]);\n            nco_crcf_step(p);\n        }\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 16;\n    nco_crcf_destroy(p);\n}\nvoid benchmark_nco_mix_block_up(struct rusage *_start,\n                                struct rusage *_finish,\n                                unsigned long int *_num_iterations)\n{\n    float complex x[16], y[16];\n    memset(x, 0, 16*sizeof(float complex));\n    nco_crcf p = nco_crcf_create(LIQUID_NCO);\n    nco_crcf_set_phase(p, 0.0f);\n    nco_crcf_set_frequency(p, 0.1f);\n    unsigned int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        nco_crcf_mix_block_up(p, x, y, 16);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 16;\n    nco_crcf_destroy(p);\n}')
"
"'Prompt: You are developing a driver for a System On Chip (SoC) platform that includes FlexRAM memory management. You need to implement a function that allocates FlexRAM memory banks based on the configuration provided by the user. The function should check for valid input parameters and set the FlexRAM bank configuration accordingly. Please provide a C function that takes a structure containing the number of DTCM, ITCM, and OCRAM banks to allocate, and sets the FlexRAM bank configuration registers accordingly.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.soc_flexram_allocate""\n#endif\nstatus_t FLEXRAM_AllocateRam(flexram_allocate_ram_t *config)\n{\n    assert(config != NULL);\n    uint8_t dtcmBankNum  = config->dtcmBankNum;\n    uint8_t itcmBankNum  = config->itcmBankNum;\n    uint8_t ocramBankNum = config->ocramBankNum;\n    uint8_t i            = 0U;\n    uint32_t bankCfg     = 0U;\n    status_t status      = kStatus_Success;\n    uint32_t tempGPR17   = 0U;\n    uint32_t tempGPR18   = 0U;\n    if ((uint8_t)FSL_FEATURE_FLEXRAM_INTERNAL_RAM_TOTAL_BANK_NUMBERS < (dtcmBankNum + itcmBankNum + ocramBankNum))\n    {\n        status = kStatus_InvalidArgument;\n    }\n    else\n    {\n        for (i = 0U; i < (uint8_t)FSL_FEATURE_FLEXRAM_INTERNAL_RAM_TOTAL_BANK_NUMBERS; i++)\n        {\n            if (i < ocramBankNum)\n            {\n                bankCfg |= ((uint32_t)kFLEXRAM_BankOCRAM) << (i * 2U);\n                continue;\n            }\n            if (i < (dtcmBankNum + ocramBankNum))\n            {\n                bankCfg |= ((uint32_t)kFLEXRAM_BankDTCM) << (i * 2U);\n                continue;\n            }\n            if (i < (dtcmBankNum + ocramBankNum + itcmBankNum))\n            {\n                bankCfg |= ((uint32_t)kFLEXRAM_BankITCM) << (i * 2U);\n                continue;\n            }\n        }\n        tempGPR17 = IOMUXC_GPR->GPR17;\n        tempGPR18 = IOMUXC_GPR->GPR18;\n        IOMUXC_GPR->GPR17 = (tempGPR17 & ~IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_LOW_MASK) | (bankCfg & 0xFFFFU);\n        IOMUXC_GPR->GPR18 = (tempGPR18 & ~IOMUXC_GPR_GPR18_FLEXRAM_BANK_CFG_HIGH_MASK) | ((bankCfg >> 16) & 0xFFFFU);\n        FLEXRAM_SetAllocateRamSrc(kFLEXRAM_BankAllocateThroughBankCfg);\n    }\n    return status;\n}'"
"'Prompt: You are developing a multi-threaded application in C that requires setting the stack address for a specific pthread attribute. The pthread library you are using supports setting the stack address using the function pthread_attr_setstackaddr(). However, you need to ensure that the system supports the necessary POSIX thread attribute (_POSIX_THREAD_ATTR_STACKADDR) for this functionality. Please provide the code snippet for the pthread_attr_setstackaddr() function that checks for the availability of the POSIX thread attribute and sets the stack address accordingly.","#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_attr_setstackaddr (pthread_attr_t * attr, void *stackaddr)\n{\n#if defined( _POSIX_THREAD_ATTR_STACKADDR ) && _POSIX_THREAD_ATTR_STACKADDR != -1\n  if (__ptw32_is_attr (attr) != 0)\n    {\n      return EINVAL;\n    }\n  (*attr)->stackaddr = stackaddr;\n  return 0;\n#else\n  return ENOSYS;\n#endif \n}'"
"('The prompt could have been: . You want to create a benchmarking function for a Dot product of complex floats using the API provided. The function needs to take the start and finish time, number of iterations, and the size of the array as input parameters. Implement the `void dotprod_cccf_bench` function that performs the benchmarking by executing the Dot product calculation using random complex float arrays. Also, define API macros for benchmarking with arrays of sizes 4, 16, 64, and 256.","void dotprod_cccf_bench(struct rusage *_start,\n                        struct rusage *_finish,\n                        unsigned long int *_num_iterations,\n                        unsigned int _n)\n{\n    *_num_iterations = *_num_iterations * 20 / _n;\n    if (*_num_iterations < 1) *_num_iterations = 1;\n    float complex x[_n];\n    float complex h[_n];\n    float complex y[8];\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        x[i] = randnf() + _Complex_I*randnf();\n        h[i] = randnf() + _Complex_I*randnf();\n    }\n    dotprod_cccf dp = dotprod_cccf_create(h,_n);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        dotprod_cccf_execute(dp, x, &y[0]);\n        dotprod_cccf_execute(dp, x, &y[1]);\n        dotprod_cccf_execute(dp, x, &y[2]);\n        dotprod_cccf_execute(dp, x, &y[3]);\n        dotprod_cccf_execute(dp, x, &y[4]);\n        dotprod_cccf_execute(dp, x, &y[5]);\n        dotprod_cccf_execute(dp, x, &y[6]);\n        dotprod_cccf_execute(dp, x, &y[7]);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 8;\n    dotprod_cccf_destroy(dp);\n}\n#define DOTPROD_CCCF_BENCHMARK_API(N)   \\\n(   struct rusage *_start,              \\\n    struct rusage *_finish,             \\\n    unsigned long int *_num_iterations) \\\n{ dotprod_cccf_bench(_start, _finish, _num_iterations, N); }\nvoid benchmark_dotprod_cccf_4      DOTPROD_CCCF_BENCHMARK_API(4)\nvoid benchmark_dotprod_cccf_16     DOTPROD_CCCF_BENCHMARK_API(16)\nvoid benchmark_dotprod_cccf_64     DOTPROD_CCCF_BENCHMARK_API(64)\nvoid benchmark_dotprod_cccf_256    DOTPROD_CCCF_BENCHMARK_API(256)')
"
"('Prompt: You are building a simulation model that requires generating random numbers following the Weibull distribution. Please provide a function in C that takes alpha, beta, and gamma as input parameters, where alpha, beta, and gamma are positive float values. The function should return a random number sampled from the Weibull distribution with the given parameters. If alpha or beta is less than or equal to zero, an error message should be displayed and 0.0 should be returned. Ensure that the generated random number is a valid result for the Weibull distribution.","//...\nfloat randweibf(float _alpha,\n                float _beta,\n                float _gamma)\n{\n    if (_alpha <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf(), alpha must be greater than zero"");\n        return 0.0f;\n    } else if (_beta <= 0) {\n        liquid_error(LIQUID_EICONFIG,""randweibf(), beta must be greater than zero"");\n        return 0.0f;\n    }\n    float u;\n    do {\n        u = randf();\n    } while (u==0.0f);\n    return _gamma + _beta*powf( -logf(u), 1.0f/_alpha );\n}\n//...')
"
"('Prompt: In a scenario where you need to initialize a data structure called `framesyncstats_s` with default values, provide a function that performs this initialization by copying the default values from a pre-defined structure `framesyncstats_default`. Ensure that the function properly initializes the provided `framesyncstats_s` pointer and returns a status code indicating success.","//...\nframesyncstats_s framesyncstats_default = {\nint framesyncstats_init_default(framesyncstats_s * _stats)\n{\n    memmove(_stats, &framesyncstats_default, sizeof(framesyncstats_s));\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on a software project involving the implementation of a digital spread spectrum system. As part of the project, you need to write a function that handles the destruction of a frame generator object. Please provide code for a function named `dsssframegen_destroy` that takes a `dsssframegen` object as a parameter and properly disposes of all memory associated with that object. The function should also return a status value indicating success or failure.","//...\n        return 0.f;\nint dsssframegen_destroy(dsssframegen _q)\n{\n    if (_q == NULL)\n        return liquid_error(LIQUID_EIOBJ,""dsssframegen_destroy(), NULL pointer passed"");\n    firinterp_crcf_destroy(_q->interp);\n    qpacketmodem_destroy(_q->header_encoder);\n    qpacketmodem_destroy(_q->payload_encoder);\n    synth_crcf_destroy(_q->header_synth);\n    synth_crcf_destroy(_q->payload_synth);\n    free(_q->preamble_pn);\n    free(_q->header);\n    free(_q->header_mod);\n    free(_q->payload_mod);\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
"""Prompt: You are working on a project that includes examples of using the LVGL library. Your project also utilizes the LibPNG library for working with PNG files. However, you want to provide alternative functionality in case LibPNG is not installed on the system. Write a code snippet that showcases displaying a PNG image using LVGL if LibPNG is available, and displaying a text label indicating that LibPNG is not installed if it's not available.","#if LV_BUILD_EXAMPLES\n#if LV_USE_LIBPNG\nvoid lv_example_libpng_1(void)\n{\n    lv_obj_t * img;\n    img = lv_image_create(lv_screen_active());\n    lv_image_set_src(img, ""A:lvgl/examples/libs/libpng/png_demo.png"");\n    lv_obj_center(img);\n}\n#else\nvoid lv_example_libpng_1(void)\n{\n    lv_obj_t * label = lv_label_create(lv_screen_active());\n    lv_label_set_text(label, ""LibPNG is not installed"");\n    lv_obj_center(label);\n}\n#endif\n#endif'"
"('Prompt: You are tasked with creating a function for 1-dimensional search that finds the minimum value given a specific context. The function should calculate the result based on the input value and a reference value. Additionally, you need to implement a test function that will use the search function to find the optimal value within specified bounds. This test function should iterate multiple times and validate the results. Finally, include an automatic test for the search function with specific parameters.. . Response: Here is the code for the function that performs a 1-dimensional search to find the minimum value, using the provided context and calculating the optimization based on the input value in relation to a reference value. Additionally, there is a test function that utilizes this search function to find the optimal value within specified bounds, iterating multiple times to validate the results. Lastly, an automatic test function is included to test the search function with specific parameters.. . ```c. float qs1dsearch_umin(float _v, void* _context) {.     float","//...\nfloat qs1dsearch_umin(float _v, void * _context)\n{\n    float v_opt = *(float*)(_context);\n    float v = _v - v_opt;\n    return tanhf(v)*tanhf(v);\n}\nvoid test_qs1dsearch(liquid_utility_1d _utility,\n                     float             _v_opt,\n                     float             _v_lo,\n                     float             _v_hi,\n                     int               _bounds,\n                     int               _direction)\n{\n    qs1dsearch q = qs1dsearch_create(_utility, &_v_opt, _direction);\n    if (_bounds) qs1dsearch_init_bounds(q, _v_lo, _v_hi);\n    else         qs1dsearch_init       (q, _v_lo);\n    unsigned int i;\n    for (i=0; i<32; i++) {\n        qs1dsearch_step(q);\n        if (liquid_autotest_verbose)\n            qs1dsearch_print(q);\n    }\n    CONTEND_DELTA( qs1dsearch_get_opt_v(q), _v_opt,                    1e-3f );\n    CONTEND_DELTA( qs1dsearch_get_opt_u(q), _utility(_v_opt, &_v_opt), 1e-3f );\n    if (liquid_autotest_verbose) {\n        printf(""%3u : u(%12.8f) = %12.4e, v_opt=%12.4e (error=%12.4e)\\n"",\n            i, qs1dsearch_get_opt_v(q), qs1dsearch_get_opt_u(q),\n            _v_opt, _v_opt - qs1dsearch_get_opt_v(q));\n    }\n    qs1dsearch_destroy(q);\n}\nvoid autotest_qs1dsearch_min_05() { test_qs1dsearch(qs1dsearch_umin, 0,   0,  0, 0, LIQUID_OPTIM_MINIMIZE); }\n//...')
"
"'Prompt: Design a set of functions to handle the configuration and control of an IEE APC (Advanced Peripheral Controller) for a platform. The functions should include enabling and disabling the APC globally, setting region configurations, locking region configurations, and enabling specific regions for encryption. Ensure that the necessary masks and bit manipulation operations are correctly implemented for the IEE APC hardware registers.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.iee_apc""\n#endif\n#define IOMUXC_LPSR_GPR_APC_ADDR_MASK 0xFFFFFFF8U\nvoid IEE_APC_GlobalEnable(IEE_APC_Type *base)\n{\n    IOMUXC_LPSR_GPR->GPR25 |= IOMUXC_LPSR_GPR_GPR25_APC_VALID_MASK;\n    __DSB();\n    return;\n}\nvoid IEE_APC_GlobalDisable(IEE_APC_Type *base)\n{\n    IOMUXC_LPSR_GPR->GPR25 &= ~IOMUXC_LPSR_GPR_GPR25_APC_VALID_MASK;\n    __DSB();\n    return;\n}\nstatus_t IEE_APC_SetRegionConfig(IEE_APC_Type *base, iee_apc_region_t region, uint32_t startAddr, uint32_t endAddr)\n{\n    if ((startAddr & (~IOMUXC_LPSR_GPR_GPR3_APC_AC_R0_TOP_MASK)) != 0U ||\n        (endAddr & (~IOMUXC_LPSR_GPR_GPR2_APC_AC_R0_BOT_MASK)) != 0U)\n    {\n        return kStatus_InvalidArgument;\n    }\n    if (region == kIEE_APC_Region0)\n    {\n        IOMUXC_LPSR_GPR->GPR2 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR3 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION0_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION0_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region1)\n    {\n        IOMUXC_LPSR_GPR->GPR4 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR5 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION1_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION1_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region2)\n    {\n        IOMUXC_LPSR_GPR->GPR6 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR7 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION2_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION2_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region3)\n    {\n        IOMUXC_LPSR_GPR->GPR8 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR9 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION3_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION3_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region4)\n    {\n        IOMUXC_LPSR_GPR->GPR10 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR11 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION4_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION4_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region5)\n    {\n        IOMUXC_LPSR_GPR->GPR12 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR13 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION5_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION5_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region6)\n    {\n        IOMUXC_LPSR_GPR->GPR14 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR15 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION6_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION6_TOP_ADDR = endAddr >> 3;\n    }\n    if (region == kIEE_APC_Region7)\n    {\n        IOMUXC_LPSR_GPR->GPR16 |= startAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IOMUXC_LPSR_GPR->GPR17 |= endAddr & IOMUXC_LPSR_GPR_APC_ADDR_MASK;\n        IEE_APC->REGION7_BOT_ADDR = startAddr >> 3;\n        IEE_APC->REGION7_TOP_ADDR = endAddr >> 3;\n    }\n    return kStatus_Success;\n}\nstatus_t IEE_APC_LockRegionConfig(IEE_APC_Type *base, iee_apc_region_t region, iee_apc_domain_t domain)\n{\n    if (region == kIEE_APC_Region0)\n    {\n        IOMUXC_LPSR_GPR->GPR2 |= IOMUXC_LPSR_GPR_GPR2_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR3 |= IOMUXC_LPSR_GPR_GPR3_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR18 |= IOMUXC_LPSR_GPR_GPR18_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION0_RDC_D0 |= IEE_APC_REGION0_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION0_RDC_D0 |= IEE_APC_REGION0_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION0_RDC_D1 |= IEE_APC_REGION0_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION0_RDC_D1 |= IEE_APC_REGION0_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region1)\n    {\n        IOMUXC_LPSR_GPR->GPR4 |= IOMUXC_LPSR_GPR_GPR4_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR5 |= IOMUXC_LPSR_GPR_GPR5_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR19 |= IOMUXC_LPSR_GPR_GPR19_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION1_RDC_D0 |= IEE_APC_REGION1_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION1_RDC_D0 |= IEE_APC_REGION1_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION1_RDC_D1 |= IEE_APC_REGION1_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION1_RDC_D1 |= IEE_APC_REGION1_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region2)\n    {\n        IOMUXC_LPSR_GPR->GPR6 |= IOMUXC_LPSR_GPR_GPR6_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR7 |= IOMUXC_LPSR_GPR_GPR7_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR20 |= IOMUXC_LPSR_GPR_GPR20_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION2_RDC_D0 |= IEE_APC_REGION2_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION2_RDC_D0 |= IEE_APC_REGION2_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION2_RDC_D1 |= IEE_APC_REGION2_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION2_RDC_D1 |= IEE_APC_REGION2_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region3)\n    {\n        IOMUXC_LPSR_GPR->GPR8 |= IOMUXC_LPSR_GPR_GPR8_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR9 |= IOMUXC_LPSR_GPR_GPR9_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR21 |= IOMUXC_LPSR_GPR_GPR21_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION3_RDC_D0 |= IEE_APC_REGION3_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION3_RDC_D0 |= IEE_APC_REGION3_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION3_RDC_D1 |= IEE_APC_REGION3_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION3_RDC_D1 |= IEE_APC_REGION3_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region4)\n    {\n        IOMUXC_LPSR_GPR->GPR10 |= IOMUXC_LPSR_GPR_GPR10_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR11 |= IOMUXC_LPSR_GPR_GPR11_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR22 |= IOMUXC_LPSR_GPR_GPR22_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION4_RDC_D0 |= IEE_APC_REGION4_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION4_RDC_D0 |= IEE_APC_REGION4_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION4_RDC_D1 |= IEE_APC_REGION4_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION4_RDC_D1 |= IEE_APC_REGION4_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region5)\n    {\n        IOMUXC_LPSR_GPR->GPR12 |= IOMUXC_LPSR_GPR_GPR12_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR13 |= IOMUXC_LPSR_GPR_GPR13_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR23 |= IOMUXC_LPSR_GPR_GPR23_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION5_RDC_D0 |= IEE_APC_REGION5_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION5_RDC_D0 |= IEE_APC_REGION5_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION5_RDC_D1 |= IEE_APC_REGION5_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION5_RDC_D1 |= IEE_APC_REGION5_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region6)\n    {\n        IOMUXC_LPSR_GPR->GPR14 |= IOMUXC_LPSR_GPR_GPR14_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR15 |= IOMUXC_LPSR_GPR_GPR15_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR24 |= IOMUXC_LPSR_GPR_GPR24_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION6_RDC_D0 |= IEE_APC_REGION6_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION6_RDC_D0 |= IEE_APC_REGION6_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION6_RDC_D1 |= IEE_APC_REGION6_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION6_RDC_D1 |= IEE_APC_REGION6_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    if (region == kIEE_APC_Region7)\n    {\n        IOMUXC_LPSR_GPR->GPR16 |= IOMUXC_LPSR_GPR_GPR15_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR17 |= IOMUXC_LPSR_GPR_GPR16_LOCK(1);\n        IOMUXC_LPSR_GPR->GPR25 |= IOMUXC_LPSR_GPR_GPR25_LOCK(1);\n        if (domain == kIEE_APC_Domain0)\n        {\n            IEE_APC->REGION7_RDC_D0 |= IEE_APC_REGION7_RDC_D0_RDC_D0_WRITE_DIS_MASK;\n            IEE_APC->REGION7_RDC_D0 |= IEE_APC_REGION7_RDC_D0_RDC_D0_LOCK_MASK;\n        }\n        else if (domain == kIEE_APC_Domain1)\n        {\n            IEE_APC->REGION7_RDC_D1 |= IEE_APC_REGION7_RDC_D1_RDC_D1_WRITE_DIS_MASK;\n            IEE_APC->REGION7_RDC_D1 |= IEE_APC_REGION7_RDC_D1_RDC_D1_LOCK_MASK;\n        }\n        else\n        {\n        }\n    }\n    return kStatus_Success;\n}\nvoid IEE_APC_RegionEnable(IEE_APC_Type *base, iee_apc_region_t region)\n{\n    if (region == kIEE_APC_Region0)\n    {\n        IOMUXC_LPSR_GPR->GPR18 |= IOMUXC_LPSR_GPR_GPR18_APC_R0_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region1)\n    {\n        IOMUXC_LPSR_GPR->GPR19 |= IOMUXC_LPSR_GPR_GPR19_APC_R1_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region2)\n    {\n        IOMUXC_LPSR_GPR->GPR20 |= IOMUXC_LPSR_GPR_GPR20_APC_R2_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region3)\n    {\n        IOMUXC_LPSR_GPR->GPR21 |= IOMUXC_LPSR_GPR_GPR21_APC_R3_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region4)\n    {\n        IOMUXC_LPSR_GPR->GPR22 |= IOMUXC_LPSR_GPR_GPR22_APC_R4_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region5)\n    {\n        IOMUXC_LPSR_GPR->GPR23 |= IOMUXC_LPSR_GPR_GPR23_APC_R5_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region6)\n    {\n        IOMUXC_LPSR_GPR->GPR24 |= IOMUXC_LPSR_GPR_GPR24_APC_R6_ENCRYPT_ENABLE_MASK;\n    }\n    if (region == kIEE_APC_Region7)\n    {\n        IOMUXC_LPSR_GPR->GPR25 |= IOMUXC_LPSR_GPR_GPR25_APC_R7_ENCRYPT_ENABLE_MASK;\n    }\n    return;\n}'"
"('Prompt: You are working on a signal processing project where you need to implement a matched filter test. The objective is to create a file called ""matched_filter_test.m"" with customizable filter parameters. Can you provide me with a C code snippet that includes a function to display usage options for the matched filter test, as well as the main function to handle user input for filter parameters such as samples per symbol (k), filter delay (m), and filter excess bandwidth factor (b)? The code should validate user input and create the matched filter based on the specified parameters.","#define OUTPUT_FILENAME ""matched_filter_test.m""\nvoid usage()\n{\n    printf(""matched_filter_test options:\\n"");\n    printf(""  u/h   : print usage/help\\n"");\n    printf(""  k     : filter samples/symbol, k >= 2, default: 4\\n"");\n    printf(""  m     : filter delay (symbols), m >= 1, default: 2\\n"");\n    printf(""  b     : filter excess bandwidth factor, 0 < b < 1, default: 0.9\\n"");\n}\nint main(int argc, char*argv[]) {\n    unsigned int k=4;   \n    unsigned int m=2;   \n    float beta=0.9f;    \n    int dopt;\n    while ((dopt = getopt(argc,argv,""uhk:m:b:"")) != EOF) {\n        switch (dopt) {\n        case \'u\':\n        case \'h\':   usage();            return 0;\n        case \'k\':   k = atoi(optarg);           break;\n        case \'m\':   m = atoi(optarg);           break;\n        case \'b\':   beta = atof(optarg);        break;\n        default:\n            exit(1);\n        }\n    }\n    if (k < 2) {\n        fprintf(stderr,""error: %s, k must be at least 2\\n"", argv[0]);\n        exit(1);\n    } else if (m < 1) {\n        fprintf(stderr,""error: %s, m must be at least 1\\n"", argv[0]);\n        exit(1);\n    } else if (beta <= 0.0f || beta >= 1.0f) {\n        fprintf(stderr,""error: %s, beta must be in (0,1)\\n"", argv[0]);\n        exit(1);\n    }\n    unsigned int h_len = 2*k*m+1;\n    float h[h_len];\n    liquid_firdes_rrcos(k,m,beta,0,h);\n    unsigned int g_len = 2*k*m;\n    float g[g_len];\n    unsigned int i;\n    for (i=0; i<g_len; i++)\n        g[i] = h[g_len-i-1];\n    firfilt_rrrf q = firfilt_rrrf_create(g,g_len);\n    float x;    \n    float y;    \n    for (i=0; i<2*g_len-1; i++) {\n        x = (i < g_len) ? h[i] : 0.0f;\n        firfilt_rrrf_push(q, x);\n        firfilt_rrrf_execute(q, &y);\n        y /= (float)k;\n        printf(""%3u : %c %12.8f\\n"", i, ((i+1)%k)==0 ? \'*\' : \' \', y);\n    }\n    firfilt_rrrf_destroy(q);\n    printf(""done.\\n"");\n    return 0;\n}')
"
'Please provide the prompt that includes the technical scenario related to multithreading and mutex synchronization mechanisms in a C programming environment.,"//...\nint\npthread_mutex_lock (pthread_mutex_t * mutex)\n{\n  pthread_mutex_t mx = *mutex;\n  int kind;\n  int result = 0;\n  if (mx == NULL)\n    {\n      return EINVAL;\n    }\n  if (mx >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER)\n    {\n      if ((result = __ptw32_mutex_check_need_init (mutex)) != 0)\n\t{\n\t  return (result);\n\t}\n      mx = *mutex;\n    }\n  kind = mx->kind;\n  if (kind >= 0)\n    {\n      if (PTHREAD_MUTEX_NORMAL == kind)\n        {\n          if  ((__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_EXCHANGE_LONG(\n\t\t        (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n\t\t        (__PTW32_INTERLOCKED_LONG) 1) != 0)\n\t    {\n\t      while  ((__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_EXCHANGE_LONG(\n                               (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n\t\t\t       (__PTW32_INTERLOCKED_LONG) -1) != 0)\n\t        {\n\t          if (WAIT_OBJECT_0 != WaitForSingleObject (mx->event, INFINITE))\n\t            {\n\t              result = EINVAL;\n\t\t      break;\n\t            }\n\t        }\n\t    }\n        }\n      else\n        {\n          pthread_t self = pthread_self();\n          if  ((__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(\n                        (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n\t\t        (__PTW32_INTERLOCKED_LONG) 1,\n\t\t        (__PTW32_INTERLOCKED_LONG) 0) == 0)\n\t    {\n\t      mx->recursive_count = 1;\n\t      mx->ownerThread = self;\n\t    }\n          else\n\t    {\n\t      if (pthread_equal (mx->ownerThread, self))\n\t        {\n\t          if (kind == PTHREAD_MUTEX_RECURSIVE)\n\t\t    {\n\t\t      mx->recursive_count++;\n\t\t    }\n\t          else\n\t\t    {\n\t\t      result = EDEADLK;\n\t\t    }\n\t        }\n\t      else\n\t        {\n\t          while  ((__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_EXCHANGE_LONG(\n                                   (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n\t\t\t           (__PTW32_INTERLOCKED_LONG) -1) != 0)\n\t\t    {\n\t              if (WAIT_OBJECT_0 != WaitForSingleObject (mx->event, INFINITE))\n\t\t        {\n\t                  result = EINVAL;\n\t\t          break;\n\t\t        }\n\t\t    }\n\t          if (0 == result)\n\t\t    {\n\t\t      mx->recursive_count = 1;\n\t\t      mx->ownerThread = self;\n\t\t    }\n\t        }\n\t    }\n        }\n    }\n  else\n    {\n      __ptw32_robust_state_t* statePtr = &mx->robustNode->stateInconsistent;\n      if  ((__PTW32_INTERLOCKED_LONG)__PTW32_ROBUST_NOTRECOVERABLE ==  __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(\n                                                  (__PTW32_INTERLOCKED_LONGPTR)statePtr,\n                                                  (__PTW32_INTERLOCKED_LONG)0))\n        {\n          result = ENOTRECOVERABLE;\n        }\n      else\n        {\n          pthread_t self = pthread_self();\n          kind = -kind - 1; \n          if (PTHREAD_MUTEX_NORMAL == kind)\n            {\n              if  ((__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_EXCHANGE_LONG(\n                            (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n                            (__PTW32_INTERLOCKED_LONG) 1) != 0)\n                {\n                  while (0 == (result = __ptw32_robust_mutex_inherit(mutex))\n                           &&  (__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_EXCHANGE_LONG(\n                                        (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n                                        (__PTW32_INTERLOCKED_LONG) -1) != 0)\n                    {\n                      if (WAIT_OBJECT_0 != WaitForSingleObject (mx->event, INFINITE))\n                        {\n                          result = EINVAL;\n                          break;\n                        }\n                      if  ((__PTW32_INTERLOCKED_LONG)__PTW32_ROBUST_NOTRECOVERABLE ==\n                                   __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(\n                                     (__PTW32_INTERLOCKED_LONGPTR)statePtr,\n                                     (__PTW32_INTERLOCKED_LONG)0))\n                        {\n                          SetEvent(mx->event);\n                          result = ENOTRECOVERABLE;\n                          break;\n                        }\n                    }\n                }\n              if (0 == result || EOWNERDEAD == result)\n                {\n                  __ptw32_robust_mutex_add(mutex, self);\n                }\n            }\n          else\n            {\n              if  ((__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(\n                            (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n                            (__PTW32_INTERLOCKED_LONG) 1,\n                            (__PTW32_INTERLOCKED_LONG) 0) == 0)\n                {\n                  mx->recursive_count = 1;\n                  __ptw32_robust_mutex_add(mutex, self);\n                }\n              else\n                {\n                  if (pthread_equal (mx->ownerThread, self))\n                    {\n                      if (PTHREAD_MUTEX_RECURSIVE == kind)\n                        {\n                          mx->recursive_count++;\n                        }\n                      else\n                        {\n                          result = EDEADLK;\n                        }\n                    }\n                  else\n                    {\n                      while (0 == (result = __ptw32_robust_mutex_inherit(mutex))\n                               &&  (__PTW32_INTERLOCKED_LONG)  __PTW32_INTERLOCKED_EXCHANGE_LONG(\n                                            (__PTW32_INTERLOCKED_LONGPTR) &mx->lock_idx,\n                                            (__PTW32_INTERLOCKED_LONG) -1) != 0)\n                        {\n                          if (WAIT_OBJECT_0 != WaitForSingleObject (mx->event, INFINITE))\n                            {\n                              result = EINVAL;\n                              break;\n                            }\n                          if  ((__PTW32_INTERLOCKED_LONG)__PTW32_ROBUST_NOTRECOVERABLE ==\n                                       __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(\n                                         (__PTW32_INTERLOCKED_LONGPTR)statePtr,\n                                         (__PTW32_INTERLOCKED_LONG)0))\n                            {\n                              SetEvent(mx->event);\n                              result = ENOTRECOVERABLE;\n                              break;\n                            }\n                        }\n                      if (0 == result || EOWNERDEAD == result)\n                        {\n                          mx->recursive_count = 1;\n                          __ptw32_robust_mutex_add(mutex, self);\n                        }\n                    }\n\t        }\n            }\n        }\n    }\n  return (result);\n}\n//...'"
"('Prompt: You are testing a function that evaluates the performance of a finite impulse response (FIR) filter for a specific filter type and parameters. The function calculates various metrics like cross-correlation and energy of the filter response. You need to provide a test case for the FIR filter with RFSECH filter type, k=2, m=9, beta=0.3, and dt=0.0. The test results should include the auto-test verbose output with specific metrics such as rxx[0], ISI (rms), and As. You should also check if rxx[0] is close to the expected value, and both ISI (rms) and As are less than -50.0 dB.","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\nvoid autotest_firfilt_rnyquist_baseline_rfsech   (){ testbench_firfilt_rnyquist(LIQUID_FIRFILT_RFSECH,   2,9,0.3f,0.0f); }\n//...')
"
"'Please provide a prompt where you are designing a software system that involves configuring and managing different hardware groups with specific priorities and orders for saving and restoring data. You need to create functions to map descriptors to a group, set the restore and save order for a group, set descriptor configurations, initialize a group with specific configurations, and trigger a software request for a group.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.ssarc""\n#endif\nstatic void SSARC_MapDescriptorsToGroup(SSARC_LP_Type *base, uint8_t groupID, uint32_t startIndex, uint32_t endIndex);\nstatic void SSARC_SetGroupRestoreOrder(SSARC_LP_Type *base, uint8_t groupID, ssarc_save_restore_order_t order);\nstatic void SSARC_SetGroupSaveOrder(SSARC_LP_Type *base, uint8_t groupID, ssarc_save_restore_order_t order);\nstatic void SSARC_MapDescriptorsToGroup(SSARC_LP_Type *base, uint8_t groupID, uint32_t startIndex, uint32_t endIndex)\n{\n    assert(groupID < SSARC_LP_DESC_CTRL0_COUNT);\n    assert((startIndex < endIndex) || (startIndex == endIndex));\n    base->GROUPS[groupID].DESC_CTRL0 = SSARC_LP_DESC_CTRL0_START(startIndex) | SSARC_LP_DESC_CTRL0_END(endIndex);\n}\nstatic void SSARC_SetGroupRestoreOrder(SSARC_LP_Type *base, uint8_t groupID, ssarc_save_restore_order_t order)\n{\n    assert(groupID < SSARC_LP_DESC_CTRL0_COUNT);\n    if (order == kSSARC_ProcessFromStartToEnd)\n    {\n        base->GROUPS[groupID].DESC_CTRL0 &= ~SSARC_LP_DESC_CTRL0_RT_ORDER_MASK;\n    }\n    else\n    {\n        base->GROUPS[groupID].DESC_CTRL0 |= SSARC_LP_DESC_CTRL0_RT_ORDER_MASK;\n    }\n}\nstatic void SSARC_SetGroupSaveOrder(SSARC_LP_Type *base, uint8_t groupID, ssarc_save_restore_order_t order)\n{\n    assert(groupID < SSARC_LP_DESC_CTRL0_COUNT);\n    if (order == kSSARC_ProcessFromStartToEnd)\n    {\n        base->GROUPS[groupID].DESC_CTRL0 &= ~SSARC_LP_DESC_CTRL0_SV_ORDER_MASK;\n    }\n    else\n    {\n        base->GROUPS[groupID].DESC_CTRL0 |= SSARC_LP_DESC_CTRL0_SV_ORDER_MASK;\n    }\n}\nvoid SSARC_SetDescriptorConfig(SSARC_HP_Type *base, uint32_t index, const ssarc_descriptor_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t temp32 = 0UL;\n    base->DESC[index].SRAM0 = config->address;\n    temp32 = SSARC_HP_SRAM2_TYPE(config->type) | SSARC_HP_SRAM2_SIZE(config->size);\n    temp32 |= (uint32_t)(config->operation);\n    base->DESC[index].SRAM2 = temp32;\n    if (config->type != kSSARC_ReadValueWriteBack)\n    {\n        base->DESC[index].SRAM1 = config->data;\n    }\n}\nvoid SSARC_GroupInit(SSARC_LP_Type *base, uint8_t groupID, const ssarc_group_config_t *config)\n{\n    assert(config != NULL);\n    assert(groupID < SSARC_LP_DESC_CTRL0_COUNT);\n    uint32_t temp32;\n    temp32 = SSARC_LP_DESC_CTRL1_POWER_DOMAIN(config->powerDomain) |\n             SSARC_LP_DESC_CTRL1_SV_PRIORITY(config->savePriority) |\n             SSARC_LP_DESC_CTRL1_RT_PRIORITY(config->restorePriority) | SSARC_LP_DESC_CTRL1_CPUD(config->cpuDomain);\n    base->GROUPS[groupID].DESC_CTRL1 = temp32;\n    SSARC_MapDescriptorsToGroup(base, groupID, config->startIndex, config->endIndex);\n    SSARC_SetGroupRestoreOrder(base, groupID, config->restoreOrder);\n    SSARC_SetGroupSaveOrder(base, groupID, config->saveOrder);\n    base->GROUPS[groupID].DESC_ADDR_UP   = config->highestAddress;\n    base->GROUPS[groupID].DESC_ADDR_DOWN = config->lowestAddress;\n    base->GROUPS[groupID].DESC_CTRL1 |= SSARC_LP_DESC_CTRL1_GP_EN_MASK;\n}\nvoid SSARC_TriggerSoftwareRequest(SSARC_LP_Type *base, uint8_t groupID, ssarc_software_trigger_mode_t mode)\n{\n    assert(groupID < SSARC_LP_DESC_CTRL0_COUNT);\n    base->GROUPS[groupID].DESC_CTRL1 |= (uint32_t)mode;\n    while (((base->GROUPS[groupID].DESC_CTRL1) & (uint32_t)mode) != 0UL)\n    {\n    }\n}'"
'Prompt: Create a function in C programming language that performs finite field multiplication of two uint8_t numbers. The function should take two unsigned 8-bit integers as input and return their result after performing the finite field multiplication according to the AES algorithm. The function should be designed to handle the carry and overflow conditions that may occur during the multiplication process.,"//...\ntestable uint8_t finiteFieldMultiply(uint8_t x, uint8_t y)\n{\n    uint8_t z = 0;\n    for(int i = 7; i >= 0; i--) {\n        z = (z << 1) ^ ((z >> 7) * 0x11D);\n        z ^= ((y >> i) & 1) * x;\n    }\n    return z;\n}\n//...'"
"('Prompt: You are working on a packetizer module for a data transmission system and you need to implement a function that returns the CRC scheme used for the packets. The function should take a packetizer object as a parameter and return the CRC scheme. Write the code for the function ""packetizer_get_crc"" that returns the CRC scheme stored in the ""check"" field of the packetizer object.","//...\ncrc_scheme packetizer_get_crc(packetizer _p)\n{\n    return _p->check;\n}\n//...')
"
('Prompt: You are working on a project that requires implementing a benchmark function for a symbolic synchronous CRCF with k=2 and m=16. Write a function in C that accomplishes this task.,"//...\nvoid benchmark_symsync_crcf_k2_m16  S\n//...')
"
"('Prompt: Write a C function that creates an OFDM frame generator object with the given parameters. Ensure that the number of subcarriers is at least 8, even, and that the cyclic prefix does not exceed the symbol length. Also, the taper length should not exceed the cyclic prefix. Initialize various arrays and structures within the object based on the given parameters and return the object. If there are any errors, return an appropriate error message.. . Technical Scenario: You need to implement a function in C that creates an OFDM frame generator object with certain constraints. The function should validate the parameters provided (number of subcarriers, cyclic prefix length, and taper length), allocate memory for various arrays and structures within the object, and initialize these variables accordingly. Finally, return the constructed object if everything is successful.","//...\nstruct ofdmframegen_s {\n    unsigned int M;         \n    unsigned int cp_len;    \n    unsigned char * p;      \n    unsigned int taper_len; \n    float * taper;          \n    float complex *postfix; \n    unsigned int M_null;    \n    unsigned int M_pilot;   \n    unsigned int M_data;    \n    unsigned int M_S0;      \n    unsigned int M_S1;      \n    float g_data;           \n    FFT_PLAN ifft;          \n    float complex * X;      \n    float complex * x;      \n    float complex * S0;     \n    float complex * s0;     \n    float complex * S1;     \n    float complex * s1;     \n    msequence ms_pilot;\n};\nofdmframegen ofdmframegen_create(unsigned int    _M,\n                                 unsigned int    _cp_len,\n                                 unsigned int    _taper_len,\n                                 unsigned char * _p)\n{\n    if (_M < 8)\n        return liquid_error_config(""ofdmframegen_create(), number of subcarriers must be at least 8"");\n    if (_M % 2)\n        return liquid_error_config(""ofdmframegen_create(), number of subcarriers must be even"");\n    if (_cp_len > _M)\n        return liquid_error_config(""ofdmframegen_create(), cyclic prefix cannot exceed symbol length"");\n    if (_taper_len > _cp_len)\n        return liquid_error_config(""ofdmframegen_create(), taper length cannot exceed cyclic prefix"");\n    ofdmframegen q = (ofdmframegen) malloc(sizeof(struct ofdmframegen_s));\n    q->M         = _M;\n    q->cp_len    = _cp_len;\n    q->taper_len = _taper_len;\n    q->p = (unsigned char*) malloc((q->M)*sizeof(unsigned char));\n    if (_p == NULL) {\n        ofdmframe_init_default_sctype(q->M, q->p);\n    } else {\n        memmove(q->p, _p, q->M*sizeof(unsigned char));\n    }\n    if (ofdmframe_validate_sctype(q->p, q->M, &q->M_null, &q->M_pilot, &q->M_data))\n        return liquid_error_config(""ofdmframegen_create(), invalid subcarrier allocation"");\n    unsigned int i;\n    q->X = (float complex*) FFT_MALLOC((q->M)*sizeof(float complex));\n    q->x = (float complex*) FFT_MALLOC((q->M)*sizeof(float complex));\n    q->ifft = FFT_CREATE_PLAN(q->M, q->X, q->x, FFT_DIR_BACKWARD, FFT_METHOD);\n    q->S0 = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->s0 = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->S1 = (float complex*) malloc((q->M)*sizeof(float complex));\n    q->s1 = (float complex*) malloc((q->M)*sizeof(float complex));\n    ofdmframe_init_S0(q->p, q->M, q->S0, q->s0, &q->M_S0);\n    ofdmframe_init_S1(q->p, q->M, q->S1, q->s1, &q->M_S1);\n    q->taper   = (float*)         malloc(q->taper_len * sizeof(float));\n    q->postfix = (float complex*) malloc(q->taper_len * sizeof(float complex));\n    for (i=0; i<q->taper_len; i++) {\n        float t = ((float)i + 0.5f) / (float)(q->taper_len);\n        float g = sinf(M_PI_2*t);\n        q->taper[i] = g*g;\n    }\n#if 0\n    for (i=0; i<q->taper_len; i++) {\n        printf(""    taper[%2u] = %12.8f (%12.8f)\\n"", i, q->taper[i],\n            q->taper[i] + q->taper[q->taper_len - i - 1]);\n    }\n#endif\n    q->g_data = 1.0f / sqrtf(q->M_pilot + q->M_data);\n    q->ms_pilot = msequence_create_default(8);\n    return q;\n}\n//...')
"
"('Please provide the prompt for a function that calculates the lower incomplete gamma function using the series representation. Additionally, include a function that calculates the gamma function and a function to calculate the natural logarithm of the gamma function. The lower incomplete gamma function is defined as the integral from 0 to z of the exponential function with the alpha parameter.","//...\nfloat liquid_lnlowergammaf(float _z, float _alpha)\n{\n    float t0 = _z * logf(_alpha);\n    float t1 = liquid_lngammaf(_z);\n    float t2 = -_alpha;\n    float t3 = 0.0f;\n    unsigned int k = 0;\n    float log_alpha = logf(_alpha);\n    float tprime = 0.0f;\n    float tmax = 0.0f;\n    float t = 0.0f;\n    for (k=0; k<LOWERGAMMA_MAX_ITERATIONS; k++) {\n        tprime = t;\n        t = k*log_alpha - liquid_lngammaf(_z + (float)k + 1.0f);\n        t3 += expf(t);\n        if (k==0 || t > tmax)\n            tmax = t;\n        if ( k > LOWERGAMMA_MIN_ITERATIONS && tprime > t && (tmax-t) > 20.0f)\n            break;\n    }\n    return t0 + t1 + t2 + logf(t3);\n}\nfloat liquid_gammaf(float _z)\n{\n    if (_z < 0) {\n        float t0 = liquid_gammaf(1.0 - _z);\n        float t1 = sinf(M_PI*_z);\n        if (t0==0 || t1==0)\n            liquid_error(LIQUID_EIVAL,""liquid_gammaf(), divide by zero"");\n        return M_PI / (t0 * t1);\n    } else {\n        return expf( liquid_lngammaf(_z) );\n    }\n}\nfloat liquid_lngammaf(float _z)\n{\n    float g;\n    if (_z < 0) {\n        liquid_error(LIQUID_EICONFIG,""liquid_lngammaf(), undefined for z <= 0"");\n        return 0.0f;\n    } else if (_z < 10.0f) {\n#if 0\n        g = -EULER_GAMMA*_z - logf(_z);\n        unsigned int k;\n        for (k=1; k<NUM_LNGAMMA_ITERATIONS; k++) {\n            float t0 = _z / (float)k;\n            float t1 = logf(1.0f + t0);\n            g += t0 - t1;\n        }\n#else\n        return liquid_lngammaf(_z + 1.0f) - logf(_z);\n#endif\n    } else {\n        g = 0.5*( logf(2*M_PI)-log(_z) );\n        g += _z*( logf(_z+(1/(12.0f*_z-0.1f/_z)))-1);\n    }\n    return g;\n}\nfloat liquid_lnuppergammaf(float _z, float _alpha)\n{\n    return logf( liquid_gammaf(_z) - liquid_lowergammaf(_z,_alpha) );\n}\nfloat liquid_lowergammaf(float _z, float _alpha)\n{\n    return expf( liquid_lnlowergammaf(_z,_alpha) );\n}\nfloat liquid_uppergammaf(float _z, float _alpha)\n{\n    return expf( liquid_lnuppergammaf(_z,_alpha) );\n}\n//...')
"
"('Prompt: You are working on a communication system and need a function to rearrange a given data buffer for interleaving purposes. The buffer should be rearranged based on certain mask values to ensure specific bits are swapped between positions. The function should be able to perform permutation on the buffer with and without a mask, as well as support soft-permutation for a more fine-grained bit manipulation. The function should take parameters including the data buffer, its size, the number of rows and columns for rearranging, and the mask value for bit swapping. This rearrangement will help in optimizing data transmission and reception. Can you provide me with C code that implements these functionalities?","//...\nint interleaver_permute_mask(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N,\n                             unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp0;\n    unsigned char tmp1;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp0 = (_x[2*i+0] & (~_mask)) | (_x[2*j+1] & ( _mask));\n        tmp1 = (_x[2*i+0] & ( _mask)) | (_x[2*j+1] & (~_mask));\n        _x[2*i+0] = tmp0;\n        _x[2*j+1] = tmp1;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute(unsigned char * _x,\n                        unsigned int    _n,\n                        unsigned int    _M,\n                        unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp = _x[2*j+1];\n        _x[2*j+1] = _x[2*i+0];\n        _x[2*i+0] = tmp;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute_mask_soft(unsigned char * _x,\n                                  unsigned int    _n,\n                                  unsigned int    _M,\n                                  unsigned int    _N,\n                                  unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int k;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        for (k=0; k<8; k++) {\n            if ( (_mask >> (8-k-1)) & 0x01 ) {\n                tmp = _x[8*(2*j+1)+k];\n                _x[8*(2*j+1)+k] = _x[8*(2*i+0)+k];\n                _x[8*(2*i+0)+k] = tmp;\n            }\n        }\n    }\n    return LIQUID_OK;\n}\n//...')
"
('Please provide a prompt that would require assistance with updating symbols synchronization in a GMSK framesync system using C code that includes FIR filtering and polyphase filters.,"//...\n#define GMSKFRAMESYNC_PREFILTER         1\n    unsigned int m;                 \n    firpfb_rrrf mf;                 \n    firpfb_rrrf dmf;                \n    unsigned int npfb;              \n    float pfb_q;                    \n    float pfb_soft;                 \n    int pfb_index;                  \n    int pfb_timer;                  \nint gmskframesync_update_symsync(gmskframesync _q,\n                                 float         _x,\n                                 float *       _y)\n{\n    firpfb_rrrf_push(_q->mf,  _x);\n    firpfb_rrrf_push(_q->dmf, _x);\n    float mf_out  = 0.0f;    \n    float dmf_out = 0.0f;    \n    int sample_available = 0;\n    if (_q->pfb_timer <= 0) {\n        sample_available = 1;\n        _q->pfb_timer = _q->k;  \n        firpfb_rrrf_execute(_q->mf,  _q->pfb_index, &mf_out);\n        firpfb_rrrf_execute(_q->dmf, _q->pfb_index, &dmf_out);\n        _q->pfb_q = 0.99f*_q->pfb_q + 0.05f*crealf( conjf(mf_out)*dmf_out );\n        _q->pfb_soft += _q->pfb_q;\n        _q->pfb_index = roundf(_q->pfb_soft);\n        while (_q->pfb_index < 0) {\n            _q->pfb_index += _q->npfb;\n            _q->pfb_soft  += _q->npfb;\n            _q->pfb_timer--;\n        }\n        while (_q->pfb_index > _q->npfb-1) {\n            _q->pfb_index -= _q->npfb;\n            _q->pfb_soft  -= _q->npfb;\n            _q->pfb_timer++;\n        }\n    }\n    _q->pfb_timer--;\n    *_y = mf_out / (float)(_q->k);\n    return sample_available;\n}\n//...')
"
"('Prompt: You are conducting an automated test for a polynomial root finding function. You want to generate random polynomial coefficients, find the roots, negate them, and then expand the roots back into new polynomial coefficients. Finally, you want to compare the original coefficients with the expanded ones within a tolerance value. Can you write a test function for this scenario?","//...\nvoid xautotest_polycf_findroots_rand()\n{\n    unsigned int n=5;\n    float tol=1e-4f;\n    float complex p[n];\n    float complex roots[n-1];\n    float complex p_hat[n];\n    unsigned int i;\n    for (i=0; i<n; i++)\n        p[i] = i == n-1 ? 1 : 3.0f * randnf();\n    polycf_findroots(p,n,roots);\n    float complex roots_hat[n-1];\n    for (i=0; i<n-1; i++)\n        roots_hat[i] = -roots[i];\n    polycf_expandroots(roots_hat,n-1,p_hat);\n    if (liquid_autotest_verbose) {\n        printf(""poly:\\n"");\n        for (i=0; i<n; i++)\n            printf(""  p[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(p[i]), cimagf(p[i]));\n        printf(""roots:\\n"");\n        for (i=0; i<n-1; i++)\n            printf(""  r[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(roots[i]), cimagf(roots[i]));\n        printf(""poly (expanded roots):\\n"");\n        for (i=0; i<n; i++)\n            printf(""  p[%3u] = %12.8f + j*%12.8f\\n"", i, crealf(p_hat[i]), cimagf(p_hat[i]));\n    }\n    for (i=0; i<n; i++) {\n        CONTEND_DELTA(crealf(p[i]), crealf(p_hat[i]), tol);\n        CONTEND_DELTA(cimagf(p[i]), cimagf(p_hat[i]), tol);\n    }\n}\n//...')
"
('Prompt: Design and implement a function that performs Fast Fourier Transform (FFT) for a given input size of 7 and compare the output with a pre-defined expected result in a unit test scenario.,"//...\nvoid autotest_fft_7()       { fft_test( fft_test_x7,   fft_test_y7,      7);     }\n//...')
"
"'Prompt: You are working on a project that involves using tiny TrueType fonts, and you need to implement functionality related to handling TrueType fonts in your project. Specifically, you need to handle font creation, destruction, glyph description, glyph bitmap retrieval, and caching. Can you provide the necessary code for handling these tasks using the STB Rect Pack and TrueType libraries in the LVGL library project?. ","#if LV_USE_TINY_TTF\n#define STB_RECT_PACK_IMPLEMENTATION\n#define STBRP_STATIC\n#define STBTT_STATIC\n#define STB_TRUETYPE_IMPLEMENTATION\n#define STBTT_HEAP_FACTOR_SIZE_32 50\n#define STBTT_HEAP_FACTOR_SIZE_128 20\n#define STBTT_HEAP_FACTOR_SIZE_DEFAULT 10\n#define STBTT_malloc(x, u) ((void)(u), lv_malloc(x))\n#define STBTT_free(x, u) ((void)(u), lv_free(x))\n#if LV_TINY_TTF_FILE_SUPPORT != 0\n#define STBTT_STREAM_TYPE ttf_cb_stream_t *\n#define STBTT_STREAM_SEEK(s, x) ttf_cb_stream_seek(s, x);\n#define STBTT_STREAM_READ(s, x, y) ttf_cb_stream_read(s, x, y);\ntypedef struct ttf_cb_stream {\n    lv_fs_file_t * file;\n    const void * data;\n    size_t size;\n    size_t position;\n} ttf_cb_stream_t;\nstatic void ttf_cb_stream_read(ttf_cb_stream_t * stream, void * data, size_t to_read);\nstatic void ttf_cb_stream_seek(ttf_cb_stream_t * stream, size_t position);\n#endif\n#define tiny_ttf_cache LV_GLOBAL_DEFAULT()->tiny_ttf_cache\ntypedef struct ttf_font_desc {\n    lv_fs_file_t file;\n#if LV_TINY_TTF_FILE_SUPPORT != 0\n    ttf_cb_stream_t stream;\n#else\n    const uint8_t * stream;\n#endif\n    stbtt_fontinfo info;\n    float scale;\n    int ascent;\n    int descent;\n} ttf_font_desc_t;\ntypedef struct _tiny_ttf_cache_data_t {\n    lv_font_t * font;\n    uint32_t unicode;\n    uint32_t size;\n    lv_draw_buf_t * draw_buf;\n} tiny_ttf_cache_data_t;\nstatic bool ttf_get_glyph_dsc_cb(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,\n                                 uint32_t unicode_letter_next);\nstatic const void * ttf_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc,\n                                            uint32_t unicode_letter, lv_draw_buf_t * draw_buf);\nstatic void ttf_release_glyph_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g_dsc);\nstatic lv_font_t * lv_tiny_ttf_create(const char * path, const void * data, size_t data_size,\n                                      int32_t font_size,\n                                      size_t cache_size);\nstatic bool tiny_ttf_cache_create_cb(tiny_ttf_cache_data_t * node, void * user_data);\nstatic void tiny_ttf_cache_free_cb(tiny_ttf_cache_data_t * node, void * user_data);\nstatic lv_cache_compare_res_t tiny_ttf_cache_compare_cb(const tiny_ttf_cache_data_t * lhs,\n                                                        const tiny_ttf_cache_data_t * rhs);\nvoid lv_tiny_ttf_set_size(lv_font_t * font, int32_t font_size)\n{\n    if(font_size <= 0) {\n        LV_LOG_ERROR(""invalid font size: %""PRIx32, font_size);\n        return;\n    }\n    ttf_font_desc_t * dsc = (ttf_font_desc_t *)font->dsc;\n    dsc->scale = stbtt_ScaleForMappingEmToPixels(&dsc->info, font_size);\n    int line_gap = 0;\n    stbtt_GetFontVMetrics(&dsc->info, &dsc->ascent, &dsc->descent, &line_gap);\n    font->line_height = (int32_t)(dsc->scale * (dsc->ascent - dsc->descent + line_gap));\n    font->base_line = (int32_t)(dsc->scale * (line_gap - dsc->descent));\n}\nvoid lv_tiny_ttf_destroy(lv_font_t * font)\n{\n    LV_ASSERT_NULL(font);\n    if(font->dsc != NULL) {\n        ttf_font_desc_t * ttf = (ttf_font_desc_t *)font->dsc;\n#if LV_TINY_TTF_FILE_SUPPORT != 0\n        if(ttf->stream.file != NULL) {\n            lv_fs_close(&ttf->file);\n        }\n#endif\n        lv_cache_drop_all(tiny_ttf_cache, (void *)font->dsc);\n        lv_free(ttf);\n        font->dsc = NULL;\n    }\n    lv_free(font);\n}\nvoid lv_tiny_ttf_init(void)\n{\n    lv_cache_ops_t ops = {\n        .compare_cb = (lv_cache_compare_cb_t)tiny_ttf_cache_compare_cb,\n        .create_cb = (lv_cache_create_cb_t)tiny_ttf_cache_create_cb,\n        .free_cb = (lv_cache_free_cb_t)tiny_ttf_cache_free_cb,\n    };\n    tiny_ttf_cache = lv_cache_create(&lv_cache_class_lru_rb_count, sizeof(tiny_ttf_cache_data_t), 128, ops);\n}\nvoid lv_tiny_ttf_deinit(void)\n{\n    lv_cache_destroy(tiny_ttf_cache, NULL);\n}\n#if LV_TINY_TTF_FILE_SUPPORT != 0\nstatic void ttf_cb_stream_read(ttf_cb_stream_t * stream, void * data, size_t to_read)\n{\n    if(stream->file != NULL) {\n        uint32_t br;\n        lv_fs_read(stream->file, data, to_read, &br);\n    }\n    else {\n        if(to_read + stream->position >= stream->size) {\n            to_read = stream->size - stream->position;\n        }\n        memcpy(data, ((const unsigned char *)stream->data + stream->position), to_read);\n        stream->position += to_read;\n    }\n}\nstatic void ttf_cb_stream_seek(ttf_cb_stream_t * stream, size_t position)\n{\n    if(stream->file != NULL) {\n        lv_fs_seek(stream->file, position, LV_FS_SEEK_SET);\n    }\n    else {\n        if(position > stream->size) {\n            stream->position = stream->size;\n        }\n        else {\n            stream->position = position;\n        }\n    }\n}\n#endif\nstatic bool ttf_get_glyph_dsc_cb(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,\n                                 uint32_t unicode_letter_next)\n{\n    if(unicode_letter < 0x20 ||\n       unicode_letter == 0xf8ff || \n       unicode_letter == 0x200c) { \n        dsc_out->box_w = 0;\n        dsc_out->adv_w = 0;\n        dsc_out->box_h = 0; \n        dsc_out->ofs_x = 0; \n        dsc_out->ofs_y = 0; \n        dsc_out->format = LV_FONT_GLYPH_FORMAT_NONE;\n        dsc_out->is_placeholder = false;\n        return true;\n    }\n    ttf_font_desc_t * dsc = (ttf_font_desc_t *)font->dsc;\n    int g1 = stbtt_FindGlyphIndex(&dsc->info, (int)unicode_letter);\n    if(g1 == 0) {\n        return false;\n    }\n    int x1, y1, x2, y2;\n    stbtt_GetGlyphBitmapBox(&dsc->info, g1, dsc->scale, dsc->scale, &x1, &y1, &x2, &y2);\n    int g2 = 0;\n    if(unicode_letter_next != 0) {\n        g2 = stbtt_FindGlyphIndex(&dsc->info, (int)unicode_letter_next);\n    }\n    int advw, lsb;\n    stbtt_GetGlyphHMetrics(&dsc->info, g1, &advw, &lsb);\n    int k = stbtt_GetGlyphKernAdvance(&dsc->info, g1, g2);\n    dsc_out->adv_w = (uint16_t)floor((((float)advw + (float)k) * dsc->scale) +\n                                     0.5f); \n    dsc_out->box_w = (x2 - x1 + 1);         \n    dsc_out->box_h = (y2 - y1 + 1);         \n    dsc_out->ofs_x = x1;                    \n    dsc_out->ofs_y = -y2;                   \n    dsc_out->format = LV_FONT_GLYPH_FORMAT_A8;\n    dsc_out->is_placeholder = false;\n    return true; \n}\nstatic const void * ttf_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc,\n                                            uint32_t unicode_letter, lv_draw_buf_t * draw_buf)\n{\n    LV_UNUSED(draw_buf);\n    const lv_font_t * font = g_dsc->resolved_font;\n    tiny_ttf_cache_data_t search_key = {\n        .font = (lv_font_t *)font,\n        .unicode = unicode_letter,\n        .size = font->line_height,\n    };\n    lv_cache_entry_t * entry = lv_cache_acquire_or_create(tiny_ttf_cache, &search_key, (void *)font->dsc);\n    if(entry == NULL) {\n        LV_LOG_ERROR(""cache not allocated\\n"");\n        return NULL;\n    }\n    g_dsc->entry = entry;\n    tiny_ttf_cache_data_t * cached_data = lv_cache_entry_get_data(entry);\n    return cached_data->draw_buf;\n}\nstatic void ttf_release_glyph_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g_dsc)\n{\n    LV_ASSERT_NULL(font);\n    if(g_dsc->entry == NULL) {\n        return;\n    }\n    lv_cache_release(tiny_ttf_cache, g_dsc->entry, NULL);\n    g_dsc->entry = NULL;\n}\nstatic lv_font_t * lv_tiny_ttf_create(const char * path, const void * data, size_t data_size, int32_t font_size,\n                                      size_t cache_size)\n{\n    LV_UNUSED(data_size);\n    LV_UNUSED(cache_size);\n    if((path == NULL && data == NULL) || 0 >= font_size) {\n        LV_LOG_ERROR(""tiny_ttf: invalid argument\\n"");\n        return NULL;\n    }\n    ttf_font_desc_t * dsc = lv_malloc_zeroed(sizeof(ttf_font_desc_t));\n    if(dsc == NULL) {\n        LV_LOG_ERROR(""tiny_ttf: out of memory\\n"");\n        return NULL;\n    }\n#if LV_TINY_TTF_FILE_SUPPORT != 0\n    if(path != NULL) {\n        if(LV_FS_RES_OK != lv_fs_open(&dsc->file, path, LV_FS_MODE_RD)) {\n            lv_free(dsc);\n            LV_LOG_ERROR(""tiny_ttf: unable to open %s\\n"", path);\n            return NULL;\n        }\n        dsc->stream.file = &dsc->file;\n    }\n    else {\n        dsc->stream.data = (const uint8_t *)data;\n        dsc->stream.size = data_size;\n    }\n    if(0 == stbtt_InitFont(&dsc->info, &dsc->stream, stbtt_GetFontOffsetForIndex(&dsc->stream, 0))) {\n        lv_free(dsc);\n        LV_LOG_ERROR(""tiny_ttf: init failed\\n"");\n        return NULL;\n    }\n#else\n    dsc->stream = (const uint8_t *)data;\n    if(0 == stbtt_InitFont(&dsc->info, dsc->stream, stbtt_GetFontOffsetForIndex(dsc->stream, 0))) {\n        lv_free(dsc);\n        LV_LOG_ERROR(""tiny_ttf: init failed\\n"");\n        return NULL;\n    }\n#endif\n    lv_font_t * out_font = lv_malloc_zeroed(sizeof(lv_font_t));\n    if(out_font == NULL) {\n        lv_free(dsc);\n        LV_LOG_ERROR(""tiny_ttf: out of memory\\n"");\n        return NULL;\n    }\n    out_font->get_glyph_dsc = ttf_get_glyph_dsc_cb;\n    out_font->get_glyph_bitmap = ttf_get_glyph_bitmap_cb;\n    out_font->release_glyph = ttf_release_glyph_cb;\n    out_font->dsc = dsc;\n    lv_tiny_ttf_set_size(out_font, font_size);\n    return out_font;\n}\n#if LV_TINY_TTF_FILE_SUPPORT != 0\nlv_font_t * lv_tiny_ttf_create_file_ex(const char * path, int32_t font_size, size_t cache_size)\n{\n    return lv_tiny_ttf_create(path, NULL, 0, font_size, cache_size);\n}\nlv_font_t * lv_tiny_ttf_create_file(const char * path, int32_t font_size)\n{\n    return lv_tiny_ttf_create(path, NULL, 0, font_size, 0);\n}\n#endif\nlv_font_t * lv_tiny_ttf_create_data_ex(const void * data, size_t data_size, int32_t font_size, size_t cache_size)\n{\n    return lv_tiny_ttf_create(NULL, data, data_size, font_size, cache_size);\n}\nlv_font_t * lv_tiny_ttf_create_data(const void * data, size_t data_size, int32_t font_size)\n{\n    return lv_tiny_ttf_create(NULL, data, data_size, font_size, 0);\n}\nstatic bool tiny_ttf_cache_create_cb(tiny_ttf_cache_data_t * node, void * user_data)\n{\n    ttf_font_desc_t * dsc = (ttf_font_desc_t *)user_data;\n    uint32_t unicode_letter = node->unicode;\n    const stbtt_fontinfo * info = (const stbtt_fontinfo *)&dsc->info;\n    int g1 = stbtt_FindGlyphIndex(info, (int)unicode_letter);\n    if(g1 == 0) {\n        return false;\n    }\n    int x1, y1, x2, y2;\n    stbtt_GetGlyphBitmapBox(info, g1, dsc->scale, dsc->scale, &x1, &y1, &x2, &y2);\n    int w, h;\n    w = x2 - x1 + 1;\n    h = y2 - y1 + 1;\n    lv_draw_buf_t * draw_buf = lv_draw_buf_create(w, h, LV_COLOR_FORMAT_A8, LV_STRIDE_AUTO);\n    if(NULL == draw_buf) {\n        LV_LOG_ERROR(""tiny_ttf: out of memory\\n"");\n        return false;\n    }\n    lv_draw_buf_clear(draw_buf, NULL);\n    uint32_t stride = draw_buf->header.stride;\n    stbtt_MakeGlyphBitmap(info, draw_buf->data, w, h, stride, dsc->scale, dsc->scale, g1);\n    node->draw_buf = draw_buf;\n    return true;\n}\nstatic void tiny_ttf_cache_free_cb(tiny_ttf_cache_data_t * node, void * user_data)\n{\n    LV_UNUSED(user_data);\n    lv_draw_buf_destroy(node->draw_buf);\n}\nstatic lv_cache_compare_res_t tiny_ttf_cache_compare_cb(const tiny_ttf_cache_data_t * lhs,\n                                                        const tiny_ttf_cache_data_t * rhs)\n{\n    if(lhs->font != rhs->font) {\n        return lhs->font > rhs->font ? 1 : -1;\n    }\n    if(lhs->unicode != rhs->unicode) {\n        return lhs->unicode > rhs->unicode ? 1 : -1;\n    }\n    if(lhs->size != rhs->size) {\n        return lhs->size > rhs->size ? 1 : -1;\n    }\n    return 0;\n}\n#endif'"
"('Please write a test scenario script for a digital signal processing application that involves testing a filter bank created using the Firpfbch2_crcf function. The scenario needs to involve generating a complex input signal, applying the analyzer and synthesizer filter bank operations, and verifying the output against the expected values. The script should include setting parameters for filter taps (_M), number of filters (_m), and stop-band attenuation (_as). It should also validate the output using a root mean square error (rmse) calculation and print the results for verification.","//...\nvoid firpfbch2_crcf_runtest(unsigned int _M,\n                            unsigned int _m,\n                            float        _as)\n{\n    float tol = 1e-3f;\n    unsigned int i;\n    unsigned int num_symbols = 8*_m;    \n    unsigned int num_samples = _M * num_symbols;\n    float complex x[num_samples];\n    float complex y[num_samples];\n    unsigned int s = 1;         \n    unsigned int p = 524287;    \n    unsigned int g =   1031;    \n    for (i=0; i<num_samples; i++) {\n        s = (s * p) % g;\n        x[i] = (float)s / (float)g - 0.5f;\n    }\n    firpfbch2_crcf qa = firpfbch2_crcf_create_kaiser(LIQUID_ANALYZER,    _M, _m, _as);\n    firpfbch2_crcf qs = firpfbch2_crcf_create_kaiser(LIQUID_SYNTHESIZER, _M, _m, _as);\n    float complex Y[_M];\n    for (i=0; i<num_samples; i+=_M/2) {\n        firpfbch2_crcf_execute(qa, &x[i], Y);\n        firpfbch2_crcf_execute(qs, Y, &y[i]);\n    }\n    firpfbch2_crcf_destroy(qa); \n    firpfbch2_crcf_destroy(qs); \n    unsigned int delay = 2*_M*_m - _M/2 + 1;\n    float rmse = 0.0f;\n    for (i=0; i<num_samples; i++) {\n        if (i < delay) {\n            CONTEND_DELTA( crealf(y[i]), 0.0f, tol );\n            CONTEND_DELTA( cimagf(y[i]), 0.0f, tol );\n        } else {\n            CONTEND_DELTA( crealf(y[i]), crealf(x[i-delay]), tol );\n            CONTEND_DELTA( cimagf(y[i]), cimagf(x[i-delay]), tol );\n        }\n        float complex err = y[i] - (i < delay ? 0.0f : x[i-delay]);\n        rmse += crealf(err * conjf(err));\n    }\n    rmse = sqrtf(rmse / (float)num_samples);\n    if (liquid_autotest_verbose)\n        printf(""firpfbch2:  M=%3u, m=%2u, as=%8.2f dB, rmse=%12.4e\\n"", _M, _m, _as, rmse);\n}\n//...')
"
"('Prompt: You are working on a digital communication system that uses frame synchronization to detect and validate frames. You need to implement a benchmarking function called benchmark_framesync64, which will measure the performance of your framesync method by executing a series of frame synchronizations. The function will take a start time, finish time, and number of iterations as inputs, divide the number of iterations by 128, generate a random payload and header, create a frame synchronization object, execute the frame generation, add noise to the frame, and then run the frame synchronization for the specified number of iterations. The callback function within the framesync method will update statistics about the number of frames detected and validated. Finally, the function will print out the results. Can you implement this benchmarking function in C?","typedef struct {\n    unsigned int num_frames_tx;         \n    unsigned int num_frames_detected;   \n    unsigned int num_frames_valid;      \n} framedata;\nstatic int callback(unsigned char *  _header,\n                    int              _header_valid,\n                    unsigned char *  _payload,\n                    unsigned int     _payload_len,\n                    int              _payload_valid,\n                    framesyncstats_s _stats,\n                    void *           _userdata)\n{\n    framedata * fd = (framedata*) _userdata;\n    fd->num_frames_detected += 1;\n    fd->num_frames_valid    += _payload_valid ? 1 : 0;\n    return 0;\n}\nvoid benchmark_framesync64(\n    struct rusage *_start,\n    struct rusage *_finish,\n    unsigned long int *_num_iterations)\n{\n    *_num_iterations /= 128;\n    unsigned long int i;\n    framegen64 fg = framegen64_create();\n    unsigned char header[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    unsigned char payload[64];\n    for (i=0; i<64; i++)\n        payload[i] = rand() & 0xff;\n    framedata fd = {0, 0, 0};\n    framesync64 fs = framesync64_create(callback,(void*)&fd);\n    unsigned int frame_len = LIQUID_FRAME64_LEN;\n    float complex frame[frame_len];\n    framegen64_execute(fg, header, payload, frame);\n    for (i=0; i<frame_len; i++)\n        frame[i] += 0.01f*(randnf() + _Complex_I*randnf()) * M_SQRT1_2;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        framesync64_execute(fs, frame, frame_len);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    framegen64_destroy(fg);\n    framesync64_destroy(fs);\n#if 0\n    fd.num_frames_tx = *_num_iterations;\n    printf(""  frames detected/valid/transmitted  :   %6u / %6u / %6u\\n"",\n            fd.num_frames_detected,\n            fd.num_frames_valid,\n            fd.num_frames_tx);\n#endif\n}')
"
"('Please provide a prompt in which you are working on implementing a Hamming(31,26) forward error correction code for a communication system. You need assistance in writing C code for encoding and decoding symbols using this FEC scheme.","#define DEBUG_FEC_HAMMING3126 0\n#define HAMMING_M1  0x036AD555  \n#define HAMMING_M2  0x02D9B333  \n#define HAMMING_M4  0x01C78F0F  \n#define HAMMING_M8  0x003F80FF  \n#define HAMMING_M16 0x00007FFF  \n#define HAMMING_S1  0x55555555  \n#define HAMMING_S2  0x33333333  \n#define HAMMING_S4  0x0f0f0f0f  \n#define HAMMING_S8  0x00ff00ff  \n#define HAMMING_S16 0x0000ffff  \nunsigned int fec_hamming3126_encode_symbol(unsigned int _sym_dec)\n{\n    if (_sym_dec >= (1<<26)) {\n        liquid_error(LIQUID_EICONFIG,""fec_hamming_encode(), input symbol too large"");\n        return 0;\n    }\n    unsigned int p1  = liquid_bdotprod_uint32(_sym_dec, HAMMING_M1);\n    unsigned int p2  = liquid_bdotprod_uint32(_sym_dec, HAMMING_M2);\n    unsigned int p4  = liquid_bdotprod_uint32(_sym_dec, HAMMING_M4);\n    unsigned int p8  = liquid_bdotprod_uint32(_sym_dec, HAMMING_M8);\n    unsigned int p16 = liquid_bdotprod_uint32(_sym_dec, HAMMING_M16);\n#if DEBUG_FEC_HAMMING\n    printf(""parity bits (p1,p2,p4,p8,p16) : (%1u,%1u,%1u,%1u,%1u)\\n"", p1, p2, p4, p8, p16);\n#endif\n    unsigned int sym_enc = ((_sym_dec & 0x00007fff) << 0) | \n                           ((_sym_dec & 0x003F8000) << 1) | \n                           ((_sym_dec & 0x01C00000) << 2) | \n                           ((_sym_dec & 0x02000000) << 3) | \n                           ( p1  << 30 ) |  \n                           ( p2  << 29 ) |  \n                           ( p4  << 27 ) |  \n                           ( p8  << 23 ) |  \n                           ( p16 << 15 );   \n    return sym_enc;\n}\nunsigned int fec_hamming3126_decode_symbol(unsigned int _sym_enc)\n{\n    if (_sym_enc >= (1u<<31)) {\n        liquid_error(LIQUID_EICONFIG,""fec_hamming_decode(), input symbol too large"");\n        return 0;\n    }\n    unsigned int s1  = liquid_bdotprod_uint32(_sym_enc, HAMMING_S1);\n    unsigned int s2  = liquid_bdotprod_uint32(_sym_enc, HAMMING_S2);\n    unsigned int s4  = liquid_bdotprod_uint32(_sym_enc, HAMMING_S4);\n    unsigned int s8  = liquid_bdotprod_uint32(_sym_enc, HAMMING_S8);\n    unsigned int s16 = liquid_bdotprod_uint32(_sym_enc, HAMMING_S16);\n    unsigned int z = (s16<<4) | (s8<<3) | (s4<<2) | (s2<<1) | s1;\n#if DEBUG_FEC_HAMMING\n    printf(""syndrome bits (s1,s2,s4,s8,16) : (%1u,%1u,%1u,%1u,%1u)\\n"", s1, s2, s4, s8, s16);\n    printf(""syndrome z : %u\\n"", z);\n#endif\n    if (z) {\n        if (z > 31) {\n            fprintf(stderr,""warning, fec_hamming3126_decode_symbol(), syndrome index exceeds maximum\\n"");\n        } else {\n            _sym_enc ^= 1 << (31-z);\n        }\n    }\n    unsigned int sym_dec = ((_sym_enc & 0x00007fff)     )   |   \n                           ((_sym_enc & 0x007f0000) >> 1)   |   \n                           ((_sym_enc & 0x07000000) >> 2)   |   \n                           ((_sym_enc & 0x10000000) >> 3);      \n    return sym_dec;\n}')
"
"('You could have prompted me with:. ""Write a code snippet that implements an autotest function for the \'filter_crosscorr_rrrf\' function. In this scenario, you need to compare the output of the \'filter_crosscorr_rrrf\' function with a known expected output for a given input signal \'x\' and \'y\'. Ensure that the results are within a tolerance of 1e-3f.""","//...\nvoid autotest_filter_crosscorr_rrrf()\n{\n    float tol = 1e-3f;\n    int x_len = 16;\n    float x[16] = {\n          0.25887000,   0.11752000,   0.67812000,  -1.02480000, \n          1.46750000,  -0.67462000,   0.93029000,   0.98751000, \n          0.00969890,   1.05300000,   1.38100000,   1.47540000, \n          1.14110000,  -0.39480000,  -0.30426000,   1.58190000 };\n    int y_len = 8;\n    float y[8] = {\n         -1.15920000,  -1.57390000,   0.65239000,  -0.54542000, \n         -0.97277000,   0.99115000,  -0.76247000,  -1.08210000 };\n    unsigned int rxy_len = x_len + y_len - 1;\n    float rxy[23];\n    float rxy_test[23] = {\n         -0.28013000,  -0.32455000,  -0.56685000,   0.45660000, \n         -0.39008000,  -1.95950000,   1.25850000,  -3.35780000, \n         -1.85760000,   1.07920000,  -5.31760000,  -2.18630000, \n         -2.05850000,  -3.52450000,  -0.90010000,  -4.55350000, \n         -4.17770000,  -1.09920000,  -5.13670000,  -1.76270000, \n          1.96850000,  -2.13700000,  -1.83370000};\n    if (liquid_autotest_verbose)\n        printf(""testing corr(x,y):\\n"");\n    int i;\n    for (i=0; i<rxy_len; i++) {\n        int lag = i - y_len + 1;\n        rxy[i] = liquid_filter_crosscorr(x,x_len, y,y_len, lag);\n        if (liquid_autotest_verbose)\n            printf(""  rxy(%3d) = %12.8f (expected %12.8f, e=%12.4e)\\n"", lag, rxy[i], rxy_test[i], rxy[i]-rxy_test[i]);\n    }\n    for (i=0; i<rxy_len; i++)\n        CONTEND_DELTA( rxy[i], rxy_test[i], tol );\n    unsigned int ryx_len = x_len + y_len - 1;\n    float ryx[23];\n    float ryx_test[23] = {\n         -1.83370000,  -2.13700000,   1.96850000,  -1.76270000, \n         -5.13670000,  -1.09920000,  -4.17770000,  -4.55350000, \n         -0.90010000,  -3.52450000,  -2.05850000,  -2.18630000, \n         -5.31760000,   1.07920000,  -1.85760000,  -3.35780000, \n          1.25850000,  -1.95950000,  -0.39008000,   0.45660000, \n         -0.56685000,  -0.32455000,  -0.28013000};\n    if (liquid_autotest_verbose)\n        printf(""testing corr(y,x):\\n"");\n    for (i=0; i<ryx_len; i++) {\n        int lag = i - x_len + 1;\n        ryx[i] = liquid_filter_crosscorr(y,y_len, x,x_len, lag);\n        if (liquid_autotest_verbose)\n            printf(""  ryx(%3d) = %12.8f (expected %12.8f, e=%12.4e)\\n"", lag, ryx[i], ryx_test[i], ryx[i]-ryx_test[i]);\n    }\n    for (i=0; i<ryx_len; i++)\n        CONTEND_DELTA( ryx[i], ryx_test[i], tol );\n}\n//...')
"
('Prompt: You are tasked with writing a function in C that sets the length of a header and performs various operations to decode the header in a software defined radio application. The function should handle both soft and hard decoding scenarios.,"//...\n    int header_soft;                    \n    modemcf mod_header;                 \n    unsigned int header_user_len;       \nint ofdmflexframesync_set_header_len(ofdmflexframesync _q,\n                                     unsigned int     _len)\n{\n    _q->header_user_len = _len;\n    _q->header_dec_len = OFDMFLEXFRAME_H_DEC + _q->header_user_len;\n    _q->header = realloc(_q->header, _q->header_dec_len*sizeof(unsigned char));\n    if (_q->p_header) {\n        packetizer_destroy(_q->p_header);\n    }\n    _q->p_header = packetizer_create(_q->header_dec_len,\n                                     _q->header_props.check,\n                                     _q->header_props.fec0,\n                                     _q->header_props.fec1);\n    if (_q->header_soft) {\n        _q->header_enc_len = 8*packetizer_get_enc_msg_len(_q->p_header);\n        _q->header_sym_len = _q->header_enc_len;\n    } else {\n        _q->header_enc_len = packetizer_get_enc_msg_len(_q->p_header);\n        unsigned int bps = modulation_types[_q->header_props.mod_scheme].bps;\n        div_t bps_d = div(_q->header_enc_len*8, bps);\n        _q->header_sym_len = bps_d.quot + (bps_d.rem ? 1 : 0);\n    }\n    _q->header_enc = realloc(_q->header_enc, _q->header_enc_len*sizeof(unsigned char));\n    _q->header_mod = realloc(_q->header_mod, _q->header_sym_len*sizeof(unsigned char));\n    if (_q->mod_header) {\n        modemcf_destroy(_q->mod_header);\n    }\n    _q->mod_header = modemcf_create(_q->header_props.mod_scheme);\n    return LIQUID_OK;\n}\nint ofdmflexframesync_decode_header(ofdmflexframesync _q)\n{\n    _q->header_valid = 0;\n    int header_ok = 0;\n    if (_q->header_soft) {\n        memmove(_q->header_enc, _q->header_mod, _q->header_enc_len);\n        unscramble_data_soft(_q->header_enc, _q->header_enc_len/8);\n        header_ok = packetizer_decode_soft(_q->p_header, _q->header_enc, _q->header);\n    } else {\n        unsigned int num_written;\n        unsigned int bps = modulation_types[_q->header_props.mod_scheme].bps;\n        liquid_repack_bytes(_q->header_mod, bps, _q->header_sym_len,\n                            _q->header_enc, 8,   _q->header_enc_len,\n                            &num_written);\n        assert(num_written==_q->header_enc_len);\n        unscramble_data(_q->header_enc, _q->header_enc_len);\n        header_ok = packetizer_decode(_q->p_header, _q->header_enc, _q->header);\n    }\n#if 0\n    printf(""header rx (enc) : "");\n    for (i=0; i<_q->header_enc_len; i++)\n        printf(""%.2X "", _q->header_enc[i]);\n    printf(""\\n"");\n    printf(""header rx (dec) : "");\n    for (i=0; i<_q->header_dec_len; i++)\n        printf(""%.2X "", _q->header[i]);\n    printf(""\\n"");\n#endif\n#if DEBUG_OFDMFLEXFRAMESYNC\n    printf(""****** header extracted [%s]\\n"", header_ok ? ""valid"" : ""INVALID!"");\n#endif\n    if (!header_ok)\n        return LIQUID_OK;\n    unsigned int n = _q->header_user_len;\n    if (_q->header[n+0] != OFDMFLEXFRAME_PROTOCOL)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframesync_decode_header(), invalid framing version"");\n    unsigned int payload_len = (_q->header[n+1] << 8) | (_q->header[n+2]);\n    unsigned int mod_scheme = _q->header[n+3];\n    if (mod_scheme == 0 || mod_scheme >= LIQUID_MODEM_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframesync_decode_header(), invalid modulation scheme"");\n    unsigned int check = (_q->header[n+4] >> 5 ) & 0x07;\n    unsigned int fec0  = (_q->header[n+4]      ) & 0x1f;\n    unsigned int fec1  = (_q->header[n+5]      ) & 0x1f;\n    if (check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframesync_decode_header(), decoded CRC exceeds available"");\n    if (fec0 >= LIQUID_FEC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframesync_decode_header(), decoded FEC (inner) exceeds available"");\n    if (fec1 >= LIQUID_FEC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""ofdmflexframesync_decode_header(), decoded FEC (outer) exceeds available"");\n#if DEBUG_OFDMFLEXFRAMESYNC\n    printf(""    properties:\\n"");\n    printf(""      * mod scheme      :   %s\\n"", modulation_types[mod_scheme].fullname);\n    printf(""      * fec (inner)     :   %s\\n"", fec_scheme_str[fec0][1]);\n    printf(""      * fec (outer)     :   %s\\n"", fec_scheme_str[fec1][1]);\n    printf(""      * CRC scheme      :   %s\\n"", crc_scheme_str[check][1]);\n    printf(""      * payload length  :   %u bytes\\n"", payload_len);\n#endif\n    _q->header_valid = 1;\n    if (mod_scheme != _q->ms_payload) {\n        _q->ms_payload  = mod_scheme;\n        _q->bps_payload = modulation_types[mod_scheme].bps;\n        _q->mod_payload = modemcf_recreate(_q->mod_payload, _q->ms_payload);\n    }\n    _q->payload_len = payload_len;\n    _q->check       = check;\n    _q->fec0        = fec0;\n    _q->fec1        = fec1;\n    _q->p_payload = packetizer_recreate(_q->p_payload,\n                                        _q->payload_len,\n                                        _q->check,\n                                        _q->fec0,\n                                        _q->fec1);\n    if (_q->payload_soft) {\n        int packetizer_msg_len = packetizer_get_enc_msg_len(_q->p_payload);\n        div_t d = div((int)8*packetizer_msg_len, (int)_q->bps_payload);\n        _q->payload_mod_len = d.quot + (d.rem ? 1 : 0);\n        _q->payload_enc_len = _q->bps_payload*_q->payload_mod_len;\n    } else {\n        _q->payload_enc_len = packetizer_get_enc_msg_len(_q->p_payload);\n        div_t d = div(8*_q->payload_enc_len, _q->bps_payload);\n        _q->payload_mod_len = d.quot + (d.rem ? 1 : 0);\n    }\n#if DEBUG_OFDMFLEXFRAMESYNC\n    printf(""      * payload encoded :   %u bytes\\n"", _q->payload_enc_len);\n#endif\n    _q->payload_enc = (unsigned char*) realloc(_q->payload_enc, _q->payload_enc_len*sizeof(unsigned char));\n    _q->payload_dec = (unsigned char*) realloc(_q->payload_dec, _q->payload_len*sizeof(unsigned char));\n    _q->payload_syms = (float complex*) realloc(_q->payload_syms, _q->payload_mod_len*sizeof(float complex));\n#if DEBUG_OFDMFLEXFRAMESYNC\n    printf(""      * payload mod syms:   %u symbols\\n"", _q->payload_mod_len);\n#endif\n    return LIQUID_OK;\n}\nint ofdmflexframesync_decode_header_soft(ofdmflexframesync _q,\n                                         int _soft)\n{\n    _q->header_soft = _soft;\n    return ofdmflexframesync_set_header_len(_q, _q->header_user_len);\n}\n//...')
"
'Please provide the prompt that led to the code snippet above so I can assist you better.,"//...\n    if(info.res == LV_COVER_RES_MASKED) return NULL;\n    info.area = area_p;\n    for(i = child_cnt - 1; i >= 0; i--) {\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)\n{\n    if(!_lv_area_is_on(area, &obj->coords)) return true;\n    lv_cover_check_info_t info;\n    info.res = LV_COVER_RES_COVER;\n    info.area = area;\n    lv_obj_send_event(obj, LV_EVENT_COVER_CHECK, &info);\n    if(info.res == LV_COVER_RES_COVER) return false;\n    else return true;\n}\nvoid refr_obj(lv_layer_t * layer, lv_obj_t * obj)\n{\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;\n    lv_layer_type_t layer_type = _lv_obj_get_layer_type(obj);\n    if(layer_type == LV_LAYER_TYPE_NONE) {\n        lv_obj_redraw(layer, obj);\n    }\n    else {\n        lv_opa_t opa = lv_obj_get_style_opa_layered(obj, 0);\n        if(opa < LV_OPA_MIN) return;\n        lv_area_t layer_area_full;\n        lv_area_t obj_draw_size;\n        lv_result_t res = layer_get_area(layer, obj, layer_type, &layer_area_full, &obj_draw_size);\n        if(res != LV_RESULT_OK) return;\n        uint32_t max_rgb_row_height = lv_area_get_height(&layer_area_full);\n        uint32_t max_argb_row_height = lv_area_get_height(&layer_area_full);\n        if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n            int32_t w = lv_area_get_width(&layer_area_full);\n            uint8_t px_size = lv_color_format_get_size(disp_refr->color_format);\n            max_rgb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / px_size;\n            max_argb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / sizeof(lv_color32_t);\n        }\n        lv_area_t layer_area_act;\n        layer_area_act.x1 = layer_area_full.x1;\n        layer_area_act.x2 = layer_area_full.x2;\n        layer_area_act.y1 = layer_area_full.y1;\n        layer_area_act.y2 = layer_area_full.y1;\n        while(layer_area_act.y2 < layer_area_full.y2) {\n            layer_area_act.y2 = layer_area_act.y1 + max_rgb_row_height - 1;\n            if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            bool area_need_alpha = alpha_test_area_on_obj(obj, &layer_area_act);\n            if(area_need_alpha) {\n                layer_area_act.y2 = layer_area_act.y1 + max_argb_row_height - 1;\n                if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            }\n            lv_layer_t * new_layer = lv_draw_layer_create(layer,\n                                                          area_need_alpha ? LV_COLOR_FORMAT_ARGB8888 : LV_COLOR_FORMAT_NATIVE, &layer_area_act);\n            lv_obj_redraw(new_layer, obj);\n            lv_draw_image_dsc_t layer_draw_dsc;\n            lv_draw_image_dsc_init(&layer_draw_dsc);\n            layer_draw_dsc.pivot.x = obj->coords.x1 + lv_obj_get_style_transform_pivot_x(obj, 0) - new_layer->buf_area.x1;\n            layer_draw_dsc.pivot.y = obj->coords.y1 + lv_obj_get_style_transform_pivot_y(obj, 0) - new_layer->buf_area.y1;\n            layer_draw_dsc.opa = opa;\n            layer_draw_dsc.rotation = lv_obj_get_style_transform_rotation(obj, 0);\n            while(layer_draw_dsc.rotation > 3600) layer_draw_dsc.rotation -= 3600;\n            while(layer_draw_dsc.rotation < 0) layer_draw_dsc.rotation += 3600;\n            layer_draw_dsc.scale_x = lv_obj_get_style_transform_scale_x(obj, 0);\n            layer_draw_dsc.scale_y = lv_obj_get_style_transform_scale_y(obj, 0);\n            layer_draw_dsc.skew_x = lv_obj_get_style_transform_skew_x(obj, 0);\n            layer_draw_dsc.skew_y = lv_obj_get_style_transform_skew_y(obj, 0);\n            layer_draw_dsc.blend_mode = lv_obj_get_style_blend_mode(obj, 0);\n            layer_draw_dsc.antialias = disp_refr->antialiasing;\n            layer_draw_dsc.bitmap_mask_src = lv_obj_get_style_bitmap_mask_src(obj, 0);\n            layer_draw_dsc.original_area = obj_draw_size;\n            layer_draw_dsc.src = new_layer;\n            lv_draw_layer(layer, &layer_draw_dsc, &layer_area_act);\n            layer_area_act.y1 = layer_area_act.y2 + 1;\n        }\n    }\n}\nstatic lv_result_t layer_get_area(lv_layer_t * layer, lv_obj_t * obj, lv_layer_type_t layer_type,\n                                  lv_area_t * layer_area_out, lv_area_t * obj_draw_size_out)\n{\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_obj_get_coords(obj, obj_draw_size_out);\n    lv_area_increase(obj_draw_size_out, ext_draw_size, ext_draw_size);\n    if(layer_type == LV_LAYER_TYPE_TRANSFORM) {\n        lv_area_t clip_coords_for_obj;\n        lv_area_t tranf_coords = *obj_draw_size_out;\n        lv_obj_get_transformed_area(obj, &tranf_coords, false, false);\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, &tranf_coords)) {\n            return LV_RESULT_INVALID;\n        }\n        lv_area_t inverse_clip_coords_for_obj = clip_coords_for_obj;\n        lv_obj_get_transformed_area(obj, &inverse_clip_coords_for_obj, false, true);\n        if(!_lv_area_intersect(&inverse_clip_coords_for_obj, &inverse_clip_coords_for_obj, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = inverse_clip_coords_for_obj;\n        lv_area_increase(layer_area_out, 5, 5); \n    }\n    else if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n        lv_area_t clip_coords_for_obj;\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = clip_coords_for_obj;\n    }\n    else {\n        LV_LOG_WARN(""Unhandled layer type"");\n        return LV_RESULT_INVALID;\n    }\n    return LV_RESULT_OK;\n}\nvoid lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)\n{\n    lv_area_t clip_area_ori = layer->_clip_area;\n    lv_area_t clip_coords_for_obj;\n    lv_area_t obj_coords_ext;\n    lv_obj_get_coords(obj, &obj_coords_ext);\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_increase(&obj_coords_ext, ext_draw_size, ext_draw_size);\n    if(!_lv_area_intersect(&clip_coords_for_obj, &clip_area_ori, &obj_coords_ext)) return;\n    layer->_clip_area = clip_coords_for_obj;\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_BEGIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_END, layer);\n#if LV_USE_REFR_DEBUG\n    lv_color_t debug_color = lv_color_make(lv_rand(0, 0xFF), lv_rand(0, 0xFF), lv_rand(0, 0xFF));\n    lv_draw_rect_dsc_t draw_dsc;\n    lv_draw_rect_dsc_init(&draw_dsc);\n    draw_dsc.bg_color = debug_color;\n    draw_dsc.bg_opa = LV_OPA_20;\n    draw_dsc.border_width = 1;\n    draw_dsc.border_opa = LV_OPA_30;\n    draw_dsc.border_color = debug_color;\n    lv_draw_rect(layer, &draw_dsc, &obj_coords_ext);\n#endif\n    const lv_area_t * obj_coords;\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_OVERFLOW_VISIBLE)) {\n        obj_coords = &obj_coords_ext;\n    }\n    else {\n        obj_coords = &obj->coords;\n    }\n    lv_area_t clip_coords_for_children;\n    bool refr_children = true;\n    if(!_lv_area_intersect(&clip_coords_for_children, &clip_area_ori, obj_coords)) {\n        refr_children = false;\n    }\n    if(refr_children) {\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(obj);\n        if(child_cnt == 0) {\n            layer->_clip_area = clip_coords_for_obj;\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n        }\n        else {\n            layer->_clip_area = clip_coords_for_children;\n            bool clip_corner = lv_obj_get_style_clip_corner(obj, LV_PART_MAIN);\n            int32_t radius = 0;\n            if(clip_corner) {\n                radius = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n                if(radius == 0) clip_corner = false;\n            }\n            if(clip_corner == false) {\n                for(i = 0; i < child_cnt; i++) {\n                    lv_obj_t * child = obj->spec_attr->children[i];\n                    refr_obj(layer, child);\n                }\n                layer->_clip_area = clip_coords_for_obj;\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n            }\n            else {\n                lv_layer_t * layer_children;\n                lv_draw_mask_rect_dsc_t mask_draw_dsc;\n                lv_draw_mask_rect_dsc_init(&mask_draw_dsc);\n                mask_draw_dsc.radius = radius;\n                mask_draw_dsc.area = obj->coords;\n                lv_draw_image_dsc_t img_draw_dsc;\n                lv_draw_image_dsc_init(&img_draw_dsc);\n                int32_t short_side = LV_MIN(lv_area_get_width(&obj->coords), lv_area_get_height(&obj->coords));\n                int32_t rout = LV_MIN(radius, short_side >> 1);\n                lv_area_t bottom = obj->coords;\n                bottom.y1 = bottom.y2 - rout + 1;\n                if(_lv_area_intersect(&bottom, &bottom, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &bottom);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &bottom);\n                }\n                lv_area_t top = obj->coords;\n                top.y2 = top.y1 + rout - 1;\n                if(_lv_area_intersect(&top, &top, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &top);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &top);\n                }\n                lv_area_t mid = obj->coords;\n                mid.y1 += rout;\n                mid.y2 -= rout;\n                if(_lv_area_intersect(&mid, &mid, &clip_area_ori)) {\n                    layer->_clip_area = mid;\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n                }\n            }\n        }\n    }\n    layer->_clip_area = clip_area_ori;\n}\nvoid refr_obj(lv_layer_t * layer, lv_obj_t * obj)\n{\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;\n    lv_layer_type_t layer_type = _lv_obj_get_layer_type(obj);\n    if(layer_type == LV_LAYER_TYPE_NONE) {\n        lv_obj_redraw(layer, obj);\n    }\n    else {\n        lv_opa_t opa = lv_obj_get_style_opa_layered(obj, 0);\n        if(opa < LV_OPA_MIN) return;\n        lv_area_t layer_area_full;\n        lv_area_t obj_draw_size;\n        lv_result_t res = layer_get_area(layer, obj, layer_type, &layer_area_full, &obj_draw_size);\n        if(res != LV_RESULT_OK) return;\n        uint32_t max_rgb_row_height = lv_area_get_height(&layer_area_full);\n        uint32_t max_argb_row_height = lv_area_get_height(&layer_area_full);\n        if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n            int32_t w = lv_area_get_width(&layer_area_full);\n            uint8_t px_size = lv_color_format_get_size(disp_refr->color_format);\n            max_rgb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / px_size;\n            max_argb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / sizeof(lv_color32_t);\n        }\n        lv_area_t layer_area_act;\n        layer_area_act.x1 = layer_area_full.x1;\n        layer_area_act.x2 = layer_area_full.x2;\n        layer_area_act.y1 = layer_area_full.y1;\n        layer_area_act.y2 = layer_area_full.y1;\n        while(layer_area_act.y2 < layer_area_full.y2) {\n            layer_area_act.y2 = layer_area_act.y1 + max_rgb_row_height - 1;\n            if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            bool area_need_alpha = alpha_test_area_on_obj(obj, &layer_area_act);\n            if(area_need_alpha) {\n                layer_area_act.y2 = layer_area_act.y1 + max_argb_row_height - 1;\n                if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            }\n            lv_layer_t * new_layer = lv_draw_layer_create(layer,\n                                                          area_need_alpha ? LV_COLOR_FORMAT_ARGB8888 : LV_COLOR_FORMAT_NATIVE, &layer_area_act);\n            lv_obj_redraw(new_layer, obj);\n            lv_draw_image_dsc_t layer_draw_dsc;\n            lv_draw_image_dsc_init(&layer_draw_dsc);\n            layer_draw_dsc.pivot.x = obj->coords.x1 + lv_obj_get_style_transform_pivot_x(obj, 0) - new_layer->buf_area.x1;\n            layer_draw_dsc.pivot.y = obj->coords.y1 + lv_obj_get_style_transform_pivot_y(obj, 0) - new_layer->buf_area.y1;\n            layer_draw_dsc.opa = opa;\n            layer_draw_dsc.rotation = lv_obj_get_style_transform_rotation(obj, 0);\n            while(layer_draw_dsc.rotation > 3600) layer_draw_dsc.rotation -= 3600;\n            while(layer_draw_dsc.rotation < 0) layer_draw_dsc.rotation += 3600;\n            layer_draw_dsc.scale_x = lv_obj_get_style_transform_scale_x(obj, 0);\n            layer_draw_dsc.scale_y = lv_obj_get_style_transform_scale_y(obj, 0);\n            layer_draw_dsc.skew_x = lv_obj_get_style_transform_skew_x(obj, 0);\n            layer_draw_dsc.skew_y = lv_obj_get_style_transform_skew_y(obj, 0);\n            layer_draw_dsc.blend_mode = lv_obj_get_style_blend_mode(obj, 0);\n            layer_draw_dsc.antialias = disp_refr->antialiasing;\n            layer_draw_dsc.bitmap_mask_src = lv_obj_get_style_bitmap_mask_src(obj, 0);\n            layer_draw_dsc.original_area = obj_draw_size;\n            layer_draw_dsc.src = new_layer;\n            lv_draw_layer(layer, &layer_draw_dsc, &layer_area_act);\n            layer_area_act.y1 = layer_area_act.y2 + 1;\n        }\n    }\n}\n//...'"
"('Prompt: You are working on a software testing program that needs to display the results of each autotest script within a package in a formatted way. Write a function that takes in a package struct and prints out the results of each autotest script within that package, including the test ID, execution time, pass/fail status, number of passed checks, total number of checks, percentage passed, and the name of the script. Ensure the output is clearly structured and easy to read for the user.","//...\ntypedef struct {\n    unsigned int id;            \n    unsigned int index;         \n    unsigned int num_scripts;   \n    const char* name;           \n    int executed;               \n} package_t;\nvoid print_autotest_results(autotest_t * _test)\n{\n    printf(""  %4u"", _test->id);\n    if (!_test->executed) {\n        printf(""[     -     ] IGNORED  "");\n    } else {\n        printf(""[%8.2f ms] %8s "", _test->extime*1e3f, _test->pass ? ""  PASS  "" : ""<<FAIL>>"");\n    }\n    printf(""passed %4lu/%4lu checks (%5.1f%%) %s\\n"",\n            _test->num_passed,\n            _test->num_checks,\n            _test->percent_passed,\n            _test->name);\n}\nvoid print_package_results(package_t * _p)\n{\n    unsigned int i;\n    printf(""%u: %s:\\n"", _p->id, _p->name);\n    for (i=_p->index; i<(_p->index+_p->num_scripts); i++) {\n        print_autotest_results( &scripts[i] );\n    }\n    printf(""\\n"");\n}\n//...')
"
"(""Prompt: In a 1-dimensional quadratic search algorithm implementation, create a function that retrieves the optimal value of parameter 'u' stored within the 'qs1dsearch' data structure.","//...\nfloat qs1dsearch_get_opt_u(qs1dsearch _q)\n{\n    return _q->u0;\n}\n//...')
"
"('Prompt: ""I need a function that implements a benchmark for acquiring and synchronizing OFDM frames with a frame length of 128. The function should be called benchmark_ofdmframesync_acquire_n128 and should be designed to test the performance of the synchronization process for OFDM frames of length 128. Can you provide me with the code for this function?""","//...\nvoid benchmark_ofdmframesync_acquire_n128   O\n//...')
"
"('Please provide a prompt where you need a code snippet for creating a deep copy function for a struct named `firdespm_s` in C programming. This struct contains multiple fields, including arrays of doubles, unsigned integers, and pointers to other memory areas. The deep copy function should correctly allocate memory for each array/pointer field and copy the values from the original struct to the new struct to avoid shallow copying issues.","//...\nstruct firdespm_s {\n    unsigned int h_len;         \n    unsigned int s;             \n    unsigned int n;             \n    unsigned int r;             \n    unsigned int num_bands;     \n    unsigned int grid_size;     \n    unsigned int grid_density;  \n    liquid_firdespm_btype btype;\n    double * bands;             \n    double * des;               \n    double * weights;           \n    liquid_firdespm_wtype * wtype;\n    double * F;                 \n    double * D;                 \n    double * W;                 \n    double * E;                 \n    double * x;                 \n    double * alpha;             \n    double * c;                 \n    double rho;                 \n    unsigned int * iext;        \n    unsigned int num_exchanges; \n    firdespm_callback callback; \n    void *            userdata; \n#if LIQUID_FIRDESPM_DEBUG\n    FILE * fid;\n#endif\n};\n    for (i=0; i<_q->grid_size; i++) {\n    for (i=0; i<_q->grid_size; i++) {\n    for (i=0; i<_q->r+1; i++) {\n        fprintf(fid,""iext(%4u) = %u;\\n"", i+1, _q->iext[i]+1);\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""grid on;\\n"");\n        double f = (double) i / (double)(2*(n-1));\n        double x = cos(2*M_PI*f);\n        double c = poly_val_lagrange_barycentric(_q->x,_q->c,_q->alpha,x,_q->r+1);\n    unsigned int num_bands = 2;\n    float bands[4]   = {0.0f, f0, f1, 0.5f};\n    float des[2]     = {1.0f, 0.0f};\n    float weights[2] = {1.0f, 1.0f}; \n#define LIQUID_FIRDESPM_DEBUG       0\n    for (i=0; i<_m; i++) {\nfirdespm firdespm_copy(firdespm q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""firdespm_copy(), object cannot be NULL"");\n    firdespm q_copy = (firdespm) malloc(sizeof(struct firdespm_s));\n    memmove(q_copy, q_orig, sizeof(struct firdespm_s));\n    q_copy->bands   = (double*)liquid_malloc_copy(q_orig->bands, 2*q_orig->num_bands, sizeof(double));\n    q_copy->des     = (double*)liquid_malloc_copy(q_orig->des,     q_orig->num_bands, sizeof(double));\n    q_copy->weights = (double*)liquid_malloc_copy(q_orig->weights, q_orig->num_bands, sizeof(double));\n    q_copy->wtype   = (liquid_firdespm_wtype*) liquid_malloc_copy(q_orig->wtype, q_orig->num_bands, sizeof(liquid_firdespm_wtype));\n    q_copy->F = (double*) liquid_malloc_copy(q_copy->F, q_orig->grid_size, sizeof(double));\n    q_copy->D = (double*) liquid_malloc_copy(q_copy->D, q_orig->grid_size, sizeof(double));\n    q_copy->W = (double*) liquid_malloc_copy(q_copy->W, q_orig->grid_size, sizeof(double));\n    q_copy->E = (double*) liquid_malloc_copy(q_copy->E, q_orig->grid_size, sizeof(double));\n    q_copy->iext  = (unsigned int*) liquid_malloc_copy(q_copy->iext, q_orig->r+1,sizeof(unsigned int));\n    q_copy->x     = (double*)       liquid_malloc_copy(q_copy->x,    q_orig->r+1,sizeof(double));\n    q_copy->alpha = (double*)       liquid_malloc_copy(q_copy->alpha,q_orig->r+1,sizeof(double));\n    q_copy->c     = (double*)       liquid_malloc_copy(q_copy->c,    q_orig->r+1,sizeof(double));\n    return q_copy;\n}\n//...')
"
"'Prompt: You are working on a platform driver for a semiconductor IP block that manages shared resources using semaphores. The driver needs to provide functions for initializing, deinitializing, locking, and unlocking semaphore gates. Additionally, there is a need to reset a specific semaphore gate with a specific pattern. Can you provide the necessary C code to implement these functionalities?","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.rdc_sema42""\n#endif\n#define RDC_SEMA42_GATE_RESET_PATTERN_1 (0xE2U)\n#define RDC_SEMA42_GATE_RESET_PATTERN_2 (0x1DU)\n#if !defined(RDC_SEMAPHORE_GATE_COUNT)\n#define RDC_SEMAPHORE_GATE_LDOM(x)    RDC_SEMAPHORE_GATE0_LDOM(x)\n#define RDC_SEMAPHORE_GATE_GTFSM(x)   RDC_SEMAPHORE_GATE0_GTFSM(x)\n#define RDC_SEMAPHORE_GATE_LDOM_MASK  RDC_SEMAPHORE_GATE0_LDOM_MASK\n#define RDC_SEMAPHORE_GATE_LDOM_SHIFT RDC_SEMAPHORE_GATE0_LDOM_SHIFT\n#endif\nuint32_t RDC_SEMA42_GetInstance(RDC_SEMAPHORE_Type *base);\nstatic RDC_SEMAPHORE_Type *const s_sema42Bases[] = RDC_SEMAPHORE_BASE_PTRS;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n#if defined(RDC_SEMA42_CLOCKS)\nstatic const clock_ip_name_t s_sema42Clocks[] = RDC_SEMA42_CLOCKS;\n#endif\n#endif \nuint32_t RDC_SEMA42_GetInstance(RDC_SEMAPHORE_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_sema42Bases); instance++)\n    {\n        if (s_sema42Bases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_sema42Bases));\n    return instance;\n}\nvoid RDC_SEMA42_Init(RDC_SEMAPHORE_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n#if defined(RDC_SEMA42_CLOCKS)\n    CLOCK_EnableClock(s_sema42Clocks[RDC_SEMA42_GetInstance(base)]);\n#endif\n#endif \n}\nvoid RDC_SEMA42_Deinit(RDC_SEMAPHORE_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n#if defined(RDC_SEMA42_CLOCKS)\n    CLOCK_DisableClock(s_sema42Clocks[RDC_SEMA42_GetInstance(base)]);\n#endif\n#endif \n}\nstatus_t RDC_SEMA42_TryLock(RDC_SEMAPHORE_Type *base, uint8_t gateNum, uint8_t masterIndex, uint8_t domainId)\n{\n    assert(gateNum < RDC_SEMA42_GATE_COUNT);\n    status_t status = kStatus_Success;\n    uint8_t regGate;\n    ++masterIndex;\n    regGate = (uint8_t)(RDC_SEMAPHORE_GATE_LDOM(domainId) | RDC_SEMAPHORE_GATE_GTFSM(masterIndex));\n    RDC_SEMA42_GATEn(base, gateNum) = masterIndex;\n    if (regGate != RDC_SEMA42_GATEn(base, gateNum))\n    {\n        status = kStatus_Fail;\n    }\n    return status;\n}\nvoid RDC_SEMA42_Lock(RDC_SEMAPHORE_Type *base, uint8_t gateNum, uint8_t masterIndex, uint8_t domainId)\n{\n    while (kStatus_Success != RDC_SEMA42_TryLock(base, gateNum, masterIndex, domainId))\n    {\n    }\n}\nint32_t RDC_SEMA42_GetLockDomainID(RDC_SEMAPHORE_Type *base, uint8_t gateNum)\n{\n    assert(gateNum < RDC_SEMA42_GATE_COUNT);\n    int32_t ret;\n    uint8_t regGate = RDC_SEMA42_GATEn(base, gateNum);\n    if (0U == (regGate & RDC_SEMAPHORE_GATE_GTFSM_MASK))\n    {\n        ret = -1;\n    }\n    else\n    {\n        ret = (int32_t)((uint8_t)((regGate & RDC_SEMAPHORE_GATE_LDOM_MASK) >> RDC_SEMAPHORE_GATE_LDOM_SHIFT));\n    }\n    return ret;\n}\nstatus_t RDC_SEMA42_ResetGate(RDC_SEMAPHORE_Type *base, uint8_t gateNum)\n{\n    status_t status;\n    if (0U != (base->RSTGT_R & RDC_SEMAPHORE_RSTGT_R_RSTGSM_MASK))\n    {\n        status = kStatus_Fail;\n    }\n    else\n    {\n        base->RSTGT_W = RDC_SEMAPHORE_RSTGT_W_RSTGDP(RDC_SEMA42_GATE_RESET_PATTERN_1);\n        base->RSTGT_W =\n            RDC_SEMAPHORE_RSTGT_W_RSTGDP(RDC_SEMA42_GATE_RESET_PATTERN_2) | RDC_SEMAPHORE_RSTGT_W_RSTGTN(gateNum);\n        status = kStatus_Success;\n    }\n    return status;\n}'"
"('Prompt: I need you to provide a function that conducts an automated test to verify whether the `randexpf()` function correctly generates exponential random variables. The function should repeatedly generate random variables using `randexpf()` based on a specified lambda value of 2.3, and then calculate the first and second moments of the generated random numbers. Finally, the function should compare these moments against the expected values based on the theoretical properties of exponential distributions. Ensure that the test validates if the `randexpf()` function behaves within a certain tolerance level.","//...\nvoid autotest_randexpf()\n{\n    unsigned long int N = LIQUID_RANDOM_AUTOTEST_NUM_TRIALS;\n    unsigned long int i;\n    float x, m1=0.0f, m2=0.0f;\n    float tol = LIQUID_RANDOM_AUTOTEST_ERROR_TOL;\n    float lambda = 2.3f;\n    for (i=0; i<N; i++) {\n        x = randexpf(lambda);\n        m1 += x;\n        m2 += x*x;\n    }\n    m1 /= (float) N;\n    m2 = (m2 / (float)N) - m1*m1;\n    float m1_exp = 1. / lambda;\n    float m2_exp = 1. / (lambda * lambda);\n    CONTEND_DELTA(m1, m1_exp, tol);\n    CONTEND_DELTA(m2, m2_exp, tol);\n}\n//...')
"
"('Prompt: You are tasked with implementing a testbench function for a numerically-controlled oscillator (NCO) using cyclic redundancy check (CRCF) with mixing functionality. This testbench function should create an NCO with a specified type, phase, and frequency, generate two buffers of complex values, perform mixing up on the buffers using the NCO, and then verify the mixing operation by comparing the output buffer elements with the expected values. Finally, ensure proper cleanup by destroying the NCO instance. Additionally, include an autotest function to test the mixing functionality of the NCO with specific parameters. You should also handle phase wrapping within the [-, ] range during the mixing process.","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_nco_4() { testbench_nco_crcf_mix(LIQUID_NCO,    M_PI,  0.000f); }\n//...')
"
"('Prompt: Can you provide a code snippet that shows how to create a usage function for a C program that prints out usage information for the command line options available? In this scenario, the program is called ""firfilt_cccf_example"" and the usage function should include options for displaying help, setting the sequence length (default value of 32), and setting the signal-to-noise ratio (default value of 20 dB).","//...\nvoid usage()\n{\n    printf(""firfilt_cccf_example:\\n"");\n    printf(""  h     : print usage/help\\n"");\n    printf(""  n     : sequence length, default: 32\\n"");\n    printf(""  s     : SNR, signal-to-noise ratio [dB], default: 20\\n"");\n}\n//...')
"
"('Prompt: Your task is to implement a function that tests the demodulation statistics of a modem using a specific modulation scheme. The function should create a modem object, modulate a signal, demodulate it, and verify the demodulated symbol matches the original symbol. Additionally, the function should check the demodulator phase error and ensure it meets certain conditions. Finally, the function should destroy the modem objects. Given the modulation scheme LIQUID_MODEM_SQAM128, can you provide the code for this test function?","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_sqam128()  { modemcf_test_demodstats(LIQUID_MODEM_SQAM128);  }\n//...')
"
"('Prompt: . You are working on an OFDM frame synchronization algorithm in a software-defined radio (SDR) application. You need to implement the functions for executing different states of the OFDM frame synchronization process. Can you provide me with the code for executing the S0a state, S0b state, and receiving symbols in the RXSYMBOLS state of the OFDM frame synchronization?. . Response: . Sure, here is the code for executing the S0a state, S0b state, and receiving symbols in the RXSYMBOLS state of the OFDM frame synchronization:. . ```c. int ofdmframesync_execute_S0a(ofdmframesync _q). {.     _q->timer++;.     if (_q->timer < _q->M2).         return LIQUID_OK;.     _q->timer = 0;.     float complex * rc;.     windowcf_read(_q->input_buffer, &rc);.     ofdmframesync_estimate_gain_S","//...\n    unsigned int M;         \n    unsigned int M2;        \n    unsigned int cp_len;    \n    unsigned char * p;      \n    float complex * x;      \n    windowcf input_buffer;  \n    unsigned int M_S0;      \n    float complex * s0;     \n    float g0;               \n    float complex * G0a;    \n    float complex * G0b;    \n    float complex * G;      \n    float complex * B;      \n    float complex * R;      \n    nco_crcf nco_rx;        \n#define DEBUG_OFDMFRAMESYNC             0\n    unsigned int backoff;       \n    float complex s_hat_0;      \n    float complex s_hat_1;      \n    for (i=0; i<_q->M; i++)\n        _q->x[i] = (i < _ntaps) ? 1.0f : 0.0f;\n        float complex w;\n        for (j=0; j<_q->M; j++) {\n    return LIQUID_OK;\nint ofdmframesync_execute_S1(ofdmframesync _q)\n{\n    _q->timer--;\n    if (_q->timer > 0)\n        return LIQUID_OK;\n    _q->num_symbols++;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S1(_q, &rc[_q->cp_len], _q->G);\n    float complex g_hat = 0.0f;\n    unsigned int i;\n    for (i=0; i<_q->M; i++) {\n        g_hat += _q->G[(i+1)%_q->M]*conjf(_q->G[i]);\n    }\n    g_hat /= _q->M_S1; \n    g_hat *= _q->g0;\n    g_hat *= liquid_cexpjf((float)(_q->backoff)*2.0f*M_PI/(float)(_q->M));\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf(""    g_hat   :   %12.4f <%12.8f>\\n"", cabsf(g_hat), cargf(g_hat));\n#endif\n    if (cabsf(g_hat) > _q->plcp_sync_thresh && fabsf(cargf(g_hat)) < 0.1f*M_PI ) {\n        _q->state = OFDMFRAMESYNC_STATE_RXSYMBOLS;\n        _q->timer = _q->M + _q->cp_len + _q->backoff;\n        _q->num_symbols = 0;\n        float g = (float)(_q->M) / sqrtf(_q->M_pilot + _q->M_data);\n        for (i=0; i<_q->M; i++) {\n            _q->G[i] *= g;          \n            _q->G[i] *= _q->B[i];   \n        }\n#if 0\n        unsigned int ntaps = (_q->M < 8) ? 2 : 8;\n        ofdmframesync_estimate_eqgain(_q, ntaps);\n#else\n        unsigned int poly_order = 4;\n        if (poly_order >= _q->M_pilot + _q->M_data)\n            poly_order = _q->M_pilot + _q->M_data - 1;\n        ofdmframesync_estimate_eqgain_poly(_q, poly_order);\n#endif\n#if 1\n        unsigned int i;\n        for (i=0; i<_q->M; i++)\n            _q->R[i] = _q->B[i] / _q->G[i];\n#endif\n        return LIQUID_OK;\n    }\n    if (_q->num_symbols == 16) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""could not find S1 symbol. bailing...\\n"");\n#endif\n        ofdmframesync_reset(_q);\n    }\n    _q->timer = _q->M2;\n    return LIQUID_OK;\n}\nint ofdmframesync_rxsymbol(ofdmframesync _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        _q->X[i] *= _q->R[i];\n    float x_phase[_q->M_pilot];\n    float y_phase[_q->M_pilot];\n    float p_phase[2];\n    unsigned int n=0;\n    unsigned int k;\n    float complex pilot = 1.0f;\n    for (i=0; i<_q->M; i++) {\n        k = (i + _q->M2) % _q->M;\n        if (_q->p[k]==OFDMFRAME_SCTYPE_PILOT) {\n            if (n == _q->M_pilot)\n                return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n            pilot = (msequence_advance(_q->ms_pilot) ? 1.0f : -1.0f);\n#if 0\n            printf(""pilot[%3u] = %12.4e + j*%12.4e (expected %12.4e + j*%12.4e)\\n"",\n                    k,\n                    crealf(_q->X[k]), cimagf(_q->X[k]),\n                    crealf(pilot),    cimagf(pilot));\n#endif\n            x_phase[n] = (k > _q->M2) ? (float)k - (float)(_q->M) : (float)k;\n            y_phase[n] = cargf(_q->X[k]*conjf(pilot));\n            n++;\n        }\n    }\n    if (n != _q->M_pilot)\n        return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n    liquid_unwrap_phase(y_phase, _q->M_pilot);\n    polyf_fit(x_phase, y_phase, _q->M_pilot, p_phase, 2);\n    float alpha = 0.3f;\n    p_phase[1] = alpha*p_phase[1] + (1-alpha)*_q->p1_prime;\n    _q->p1_prime = p_phase[1];\n#if DEBUG_OFDMFRAMESYNC\n    if (_q->debug_enabled) {\n        memmove(_q->px, x_phase, _q->M_pilot*sizeof(float));\n        memmove(_q->py, y_phase, _q->M_pilot*sizeof(float));\n        _q->p_phase[0] = p_phase[1];\n        _q->p_phase[1] = p_phase[0];\n        windowf_push(_q->debug_pilot_0, p_phase[0]);\n        windowf_push(_q->debug_pilot_1, p_phase[1]);\n    }\n#endif\n    for (i=0; i<_q->M; i++) {\n        if (_q->p[i] == OFDMFRAME_SCTYPE_NULL) {\n            _q->X[i] = 0.0f;\n        } else {\n            float fx    = (i > _q->M2) ? (float)i - (float)(_q->M) : (float)i;\n            float theta = polyf_val(p_phase, 2, fx);\n            _q->X[i] *= liquid_cexpjf(-theta);\n        }\n    }\n    if (_q->num_symbols > 0) {\n        float dphi_prime = p_phase[0] - _q->phi_prime;\n        while (dphi_prime >  M_PI) dphi_prime -= M_2_PI;\n        while (dphi_prime < -M_PI) dphi_prime += M_2_PI;\n        nco_crcf_adjust_frequency(_q->nco_rx, 1e-3f*dphi_prime);\n    }\n    _q->phi_prime = p_phase[0];\n    _q->num_symbols++;\n#if 0\n    for (i=0; i<_q->M_pilot; i++)\n        printf(""x_phase(%3u) = %12.8f; y_phase(%3u) = %12.8f;\\n"", i+1, x_phase[i], i+1, y_phase[i]);\n    printf(""poly : p0=%12.8f, p1=%12.8f\\n"", p_phase[0], p_phase[1]);\n#endif\n    return LIQUID_OK;\n}\nint ofdmframesync_S0_metrics(ofdmframesync   _q,\n                             float complex * _G,\n                             float complex * _s_hat)\n{\n    unsigned int i;\n    float complex s_hat = 0.0f;\n    for (i=0; i<_q->M; i+=2) {\n        s_hat += _G[(i+2)%_q->M]*conjf(_G[i]);\n    }\n    s_hat /= _q->M_S0; \n    *_s_hat = s_hat;\n    return LIQUID_OK;\n}\nint ofdmframesync_estimate_gain_S0(ofdmframesync   _q,\n                                   float complex * _x,\n                                   float complex * _G)\n{\n    memmove(_q->x, _x, (_q->M)*sizeof(float complex));\n    FFT_EXECUTE(_q->fft);\n    unsigned int i;\n    float gain = sqrtf(_q->M_S0) / (float)(_q->M);\n    for (i=0; i<_q->M; i++) {\n        if (_q->p[i] != OFDMFRAME_SCTYPE_NULL && (i%2)==0) {\n            _G[i] = _q->X[i] * conjf(_q->S0[i]);\n        } else {\n            _G[i] = 0.0f;\n        }\n        _G[i] *= gain;\n    }\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_S0b(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M2)\n        return LIQUID_OK;\n    _q->timer = _q->M + _q->cp_len - _q->backoff;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0b);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0b, &s_hat);\n    s_hat *= _q->g0;\n    _q->s_hat_1 = s_hat;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n    printf(""********** S0[1] received ************\\n"");\n    printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n    printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n    tau_hat  = cargf(_q->s_hat_0 + _q->s_hat_1) * (float)(_q->M2) / (2*M_PI);\n    printf(""  tau_hat * :   %12.8f\\n"", tau_hat);\n    printf(""**********\\n"");\n#endif\n    float tau_prime = cargf(_q->s_hat_0 + _q->s_hat_1) * (float)(_q->M2) / (2*M_PI);\n    _q->timer -= (int)roundf(tau_prime);\n#if 0\n    if (cabsf(s_hat) < 0.3f) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""false alarm S0[1]\\n"");\n#endif\n        ofdmframesync_reset(_q);\n        return;\n    }\n#endif\n    unsigned int i;\n#if 0\n    float complex g_hat = 0.0f;\n    for (i=0; i<_q->M; i++)\n        g_hat += _q->G0b[i] * conjf(_q->G0a[i]);\n    float nu_hat = 2.0f * cargf(g_hat) / (float)(_q->M);\n#else\n    float complex t0 = 0.0f;\n    for (i=0; i<_q->M2; i++) {\n        t0 += conjf(rc[i])       *       _q->s0[i] * \n                    rc[i+_q->M2] * conjf(_q->s0[i+_q->M2]);\n    }\n    float nu_hat = cargf(t0) / (float)(_q->M2);\n#endif\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf(""   nu_hat   :   %12.8f\\n"", nu_hat);\n#endif\n    nco_crcf_set_frequency(_q->nco_rx, nu_hat);\n    _q->state = OFDMFRAMESYNC_STATE_PLCPLONG;\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_seekplcp(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M)\n        return LIQUID_OK;\n    _q->timer = 0;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    unsigned int i;\n    float g = 1.0e-9f;\n    for (i=_q->cp_len; i<_q->M + _q->cp_len; i++) {\n        g += crealf(rc[i])*crealf(rc[i]) + cimagf(rc[i])*cimagf(rc[i]);\n    }\n    g = (float)(_q->M) / g;\n#if OFDMFRAMESYNC_ENABLE_SQUELCH\n    if ( -10*log10f( sqrtf(g) ) < _q->squelch_threshold &&\n         _q->squelch_enabled)\n    {\n        printf(""squelch\\n"");\n        return LIQUID_OK;\n    }\n#endif\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);\n    s_hat *= g;\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf("" - gain=%12.3f, rssi=%12.8f, s_hat=%12.4f <%12.8f>, tau_hat=%8.3f\\n"",\n            sqrt(g),\n            -10*log10(g),\n            cabsf(s_hat), cargf(s_hat),\n            tau_hat);\n#endif\n    _q->g0 = g;\n    if (cabsf(s_hat) > _q->plcp_detect_thresh) {\n        int dt = (int)roundf(tau_hat);\n        _q->timer = (_q->M + dt) % (_q->M2);\n        _q->timer += _q->M; \n        _q->state = OFDMFRAMESYNC_STATE_PLCPSHORT0;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""********** frame detected! ************\\n"");\n        printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n        printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n        printf(""    dt      :   %12d\\n"", dt);\n        printf(""    timer   :   %12u\\n"", _q->timer);\n#endif\n    }\n    return LIQUID_OK;\n}\nint ofdmframesync_estimate_eqgain_poly(ofdmframesync _q,\n                                       unsigned int _order)\n{\n#if DEBUG_OFDMFRAMESYNC\n    if (_q->debug_enabled) {\n        memmove(_q->G_hat, _q->G, _q->M*sizeof(float complex));\n    }\n#endif\n    unsigned int i;\n    unsigned int N = _q->M_pilot + _q->M_data;\n    if (_order > N-1) _order = N-1;\n    if (_order > 10)  _order = 10;\n    float x_freq[N];\n    float y_abs[N];\n    float y_arg[N];\n    float p_abs[_order+1];\n    float p_arg[_order+1];\n    unsigned int n=0;\n    unsigned int k;\n    for (i=0; i<_q->M; i++) {\n        k = (i + _q->M2) % _q->M;\n        if (_q->p[k] != OFDMFRAME_SCTYPE_NULL) {\n            if (n == N)\n                return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n            x_freq[n] = (k > _q->M2) ? (float)k - (float)(_q->M) : (float)k;\n            x_freq[n] = x_freq[n] / (float)(_q->M);\n            y_abs[n] = cabsf(_q->G[k]);\n            y_arg[n] = cargf(_q->G[k]);\n            n++;\n        }\n    }\n    if (n != N)\n        return liquid_error(LIQUID_EINT,""ofdmframesync_estimate_eqgain_poly(), pilot subcarrier mismatch"");\n    liquid_unwrap_phase(y_arg, N);\n    polyf_fit(x_freq, y_abs, N, p_abs, _order+1);\n    polyf_fit(x_freq, y_arg, N, p_arg, _order+1);\n    for (i=0; i<_q->M; i++) {\n        float freq = (i > _q->M2) ? (float)i - (float)(_q->M) : (float)i;\n        freq = freq / (float)(_q->M);\n        float A     = polyf_val(p_abs, _order+1, freq);\n        float theta = polyf_val(p_arg, _order+1, freq);\n        _q->G[i] = (_q->p[i] == OFDMFRAME_SCTYPE_NULL) ? 0.0f : A * liquid_cexpjf(theta);\n    }\n#if 0\n    for (i=0; i<N; i++)\n        printf(""x(%3u) = %12.8f; y_abs(%3u) = %12.8f; y_arg(%3u) = %12.8f;\\n"",\n                i+1, x_freq[i],\n                i+1, y_abs[i],\n                i+1, y_arg[i]);\n    for (i=0; i<=_order; i++)\n        printf(""p_abs(%3u) = %12.8f;\\n"", i+1, p_abs[i]);\n    for (i=0; i<=_order; i++)\n        printf(""p_arg(%3u) = %12.8f;\\n"", i+1, p_arg[i]);\n#endif\n    return LIQUID_OK;\n}\nint ofdmframesync_estimate_gain_S1(ofdmframesync _q,\n                                   float complex * _x,\n                                   float complex * _G)\n{\n    memmove(_q->x, _x, (_q->M)*sizeof(float complex));\n    FFT_EXECUTE(_q->fft);\n    unsigned int i;\n    float gain = sqrtf(_q->M_S1) / (float)(_q->M);\n    for (i=0; i<_q->M; i++) {\n        if (_q->p[i] != OFDMFRAME_SCTYPE_NULL) {\n            _G[i] = _q->X[i] * conjf(_q->S1[i]);\n        } else {\n            _G[i] = 0.0f;\n        }\n        _G[i] *= gain;\n    }   \n    return LIQUID_OK;\n}\nint ofdmframesync_reset(ofdmframesync _q)\n{\n#if 0\n    unsigned int i;\n    for (i=0; i<_q->M; i++)\n        _q->G[i] = 1.0f;\n#endif\n    nco_crcf_reset(_q->nco_rx);\n    msequence_reset(_q->ms_pilot);\n    _q->timer = 0;\n    _q->num_symbols = 0;\n    _q->s_hat_0 = 0.0f;\n    _q->s_hat_1 = 0.0f;\n    _q->phi_prime = 0.0f;\n    _q->p1_prime = 0.0f;\n    _q->plcp_detect_thresh = (_q->M > 44) ? 0.35f : 0.35f + 0.01f*(44 - _q->M);\n    _q->plcp_sync_thresh   = (_q->M > 44) ? 0.30f : 0.30f + 0.01f*(44 - _q->M);\n    _q->state = OFDMFRAMESYNC_STATE_SEEKPLCP;\n    return LIQUID_OK;\n}\nint ofdmframesync_execute(ofdmframesync   _q,\n                          float complex * _x,\n                          unsigned int    _n)\n{\n    unsigned int i;\n    float complex x;\n    for (i=0; i<_n; i++) {\n        x = _x[i];\n        if (_q->state != OFDMFRAMESYNC_STATE_SEEKPLCP) {\n            nco_crcf_mix_down(_q->nco_rx, x, &x);\n            nco_crcf_step(_q->nco_rx);\n        }\n        windowcf_push(_q->input_buffer,x);\n#if DEBUG_OFDMFRAMESYNC\n        if (_q->debug_enabled) {\n            windowcf_push(_q->debug_x, x);\n            windowf_push(_q->debug_rssi, crealf(x)*crealf(x) + cimagf(x)*cimagf(x));\n        }\n#endif\n        switch (_q->state) {\n        case OFDMFRAMESYNC_STATE_SEEKPLCP:\n            ofdmframesync_execute_seekplcp(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_PLCPSHORT0:\n            ofdmframesync_execute_S0a(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_PLCPSHORT1:\n            ofdmframesync_execute_S0b(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_PLCPLONG:\n            ofdmframesync_execute_S1(_q);\n            break;\n        case OFDMFRAMESYNC_STATE_RXSYMBOLS:\n            ofdmframesync_execute_rxsymbols(_q);\n            break;\n        default:;\n        }\n    } \n    return LIQUID_OK;\n}\nint ofdmframesync_execute_S0a(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M2)\n        return LIQUID_OK;\n    _q->timer = 0;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);\n    s_hat *= _q->g0;\n    _q->s_hat_0 = s_hat;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n    printf(""********** S0[0] received ************\\n"");\n    printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n    printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n#endif\n#if 0\n    if (cabsf(s_hat) < 0.3f) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""false alarm S0[0]\\n"");\n#endif\n        ofdmframesync_reset(_q);\n        return;\n    }\n#endif\n    _q->state = OFDMFRAMESYNC_STATE_PLCPSHORT1;\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_rxsymbols(ofdmframesync _q)\n{\n    _q->timer--;\n    if (_q->timer == 0) {\n        float complex * rc;\n        windowcf_read(_q->input_buffer, &rc);\n        memmove(_q->x, &rc[_q->cp_len-_q->backoff], (_q->M)*sizeof(float complex));\n        FFT_EXECUTE(_q->fft);\n        ofdmframesync_rxsymbol(_q);\n#if DEBUG_OFDMFRAMESYNC\n        if (_q->debug_enabled) {\n            unsigned int i;\n            for (i=0; i<_q->M; i++) {\n                if (_q->p[i] == OFDMFRAME_SCTYPE_DATA)\n                    windowcf_push(_q->debug_framesyms, _q->X[i]);\n            }\n        }\n#endif\n        if (_q->callback != NULL) {\n            int retval = _q->callback(_q->X, _q->p, _q->M, _q->userdata);\n            if (retval != 0)\n                ofdmframesync_reset(_q);\n        }\n        _q->timer = _q->M + _q->cp_len;\n    }\n    return LIQUID_OK;\n}\nint ofdmframesync_execute_S0b(ofdmframesync _q)\n{\n    _q->timer++;\n    if (_q->timer < _q->M2)\n        return LIQUID_OK;\n    _q->timer = _q->M + _q->cp_len - _q->backoff;\n    float complex * rc;\n    windowcf_read(_q->input_buffer, &rc);\n    ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0b);\n    float complex s_hat;\n    ofdmframesync_S0_metrics(_q, _q->G0b, &s_hat);\n    s_hat *= _q->g0;\n    _q->s_hat_1 = s_hat;\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    float tau_hat  = cargf(s_hat) * (float)(_q->M2) / (2*M_PI);\n    printf(""********** S0[1] received ************\\n"");\n    printf(""    s_hat   :   %12.8f <%12.8f>\\n"", cabsf(s_hat), cargf(s_hat));\n    printf(""  tau_hat   :   %12.8f\\n"", tau_hat);\n    tau_hat  = cargf(_q->s_hat_0 + _q->s_hat_1) * (float)(_q->M2) / (2*M_PI);\n    printf(""  tau_hat * :   %12.8f\\n"", tau_hat);\n    printf(""**********\\n"");\n#endif\n    float tau_prime = cargf(_q->s_hat_0 + _q->s_hat_1) * (float)(_q->M2) / (2*M_PI);\n    _q->timer -= (int)roundf(tau_prime);\n#if 0\n    if (cabsf(s_hat) < 0.3f) {\n#if DEBUG_OFDMFRAMESYNC_PRINT\n        printf(""false alarm S0[1]\\n"");\n#endif\n        ofdmframesync_reset(_q);\n        return;\n    }\n#endif\n    unsigned int i;\n#if 0\n    float complex g_hat = 0.0f;\n    for (i=0; i<_q->M; i++)\n        g_hat += _q->G0b[i] * conjf(_q->G0a[i]);\n    float nu_hat = 2.0f * cargf(g_hat) / (float)(_q->M);\n#else\n    float complex t0 = 0.0f;\n    for (i=0; i<_q->M2; i++) {\n        t0 += conjf(rc[i])       *       _q->s0[i] * \n                    rc[i+_q->M2] * conjf(_q->s0[i+_q->M2]);\n    }\n    float nu_hat = cargf(t0) / (float)(_q->M2);\n#endif\n#if DEBUG_OFDMFRAMESYNC_PRINT\n    printf(""   nu_hat   :   %12.8f\\n"", nu_hat);\n#endif\n    nco_crcf_set_frequency(_q->nco_rx, nu_hat);\n    _q->state = OFDMFRAMESYNC_STATE_PLCPLONG;\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: Implement a function in C that performs a test on a complex FIR filter with data of size 23x64. The function should take in the input signal, filter coefficients, and expected output signal as arguments. Ensure that the implementation is correct and produces the expected output.","//...\nvoid autotest_firfilt_cccf_data_h23x64()\n{\n    firfilt_cccf_test(firfilt_cccf_data_h23x64_h, 23,\n                      firfilt_cccf_data_h23x64_x, 64,\n                      firfilt_cccf_data_h23x64_y, 64);\n}\n//...')
"
"'Prompt: You are working on a driver for GPIO pins on a specific platform, and you need to implement functions for initializing, writing to, and setting interrupt configurations for GPIO pins. You also need to handle clock control for the GPIO driver. Can you provide the code for these functions, taking into consideration the necessary clock control and instance identification?. . Response: . ```c. #ifndef FSL_COMPONENT_ID. #define FSL_COMPONENT_ID ""platform.drivers.igpio"". #endif. . #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL). static GPIO_Type *const s_gpioBases[] = GPIO_BASE_PTRS;. #endif. . #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL). static const clock_ip_name_t s_gpioClock[] = GPIO_CLOCKS;. #endif . . #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL). static uint32_t GPIO_GetInstance(GPIO_Type *","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.igpio""\n#endif\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic GPIO_Type *const s_gpioBases[] = GPIO_BASE_PTRS;\n#endif\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_gpioClock[] = GPIO_CLOCKS;\n#endif \n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic uint32_t GPIO_GetInstance(GPIO_Type *base);\nstatic uint32_t GPIO_GetInstance(GPIO_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0U; instance < ARRAY_SIZE(s_gpioBases); instance++)\n    {\n        if (s_gpioBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_gpioBases));\n    return instance;\n}\n#endif\nvoid GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *Config)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    uint32_t instance = GPIO_GetInstance(base);\n    if ((instance < ARRAY_SIZE(s_gpioClock)) && (kCLOCK_IpInvalid != s_gpioClock[instance]))\n    {\n        (void)CLOCK_EnableClock(s_gpioClock[instance]);\n    }\n#endif \n    base->IMR &= ~(1UL << pin);\n    if (Config->direction == kGPIO_DigitalInput)\n    {\n        base->GDIR &= ~(1UL << pin);\n    }\n    else\n    {\n        GPIO_PinWrite(base, pin, Config->outputLogic);\n        base->GDIR |= (1UL << pin);\n    }\n    GPIO_SetPinInterruptConfig(base, pin, Config->interruptMode);\n}\nvoid GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)\n{\n    assert(pin < 32U);\n    if (output == 0U)\n    {\n#if (defined(FSL_FEATURE_IGPIO_HAS_DR_CLEAR) && FSL_FEATURE_IGPIO_HAS_DR_CLEAR)\n        base->DR_CLEAR = (1UL << pin);\n#else\n        base->DR &= ~(1UL << pin); \n#endif\n    }\n    else\n    {\n#if (defined(FSL_FEATURE_IGPIO_HAS_DR_SET) && FSL_FEATURE_IGPIO_HAS_DR_SET)\n        base->DR_SET = (1UL << pin);\n#else\n        base->DR |= (1UL << pin);  \n#endif\n    }\n}\nvoid GPIO_PinSetInterruptConfig(GPIO_Type *base, uint32_t pin, gpio_interrupt_mode_t pinInterruptMode)\n{\n    volatile uint32_t *icr;\n    uint32_t icrShift;\n    icrShift = pin;\n    base->EDGE_SEL &= ~(1UL << pin);\n    if (pin < 16U)\n    {\n        icr = &(base->ICR1);\n    }\n    else\n    {\n        icr = &(base->ICR2);\n        icrShift -= 16U;\n    }\n    switch (pinInterruptMode)\n    {\n        case (kGPIO_IntLowLevel):\n            *icr &= ~(3UL << (2UL * icrShift));\n            break;\n        case (kGPIO_IntHighLevel):\n            *icr = (*icr & (~(3UL << (2UL * icrShift)))) | (1UL << (2UL * icrShift));\n            break;\n        case (kGPIO_IntRisingEdge):\n            *icr = (*icr & (~(3UL << (2UL * icrShift)))) | (2UL << (2UL * icrShift));\n            break;\n        case (kGPIO_IntFallingEdge):\n            *icr |= (3UL << (2UL * icrShift));\n            break;\n        case (kGPIO_IntRisingOrFallingEdge):\n            base->EDGE_SEL |= (1UL << pin);\n            break;\n        default:; \n            break;\n    }\n}'"
"('Prompt: You have an array of complex numbers and you need to calculate the sum of squares of the real and imaginary parts separately. Write a function in C that takes an array of complex numbers and its size and returns the sum of squares of the real and imaginary parts. . . Response: . ```c. float liquid_sumsqf(float *      _v,.                     unsigned int _n). {.     float r=0;.     unsigned int t=(_n>>2)<<2; .     unsigned int i;.     for (i=0; i<t; i+=4) {.         r += _v[i  ] * _v[i  ];.         r += _v[i+1] * _v[i+1];.         r += _v[i+2] * _v[i+2];.         r += _v[i+3] * _v[i+3];.     }.     for ( ; i<_n; i++).         r += _v[i]","//...\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    float r=0;\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        r += _v[i  ] * _v[i  ];\n        r += _v[i+1] * _v[i+1];\n        r += _v[i+2] * _v[i+2];\n        r += _v[i+3] * _v[i+3];\n    }\n    for ( ; i<_n; i++)\n        r += _v[i] * _v[i];\n    return r;\n}\nfloat liquid_sumsqcf(float complex * _v,\n                     unsigned int    _n)\n{\n    float * v = (float*) _v;\n    return liquid_sumsqf(v, 2*_n);\n}\n//...')
"
"(""Please write a prompt instructing me to provide code for a C function that sets properties for a flexible frame generator. The function should take into account the frame's status, error checking, correction schemes, and modulation schemes in order to configure the properties accordingly. Additionally, include a function that reconfigures the flexible frame generator based on the new properties set.. . Technical Scenario:. You are working on a project involving flexible frame generation in C programming. You need code for a function that can set properties for a flexible frame generator based on certain conditions and constraints. This function should also have the ability to reconfigure the flexible frame generator according to the newly set properties. You want to ensure that error handling is implemented properly for the configuration process.","//...\n    unsigned int    k;                  \n    unsigned int    m;                  \n    flexframegenprops_s props;          \n    flexframegenprops_s header_props;   \n    unsigned char * header;             \n    unsigned int    header_user_len;    \n    unsigned int    header_dec_len;     \n    qpacketmodem    header_encoder;     \n    unsigned int    header_mod_len;     \n    float complex * header_mod;         \n    qpilotgen       header_pilotgen;    \n    unsigned int    header_sym_len;     \n    float complex * header_sym;         \n        _q->frame_assembled = 0;\nint flexframegen_setprops(flexframegen          _q,\n                          flexframegenprops_s * _props)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), frame is already assembled; must reset() first"");\n    if (_props == NULL)\n        return flexframegen_setprops(_q, &flexframegenprops_default);\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), invalid/unsupported FEC scheme"");\n    if (_props->mod_scheme == LIQUID_MODEM_UNKNOWN )\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), invalid/unsupported modulation scheme"");\n    memmove(&_q->props, _props, sizeof(flexframegenprops_s));\n    return flexframegen_reconfigure(_q);\n}\nint flexframegen_reconfigure(flexframegen _q)\n{\n    qpacketmodem_configure(_q->payload_encoder,\n                           _q->payload_dec_len,\n                           _q->props.check,\n                           _q->props.fec0,\n                           _q->props.fec1,\n                           _q->props.mod_scheme);\n    _q->payload_sym_len = qpacketmodem_get_frame_len(_q->payload_encoder);\n    _q->payload_sym = (float complex*) realloc(_q->payload_sym,\n                                               _q->payload_sym_len*sizeof(float complex));\n    if (_q->payload_sym == NULL)\n        return liquid_error(LIQUID_EIMEM,""flexframegen_reconfigure(), could not re-allocate payload array"");\n    return LIQUID_OK;\n}\nint flexframegen_set_header_len(flexframegen   _q,\n                                 unsigned int   _len)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), frame is already assembled; must reset() first"");\n    _q->header_user_len = _len;\n    _q->header_dec_len = FLEXFRAME_H_DEC + _q->header_user_len;\n    _q->header     = (unsigned char *) realloc(_q->header, _q->header_dec_len*sizeof(unsigned char));\n    if (_q->header_encoder) {\n        qpacketmodem_destroy(_q->header_encoder);\n    }\n    _q->header_encoder = qpacketmodem_create();\n    qpacketmodem_configure(_q->header_encoder,\n                           _q->header_dec_len,\n                           _q->header_props.check,\n                           _q->header_props.fec0,\n                           _q->header_props.fec1,\n                           _q->header_props.mod_scheme);\n    _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_encoder);\n    _q->header_mod     = (float complex *) realloc(_q->header_mod, _q->header_mod_len*sizeof(float complex));\n    if (_q->header_pilotgen) {\n        qpilotgen_destroy(_q->header_pilotgen);\n    }\n    _q->header_pilotgen = qpilotgen_create(_q->header_mod_len, 16);\n    _q->header_sym_len  = qpilotgen_get_frame_len(_q->header_pilotgen);\n    _q->header_sym      = (float complex *) realloc(_q->header_sym, _q->header_sym_len*sizeof(float complex));\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on testing a resampling filter implementation, specifically a complex resampling filter. The design parameters for the resampling filter are specified by the user at runtime. The filter is created using a Kaiser window design with certain parameters for the transition bandwidth and stopband attenuation. You need to implement a test harness function called `test_harness_rresamp_crcf_part` that takes in four parameters: P, Q, m, and n. These parameters specify the filter characteristics as well as the size of the input and output buffers. The test harness function should create two instances of the resampling filter with the same parameters and execute resampling operations using input data generated with a Hamming window and a complex exponential function. The output from both instances of the filter should be compared using a tolerance value. After the comparison, the memory allocated for the filters should be destroyed. Additionally, you need to implement an auto test function called `autotest_rresamp_crcf_part_P6","//...\nvoid test_harness_rresamp_crcf_part(unsigned int _P, \n                                    unsigned int _Q, \n                                    unsigned int _m, \n                                    unsigned int _n) \n{\n    float tol = 1e-12f; \n    float bw  = 0.5f;   \n    float As  = 60.0f;  \n    rresamp_crcf q0 = rresamp_crcf_create_kaiser(_P,_Q,_m,bw,As);\n    rresamp_crcf q1 = rresamp_crcf_create_kaiser(_P,_Q,_m,bw,As);\n    float complex buf_in   [2*_Q*_n]; \n    float complex buf_out_0[2*_P*_n]; \n    float complex buf_out_1[2*_P*_n]; \n    unsigned int i;\n    for (i=0; i<2*_Q*_n; i++)\n        buf_in[i] = liquid_hamming(i,2*_Q*_n) * cexpf(_Complex_I*2*M_PI*0.037f*i);\n    rresamp_crcf_execute_block(q0, buf_in, 2*_n, buf_out_0);\n    rresamp_crcf_reset(q0);\n    rresamp_crcf_execute_block(q0, buf_in, _n, buf_out_1);\n    for (i=0; i<_m; i++)\n        rresamp_crcf_write(q1, buf_in + _Q*_n - (_m-i)*_Q);\n    rresamp_crcf_execute_block(q1, buf_in + _Q*_n, _n, buf_out_1 + _P*_n);\n    rresamp_crcf_destroy(q0);\n    rresamp_crcf_destroy(q1);\n    for (i=0; i<2*_P*_n; i++) {\n        CONTEND_DELTA( crealf(buf_out_0[i]), crealf(buf_out_1[i]), tol );\n        CONTEND_DELTA( cimagf(buf_out_0[i]), cimagf(buf_out_1[i]), tol );\n    }\n}\nvoid autotest_rresamp_crcf_part_P6_Q5() { test_harness_rresamp_crcf_part( 6, 5, 15, 20); }\n//...')
"
"'Prompt: Please provide a code snippet for a single threaded client using the MQTT protocol to send and receive messages. The code should include functions for connecting to a server, subscribing to a topic, sending and receiving messages, and disconnecting from the server. Additionally, the code should handle message arrival and logging.","//...\nstatic volatile MessageData* test1_message_data = NULL;\nstatic mqtt_msg pubmsg;\n#define LOGA_DEBUG 0\n    return 1;\n    opts.will->message = test6_will_message;\n    opts.will->payload.data = test6_will_message;\n    opts.will->payload.len = strlen(test6_will_message) + 1;\nvoid write_test_result(void)\n{\n    uint64_t duration = time_elapsed_ms(&g_start_time);\n    fprintf(xml, "" time=\\""%ld.%.3ld\\"" >\\n"", duration / 1000, duration % 1000);\n    if (cur_output != output) {\n        fprintf(xml, ""%s"", output);\n        cur_output = output;\n    }\n    fprintf(xml, ""</testcase>\\n"");\n}\nvoid messageArrived(MessageData* md)\n{\n    test1_message_data = md;\n    mqtt_msg* m = md->message;\n    assert(""Good message lengths"", pubmsg.payloadlen == m->payloadlen,\n                    ""payloadlen was %d"", m->payloadlen);\n    if (pubmsg.payloadlen == m->payloadlen)\n            assert(""Good message contents"", memcmp(m->payload, pubmsg.payload, m->payloadlen) == 0,\n                            ""payload was %s"", m->payload);\n}\nvoid MyLog(int LOGA_level, char* format, ...)\n{\n    static char msg_buf[256];\n    va_list args;\n    struct timeb ts;\n    struct tm *timeinfo;\n    ftime(&ts);\n    timeinfo = localtime(&ts.time);\n    strftime(msg_buf, 80, ""%Y%m%d %H%M%S"", timeinfo);\n    sprintf(&msg_buf[strlen(msg_buf)], "".%.3hu "", ts.millitm);\n    va_start(args, format);\n    vsnprintf(&msg_buf[strlen(msg_buf)], sizeof(msg_buf) - strlen(msg_buf), format, args);\n    va_end(args);\n    printf(""%s\\n"", msg_buf);\n    fflush(stdout);\n}\nint test1(struct Options options)\n{\n    int subsqos = 2;\n    mqtt_client c;\n    int rc = 0;\n    char* test_topic = ""C client test1"";\n    fprintf(xml, ""<testcase classname=\\""test1\\"" name=\\""single threaded client using receive\\"""");\n    gettimeofday(&g_start_time, NULL);\n    failures = 0;\n    MyLog(LOGA_INFO, ""Starting test 1 - single threaded client using receive"");\n    mqtt_client_init(&c, options.host, options.port);\n    mqtt_suback_data tmp_subback_data;\n    mqtt_connack_data tmp_data;\n    mqtt_pkt_conn_data data = mqtt_pkt_conn_data_initializer;\n    data.willFlag = 1;\n    data.mqtt_version = options.mqtt_version;\n    data.clientID.cstring = ""single-threaded-test"";\n    data.username.cstring = ""testuser"";\n    data.password.cstring = ""testpassword"";\n    data.keepAliveInterval = 20;\n    data.cleansession = 1;\n    data.will.message.cstring = ""will message"";\n    data.will.qos = 1;\n    data.will.retained = 0;\n    data.will.topicName.cstring = ""will topic"";\n    MyLog(LOGA_DEBUG, ""Connecting"");\n    rc = mqtt_connect(&c, &data, &tmp_data);\n    assert(""Good rc from connect"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    if (rc != MQTT_SUCCESS)\n        goto exit;\n    rc = mqtt_subscribe(&c, test_topic, subsqos, messageArrived, &tmp_subback_data);\n    assert(""Good rc from subscribe"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    test1_sendAndReceive(&c, 0, test_topic);\n    test1_sendAndReceive(&c, 1, test_topic);\n    test1_sendAndReceive(&c, 2, test_topic);\n    MyLog(LOGA_DEBUG, ""Stopping\\n"");\n    rc = mqtt_unsubscribe(&c, test_topic);\n    assert(""Unsubscribe successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n#if 0\n    rc = mqtt_connect(&c, &data, &tmp_data);\n    assert(""Connect successful"",  rc == MQTT_SUCCESS, ""rc was %d"", rc);\n    rc = mqtt_disconnect(&c);\n    assert(""Disconnect successful"", rc == MQTT_SUCCESS, ""rc was %d"", rc);\n#endif\nexit:\n    MyLog(LOGA_INFO, ""TEST1: test %s. %d tests run, %d failures."",\n                    (failures == 0) ? ""passed"" : ""failed"", tests, failures);\n    write_test_result();\n    mqtt_client_deinit(&c);\n    return failures;\n}\nlong elapsed(START_TIME_TYPE start_time)\n{\n    struct timeval now, res;\n    gettimeofday(&now, NULL);\n    timersub(&now, &start_time, &res);\n    return (res.tv_sec)*1000 + (res.tv_usec)/1000;\n}\nvoid test1_sendAndReceive(mqtt_client* c, int qos, char* test_topic)\n{\n    int i = 0;\n    int iterations = 5;\n    int rc;\n    int wait_seconds;\n    MyLog(LOGA_DEBUG, ""%d messages at QoS %d"", iterations, qos);\n    memset(&pubmsg, \'\\0\', sizeof(pubmsg));\n    pubmsg.payload = ""a much longer message that we can shorten to the extent that we need to payload up to 11"";\n    pubmsg.payloadlen = 11;\n    pubmsg.qos = qos;\n    pubmsg.retained = 0;\n    pubmsg.dup = 0;\n    for (i = 0; i < iterations; ++i) {\n        test1_message_data = NULL;\n        rc = mqtt_publish(c, test_topic, &pubmsg);\n        assert(""Good rc from publish"", rc == MQTT_SUCCESS, ""rc was %d\\n"", rc);\n        wait_seconds = 10;\n        while ((test1_message_data == NULL) && (wait_seconds-- > 0)) {\n            mqtt_yield(c, 100);\n        }\n        assert(""Message Arrived"", wait_seconds > 0, ""Time out waiting for message %d\\n"", i);\n        if (!test1_message_data)\n            printf(""No message received within timeout period\\n"");\n    }\n    wait_seconds = 2;\n    while (wait_seconds-- > 0) {\n        mqtt_yield(c, 1000);\n    }\n}\nvoid messageArrived(MessageData* md)\n{\n    test1_message_data = md;\n    mqtt_msg* m = md->message;\n    assert(""Good message lengths"", pubmsg.payloadlen == m->payloadlen,\n                    ""payloadlen was %d"", m->payloadlen);\n    if (pubmsg.payloadlen == m->payloadlen)\n            assert(""Good message contents"", memcmp(m->payload, pubmsg.payload, m->payloadlen) == 0,\n                            ""payload was %s"", m->payload);\n}\n//...'"
"'Prompt: You are working on implementing a ring buffer data structure in C, where elements are added until the buffer is full and then the oldest elements are replaced by newer elements. Write a function `foo` that demonstrates the functionality of your ring buffer implementation. The function should create a ring buffer of size 1024, write the string ""hello world"" into it multiple times, and then read and print the contents to test if elements are being replaced properly.","//...\nint foo()\n{\n    struct ringbuffer *rb = rb_create(1024);\n    const char *tmp = ""hello world"";\n    ssize_t ret = 0;\n    size_t len = 0;\n    int i;\n    for (i = 0; i < 100; i++) {\n        printf(""free=%zu, used=%zu\\n"", rb_get_space_free(rb), rb_get_space_used(rb));\n        ret = rb_write(rb, tmp, strlen(tmp));\n        if (ret < 0) {\n            break;\n        }\n    }\n    printf(""dump = %s\\n"", (char *)rb_dump(rb, &len));\n    printf(""rb_write len=%zu\\n"", len);\n    char tmp2[9];\n    memset(tmp2, 0, sizeof(tmp2));\n    rb_read(rb, tmp2, sizeof(tmp2)-1);\n    printf(""rb_read str=%s\\n"", tmp2);\n    memset(tmp2, 0, sizeof(tmp2));\n    rb_read(rb, tmp2, sizeof(tmp2)-1);\n    printf(""rb_read str=%s\\n"", tmp2);\n    return 0;\n}\n//...'"
"'Prompt: Can you provide a code snippet for managing a PulseAudio context in a multimedia application? Include the struct definition for the Pulse context, initialization functions, and a function for checking if the Pulse context is ready for use. Additionally, show how to set PulseAudio properties using a proplist.","//...\nstruct pulse_ctx {\n    int                   fd;\n    struct avcap_ctx       *parent;\n    bool                  is_streaming;\n    char                 *device;\n    uint64_t              frame_id;\n    pa_sample_format_t    format;\n    uint32_t              sample_rate;\n    uint32_t              bytes_per_frame;\n    uint8_t               channels;\n    uint64_t              first_ts;\n    enum speaker_layout   speakers;\n    pa_threaded_mainloop *pa_mainloop;\n    pa_context           *pa_ctx;\n    pa_stream            *pa_stream;\n    pa_context_state_t    pa_state;\n    pa_stream_state_t     pa_stream_state;\n    pa_sample_spec        pa_sample_spec;\n    pa_channel_map        pa_channel_map;\n    pa_server_info        pa_server_info;\n};\nstruct avcap_ops pulseaudio_ops = {\n    ._open         = _pa_open,\n    ._close        = _pa_close,\n    .ioctl        = NULL,\n    .start_stream = _pa_start_stream,\n    .stop_stream  = _pa_stop_stream,\n    .query_frame  = _pa_query_frame,\n};\n    return c;\n    c->pa_mainloop = pa_threaded_mainloop_new();\n    pa_proplist *p = pulse_properties();\n    c->pa_ctx = pa_context_new_with_proplist(pa_threaded_mainloop_get_api(c->pa_mainloop), ""libavcap"", p);\nstatic pa_proplist *pulse_properties()\n{\n    pa_proplist *p = pa_proplist_new();\n    pa_proplist_sets(p, PA_PROP_APPLICATION_NAME, ""libavcap"");\n    pa_proplist_sets(p, PA_PROP_APPLICATION_ICON_NAME, ""libavcap"");\n    pa_proplist_sets(p, PA_PROP_MEDIA_ROLE, ""production"");\n    return p;\n}\nstatic int pulse_context_ready(struct pulse_ctx *c)\n{\n    pa_threaded_mainloop_lock(c->pa_mainloop);\n    if (!PA_CONTEXT_IS_GOOD(pa_context_get_state(c->pa_ctx))) {\n        pa_threaded_mainloop_unlock(c->pa_mainloop);\n        return -1;\n    }\n    while (pa_context_get_state(c->pa_ctx) != PA_CONTEXT_READY) {\n        pa_threaded_mainloop_wait(c->pa_mainloop);\n    }\n    pa_threaded_mainloop_unlock(c->pa_mainloop);\n    return 0;\n}\n//...'"
"('Prompt: You are working on a program that utilizes gradient search to fit a function to a dataset. The program includes a struct definition for a dataset, functions for calculating error and the function to be fitted, as well as the main function that performs the gradient search. Please provide the code for the main function that creates the dataset, initializes the gradient search, performs iterations, and outputs the results to a file named ""gradsearch_datafit_example.m"". ","#define OUTPUT_FILENAME ""gradsearch_datafit_example.m""\nstruct gsdataset {\n    float * x;\n    float * y;\n    unsigned int n;\n};\nfloat gserror(void * _dataset,\n              float * _v,\n              unsigned int _n);\nfloat gsfunc(float _x, float * _v)\n{\n    float c0 = _v[0];\n    float c1 = _v[1];\n    float c2 = _v[2];\n    return c0 + sincf(c1*(_x-c2));\n}\nint main() {\n    unsigned int num_samples = 400;     \n    float sig = 0.1f;                   \n    unsigned int num_iterations = 1000; \n    float v[3] = {1, 1, 1};\n    unsigned int i;\n    float xmin = 0.0f;\n    float xmax = 6.0f;\n    float dx = (xmax - xmin) / (num_samples-1);\n    float x[num_samples];\n    float y[num_samples];\n    for (i=0; i<num_samples; i++) {\n        x[i] = xmin + i*dx;\n        y[i] = sincf(x[i]) + randnf()*sig;\n    }\n    struct gsdataset q = {x, y, num_samples};\n    gradsearch gs = gradsearch_create((void*)&q, v, 3, gserror, LIQUID_OPTIM_MINIMIZE);\n    float rmse;\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""u = zeros(1,%u);\\n"", num_iterations);\n    for (i=0; i<num_iterations; i++) {\n        rmse = gserror((void*)&q,v,3);\n        fprintf(fid,""u(%3u) = %12.4e;\\n"", i+1, rmse);\n        gradsearch_step(gs);\n        if (((i+1)%100)==0)\n            gradsearch_print(gs);\n    }\n    printf(""\\n"");\n    gradsearch_print(gs);\n    printf(""  c0 = %12.8f, opt = 1\\n"", v[0]);\n    printf(""  c1 = %12.8f, opt = 0\\n"", v[1]);\n    printf(""  c2 = %12.8f, opt = 1\\n"", v[2]);\n    printf(""  rmse = %12.4e\\n"", rmse);\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""semilogy(u);\\n"");\n    fprintf(fid,""xlabel(\'iteration\');\\n"");\n    fprintf(fid,""ylabel(\'error\');\\n"");\n    fprintf(fid,""title(\'gradient search results\');\\n"");\n    fprintf(fid,""grid on;\\n"");\n    for (i=0; i<num_samples; i++) {\n        fprintf(fid,""  x(%4u) = %12.8f;\\n"", i+1, x[i]);\n        fprintf(fid,""  y(%4u) = %12.8f;\\n"", i+1, y[i]);\n        fprintf(fid,""  y_hat(%4u) = %12.8f;\\n"", i+1, gsfunc(x[i],v));\n    }\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""plot(x,y,\'x\', x,y_hat,\'-\');\\n"");\n    fprintf(fid,""xlabel(\'x\');\\n"");\n    fprintf(fid,""ylabel(\'f(x)\');\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""legend(\'data\',\'fit\',1);\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"", OUTPUT_FILENAME);\n    gradsearch_destroy(gs);\n    return 0;\n}\nfloat gserror(void * _dataset,\n              float * _v,\n              unsigned int _n)\n{\n    struct gsdataset * p = (struct gsdataset *) _dataset;\n    float rmse = 0.0f; \n    unsigned int i;\n    for (i=0; i<p->n; i++) {\n        float y_hat = gsfunc(p->x[i], _v);\n        float e = p->y[i] - y_hat;\n        rmse += e*e;\n    }\n    rmse = sqrtf(rmse / (float)(p->n));\n    return rmse;\n}')
"
"'Prompt: As part of a project utilizing LittlevGL, you need to create an example function that demonstrates the use of images. The function should create two image objects on the active screen. The first image should display a cogwheel image, while the second image should display an ""Accept"" symbol. Both images should be aligned centrally on the screen, with the second image positioned below the first image with a distance of 20 pixels. Implement the example function for this scenario.","#if LV_USE_IMAGE && LV_BUILD_EXAMPLES\nvoid lv_example_image_1(void)\n{\n    LV_IMAGE_DECLARE(img_cogwheel_argb);\n    lv_obj_t * img1 = lv_image_create(lv_screen_active());\n    lv_image_set_src(img1, &img_cogwheel_argb);\n    lv_obj_align(img1, LV_ALIGN_CENTER, 0, 0);\n    lv_obj_t * img2 = lv_image_create(lv_screen_active());\n    lv_image_set_src(img2, LV_SYMBOL_OK ""Accept"");\n    lv_obj_align_to(img2, img1, LV_ALIGN_OUT_BOTTOM_MID, 0, 20);\n}\n#endif'"
"('Prompt: You are working on a project that requires implementing a function for calculating the dot product of two complex arrays in a digital signal processing software library. The initial implementation provided is functional, but you are looking to optimize it for improved performance on modern processors with SIMD capabilities. Your task is to modify the existing `dotprod_crcf_run` function to create a new function called `dotprod_crcf_run4` that exploits SIMD parallelism by processing four complex samples per iteration. You will need to update the loop logic to process the array elements in groups of four to maximize efficiency.","//...\nint dotprod_crcf_run(float *         _h,\n                     float complex * _x,\n                     unsigned int    _n,\n                     float complex * _y)\n{\n    float complex r = 0;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\nint dotprod_crcf_run4(float *         _h,\n                      float complex * _x,\n                      unsigned int    _n,\n                      float complex * _y)\n{\n    float complex r = 0;\n    unsigned int t=(_n>>2)<<2; \n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        r += _h[i]   * _x[i];\n        r += _h[i+1] * _x[i+1];\n        r += _h[i+2] * _x[i+2];\n        r += _h[i+3] * _x[i+3];\n    }\n    for ( ; i<_n; i++)\n        r += _h[i] * _x[i];\n    *_y = r;\n    return LIQUID_OK;\n}\n//...')
"
('Please provide the corresponding test scenario that verifies the functionality of the `modemcf_test_demodsoft` function for demodulating a soft PSK16 modem.,"//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_psk16()     { modemcf_test_demodsoft(LIQUID_MODEM_PSK16);     }\n//...')
"
"('Prompt: . You are developing a software-defined radio application that requires resampling of a signal with a multi-stage resampler. You need to test the functionality of the resampler with a specific set of parameters: 1 stage, a center frequency of 0.45, and a stop-band attenuation of 60.0. Write a testbench function in C that sets up the resampler with these parameters, generates a test signal, processes it, and validates the output signal using an automated PSD (power spectral density) test. The output should be saved in a file for further analysis.","//...\nvoid testbench_msresamp2_crcf_interp(unsigned int _num_stages,\n                                     float        _fc,\n                                     float        _as)\n{\n    msresamp2_crcf resamp = msresamp2_crcf_create(\n        LIQUID_RESAMP_INTERP, _num_stages, _fc, 0.0f, _as);\n    float delay = msresamp2_crcf_get_delay(resamp);\n    unsigned int  M = 1 << _num_stages; \n    unsigned int  buf_len = 0;\n    unsigned int  num_blocks = 0;\n    while ((float)buf_len < 2*M*delay) {\n        buf_len += M;\n        num_blocks++;\n    }\n    float complex buf[buf_len]; \n    unsigned int i;\n    for (i=0; i<num_blocks; i++) {\n        float complex x = (i==0) ? 1.0f : 0.0f;\n        msresamp2_crcf_execute(resamp, &x, buf+ i*M);\n    }\n    liquid_vectorcf_mulscalar(buf, buf_len, 1.0f/(float)M, buf);\n#if 0\n    for (i=0; i<buf_len; i++)\n        printf(""%3u : %12.8f %12.8f\\n"", i, crealf(buf[i]), cimagf(buf[i]));\n#endif\n    float f0 = _fc / (float)M;\n    float f1 = 1.0f / (float)M - f0;\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f, .fmax=-f1,   .pmin=   0, .pmax=-_as, .test_lo=0, .test_hi=1},\n        {.fmin=  -f0, .fmax= f0,   .pmin=-0.1, .pmax= 0.1, .test_lo=1, .test_hi=1},\n        {.fmin=   f1, .fmax= 0.5f, .pmin=   0, .pmax=-_as, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/msresamp2_crcf_interp_M%u_f%.3u_a%u.m"",\n        M, (int)(_fc*1000), (int)_as);\n    liquid_autotest_validate_psd_signal(buf, buf_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    msresamp2_crcf_destroy(resamp);\n}\nvoid autotest_msresamp2_crcf_interp_05() { testbench_msresamp2_crcf_interp(1, 0.45f, 60.0f); }\n//...')
"
"('Prompt: You are working on testing the functionality of GMSK frame synchronization for a communication system. You need to create a testbench function that sets up a GMSK frame generator and a GMSK frame synchronizer with specified parameters (_k, _m, _bt) and tests the synchronization process. The testbench function should generate a GMSK frame, send it to the frame synchronizer, and check if the synchronization was successful. Additionally, provide an autotest function that uses specific parameters (k=4, m=5, bt=0.30) to test the frame synchronization. Your task is to write the code that achieves this scenario.","//...\nvoid testbench_gmskframesync(unsigned int _k, unsigned int _m, float _bt)\n{\n    gmskframegen  fg = gmskframegen_create_set (_k,_m,_bt);\n    gmskframesync fs = gmskframesync_create_set(_k,_m,_bt,NULL,NULL);\n    gmskframegen_assemble_default(fg, 80);\n    unsigned int  buf_len = 200;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = gmskframegen_write(fg, buf, buf_len);\n        gmskframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        gmskframesync_print(fs);\n    framedatastats_s stats = gmskframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received,  80);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n}\nvoid autotest_gmskframesync_k04_m05_bt30() { testbench_gmskframesync( 4, 5, 0.30f); }\n//...')
"
"('Prompt: You are testing a function that calculates the delay of a symmetrical root raised cosine filter for a specific bandwidth and number of taps. The function creates the filter, writes samples to it, sets the gain, performs a Fourier transform operation, and finally calculates the delay. The delay is then compared to an expected value with a tolerance level. Can you provide a test function to automate this process for a bandwidth of 0.3 and 12 taps?","//...\nvoid testbench_symstreamrcf_delay(float        _bw,\n                                  unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamrcf gen    = symstreamrcf_create_linear(ftype,_bw,_m,beta,ms);\n    float        delay  = symstreamrcf_get_delay(gen);\n    float        tol    = 0.05; \n    unsigned int  nfft = 2*(120 + (unsigned int)(delay/sqrtf(_bw)));\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    symstreamrcf_write_samples(gen, buf_time, 1);\n    symstreamrcf_set_gain(gen, 0.0f);\n    symstreamrcf_write_samples(gen, buf_time+1, nfft-1);\n    symstreamrcf_destroy(gen);\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    unsigned int m = 0.4 * _bw * nfft; \n    float complex p = 0.0f;\n    int i;\n    for (i=-(int)m; i<(int)m; i++)\n        p += buf_freq[(nfft+i)%nfft] * conjf(buf_freq[(nfft+i+1)%nfft]);\n    float delay_meas = cargf(p) * nfft / (2*M_PI);\n    if (liquid_autotest_verbose) {\n        printf(""expected delay: %.6f, measured: %.6f, err: %.6f (tol= %.3f)\\n"",\n                delay, delay_meas, delay-delay_meas,tol);\n    }\n    CONTEND_DELTA(delay, delay_meas, tol);\n}\nvoid autotest_symstreamrcf_delay_15() { testbench_symstreamrcf_delay(0.300f,12); }\n//...')
"
"('Prompt: Write two functions in C that return the generator polynomial and the length of the generator polynomial for a given m-sequence structure, where the generator polynomial and its length are stored as member variables in the msequence structure.","//...\nunsigned int msequence_get_genpoly(msequence _ms)\n{\n    return _ms->g;\n}\nunsigned int msequence_get_genpoly_length(msequence _ms)\n{\n    return _ms->m;\n}\n//...')
"
'You are working on a multithreaded application and need a way to programmatically cancel a specific thread. You want to implement a function that allows you to cancel a thread using the POSIX pthread_cancel function. The function should check if the target thread is cancelable and handle the cancellation process appropriately.,"#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nstatic void\n__ptw32_cancel_self (void)\n{\n  __ptw32_throw  (__PTW32_EPS_CANCEL);\n}\nstatic void CALLBACK\n__ptw32_cancel_callback (ULONG_PTR unused)\n{\n  __ptw32_throw  (__PTW32_EPS_CANCEL);\n}\nDWORD\n__ptw32_Registercancellation (PAPCFUNC unused1, HANDLE threadH, DWORD unused2)\n{\n  CONTEXT context;\n  context.ContextFlags = CONTEXT_CONTROL;\n  GetThreadContext (threadH, &context);\n   __PTW32_PROGCTR (context) = (DWORD_PTR) __ptw32_cancel_self;\n  SetThreadContext (threadH, &context);\n  return 0;\n}\nint\npthread_cancel (pthread_t thread)\n{\n  int result;\n  int cancel_self;\n  pthread_t self;\n  __ptw32_thread_t * tp;\n  __ptw32_mcs_local_node_t stateLock;\n  result = pthread_kill (thread, 0);\n  if (0 != result)\n    {\n      return result;\n    }\n  if ((self = pthread_self ()).p == NULL)\n    {\n      return ENOMEM;\n    };\n  cancel_self = pthread_equal (thread, self);\n  tp = (__ptw32_thread_t *) thread.p;\n  __ptw32_mcs_lock_acquire (&tp->stateLock, &stateLock);\n  if (tp->cancelType == PTHREAD_CANCEL_ASYNCHRONOUS\n      && tp->cancelState == PTHREAD_CANCEL_ENABLE\n      && tp->state < PThreadStateCanceling)\n    {\n      if (cancel_self)\n\t{\n\t  tp->state = PThreadStateCanceling;\n\t  tp->cancelState = PTHREAD_CANCEL_DISABLE;\n\t  __ptw32_mcs_lock_release (&stateLock);\n\t  __ptw32_throw  (__PTW32_EPS_CANCEL);\n\t}\n      else\n\t{\n\t  HANDLE threadH = tp->threadH;\n\t  SuspendThread (threadH);\n\t  if (WaitForSingleObject (threadH, 0) == WAIT_TIMEOUT)\n\t    {\n\t      tp->state = PThreadStateCanceling;\n\t      tp->cancelState = PTHREAD_CANCEL_DISABLE;\n\t      __ptw32_register_cancellation ((PAPCFUNC)__ptw32_cancel_callback, threadH, 0);\n\t      __ptw32_mcs_lock_release (&stateLock);\n\t      ResumeThread (threadH);\n\t    }\n\t}\n    }\n  else\n    {\n      if (tp->state < PThreadStateCancelPending)\n\t{\n\t  tp->state = PThreadStateCancelPending;\n\t  if (!SetEvent (tp->cancelEvent))\n\t    {\n\t      result = ESRCH;\n\t    }\n\t}\n      else if (tp->state >= PThreadStateCanceling)\n\t{\n\t  result = ESRCH;\n\t}\n      __ptw32_mcs_lock_release (&stateLock);\n    }\n  return (result);\n}'"
"('Prompt: You are working on a digital signal processing project involving DSSS frame synchronization. You have a code snippet that includes an enum defining different states in the frame synchronization process and functions for executing various steps such as detecting frames, receiving preamble, decoding payload, and configuring payload. Please provide the code for handling the frame synchronization process, including functions like dsssframesync_step, dsssframesync_execute_seekpn, dsssframesync_decode_payload, dsssframesync_configure_payload, dsssframesync_execute_rxpreamble, dsssframesync_decode_header, dsssframesync_execute_rxheader, dsssframesync_execute_rxpayload, dsssframesync_execute, and dsssframesync_reset.","//...\nenum state {\n    DSSSFRAMESYNC_STATE_DETECTFRAME = 0,\n    DSSSFRAMESYNC_STATE_RXPREAMBLE,\n    DSSSFRAMESYNC_STATE_RXHEADER,\n    DSSSFRAMESYNC_STATE_RXPAYLOAD,\n};\nint dsssframesync_step(dsssframesync _q, float complex _x, float complex * _y)\n{\n    float complex v;\n    nco_crcf_mix_down(_q->mixer, _x, &v);\n    nco_crcf_step(_q->mixer);\n    firpfb_crcf_push(_q->mf, v);\n    firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);\n    _q->mf_counter++;\n    int sample_available = (_q->mf_counter >= 1) ? 1 : 0;\n    if (sample_available) {\n        *_y = v;\n        _q->mf_counter -= _q->k;\n    }\n    return sample_available;\n}\nint dsssframesync_execute_seekpn(dsssframesync _q, float complex _x)\n{\n    float complex * v = qdetector_cccf_execute(_q->detector, _x);\n    if (v == NULL)\n        return LIQUID_OK;\n    _q->tau_hat   = qdetector_cccf_get_tau(_q->detector);\n    _q->gamma_hat = qdetector_cccf_get_gamma(_q->detector);\n    _q->dphi_hat  = qdetector_cccf_get_dphi(_q->detector);\n    _q->phi_hat   = qdetector_cccf_get_phi(_q->detector);\n    if (_q->tau_hat > 0) {\n        _q->pfb_index  = (unsigned int)(_q->tau_hat * _q->npfb) % _q->npfb;\n        _q->mf_counter = 0;\n    } else {\n        _q->pfb_index  = (unsigned int)((1.0f + _q->tau_hat) * _q->npfb) % _q->npfb;\n        _q->mf_counter = 1;\n    }\n    firpfb_crcf_set_scale(_q->mf, 0.5f / _q->gamma_hat);\n    nco_crcf_set_frequency(_q->mixer, _q->dphi_hat);\n    nco_crcf_set_phase(_q->mixer, _q->phi_hat);\n    _q->state = DSSSFRAMESYNC_STATE_RXPREAMBLE;\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q->detector);\n    return dsssframesync_execute(_q, v, buf_len);\n}\nint dsssframesync_decode_payload(dsssframesync _q)\n{\n    float complex prev_corr, corr, next_corr;\n    nco_crcf_mix_block_down(\n        _q->pll, _q->payload_spread, _q->payload_spread, synth_crcf_get_length(_q->payload_synth));\n    synth_crcf_despread_triple(\n        _q->payload_synth, _q->payload_spread, &prev_corr, &corr, &next_corr);\n    int   complete    = qpacketmodem_decode_soft_sym(_q->payload_decoder, corr);\n    float phase_error = qpacketmodem_get_demodulator_phase_error(_q->payload_decoder);\n    nco_crcf_pll_step(_q->pll, synth_crcf_get_length(_q->payload_synth) * phase_error);\n    if (!complete) {\n        return 0;\n    }\n    _q->payload_valid = qpacketmodem_decode_soft_payload(_q->payload_decoder, _q->payload_dec);\n    return 1;\n}\nint dsssframesync_configure_payload(dsssframesync _q)\n{\n    _q->header_valid = qpacketmodem_decode_soft_payload(_q->header_decoder, _q->header_dec);\n    if (!_q->header_valid)\n        return LIQUID_OK;\n    unsigned int n = _q->header_user_len;\n    unsigned int protocol = _q->header_dec[n + 0];\n    if (protocol != DSSSFRAME_PROTOCOL) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), invalid framing protocol %u (expected %u)\\n"",protocol,DSSSFRAME_PROTOCOL);\n    }\n    unsigned int payload_dec_len = (_q->header_dec[n + 1] << 8) | (_q->header_dec[n + 2]);\n    _q->payload_dec_len          = payload_dec_len;\n    unsigned int check = (_q->header_dec[n + 3] >> 5) & 0x07;\n    unsigned int fec0  = (_q->header_dec[n + 3]) & 0x1f;\n    unsigned int fec1  = (_q->header_dec[n + 4]) & 0x1f;\n    if (check == LIQUID_CRC_UNKNOWN || check >= LIQUID_CRC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded CRC exceeds available\\n"");\n    } else if (fec0 == LIQUID_FEC_UNKNOWN || fec0 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded FEC (inner) exceeds available\\n"");\n        return LIQUID_OK;\n    } else if (fec1 == LIQUID_FEC_UNKNOWN || fec1 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMODE,""dsssframesync_decode_header(), decoded FEC (outer) exceeds available\\n"");\n    }\n    _q->payload_dec\n        = (unsigned char *)realloc(_q->payload_dec, (_q->payload_dec_len) * sizeof(unsigned char));\n    qpacketmodem_configure(\n        _q->payload_decoder, _q->payload_dec_len, check, fec0, fec1, LIQUID_MODEM_BPSK);\n    synth_crcf_set_frequency(_q->payload_synth, synth_crcf_get_frequency(_q->header_synth));\n    return LIQUID_OK;\n}\nint dsssframesync_execute_rxpreamble(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.0f;\n    int           sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    unsigned int delay = _q->k * _q->m; \n    if (_q->preamble_counter >= delay) {\n        unsigned int index     = _q->preamble_counter - delay;\n        _q->preamble_rx[index] = mf_out;\n    }\n    _q->preamble_counter++;\n    if (_q->preamble_counter == 64 + delay)\n        _q->state = DSSSFRAMESYNC_STATE_RXHEADER;\n    return LIQUID_OK;\n}\nint dsssframesync_decode_header(dsssframesync _q)\n{\n    float complex prev_corr, corr, next_corr;\n    nco_crcf_mix_block_down(\n        _q->pll, _q->header_spread, _q->header_spread, synth_crcf_get_length(_q->header_synth));\n    synth_crcf_despread_triple(_q->header_synth, _q->header_spread, &prev_corr, &corr, &next_corr);\n    int   complete    = qpacketmodem_decode_soft_sym(_q->header_decoder, corr);\n    float phase_error = qpacketmodem_get_demodulator_phase_error(_q->header_decoder);\n    nco_crcf_pll_step(_q->pll, synth_crcf_get_length(_q->header_synth) * phase_error);\n    if (!complete) {\n        return 0;\n    }\n    dsssframesync_configure_payload(_q);\n    return 1;\n}\nint dsssframesync_execute_rxheader(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int           sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->header_spread[_q->symbol_counter % synth_crcf_get_length(_q->header_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->header_synth))\n        return LIQUID_OK;\n    int header_complete = dsssframesync_decode_header(_q);\n    if (!header_complete)\n        return LIQUID_OK;\n    if (_q->header_valid) {\n        _q->symbol_counter = 0;\n        _q->state = DSSSFRAMESYNC_STATE_RXPAYLOAD;\n        return LIQUID_OK;\n    }\n    ++_q->framedatastats.num_frames_detected;\n    if (_q->callback != NULL) {\n        _q->framesyncstats.evm           = 0.f;\n        _q->framesyncstats.rssi          = 20 * log10f(_q->gamma_hat);\n        _q->framesyncstats.cfo           = nco_crcf_get_frequency(_q->mixer);\n        _q->framesyncstats.framesyms     = NULL;\n        _q->framesyncstats.num_framesyms = 0;\n        _q->framesyncstats.check         = LIQUID_CRC_UNKNOWN;\n        _q->framesyncstats.fec0          = LIQUID_FEC_UNKNOWN;\n        _q->framesyncstats.fec1          = LIQUID_FEC_UNKNOWN;\n        _q->callback(\n            _q->header_dec, _q->header_valid, NULL, 0, 0, _q->framesyncstats, _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\nint dsssframesync_execute_rxpayload(dsssframesync _q, float complex _x)\n{\n    float complex mf_out           = 0.f;\n    int                  sample_available = dsssframesync_step(_q, _x, &mf_out);\n    if (!sample_available)\n        return LIQUID_OK;\n    _q->payload_spread[_q->symbol_counter % synth_crcf_get_length(_q->payload_synth)] = mf_out;\n    ++_q->symbol_counter;\n    if (_q->symbol_counter % synth_crcf_get_length(_q->payload_synth) != 0)\n        return LIQUID_OK;\n    int payload_complete = dsssframesync_decode_payload(_q);\n    if (!payload_complete)\n        return LIQUID_OK;\n    _q->framesyncstats.check = qpacketmodem_get_crc(_q->payload_decoder);\n    _q->framesyncstats.fec0  = qpacketmodem_get_fec0(_q->payload_decoder);\n    _q->framesyncstats.fec1  = qpacketmodem_get_fec1(_q->payload_decoder);\n    if (_q->callback != NULL) {\n        _q->callback(_q->header_dec,\n                     _q->header_valid,\n                     _q->payload_dec,\n                     _q->payload_dec_len,\n                     _q->payload_valid,\n                     _q->framesyncstats,\n                     _q->userdata);\n    }\n    return dsssframesync_reset(_q);\n}\nint dsssframesync_execute(dsssframesync _q, float complex * _x, unsigned int _n)\n{\n    unsigned int i;\n    for (i = 0; i < _n; i++) {\n        switch (_q->state) {\n        case DSSSFRAMESYNC_STATE_DETECTFRAME:\n            dsssframesync_execute_seekpn(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPREAMBLE:\n            dsssframesync_execute_rxpreamble(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXHEADER:\n            dsssframesync_execute_rxheader(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPAYLOAD:\n            dsssframesync_execute_rxpayload(_q, _x[i]);\n            break;\n        default:\n            return liquid_error(LIQUID_EINT,""dsssframesync_execute(), invalid internal state"");\n        }\n    }\n    return LIQUID_OK;\n}\nint dsssframesync_reset(dsssframesync _q)\n{\n    qdetector_cccf_reset(_q->detector);\n    nco_crcf_reset(_q->mixer);\n    nco_crcf_reset(_q->pll);\n    firpfb_crcf_reset(_q->mf);\n    _q->state            = DSSSFRAMESYNC_STATE_DETECTFRAME;\n    _q->preamble_counter = 0;\n    _q->symbol_counter   = 0;\n    _q->framesyncstats.evm = 0.f;\n    return LIQUID_OK;\n}\nint dsssframesync_execute(dsssframesync _q, float complex * _x, unsigned int _n)\n{\n    unsigned int i;\n    for (i = 0; i < _n; i++) {\n        switch (_q->state) {\n        case DSSSFRAMESYNC_STATE_DETECTFRAME:\n            dsssframesync_execute_seekpn(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPREAMBLE:\n            dsssframesync_execute_rxpreamble(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXHEADER:\n            dsssframesync_execute_rxheader(_q, _x[i]);\n            break;\n        case DSSSFRAMESYNC_STATE_RXPAYLOAD:\n            dsssframesync_execute_rxpayload(_q, _x[i]);\n            break;\n        default:\n            return liquid_error(LIQUID_EINT,""dsssframesync_execute(), invalid internal state"");\n        }\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Please provide a prompt that describes a scenario where you need to implement Hamming (128, 120) forward error correction for a communication system that includes encoding and decoding functionalities.","//...\nint fec_hamming128_encode(fec             _q,\n                          unsigned int    _dec_msg_len,\n                          unsigned char * _msg_dec,\n                          unsigned char * _msg_enc)\n{\n    unsigned int i, j=0;    \n    unsigned char s0, s1;   \n    unsigned int m0, m1;    \n    unsigned int r = _dec_msg_len % 2;\n    for (i=0; i<_dec_msg_len-r; i+=2) {\n        s0 = _msg_dec[i+0];\n        s1 = _msg_dec[i+1];\n#if FEC_HAMMING128_ENC_GENTAB\n        m0 = hamming128_enc_gentab[s0];\n        m1 = hamming128_enc_gentab[s1];\n#else\n        m0 = fec_hamming128_encode_symbol(s0);\n        m1 = fec_hamming128_encode_symbol(s1);\n#endif\n        _msg_enc[j+0] =  (m0 >> 4) & 0xff;\n        _msg_enc[j+1] = ((m0 << 4) & 0xf0) | ((m1 >> 8) & 0x0f);\n        _msg_enc[j+2] =  (m1     ) & 0xff;\n        j += 3;\n    }\n    if (r) {\n        s0 = _msg_dec[_dec_msg_len-1];\n#if FEC_HAMMING128_ENC_GENTAB\n        m0 = hamming128_enc_gentab[s0];\n#else\n        m0 = fec_hamming128_encode_symbol(s0);\n#endif\n        _msg_enc[j+0] = ( m0 & 0x0ff0 ) >> 4;\n        _msg_enc[j+1] = ( m0 & 0x000f ) << 4;\n        j += 2;\n    }\n    assert(j== fec_get_enc_msg_length(LIQUID_FEC_HAMMING128,_dec_msg_len));\n    return LIQUID_OK;\n}\nunsigned int fec_hamming128_encode_symbol(unsigned int _sym_dec)\n{\n    if (_sym_dec >= (1<<8)) {\n        liquid_error(LIQUID_EICONFIG,""fec_hamming128_encode(), input symbol too large"");\n        return 0;\n    }\n    unsigned int p1 = liquid_bdotprod_uint16(_sym_dec, HAMMING128_M1);\n    unsigned int p2 = liquid_bdotprod_uint16(_sym_dec, HAMMING128_M2);\n    unsigned int p4 = liquid_bdotprod_uint16(_sym_dec, HAMMING128_M4);\n    unsigned int p8 = liquid_bdotprod_uint16(_sym_dec, HAMMING128_M8);\n#if DEBUG_FEC_HAMMING128\n    printf(""parity bits (p1,p2,p4,p8) : (%1u,%1u,%1u,%1u)\\n"", p1, p2, p4, p8);\n#endif\n    unsigned int sym_enc = ((_sym_dec & 0x000f) << 0) |\n                           ((_sym_dec & 0x0070) << 1) |\n                           ((_sym_dec & 0x0080) << 2) |\n                           ( p1 << 11 ) |\n                           ( p2 << 10 ) |\n                           ( p4 << 8  ) |\n                           ( p8 << 4  );\n    return sym_enc;\n}\nunsigned int fecsoft_hamming128_decode(unsigned char * _soft_bits)\n{\n    unsigned int d;             \n    unsigned int dmin = 0;      \n    unsigned int s_hat = 0;     \n    unsigned int c;             \n    unsigned int s;\n    for (s=0; s<256; s++) {\n#if FEC_HAMMING128_ENC_GENTAB\n        c = hamming128_enc_gentab[s];\n#else\n        c = fec_hamming128_encode_symbol(s);\n#endif\n        d = 0;\n        d += (c & 0x0800) ? 255 - _soft_bits[ 0] : _soft_bits[ 0];\n        d += (c & 0x0400) ? 255 - _soft_bits[ 1] : _soft_bits[ 1];\n        d += (c & 0x0200) ? 255 - _soft_bits[ 2] : _soft_bits[ 2];\n        d += (c & 0x0100) ? 255 - _soft_bits[ 3] : _soft_bits[ 3];\n        d += (c & 0x0080) ? 255 - _soft_bits[ 4] : _soft_bits[ 4];\n        d += (c & 0x0040) ? 255 - _soft_bits[ 5] : _soft_bits[ 5];\n        d += (c & 0x0020) ? 255 - _soft_bits[ 6] : _soft_bits[ 6];\n        d += (c & 0x0010) ? 255 - _soft_bits[ 7] : _soft_bits[ 7];\n        d += (c & 0x0008) ? 255 - _soft_bits[ 8] : _soft_bits[ 8];\n        d += (c & 0x0004) ? 255 - _soft_bits[ 9] : _soft_bits[ 9];\n        d += (c & 0x0002) ? 255 - _soft_bits[10] : _soft_bits[10];\n        d += (c & 0x0001) ? 255 - _soft_bits[11] : _soft_bits[11];\n        if (d < dmin || s==0) {\n            s_hat = s;\n            dmin = d;\n        }\n    }\n    return s_hat;\n}\n//...')
"
"'Given the technical scenario of a network communication application that can be used to create client-server connections and perform various network operations such as getting TCP information, resolving domain names to IP addresses, and sending/receiving data over TCP connections, the prompt could have been:. . ""Design and implement a network communication application that utilizes a custom socket library. The application should support functionalities like creating a server or client connection, sending and receiving data over TCP connections, retrieving TCP information, resolving domain names to IP addresses, and handling interruptions like Ctrl+C. Please provide the code for this application.""","//...\nstatic void on_connect_client(struct sock_client *c, struct sock_connection *conn)\n{\n    printf(""on_connect_client: fd=%d local=%s:%d, remote=%s:%d\\n"", c->conn->fd,\n            conn->local.ip_str, conn->local.port,\n            conn->remote.ip_str, conn->remote.port);\n#if defined (OS_LINUX)\n    int ret=0;\n    struct tcp_info tcpi;\n    if (conn->type == SOCK_STREAM) {\n        memset(&tcpi, 0, sizeof(tcpi));\n        ret = sock_get_tcp_info(conn->fd, &tcpi);\n        if (ret == 0) {\n            printf(""unrecovered=%u ""\n                 ""rto=%u ato=%u snd_mss=%u rcv_mss=%u ""\n                 ""lost=%u retrans=%u rtt=%u rttvar=%u ""\n                 ""sshthresh=%u cwnd=%u total_retrans=%u\\n"",\n                 tcpi.tcpi_retransmits,  \n                 tcpi.tcpi_rto,          \n                 tcpi.tcpi_ato,          \n                 tcpi.tcpi_snd_mss,\n                 tcpi.tcpi_rcv_mss,\n                 tcpi.tcpi_lost,         \n                 tcpi.tcpi_retrans,      \n                 tcpi.tcpi_rtt,          \n                 tcpi.tcpi_rttvar,       \n                 tcpi.tcpi_snd_ssthresh,\n                 tcpi.tcpi_snd_cwnd,\n                 tcpi.tcpi_total_retrans);  \n        }\n    }\n#endif\n}\nint main(int argc, char **argv)\n{\n    char buf[64];\n    int n;\n    uint16_t port;\n    const char *ip;\n    struct sock_server *ss;\n    struct sock_client *sc;\n    if (argc < 2) {\n        usage();\n        exit(0);\n    }\n#if defined (OS_LINUX)\n    sock_get_local_info();\n    signal(SIGINT, ctrl_c_op);\n#endif\n    if (!strcmp(argv[1], ""-s"")) {\n        if (argc == 3)\n            port = atoi(argv[2]);\n        else\n            port = 0;\n        ss = sock_server_create(NULL, port, SOCK_TYPE_TCP);\n        sock_server_set_callback(ss, on_connect_server, on_recv_buf, NULL);\n        sock_server_dispatch(ss);\n    } else if (!strcmp(argv[1], ""-S"")) {\n        if (argc == 3)\n            port = atoi(argv[2]);\n        else\n            port = 0;\n#ifdef ENABLE_PTCP\n        ss = sock_server_create(NULL, port, SOCK_TYPE_PTCP);\n        printf(""sock_server_create PTCP success!\\n"");\n        sock_server_set_callback(ss, on_connect_server, on_recv_buf, NULL);\n        sock_server_dispatch(ss);\n#endif\n    } else if (!strcmp(argv[1], ""-c"")) {\n        if (argc == 3) {\n            ip = ""127.0.0.1"";\n            port = atoi(argv[2]);\n        } else if (argc == 4) {\n            ip = argv[2];\n            port = atoi(argv[3]);\n        } else {\n            printf(""ip:port need input\\n"");\n            return -1;\n        }\n        sc = sock_client_create(ip, port, SOCK_TYPE_TCP);\n        sock_client_set_callback(sc, on_connect_client, on_recv_buf_cli, NULL);\n        sock_client_connect(sc);\n        while (1) {\n            memset(buf, 0, sizeof(buf));\n            printf(""input> "");\n            scanf(""%63s"", buf);\n            printf(""%s:%d fd=%d\\n"", __func__, __LINE__, sc->fd);\n            n = sock_send(sc->fd, buf, strlen(buf));\n            if (n == -1) {\n                printf(""sock_send failed!\\n"");\n                return -1;\n            }\n        }\n    } else if (!strcmp(argv[1], ""-C"")) {\n        if (argc == 3) {\n            ip = ""127.0.0.1"";\n            port = atoi(argv[2]);\n        } else if (argc == 4) {\n            ip = argv[2];\n            port = atoi(argv[3]);\n        } else {\n            printf(""ip:port need input\\n"");\n            return -1;\n        }\n#ifdef ENABLE_PTCP\n        sc = sock_client_create(ip, port, SOCK_TYPE_PTCP);\n        sock_client_set_callback(sc, on_connect_client, on_recv_buf_cli, NULL);\n        sock_client_connect(sc);\n        while (1) {\n            memset(buf, 0, sizeof(buf));\n            printf(""input> "");\n            scanf(""%s"", buf);\n            n = sock_send(sc->conn->fd64, buf, strlen(buf));\n            if (n == -1) {\n                printf(""sock_send failed!\\n"");\n                return -1;\n            }\n        }\n#endif\n    }\n    if (!strcmp(argv[1], ""-t"")) {\n        addr_test();\n    }\n    if (!strcmp(argv[1], ""-d"")) {\n        domain_test();\n    }\n    while (1) sleep(1);\n    return 0;\n}\nvoid ctrl_c_op(int signo)\n{\n    exit(0);\n}\nstatic void on_recv_buf(struct sock_server *s, void *buf, size_t len)\n{\n    printf(""%s:%d fd = %d, recv buf = %s\\n"", __func__, __LINE__, s->fd, (char *)buf);\n}\nvoid domain_test()\n{\n#if defined (OS_LINUX)\n    void *p;\n    char str[SOCK_ADDR_LEN];\n    sock_addr_list_t *tmp;\n    if (0 == sock_get_local_list(&tmp, 0)) {\n        for (; tmp; tmp = tmp->next) {\n            sock_addr_ntop(str, tmp->addr.ip);\n            printf(""ip = %s port = %d\\n"", str, tmp->addr.port);\n        }\n    }\n    if (0 == sock_getaddrinfo(&tmp, ""www.sina.com"", ""3478"")) {\n        for (; tmp; tmp = tmp->next) {\n            sock_addr_ntop(str, tmp->addr.ip);\n            printf(""ip = %s port = %d\\n"", str, tmp->addr.port);\n        }\n    }\n    if (0 == sock_gethostbyname(&tmp, ""www.baidu.com"")) {\n        for (; tmp; tmp = tmp->next) {\n            sock_addr_ntop(str, tmp->addr.ip);\n            printf(""ip = %s port = %d\\n"", str, tmp->addr.port);\n        }\n    }\n    do {\n        p = tmp;\n        if (tmp) tmp = tmp->next;\n        if (p) free(p);\n    } while (tmp);\n    #endif\n}\nvoid usage()\n{\n    fprintf(stderr, ""./test_libsock -s port\\n""\n                    ""./test_libsock -c ip port\\n"");\n}\nstatic void on_connect_server(struct sock_server *s, struct sock_connection *conn)\n{\n    printf(""on_connect_server: fd=%d local=%s:%d, remote=%s:%d\\n"", conn->fd,\n            conn->local.ip_str, conn->local.port,\n            conn->remote.ip_str, conn->remote.port);\n}\nvoid addr_test()\n{\n    char str_ip[SOCK_ADDR_LEN];\n    uint32_t net_ip;\n    net_ip = sock_addr_pton(""192.168.1.123"");\n    printf(""ip = %x\\n"", net_ip);\n    sock_addr_ntop(str_ip, net_ip);\n    printf(""ip = %s\\n"", str_ip);\n}\nstatic void on_recv_buf_cli(struct sock_client *c, void *buf, size_t len)\n{\n    printf(""%s:%d fd = %d, recv buf = %s\\n"", __func__, __LINE__, c->fd, (char *)buf);\n}\nvoid domain_test()\n{\n#if defined (OS_LINUX)\n    void *p;\n    char str[SOCK_ADDR_LEN];\n    sock_addr_list_t *tmp;\n    if (0 == sock_get_local_list(&tmp, 0)) {\n        for (; tmp; tmp = tmp->next) {\n            sock_addr_ntop(str, tmp->addr.ip);\n            printf(""ip = %s port = %d\\n"", str, tmp->addr.port);\n        }\n    }\n    if (0 == sock_getaddrinfo(&tmp, ""www.sina.com"", ""3478"")) {\n        for (; tmp; tmp = tmp->next) {\n            sock_addr_ntop(str, tmp->addr.ip);\n            printf(""ip = %s port = %d\\n"", str, tmp->addr.port);\n        }\n    }\n    if (0 == sock_gethostbyname(&tmp, ""www.baidu.com"")) {\n        for (; tmp; tmp = tmp->next) {\n            sock_addr_ntop(str, tmp->addr.ip);\n            printf(""ip = %s port = %d\\n"", str, tmp->addr.port);\n        }\n    }\n    do {\n        p = tmp;\n        if (tmp) tmp = tmp->next;\n        if (p) free(p);\n    } while (tmp);\n    #endif\n}\n//...'"
"('Prompt: You are tasked with creating a testbench function to evaluate a finite impulse response (FIR) filter with a Rnyquist filter design using various parameters. The function should calculate the cross-correlation of the filter coefficients, root mean square intersymbol interference (isi_rms), and energy spread (As). The function should also perform assertions based on the calculated values. The specific scenario you need to address is to test the FIR filter with Rnyquist design using the RKAISER method with parameters: k=20, m=40, beta=0.20, and dt=0.5.. . Response: . void testbench_firfilt_rnyquist(int          _ftype,.                                 unsigned int _k,    .                                 unsigned int _m,    .                                 float        _beta, .                                 float        _dt)   . {.     unsigned int i;.     unsigned int h_len  = 2*_k*_m+1;  .     unsigned int hc_len = 4","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\nvoid autotest_firfilt_rnyquist_9(){ testbench_firfilt_rnyquist(LIQUID_FIRFILT_RKAISER, 20,40,0.20f,0.5f); }\n//...')
"
"'Please provide code for a Reed-Solomon error correction calculator where the finite field multiplication is performed using a Galois Field GF(2^8) with polynomial 0x11D, and the remainder calculation function applies this field multiplication to generate error correction data for a given data set when provided with a generator polynomial.","//...\ntestable uint8_t finiteFieldMultiply(uint8_t x, uint8_t y)\n{\n    uint8_t z = 0;\n    for(int i = 7; i >= 0; i--) {\n        z = (z << 1) ^ ((z >> 7) * 0x11D);\n        z ^= ((y >> i) & 1) * x;\n    }\n    return z;\n}\ntestable void calcReedSolomonRemainder(const uint8_t data[], int dataLen,\n                                       const uint8_t generator[], int degree, uint8_t result[])\n{\n    LV_ASSERT(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);\n    memset(result, 0, degree * sizeof(result[0]));\n    for(int i = 0; i < dataLen; i++) {\n        uint8_t factor = data[i] ^ result[0];\n        memmove(&result[0], &result[1], (degree - 1) * sizeof(result[0]));\n        result[degree - 1] = 0;\n        for(int j = 0; j < degree; j++)\n            result[j] ^= finiteFieldMultiply(generator[j], factor);\n    }\n}\n//...'"
"'Prompt: You are working on a project involving a LM3S69XX microcontroller and need to write code to enable various clock signals for different peripherals. Write code snippets for functions to enable GPIO, UART, SSI, and PWM clocks. Each function should take a port number and a boolean enable parameter and modify the corresponding register in the lm3s69xx_syscon struct. Be sure to include a function to delay 3 clock cycles after modifying the register.","static void delay_3_clocks(void)\n{\n  asm volatile(\n      ""nop\\n\\t""\n      ""nop\\n\\t""\n      ""nop"");\n}\nvoid __attribute__((naked)) lm3s69xx_syscon_delay_3x_clocks(unsigned long x_count)\n{\n    asm volatile(\n                 ""subs  r0, #1\\n\\t""\n                 ""bne   lm3s69xx_syscon_delay_3x_clocks\\n\\t""\n                 ""bx    lr""\n                 );\n}\nvoid lm3s69xx_syscon_enable_gpio_clock(unsigned int port, bool enable)\n{\n  volatile lm3s69xx_syscon *syscon = LM3S69XX_SYSCON;\n  uint32_t mask = 1 << port;\n  rtems_interrupt_level level;\n  rtems_interrupt_disable(level);\n  if (enable)\n    syscon->rcgc2 |= mask;\n  else\n    syscon->rcgc2 &= ~mask;\n  delay_3_clocks();\n  rtems_interrupt_enable(level);\n}\nvoid lm3s69xx_syscon_enable_uart_clock(unsigned int port, bool enable)\n{\n  volatile lm3s69xx_syscon *syscon = LM3S69XX_SYSCON;\n  uint32_t mask = 1 << port;\n  rtems_interrupt_level level;\n  rtems_interrupt_disable(level);\n  if (enable)\n    syscon->rcgc1 |= mask;\n  else\n    syscon->rcgc1 &= ~mask;\n  delay_3_clocks();\n  rtems_interrupt_enable(level);\n}\nvoid lm3s69xx_syscon_enable_ssi_clock(unsigned int port, bool enable)\n{\n  volatile lm3s69xx_syscon *syscon = LM3S69XX_SYSCON;\n  uint32_t mask = 1 << (port + 4);\n  rtems_interrupt_level level;\n  rtems_interrupt_disable(level);\n  if (enable)\n    syscon->rcgc1 |= mask;\n  else\n    syscon->rcgc1 &= ~mask;\n  delay_3_clocks();\n  rtems_interrupt_enable(level);\n}\nvoid lm3s69xx_syscon_enable_pwm_clock(bool enable)\n{\n  volatile lm3s69xx_syscon *syscon = LM3S69XX_SYSCON;\n  rtems_interrupt_level level;\n  rtems_interrupt_disable(level);\n  if (enable)\n    syscon->rcgc0 |= SYSCONRCGC0_PWM;\n  else\n    syscon->rcgc0 &= ~SYSCONRCGC0_PWM;\n  delay_3_clocks();\n  rtems_interrupt_enable(level);\n}\nvoid lm3s69xx_syscon_set_pwmdiv(unsigned int div)\n{\n  volatile lm3s69xx_syscon *syscon = LM3S69XX_SYSCON;\n  rtems_interrupt_level level;\n  rtems_interrupt_disable(level);\n  syscon->rcc = (syscon->rcc & ~SYSCONRCC_PWMDIV_MSK) | SYSCONRCC_PWMDIV(div)\n      | SYSCONRCC_USEPWMDIV;\n  rtems_interrupt_enable(level);\n}'"
"('Prompt: In a testing scenario for a Linear Feedback Shift Register (LFSR) implementation using the code provided, verify the period of the LFSR generator for a specific m-value. Write a function that creates a default LFSR generator with the given m value, measures its period, and compares it to the expected period calculated based on the m-value. Make sure to include a test function that calls this function with an m-value of 6.","//...\nvoid msequence_test_period(unsigned int _m)\n{\n    msequence q = msequence_create_default(_m);\n    unsigned int n = (1U << _m) - 1;\n    unsigned int p = msequence_measure_period(q);\n    CONTEND_EQUALITY(p,n)\n    msequence_destroy(q);\n}\nvoid autotest_msequence_period_m6()  { msequence_test_period(6);  }\n//...')
"
"('You need to test the phase error of the demodulator for a binary phase shift keying (BPSK) modulation scheme. This test function creates a modulator and a demodulator using BPSK modulation, modulates a symbol, adds some noise, demodulates it back, and confirms that the output symbol matches the input symbol. The code then checks if the phase error of the demodulator is within certain thresholds for the BPSK modulation.. . Prompt: Develop a test function that checks the phase error of the demodulator for a BPSK modulation scheme. The test should include modulating and demodulating symbols with added noise, and verifying that the demodulator output matches the input symbol. Also, ensure that the phase error of the demodulator is within set thresholds for both positive and negative phases.","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_bpsk()     { modemcf_test_demodstats(LIQUID_MODEM_BPSK);     }\n//...')
"
"('Prompt: . . In a project focused on optimizing the performance of signal processing algorithms, you are tasked with implementing a benchmark function for a pre-synced cyclic prefix continuous-complex pre-transform function with a block size of 16 samples. Can you provide the code for the benchmark_presync_cccf_16 function?","//...\nvoid benchmark_presync_cccf_16   P\n//...')
"
"'Prompt: You are working on a project that involves image processing with neon optimization, and you need to write a function to save a JPEG file. The function should take a file name and a structure containing image data as input and return 0 if successful. You have access to the neon structure `yuv_neon` and need to write the `save_jpeg_file` function using it along with handling file operations correctly.","//...\n      yuv_neon.in = yuv->uv_addr_offset;\n      for (i = 0; i < yuv->height; i++) {\n        yuv_neon.v = output;\n        yuv_neon.u = output + width * height;\n#define WIDTH \t1920\n    int fd = -1;\n    return 0;\n    struct jpeg *jpeg = je_jpeg_new(WIDTH, HEIGH);\nint save_jpeg_file(char *filename, struct je_jpeg *jpeg)\n{\n    int fd = -1;\n    if ((fd = open(filename, O_CREAT | O_TRUNC | O_WRONLY, 0777)) < 0) {\n      perror(""Failed to open file\\n"");\n      return -1;\n    }\n    if (write(fd, jpeg->data.iov_base, jpeg->data.iov_len) < 0) {\n      perror(""Failed to sava data into file\\n"");\n      return -1;\n    }\n    close(fd);\n    return 0;\n}\n//...'"
"('Prompt: Can you provide me with a C function that calculates the inverse Gaussian cumulative distribution function based on an input vector? The function should take a void pointer to user data, a float pointer to the input vector, and an unsigned integer denoting the length of the vector. If the input vector length is zero, the function should return an error. The function should perform computations on the input vector according to the inverse Gaussian cumulative distribution formula and return the result as a float value.","//...\nfloat liquid_invgauss(void *       _userdata,\n                      float *      _v,\n                      unsigned int _n)\n{\n    if (_n == 0) {\n        liquid_error(LIQUID_EICONFIG,""liquid_invgauss(), input vector length cannot be zero"");\n        return 0.0f;\n    }\n    float t = 0.0f;\n    float sigma = 1.0f;\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        t += (_v[i]-1.0f)*(_v[i]-1.0f) / (sigma*sigma);\n        sigma *= 1.5f;\n    }\n    return 1 - expf(-t);\n}\n//...')
"
"('Prompt: Can you provide code to test the functionality of a modem that can modulate and demodulate signals using the 16-level Amplitude Shift Keying (ASK16) modulation scheme?. . Response:. //.... void modemcf_test_mod_demod(modulation_scheme _ms). {.     modemcf mod   = modemcf_create(_ms);.     modemcf demod = modemcf_create(_ms);.     unsigned int i, s, M = 1 << modemcf_get_bps(mod);.     float complex x;.     float e = 0.0f;.     for (i=0; i<M; i++) {.         modemcf_modulate(mod, i, &x);.         modemcf_demodulate(demod, x, &s);.         CONTEND_EQUALITY(s, i);.         CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);.         CONTEND_DELTA( modem","//...\nvoid modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_ask16()     { modemcf_test_mod_demod(LIQUID_MODEM_ASK16);     }\n//...')
"
"(""Prompt: You are designing a program for OFDM frame synchronization and signal processing. To aid in debugging and analyzing the program's performance, you want to implement a function that enables debug mode with specific buffers and variables to store intermediate values. Can you provide a code snippet for a function `ofdmframesync_debug_enable()` that initializes various debug buffers and objects such as `debug_x`, `debug_rssi`, `debug_framesyms`, `G_hat`, `px`, `py`, `debug_pilot_0`, and `debug_pilot_1` based on the configuration settings? Ensure that the function properly allocates memory for the debug objects and returns with an OK status if debug mode is enabled at compile time.","//...\n    unsigned int M;         \n    unsigned char * p;      \n    unsigned int M_pilot;   \n    float complex * x;      \n    float complex * G;      \n    float complex * B;      \n    float complex * R;      \n#define DEBUG_OFDMFRAMESYNC             0\n    int debug_objects_created;\n    windowcf debug_x;\n    windowf  debug_rssi;\n    windowcf debug_framesyms;\n        float complex G_hat = 0.0f;\n    float * px;             \n    float * py;             \n    windowf debug_pilot_0;  \n    windowf debug_pilot_1;  \n    for (i=0; i<_q->M; i++)\n        float complex w;\n        for (j=0; j<_q->M; j++) {\n    return LIQUID_OK;\nint ofdmframesync_debug_enable(ofdmframesync _q)\n{\n#if DEBUG_OFDMFRAMESYNC\n    if (_q->debug_objects_created)\n        return LIQUID_OK;\n    _q->debug_x         = windowcf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);\n    _q->debug_rssi      = windowf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);\n    _q->debug_framesyms = windowcf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);\n    _q->G_hat           = (float complex*) malloc((_q->M)*sizeof(float complex));\n    _q->px = (float*) malloc((_q->M_pilot)*sizeof(float));\n    _q->py = (float*) malloc((_q->M_pilot)*sizeof(float));\n    _q->debug_pilot_0 = windowf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);\n    _q->debug_pilot_1 = windowf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);\n    _q->debug_enabled   = 1;\n    _q->debug_objects_created = 1;\n    return LIQUID_OK;\n#else\n    return liquid_error(LIQUID_EICONFIG,""ofdmframesync_debug_enable(): compile-time debugging disabled"");\n#endif\n}\n//...')
"
"('Prompt: You are tasked with creating a function that tests the spectral estimation performance of a signal processing library using a spectrogram. The function should generate a noise signal, calculate its power spectral density using a spectrogram, and compare the results to a predefined noise floor value with a certain tolerance. The function takes parameters such as FFT size, window type, noise floor level, etc. Write a test function for the specific scenario where the FFT size is 400, window type is Hamming, noise floor level is -80.0 dB, window length is 400, and delay is 100.","//...\nvoid testbench_spgramcf_noise(unsigned int _nfft,\n                              unsigned int _wlen,\n                              unsigned int _delay,\n                              int          _wtype,\n                              float        _noise_floor)\n{\n    unsigned int num_samples = 2000*_nfft;  \n    float        nstd        = powf(10.0f,_noise_floor/20.0f); \n    float        tol         = 0.5f; \n    if (liquid_autotest_verbose) {\n        printf(""  spgramcf test  (noise): nfft=%6u, wtype=%24s, noise floor=%6.1f\\n"",\n                _nfft, liquid_window_str[_wtype][1], _noise_floor);\n    }\n    spgramcf q = NULL;\n    if (_wlen==0 || _delay==0 || _wtype==LIQUID_WINDOW_UNKNOWN)\n        q = spgramcf_create_default(_nfft);\n    else\n        q = spgramcf_create(_nfft, _wtype, _wlen, _delay);\n    unsigned int i;\n    for (i=0; i<num_samples; i++)\n        spgramcf_push(q, nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2);\n    CONTEND_EQUALITY(spgramcf_get_num_samples(q),       num_samples);\n    CONTEND_EQUALITY(spgramcf_get_num_samples_total(q), num_samples);\n    float psd[_nfft];\n    spgramcf_get_psd(q, psd);\n    for (i=0; i<_nfft; i++)\n        CONTEND_DELTA(psd[i], _noise_floor, tol)\n    spgramcf_destroy(q);\n}\nvoid autotest_spgramcf_noise_custom_0() { testbench_spgramcf_noise(400, 400, 100, LIQUID_WINDOW_HAMMING, -80.0); }\n//...')
"
"('Prompt: As part of a software testing scenario for an equalizer Least Mean Squares (eqlms) configuration, could you provide a set of tests to verify various configurations and functionalities in the eqlms_cccf module? The goal is to ensure that the eqlms implementation is robust and handles invalid configurations correctly. Specifically, we need tests to check for creating eqlms objects with different parameters, setting bandwidth, executing decimation, copying coefficients, and destroying eqlms objects. We also want to verify that certain error conditions are correctly handled.","//...\nvoid autotest_eqlms_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping eqlms config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER, 0, 12, 0.3f, 0.0f));\n    CONTEND_ISNULL(eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER, 2,  0, 0.3f, 0.0f));\n    CONTEND_ISNULL(eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER, 2, 12, 2.0f, 0.0f));\n    CONTEND_ISNULL(eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER, 2, 12, 0.3f,-2.0f));\n    CONTEND_ISNULL(eqlms_cccf_create_lowpass( 0, 0.1f));\n    CONTEND_ISNULL(eqlms_cccf_create_lowpass(13,-0.1f));\n    unsigned int i, k=2, m=3, h_len = 2*k*m+1;\n    eqlms_cccf q = eqlms_cccf_create(NULL, h_len);\n    CONTEND_EQUALITY(LIQUID_OK, eqlms_cccf_print(q));\n    CONTEND_EQUALITY(eqlms_cccf_get_length(q), h_len);\n    float mu = 0.1f;\n    eqlms_cccf_set_bw(q, mu);\n    CONTEND_EQUALITY(eqlms_cccf_get_bw(q), mu);\n    CONTEND_INEQUALITY(LIQUID_OK, eqlms_cccf_set_bw(q, -1));\n    CONTEND_INEQUALITY(LIQUID_OK, eqlms_cccf_decim_execute(q, NULL, NULL, 0));\n    float complex h[h_len];\n    eqlms_cccf_copy_coefficients(q, h);\n    for (i=0; i<h_len; i++)\n        CONTEND_EQUALITY(h[i], i==k*m ? 1 : 0);\n    const float complex * w = eqlms_cccf_get_coefficients(q);\n    for (i=0; i<h_len; i++)\n        CONTEND_EQUALITY(w[i], i==k*m ? 1 : 0);\n    eqlms_cccf_destroy(q);\n}\n//...')
"
('Prompt: Write a C code snippet that multiplies two complex matrices `matrixcf_data_mul_x` and `matrixcf_data_mul_y` element-wise and store the result in a new complex matrix `matrixcf_data_mul_z`. Detail the technical scenario:. . You have two float complex arrays `matrixcf_data_mul_x` and `matrixcf_data_mul_y` containing complex numbers. Each array represents a matrix with the same dimensions. You need to multiply the corresponding elements of these matrices to perform element-wise multiplication and store the results in a new complex array `matrixcf_data_mul_z`.,"float complex matrixcf_data_mul_x[] = {\n    1.131277322769 +  -2.908640623093*_Complex_I ,\n    0.847201466560 +  -1.637244105339*_Complex_I ,\n   -2.173580169678 +   0.096817605197*_Complex_I ,\n    0.792498826981 +  -0.358158409595*_Complex_I ,\n   -0.243082717061 +   0.824095964432*_Complex_I ,\n   -1.889652967453 +   0.283876717091*_Complex_I ,\n    0.044418141246 +  -0.882465064526*_Complex_I ,\n    0.515216410160 +  -0.366532146931*_Complex_I ,\n    0.579283773899 +   1.173513293266*_Complex_I ,\n    0.059265002608 +  -0.497733235359*_Complex_I ,\n   -0.877321839333 +   0.404732406139*_Complex_I ,\n   -0.794282734394 +   0.456011295319*_Complex_I ,\n   -1.174414634705 +  -1.358565688133*_Complex_I ,\n   -0.418152034283 +   1.380919337273*_Complex_I ,\n   -0.747197151184 +   1.584241986275*_Complex_I ,\n   -0.522293865681 +  -0.573823392391*_Complex_I ,\n   -1.866284489632 +  -0.199214607477*_Complex_I ,\n   -0.453905433416 +   0.452787637711*_Complex_I ,\n    1.989426016808 +  -1.771166682243*_Complex_I ,\n    2.234328985214 +   0.855401337147*_Complex_I };\nfloat complex matrixcf_data_mul_y[] = {\n    0.122429788113 +  -1.041572093964*_Complex_I ,\n   -1.123313307762 +  -1.396123170853*_Complex_I ,\n   -0.318034142256 +  -0.537796914577*_Complex_I ,\n    0.096901215613 +  -0.035752061754*_Complex_I ,\n    0.423960685730 +  -0.379842221737*_Complex_I ,\n   -0.184147700667 +   0.022100308910*_Complex_I ,\n    0.189968794584 +   0.919595599174*_Complex_I ,\n    0.621766507626 +  -0.634516119957*_Complex_I ,\n    0.605251312256 +   1.410223841667*_Complex_I ,\n    0.427330523729 +   0.042397715151*_Complex_I ,\n    0.204851210117 +   0.611065924168*_Complex_I ,\n    0.562124013901 +   0.047597970814*_Complex_I };\nfloat complex matrixcf_data_mul_z[] = {\n   -3.015598273252 +  -3.823225604286*_Complex_I ,\n   -6.503138041472 +   2.522251659946*_Complex_I ,\n   -3.033435877267 +  -2.533375977709*_Complex_I ,\n    1.711291176504 +   0.187568584413*_Complex_I ,\n    0.527484730969 +  -0.085346610822*_Complex_I ,\n    2.440625470928 +  -0.878385559540*_Complex_I ,\n    0.383559143593 +  -1.078745633782*_Complex_I ,\n    0.093675017974 +  -1.944126015771*_Complex_I ,\n   -1.122987739839 +  -1.365514815630*_Complex_I ,\n   -3.347645581625 +   0.552152171890*_Complex_I ,\n    0.554058303745 +   4.932442551750*_Complex_I ,\n   -3.263304464031 +   0.357861697730*_Complex_I ,\n    2.461434774758 +   3.932854324787*_Complex_I ,\n    1.845966920717 +   2.370697350446*_Complex_I ,\n    5.477082880684 +   3.294354034834*_Complex_I };')
"
"('Prompt: Given the technical scenario where you need a function to calculate the Kaiser window shape parameter beta based on the stopband attenuation (_as) value in a digital signal processing application, write a C function that takes the stopband attenuation value as input and returns the corresponding Kaiser beta value. Handle different scenarios for the stopband attenuation value and calculate the beta accordingly.","//...\nfloat kaiser_beta_As(float _as)\n{\n    _as = fabsf(_as);\n    float beta;\n    if (_as > 50.0f)\n        beta = 0.1102f*(_as - 8.7f);\n    else if (_as > 21.0f)\n        beta = 0.5842*powf(_as - 21, 0.4f) + 0.07886f*(_as - 21);\n    else\n        beta = 0.0f;\n    return beta;\n}\n//...')
"
"('Prompt: You are conducting benchmarking tests for different functions involving a variable-controlled oscillator (VCO) in a software-defined radio application. You need to measure the performance of the functions `nco_crcf_sincos`, `nco_crcf_mix_up`, and `nco_crcf_mix_block_up`. Provide code snippets for benchmarking each function in terms of execution time using `struct rusage`, starting with a given `_start` timestamp, ending with `_finish` timestamp, and running for a specified number of iterations stored in `_num_iterations`. Ensure that the VCO is initialized with a phase of 0.0 and frequency of 0.1 in each benchmark function. At the end of each benchmark function, the number of iterations should be multiplied by 16, and the VCO instance should be destroyed.","void benchmark_vco_sincos(struct rusage *_start,\n                          struct rusage *_finish,\n                          unsigned long int *_num_iterations)\n{\n    float s, c;\n    nco_crcf p = nco_crcf_create(LIQUID_VCO);\n    nco_crcf_set_phase(p, 0.0f);\n    nco_crcf_set_frequency(p, 0.1f);\n    unsigned int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        nco_crcf_sincos(p, &s, &c);\n        nco_crcf_step(p);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    nco_crcf_destroy(p);\n}\nvoid benchmark_vco_mix_up(struct rusage *_start,\n                          struct rusage *_finish,\n                          unsigned long int *_num_iterations)\n{\n    float complex x[16],  y[16];\n    memset(x, 0, 16*sizeof(float complex));\n    nco_crcf p = nco_crcf_create(LIQUID_VCO);\n    nco_crcf_set_phase(p, 0.0f);\n    nco_crcf_set_frequency(p, 0.1f);\n    unsigned int i, j;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        for (j=0; j<16; j++) {\n            nco_crcf_mix_up(p, x[j], &y[j]);\n            nco_crcf_step(p);\n        }\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 16;\n    nco_crcf_destroy(p);\n}\nvoid benchmark_vco_mix_block_up(struct rusage *_start,\n                                struct rusage *_finish,\n                                unsigned long int *_num_iterations)\n{\n    float complex x[16], y[16];\n    memset(x, 0, 16*sizeof(float complex));\n    nco_crcf p = nco_crcf_create(LIQUID_VCO);\n    nco_crcf_set_phase(p, 0.0f);\n    nco_crcf_set_frequency(p, 0.1f);\n    unsigned int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        nco_crcf_mix_block_up(p, x, y, 16);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 16;\n    nco_crcf_destroy(p);\n}')
"
"('Please provide a code snippet for an Automatic Gain Control (AGC) algorithm in C that includes functions for creating, copying, destroying, printing, resetting, executing, locking, unlocking, setting parameters (bandwidth, signal level, gain, scale), initializing, enabling/disabling squelch, setting squelch threshold, setting timeout, and updating squelch mode.","#define AGC_DEFAULT_BW   (1e-2f)\nint AGC(_squelch_update_mode)(AGC() _q);\nstruct AGC(_s) {\n    T g;            \n    T scale;        \n    float bandwidth;\n    T alpha;        \n    T y2_prime;     \n    int is_locked;\n    agc_squelch_mode squelch_mode;\n    T squelch_threshold;\n    unsigned int squelch_timeout;\n    unsigned int squelch_timer;\n};\nAGC() AGC(_create)(void)\n{\n    AGC() _q = (AGC()) malloc(sizeof(struct AGC(_s)));\n    AGC(_set_bandwidth)(_q, AGC_DEFAULT_BW);\n    AGC(_reset)(_q);\n    AGC(_squelch_disable)(_q);\n    AGC(_squelch_set_threshold)(_q, 0.0f);\n    AGC(_squelch_set_timeout  )(_q, 100);\n    _q->scale = 1;\n    return _q;\n}\nAGC() AGC(_copy)(AGC() q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""agc_%s_copy(), object cannot be NULL"", EXTENSION_FULL);\n    AGC() q_copy = (AGC()) malloc(sizeof(struct AGC(_s)));\n    memmove(q_copy, q_orig, sizeof(struct AGC(_s)));\n    return q_copy;\n}\nint AGC(_destroy)(AGC() _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\nint AGC(_print)(AGC() _q)\n{\n    printf(""agc [rssi: %12.4f dB, output gain: %.3f dB, bw: %12.4e, locked: %s, squelch: %s]:\\n"",\n            AGC(_get_rssi)(_q),\n            _q->scale > 0 ? 10.*log10f(_q->scale) : -100.0f,\n            _q->bandwidth,\n            _q->is_locked ? ""yes"" : ""no"",\n            _q->squelch_mode == LIQUID_AGC_SQUELCH_DISABLED ? ""disabled"" : ""enabled"");\n    return LIQUID_OK;\n}\nint AGC(_reset)(AGC() _q)\n{\n    _q->g = 1.0f;\n    _q->y2_prime = 1.0f;\n    AGC(_unlock)(_q);\n    _q->squelch_mode = (_q->squelch_mode == LIQUID_AGC_SQUELCH_DISABLED) ?\n        LIQUID_AGC_SQUELCH_DISABLED : LIQUID_AGC_SQUELCH_ENABLED;\n    return LIQUID_OK;\n}\nint AGC(_execute)(AGC() _q,\n                  TC    _x,\n                  TC *  _y)\n{\n    *_y = _x * _q->g;\n    T y2 = crealf( (*_y)*conjf(*_y) );\n    _q->y2_prime = (1.0-_q->alpha)*_q->y2_prime + _q->alpha*y2;\n    if (_q->is_locked)\n        return LIQUID_OK;\n    if (_q->y2_prime > 1e-6f)\n        _q->g *= expf( -0.5f*_q->alpha*logf(_q->y2_prime) );\n    _q->g = (_q->g > 1e6f) ? 1e6f : _q->g;\n    AGC(_squelch_update_mode)(_q);\n    *_y *= _q->scale;\n    return LIQUID_OK;\n}\nint AGC(_execute_block)(AGC()        _q,\n                        TC *         _x,\n                        unsigned int _n,\n                        TC *         _y)\n{\n    unsigned int i;\n    int rc = LIQUID_OK;\n    for (i=0; i<_n; i++) {\n        rc |= AGC(_execute)(_q, _x[i], &_y[i]);\n    }\n    return rc;\n}\nint AGC(_lock)(AGC() _q)\n{\n    _q->is_locked = 1;\n    return LIQUID_OK;\n}\nint AGC(_unlock)(AGC() _q)\n{\n    _q->is_locked = 0;\n    return LIQUID_OK;\n}\nint AGC(_is_locked)(AGC() _q)\n{\n    return _q->is_locked;\n}\nfloat AGC(_get_bandwidth)(AGC() _q)\n{\n    return _q->bandwidth;\n}\nint AGC(_set_bandwidth)(AGC() _q,\n                        float _bt)\n{\n    if ( _bt < 0 )\n        return liquid_error(LIQUID_EICONFIG,""agc_%s_set_bandwidth(), bandwidth must be positive"", EXTENSION_FULL);\n    if ( _bt > 1.0f )\n        return liquid_error(LIQUID_EICONFIG,""agc_%s_set_bandwidth(), bandwidth must less than 1.0"", EXTENSION_FULL);\n    _q->bandwidth = _bt;\n    _q->alpha = _q->bandwidth;\n    return LIQUID_OK;\n}\nfloat AGC(_get_signal_level)(AGC() _q)\n{\n    return 1.0f / _q->g;\n}\nint AGC(_set_signal_level)(AGC() _q,\n                           float _x2)\n{\n    if ( _x2 <= 0 )\n        return liquid_error(LIQUID_EICONFIG,""error: agc_%s_set_signal_level(), bandwidth must be greater than zero"", EXTENSION_FULL);\n    _q->g = 1.0f / _x2;\n    _q->y2_prime = 1.0f;\n    return LIQUID_OK;\n}\nfloat AGC(_get_rssi)(AGC() _q)\n{\n    return -20*log10(_q->g);\n}\nint AGC(_set_rssi)(AGC() _q,\n                   float _rssi)\n{\n    _q->g = powf(10.0f, -_rssi/20.0f);\n    _q->g = (_q->g < 1e-16f) ? 1e-16f : _q->g;\n    _q->y2_prime = 1.0f;\n    return LIQUID_OK;\n}\nfloat AGC(_get_gain)(AGC() _q)\n{\n    return _q->g;\n}\nint AGC(_set_gain)(AGC() _q,\n                   float _gain)\n{\n    if ( _gain <= 0 )\n        return liquid_error(LIQUID_EICONFIG,""error: agc_%s_set_gain(), gain must be greater than zero"", EXTENSION_FULL);\n    _q->g = _gain;\n    return LIQUID_OK;\n}\nfloat AGC(_get_scale)(AGC() _q)\n{\n    return _q->scale;\n}\nint AGC(_set_scale)(AGC() _q,\n                    float _scale)\n{\n    if ( _scale <= 0 )\n        return liquid_error(LIQUID_EICONFIG,""error: agc_%s_set_scale(), scale must be greater than zero"", EXTENSION_FULL);\n    _q->scale = _scale;\n    return LIQUID_OK;\n}\nint AGC(_init)(AGC()        _q,\n               TC *         _x,\n               unsigned int _n)\n{\n    if ( _n == 0 )\n        return liquid_error(LIQUID_EICONFIG,""error: agc_%s_init(), number of samples must be greater than zero"", EXTENSION_FULL);\n    unsigned int i;\n    T x2 = 0;\n    for (i=0; i<_n; i++)\n        x2 += crealf( _x[i]*conjf(_x[i]) );\n    x2 = sqrtf( x2 / (float) _n ) + 1e-16f;\n    AGC(_set_signal_level)(_q, x2);\n    return LIQUID_OK;\n}\nint AGC(_squelch_enable)(AGC() _q)\n{\n    _q->squelch_mode = LIQUID_AGC_SQUELCH_ENABLED;\n    return LIQUID_OK;\n}\nint AGC(_squelch_disable)(AGC() _q)\n{\n    _q->squelch_mode = LIQUID_AGC_SQUELCH_DISABLED;\n    return LIQUID_OK;\n}\nint  AGC(_squelch_is_enabled)(AGC() _q)\n{\n    return _q->squelch_mode == LIQUID_AGC_SQUELCH_DISABLED ? 0 : 1;\n}\nint AGC(_squelch_set_threshold)(AGC() _q,\n                                T     _threshold)\n{\n    _q->squelch_threshold = _threshold;\n    return LIQUID_OK;\n}\nT AGC(_squelch_get_threshold)(AGC() _q)\n{\n    return _q->squelch_threshold;\n}\nint AGC(_squelch_set_timeout)(AGC()        _q,\n                              unsigned int _timeout)\n{\n    _q->squelch_timeout = _timeout;\n    return LIQUID_OK;\n}\nunsigned int AGC(_squelch_get_timeout)(AGC() _q)\n{\n    return _q->squelch_timeout;\n}\nint AGC(_squelch_get_status)(AGC() _q)\n{\n    return _q->squelch_mode;\n}\nint AGC(_squelch_update_mode)(AGC() _q)\n{\n    int threshold_exceeded = (AGC(_get_rssi)(_q) > _q->squelch_threshold);\n    switch (_q->squelch_mode) {\n    case LIQUID_AGC_SQUELCH_ENABLED:\n        _q->squelch_mode = threshold_exceeded ? LIQUID_AGC_SQUELCH_RISE : LIQUID_AGC_SQUELCH_ENABLED;\n        break;\n    case LIQUID_AGC_SQUELCH_RISE:\n        _q->squelch_mode = threshold_exceeded ? LIQUID_AGC_SQUELCH_SIGNALHI : LIQUID_AGC_SQUELCH_FALL;\n        break;\n    case LIQUID_AGC_SQUELCH_SIGNALHI:\n        _q->squelch_mode = threshold_exceeded ? LIQUID_AGC_SQUELCH_SIGNALHI : LIQUID_AGC_SQUELCH_FALL;\n        break;\n    case LIQUID_AGC_SQUELCH_FALL:\n        _q->squelch_mode = threshold_exceeded ? LIQUID_AGC_SQUELCH_SIGNALHI : LIQUID_AGC_SQUELCH_SIGNALLO;\n        _q->squelch_timer = _q->squelch_timeout;\n        break;\n    case LIQUID_AGC_SQUELCH_SIGNALLO:\n        _q->squelch_timer--;\n        if (_q->squelch_timer == 0)\n            _q->squelch_mode = LIQUID_AGC_SQUELCH_TIMEOUT;\n        else if (threshold_exceeded)\n            _q->squelch_mode = LIQUID_AGC_SQUELCH_SIGNALHI;\n        break;\n    case LIQUID_AGC_SQUELCH_TIMEOUT:\n        _q->squelch_mode = LIQUID_AGC_SQUELCH_ENABLED;\n        break;\n    case LIQUID_AGC_SQUELCH_DISABLED:\n        break;\n    case LIQUID_AGC_SQUELCH_UNKNOWN:\n    default:\n        return liquid_error(LIQUID_EINT,""agc_%s_execute(), invalid/unsupported squelch mode: %d"",\n                EXTENSION_FULL, _q->squelch_mode);\n    }\n    return LIQUID_OK;\n}')
"
'Prompt: You are working on integrating LVGL (Light and Versatile Graphics Library) into a project that uses PikaScript for scripting. The project requires a function that retrieves the coordinates of a touch input and stores them in a PikaScript object. Write a function in C that performs this task. Remember to only compile this code if LVGL is included and if defined using PIKASCRIPT.,"#if defined(LV_LVGL_H_INCLUDE_SIMPLE)\n#else\n#endif\n#ifdef PIKASCRIPT\nvoid pika_lvgl_indev_t_get_vect(PikaObj* self, PikaObj* point) {\n    lv_indev_t* lv_indev = obj_getPtr(self, ""lv_indev"");\n    lv_point_t* lv_point = obj_getPtr(point, ""lv_point"");\n    lv_indev_get_vect(lv_indev, lv_point);\n    obj_setInt(point, ""x"", lv_point->x);\n    obj_setInt(point, ""y"", lv_point->y);\n}\n#endif'"
"'Prompt: . Please provide code for initializing and configuring various power management units in a static scenario. This code should include setting control modes, enabling different modes, and configuring specific registers.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.pmu_1""\n#endif\n#define PMU_LDO_LPSR_DIG_TRG_SPX_REG_SETPOINT_COUNTS         4U\n#define PMU_LDO_LPSR_DIG_TRG_SPX_VOLTAGE_SETPOINTX_BIT_WIDTH 8UL\n#define PMU_POWER_DETECT_CTRL_REGISTER (ANADIG_PMU->PMU_POWER_DETECT_CTRL)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_WELL_SELECT_MASK (0x1U)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_MASK  (0x2U)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_SHIFT 1U\n#define PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD(x)                                    \\\n    (((uint32_t)(((uint32_t)(x)) << PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_SHIFT)) & \\\n     PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_MASK)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_DRIVE_STRENGTH_MASK  (0x1CU)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_DRIVE_STRENGTH_SHIFT 2U\n#define PMU_BIAS_CTRL_WB_CFG_1P8_DRIVE_STRENGTH(x)                                    \\\n    (((uint32_t)(((uint32_t)(x)) << PMU_BIAS_CTRL_WB_CFG_1P8_DRIVE_STRENGTH_SHIFT)) & \\\n     PMU_BIAS_CTRL_WB_CFG_1P8_DRIVE_STRENGTH_MASK)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_OSCILLATOR_FREQ_MASK  (0x1E0U)\n#define PMU_BIAS_CTRL_WB_CFG_1P8_OSCILLATOR_FREQ_SHIFT 5U\n#define PMU_BIAS_CTRL_WB_CFG_1P8_OSCILLATOR_FREQ(x)                                    \\\n    (((uint32_t)(((uint32_t)(x)) << PMU_BIAS_CTRL_WB_CFG_1P8_OSCILLATOR_FREQ_SHIFT)) & \\\n     PMU_BIAS_CTRL_WB_CFG_1P8_OSCILLATOR_FREQ_MASK)\n#define PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(member) \\\n    ((uint32_t)((ANADIG_PMU_BASE) + (uint32_t)offsetof(ANADIG_PMU_Type, member)))\n#define PMU_LDO_ENABLE_SETPOINT_REGISTERS                                  \\\n    {                                                                      \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_PLL_ENABLE_SP),              \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_ANA_ENABLE_SP),     \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_ENABLE_SP), 0UL \\\n    }\n#define PMU_LDO_LP_MODE_EN_SETPOINT_REGISTERS                               \\\n    {                                                                       \\\n        0UL, PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_ANA_LP_MODE_SP),    \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_LP_MODE_SP), 0UL \\\n    }\n#define PMU_LDO_TRACKING_EN_SETPOINT_REGISTERS                                  \\\n    {                                                                           \\\n        0UL, PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_ANA_TRACKING_EN_SP),    \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_TRACKING_EN_SP), 0UL \\\n    }\n#define PMU_LDO_BYPASS_EN_SETPOINT_REGISTERS                                  \\\n    {                                                                         \\\n        0UL, PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_ANA_BYPASS_EN_SP),    \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_BYPASS_EN_SP), 0UL \\\n    }\n#define PMU_LDO_STBY_EN_REGISTERS                                           \\\n    {                                                                       \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(PLL_LDO_STBY_EN_SP),              \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_ANA_STBY_EN_SP),     \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_STBY_EN_SP), 0UL \\\n    }\n#define PMU_LPSR_DIG_TRG_REGISTERS                                   \\\n    {                                                                \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_TRG_SP0),     \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_TRG_SP1), \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_TRG_SP2), \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(LDO_LPSR_DIG_TRG_SP3)  \\\n    }\n#if (defined(PMU_HAS_FBB) && PMU_HAS_FBB)\n#define PMU_BODY_BIAS_ENABLE_REGISTERS                                                                             \\\n    {                                                                                                              \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(FBB_M7_ENABLE_SP), PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_SOC_ENABLE_SP), \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_LPSR_ENABLE_SP)                                                  \\\n    }\n#else\n#define PMU_BODY_BIAS_ENABLE_REGISTERS                                                                              \\\n    {                                                                                                               \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_SOC_ENABLE_SP), PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_LPSR_ENABLE_SP) \\\n    }\n#endif \n#if (defined(PMU_HAS_FBB) && PMU_HAS_FBB)\n#define PMU_BODY_BIAS_STBY_EN_REGISTERS                                                                              \\\n    {                                                                                                                \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(FBB_M7_STBY_EN_SP), PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_SOC_STBY_EN_SP), \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_LPSR_STBY_EN_SP)                                                   \\\n    }\n#else\n#define PMU_BODY_BIAS_STBY_EN_REGISTERS                                                                               \\\n    {                                                                                                                 \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_SOC_STBY_EN_SP), PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_LPSR_STBY_EN_SP) \\\n    }\n#endif \n#if (defined(PMU_HAS_FBB) && PMU_HAS_FBB)\n#define PMU_BODY_BIAS_CONFIGURE_REGISTERS                                                                          \\\n    {                                                                                                              \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(FBB_M7_CONFIGURE), PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_SOC_CONFIGURE), \\\n            PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_LPSR_CONFIGURE)                                                  \\\n    }\n#else\n#define PMU_BODY_BIAS_CONFIGURE_REGISTERS                                                                           \\\n    {                                                                                                               \\\n        PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_SOC_CONFIGURE), PMU_GET_ANADIG_PMU_MEMBER_ADDRESS(RBB_LPSR_CONFIGURE) \\\n    }\n#endif \nvoid PMU_SetPllLdoControlMode(ANADIG_PMU_Type *base, pmu_control_mode_t mode)\n{\n    if (mode == kPMU_StaticMode)\n    {\n        base->PMU_LDO_PLL &= ~ANADIG_PMU_PMU_LDO_PLL_LDO_PLL_CONTROL_MODE_MASK;\n    }\n    else\n    {\n        base->PMU_LDO_PLL |= ANADIG_PMU_PMU_LDO_PLL_LDO_PLL_CONTROL_MODE_MASK;\n    }\n}\nvoid PMU_SwitchPllLdoToGPCMode(ANADIG_PMU_Type *base)\n{\n    if ((base->LDO_PLL_ENABLE_SP & ANADIG_PMU_LDO_PLL_ENABLE_SP_ON_OFF_SETPOINT0_MASK) != 0UL)\n    {\n        base->PMU_LDO_PLL |= ANADIG_PMU_PMU_LDO_PLL_LDO_PLL_ENABLE_MASK;\n    }\n    else\n    {\n        base->PMU_LDO_PLL &= ~ANADIG_PMU_PMU_LDO_PLL_LDO_PLL_ENABLE_MASK;\n    }\n}\nvoid PMU_StaticEnablePllLdo(ANADIG_PMU_Type *base)\n{\n    uint32_t temp32;\n    temp32 = ANATOP_AI_Read(kAI_Itf_Ldo, kAI_PHY_LDO_CTRL0);\n    if (temp32 !=\n        (AI_PHY_LDO_CTRL0_OUTPUT_TRG(0x10) | AI_PHY_LDO_CTRL0_LINREG_EN_MASK | AI_PHY_LDO_CTRL0_LIMIT_EN_MASK))\n    {\n        ANATOP_AI_Write(\n            kAI_Itf_Ldo, kAI_PHY_LDO_CTRL0,\n            (AI_PHY_LDO_CTRL0_OUTPUT_TRG(0x10) | AI_PHY_LDO_CTRL0_LINREG_EN_MASK | AI_PHY_LDO_CTRL0_LIMIT_EN_MASK));\n        SDK_DelayAtLeastUs(1, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_REF_CTRL |= ANADIG_PMU_PMU_REF_CTRL_EN_PLL_VOL_REF_BUFFER_MASK;\n    }\n}\nvoid PMU_StaticDisablePllLdo(void)\n{\n    ANATOP_AI_Write(kAI_Itf_Ldo, kAI_PHY_LDO_CTRL0, 0UL);\n}\nvoid PMU_SetLpsrAnaLdoControlMode(ANADIG_LDO_SNVS_Type *base, pmu_control_mode_t mode)\n{\n    if (mode == kPMU_StaticMode)\n    {\n        base->PMU_LDO_LPSR_ANA &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_LPSR_ANA_CONTROL_MODE_MASK;\n    }\n    else\n    {\n        base->PMU_LDO_LPSR_ANA |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_LPSR_ANA_CONTROL_MODE_MASK;\n    }\n}\nvoid PMU_StaticEnableLpsrAnaLdoBypassMode(ANADIG_LDO_SNVS_Type *base, bool enable)\n{\n    if (enable == false)\n    {\n        base->PMU_LDO_LPSR_ANA &=\n            ~(ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_LP_EN_MASK | ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_DISABLE_MASK);\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_ANA &= ~(ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_BYPASS_MODE_EN_MASK);\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_ANA &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_TRACK_MODE_EN_MASK;\n    }\n    else\n    {\n        base->PMU_LDO_LPSR_ANA &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_LP_EN_MASK;\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_ANA |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_TRACK_MODE_EN_MASK;\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_ANA |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_BYPASS_MODE_EN_MASK;\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_ANA |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_DISABLE_MASK;\n    }\n}\nvoid PMU_StaticGetLpsrAnaLdoDefaultConfig(pmu_static_lpsr_ana_ldo_config_t *config)\n{\n    assert(config != NULL);\n    (void)memset(config, 0, sizeof(*config));\n    config->mode              = kPMU_HighPowerMode;\n    config->enable2mALoad     = true;\n    config->enable20uALoad    = false;\n    config->enable4mALoad     = true;\n    config->enableStandbyMode = false;\n}\nvoid PMU_StaticLpsrAnaLdoInit(ANADIG_LDO_SNVS_Type *base, const pmu_static_lpsr_ana_ldo_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t regValue = base->PMU_LDO_LPSR_ANA;\n    regValue &=\n        ~(ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_LP_EN_MASK | ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_PULL_DOWN_2MA_EN_MASK |\n          ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_ALWAYS_4MA_PULLDOWN_EN_MASK |\n          ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_PULL_DOWN_20UA_EN_MASK | ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_STANDBY_EN_MASK);\n    if ((config->mode) == kPMU_LowPowerMode)\n    {\n        regValue |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_LP_EN_MASK;\n    }\n    regValue |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_PULL_DOWN_2MA_EN(config->enable2mALoad);\n    regValue |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_ALWAYS_4MA_PULLDOWN_EN(config->enable4mALoad);\n    regValue |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_PULL_DOWN_20UA_EN(config->enable20uALoad);\n    regValue |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_STANDBY_EN(config->enableStandbyMode);\n    base->PMU_LDO_LPSR_ANA = regValue;\n    base->PMU_LDO_LPSR_ANA &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_DISABLE_MASK;\n}\nvoid PMU_StaticLpsrAnaLdoDeinit(ANADIG_LDO_SNVS_Type *base)\n{\n    base->PMU_LDO_LPSR_ANA |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_ANA_REG_DISABLE_MASK;\n}\nvoid PMU_SetLpsrDigLdoControlMode(ANADIG_LDO_SNVS_Type *base, pmu_control_mode_t mode)\n{\n    if (mode == kPMU_StaticMode)\n    {\n        base->PMU_LDO_LPSR_DIG &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_LPSR_DIG_CONTROL_MODE_MASK;\n    }\n    else\n    {\n        base->PMU_LDO_LPSR_DIG |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_LPSR_DIG_CONTROL_MODE_MASK;\n    }\n}\nvoid PMU_StaticEnableLpsrDigLdoBypassMode(ANADIG_LDO_SNVS_Type *base, bool enable)\n{\n    if (enable)\n    {\n        base->PMU_LDO_LPSR_DIG |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_TRACKING_MODE_MASK;\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_DIG |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_BYPASS_MODE_MASK;\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_DIG &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_REG_EN_MASK;\n    }\n    else\n    {\n        base->PMU_LDO_LPSR_DIG |= (ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_REG_EN_MASK);\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_DIG &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_BYPASS_MODE_MASK;\n        SDK_DelayAtLeastUs(1000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n        base->PMU_LDO_LPSR_DIG &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_TRACKING_MODE_MASK;\n    }\n}\nvoid PMU_StaticGetLpsrDigLdoDefaultConfig(pmu_static_lpsr_dig_config_t *config)\n{\n    assert(config != NULL);\n    (void)memset(config, 0, sizeof(*config));\n    config->voltageStepTime = kPMU_LpsrDigVoltageStepInc50us;\n    config->targetVoltage   = kPMU_LpsrDigTargetStableVoltage1P0V;\n}\nvoid PMU_StaticLpsrDigLdoInit(ANADIG_LDO_SNVS_Type *base, const pmu_static_lpsr_dig_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t temp32 = base->PMU_LDO_LPSR_DIG;\n    temp32 &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT_MASK;\n    temp32 |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_VOLTAGE_SELECT(config->targetVoltage);\n    base->PMU_LDO_LPSR_DIG = temp32;\n    temp32 = base->PMU_LDO_LPSR_DIG_2;\n    temp32 &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_2_VOLTAGE_STEP_INC_MASK;\n    temp32 |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_2_VOLTAGE_STEP_INC(config->voltageStepTime);\n    base->PMU_LDO_LPSR_DIG_2 = temp32;\n    base->PMU_LDO_LPSR_DIG |= ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_REG_EN_MASK;\n    SDK_DelayAtLeastUs(125U, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);\n    PMU_POWER_DETECT_CTRL_REGISTER |= ANADIG_PMU_PMU_POWER_DETECT_CTRL_CKGB_LPSR1P0_MASK;\n}\nvoid PMU_StaticLpsrDigLdoDeinit(ANADIG_LDO_SNVS_Type *base)\n{\n    PMU_POWER_DETECT_CTRL_REGISTER &= ~ANADIG_PMU_PMU_POWER_DETECT_CTRL_CKGB_LPSR1P0_MASK;\n    base->PMU_LDO_LPSR_DIG &= ~ANADIG_LDO_SNVS_PMU_LDO_LPSR_DIG_REG_EN_MASK;\n}\nvoid PMU_GPCSetLpsrDigLdoTargetVoltage(uint32_t setpointMap, pmu_lpsr_dig_target_output_voltage_t voltageValue)\n{\n    uint32_t regValue                   = 0UL;\n    const uint32_t lpsrDigTrgRegArray[] = PMU_LPSR_DIG_TRG_REGISTERS;\n    uint8_t regIndex;\n    uint8_t temp8;\n    uint32_t i;\n    for (regIndex = 0U; regIndex < ARRAY_SIZE(lpsrDigTrgRegArray); regIndex++)\n    {\n        temp8 = (((uint8_t)(setpointMap >> (PMU_LDO_LPSR_DIG_TRG_SPX_REG_SETPOINT_COUNTS * regIndex))) & 0xFU);\n        if (temp8 != 0UL)\n        {\n            regValue = (*(volatile uint32_t *)lpsrDigTrgRegArray[regIndex]);\n            for (i = 0U; i < PMU_LDO_LPSR_DIG_TRG_SPX_REG_SETPOINT_COUNTS; i++)\n            {\n                if (((temp8 >> (1U * i)) & 0x1U) != 0U)\n                {\n                    regValue &= ~(0xFFUL << (PMU_LDO_LPSR_DIG_TRG_SPX_VOLTAGE_SETPOINTX_BIT_WIDTH * i));\n                    regValue |= (uint32_t)voltageValue << (PMU_LDO_LPSR_DIG_TRG_SPX_VOLTAGE_SETPOINTX_BIT_WIDTH * i);\n                }\n            }\n            (*(volatile uint32_t *)lpsrDigTrgRegArray[regIndex]) = regValue;\n        }\n    }\n}\nvoid PMU_GetSnvsDigLdoDefaultConfig(pmu_snvs_dig_config_t *config)\n{\n    assert(config != NULL);\n    (void)memset(config, 0, sizeof(*config));\n    config->mode                   = kPMU_LowPowerMode;\n    config->chargePumpCurrent      = kPMU_SnvsDigChargePump12P5nA;\n    config->dischargeResistorValue = kPMU_SnvsDigDischargeResistor15K;\n    config->trimValue              = 0U;\n    config->enablePullDown         = true;\n    config->enableLdoStable        = false;\n}\nvoid PMU_SnvsDigLdoInit(ANADIG_LDO_SNVS_DIG_Type *base, pmu_ldo_operate_mode_t mode)\n{\n    uint32_t temp32 = base->PMU_LDO_SNVS_DIG;\n    temp32 &= ~(ANADIG_LDO_SNVS_DIG_PMU_LDO_SNVS_DIG_REG_LP_EN_MASK);\n    temp32 |= (ANADIG_LDO_SNVS_DIG_PMU_LDO_SNVS_DIG_REG_LP_EN(mode) | ANADIG_LDO_SNVS_DIG_PMU_LDO_SNVS_DIG_REG_EN_MASK);\n    base->PMU_LDO_SNVS_DIG = temp32;\n}\nvoid PMU_GPCEnableLdo(pmu_ldo_name_t name, uint32_t setpointMap)\n{\n    assert(name != kPMU_SnvsDigLdo);\n    uint32_t ldoEnableRegArray[] = PMU_LDO_ENABLE_SETPOINT_REGISTERS;\n    (*(volatile uint32_t *)ldoEnableRegArray[(uint8_t)name]) = ~setpointMap;\n}\nvoid PMU_GPCSetLdoOperateMode(pmu_ldo_name_t name, uint32_t setpointMap, pmu_ldo_operate_mode_t mode)\n{\n    assert(name > kPMU_PllLdo);\n    assert(name < kPMU_SnvsDigLdo);\n    uint32_t ldoLpModeRegArray[] = PMU_LDO_LP_MODE_EN_SETPOINT_REGISTERS;\n    if (mode == kPMU_LowPowerMode)\n    {\n        (*(volatile uint32_t *)ldoLpModeRegArray[(uint8_t)name]) &= ~setpointMap;\n    }\n    else\n    {\n        (*(volatile uint32_t *)ldoLpModeRegArray[(uint8_t)name]) |= setpointMap;\n    }\n}\nvoid PMU_GPCEnableLdoTrackingMode(pmu_ldo_name_t name, uint32_t setpointMap)\n{\n    assert(name > kPMU_PllLdo);\n    assert(name < kPMU_SnvsDigLdo);\n    uint32_t ldoTrackingEnableRegArray[] = PMU_LDO_TRACKING_EN_SETPOINT_REGISTERS;\n    (*(volatile uint32_t *)ldoTrackingEnableRegArray[(uint8_t)name]) = setpointMap;\n}\nvoid PMU_GPCEnableLdoBypassMode(pmu_ldo_name_t name, uint32_t setpointMap)\n{\n    assert(name > kPMU_PllLdo);\n    assert(name < kPMU_SnvsDigLdo);\n    uint32_t ldoBypassEnableRegArray[] = PMU_LDO_BYPASS_EN_SETPOINT_REGISTERS;\n    (*(volatile uint32_t *)ldoBypassEnableRegArray[(uint8_t)name]) = setpointMap;\n}\nvoid PMU_GPCEnableLdoStandbyMode(pmu_ldo_name_t name, uint32_t setpointMap)\n{\n    assert(name != kPMU_SnvsDigLdo);\n    uint32_t ldoStandbyEnableRegArray[] = PMU_LDO_STBY_EN_REGISTERS;\n    (*(volatile uint32_t *)ldoStandbyEnableRegArray[(uint8_t)name]) = setpointMap;\n}\nvoid PMU_SetBandgapControlMode(ANADIG_PMU_Type *base, pmu_control_mode_t mode)\n{\n    if (mode == kPMU_StaticMode)\n    {\n        base->PMU_REF_CTRL &= ~ANADIG_PMU_PMU_REF_CTRL_REF_CONTROL_MODE_MASK;\n    }\n    else\n    {\n        base->PMU_REF_CTRL |= ANADIG_PMU_PMU_REF_CTRL_REF_CONTROL_MODE_MASK;\n    }\n}\nvoid PMU_SwitchBandgapToGPCMode(ANADIG_PMU_Type *base)\n{\n    if ((base->BANDGAP_ENABLE_SP & ANADIG_PMU_BANDGAP_ENABLE_SP_ON_OFF_SETPOINT0_MASK) == 0UL)\n    {\n        base->PMU_REF_CTRL &= ~ANADIG_PMU_PMU_REF_CTRL_REF_ENABLE_MASK;\n    }\n    else\n    {\n        base->PMU_REF_CTRL |= ANADIG_PMU_PMU_REF_CTRL_REF_ENABLE_MASK;\n    }\n}\nvoid PMU_DisableBandgapSelfBiasAfterPowerUp(void)\n{\n    uint32_t temp32;\n    uint32_t regValue;\n    do\n    {\n        regValue = ANATOP_AI_Read(kAI_Itf_Bandgap, kAI_BANDGAP_STAT0);\n    } while ((regValue & AI_BANDGAP_STAT0_REFTOP_VBGUP_MASK) == 0UL);\n    temp32 = ANATOP_AI_Read(kAI_Itf_Bandgap, kAI_BANDGAP_CTRL0);\n    temp32 |= AI_BANDGAP_CTRL0_REFTOP_SELFBIASOFF_MASK;\n    ANATOP_AI_Write(kAI_Itf_Bandgap, kAI_BANDGAP_CTRL0, temp32);\n}\nvoid PMU_EnableBandgapSelfBiasBeforePowerDown(void)\n{\n    uint32_t temp32;\n    temp32 = ANATOP_AI_Read(kAI_Itf_Bandgap, kAI_BANDGAP_CTRL0);\n    temp32 &= ~AI_BANDGAP_CTRL0_REFTOP_SELFBIASOFF_MASK;\n    ANATOP_AI_Write(kAI_Itf_Bandgap, kAI_BANDGAP_CTRL0, temp32);\n}\nvoid PMU_StaticBandgapInit(const pmu_static_bandgap_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t temp32;\n    temp32 = ANATOP_AI_Read(kAI_Itf_Bandgap, kAI_BANDGAP_CTRL0);\n    temp32 &= ~(AI_BANDGAP_CTRL0_REFTOP_PWD_MASK | AI_BANDGAP_CTRL0_REFTOP_LINREGREF_PWD_MASK |\n                AI_BANDGAP_CTRL0_REFTOP_PWDVBGUP_MASK | AI_BANDGAP_CTRL0_REFTOP_LOWPOWER_MASK |\n                AI_BANDGAP_CTRL0_REFTOP_VBGADJ_MASK | AI_BANDGAP_CTRL0_REFTOP_IBZTCADJ_MASK);\n    temp32 |= ((uint32_t)(config->powerDownOption) &\n               (AI_BANDGAP_CTRL0_REFTOP_PWD_MASK | AI_BANDGAP_CTRL0_REFTOP_LINREGREF_PWD_MASK |\n                AI_BANDGAP_CTRL0_REFTOP_PWDVBGUP_MASK));\n    temp32 |= AI_BANDGAP_CTRL0_REFTOP_LOWPOWER(config->enableLowPowerMode);\n    temp32 |= AI_BANDGAP_CTRL0_REFTOP_VBGADJ(config->outputVoltage);\n    temp32 |= AI_BANDGAP_CTRL0_REFTOP_IBZTCADJ(config->outputCurrent);\n    ANATOP_AI_Write(kAI_Itf_Bandgap, kAI_BANDGAP_CTRL0, temp32);\n}\nvoid PMU_WellBiasInit(ANADIG_PMU_Type *base, const pmu_well_bias_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t tmp32;\n    tmp32 = base->PMU_BIAS_CTRL;\n    tmp32 &= ~(ANADIG_PMU_PMU_BIAS_CTRL_WB_CFG_1P8_MASK | ANADIG_PMU_PMU_BIAS_CTRL_WB_VDD_SEL_1P8_MASK);\n    tmp32 |= ((uint32_t)config->wellBiasOption.wellBiasData &\n              (ANADIG_PMU_PMU_BIAS_CTRL_WB_CFG_1P8_MASK | ANADIG_PMU_PMU_BIAS_CTRL_WB_VDD_SEL_1P8_MASK));\n    base->PMU_BIAS_CTRL = tmp32;\n    tmp32 = base->PMU_BIAS_CTRL2;\n    tmp32 &= ~ANADIG_PMU_PMU_BIAS_CTRL2_WB_ADJ_1P8_MASK;\n    tmp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_WB_ADJ_1P8(config->adjustment);\n    base->PMU_BIAS_CTRL2 = tmp32;\n}\nvoid PMU_GetWellBiasDefaultConfig(pmu_well_bias_config_t *config)\n{\n    assert(config != NULL);\n    (void)memset(config, 0, sizeof(*config));\n    config->wellBiasOption.wellBiasData = 0U;\n    config->adjustment                  = kPMU_Cref0fFCspl0fFDeltaC0fF;\n}\nvoid PMU_SetBodyBiasControlMode(ANADIG_PMU_Type *base, pmu_body_bias_name_t name, pmu_control_mode_t mode)\n{\n    uint32_t temp32;\n    switch (name)\n    {\n#if (defined(PMU_HAS_FBB) && PMU_HAS_FBB)\n        case kPMU_FBB_CM7:\n        {\n            temp32 = base->PMU_BIAS_CTRL2;\n            temp32 &= ~ANADIG_PMU_PMU_BIAS_CTRL2_FBB_M7_CONTROL_MODE_MASK;\n            temp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_FBB_M7_CONTROL_MODE(mode);\n            base->PMU_BIAS_CTRL2 = temp32;\n            break;\n        }\n#endif \n        case kPMU_RBB_SOC:\n        {\n            temp32 = base->PMU_BIAS_CTRL2;\n            temp32 &= ~ANADIG_PMU_PMU_BIAS_CTRL2_RBB_SOC_CONTROL_MODE_MASK;\n            temp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_RBB_SOC_CONTROL_MODE(mode);\n            base->PMU_BIAS_CTRL2 = temp32;\n            break;\n        }\n        case kPMU_RBB_LPSR:\n        {\n            temp32 = base->PMU_BIAS_CTRL2;\n            temp32 &= ~ANADIG_PMU_PMU_BIAS_CTRL2_RBB_LPSR_CONTROL_MODE_MASK;\n            temp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_RBB_LPSR_CONTROL_MODE(mode);\n            base->PMU_BIAS_CTRL2 = temp32;\n            break;\n        }\n        default:\n            break;\n    }\n}\nvoid PMU_EnableBodyBias(ANADIG_PMU_Type *base, pmu_body_bias_name_t name, bool enable)\n{\n    uint32_t tmp32;\n    if (enable)\n    {\n        switch (name)\n        {\n#if (defined(PMU_HAS_FBB) && PMU_HAS_FBB)\n            case kPMU_FBB_CM7:\n            {\n                tmp32 = base->PMU_BIAS_CTRL;\n                tmp32 &= ~PMU_BIAS_CTRL_WB_CFG_1P8_WELL_SELECT_MASK;\n                tmp32 |= PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_MASK;\n                base->PMU_BIAS_CTRL = tmp32;\n                tmp32 = base->PMU_BIAS_CTRL2;\n                tmp32 &= ~(ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8_MASK);\n                tmp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8(1U) | ANADIG_PMU_PMU_BIAS_CTRL2_WB_EN_MASK;\n                base->PMU_BIAS_CTRL2 = tmp32;\n                while ((base->PMU_BIAS_CTRL2 & ANADIG_PMU_PMU_BIAS_CTRL2_WB_OK_MASK) !=\n                       ANADIG_PMU_PMU_BIAS_CTRL2_WB_OK_MASK)\n                {\n                }\n                break;\n            }\n#endif \n            case kPMU_RBB_SOC:\n            {\n                tmp32 = base->PMU_BIAS_CTRL;\n                tmp32 &= ~(PMU_BIAS_CTRL_WB_CFG_1P8_WELL_SELECT_MASK | PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_MASK);\n                base->PMU_BIAS_CTRL = tmp32;\n                tmp32 = base->PMU_BIAS_CTRL2;\n                tmp32 &= ~(ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8_MASK);\n                tmp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8(2U) | ANADIG_PMU_PMU_BIAS_CTRL2_WB_EN_MASK;\n                base->PMU_BIAS_CTRL2 = tmp32;\n                while ((base->PMU_BIAS_CTRL2 & ANADIG_PMU_PMU_BIAS_CTRL2_WB_OK_MASK) !=\n                       ANADIG_PMU_PMU_BIAS_CTRL2_WB_OK_MASK)\n                {\n                }\n                break;\n            }\n            case kPMU_RBB_LPSR:\n            {\n                tmp32 = base->PMU_BIAS_CTRL;\n                tmp32 &= ~(PMU_BIAS_CTRL_WB_CFG_1P8_WELL_SELECT_MASK | PMU_BIAS_CTRL_WB_CFG_1P8_VOLTAGE_THRESHOLD_MASK);\n                base->PMU_BIAS_CTRL = tmp32;\n                tmp32 = base->PMU_BIAS_CTRL2;\n                tmp32 &= ~(ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8_MASK);\n                tmp32 |= ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8(4U) | ANADIG_PMU_PMU_BIAS_CTRL2_WB_EN_MASK;\n                base->PMU_BIAS_CTRL2 = tmp32;\n                while ((base->PMU_BIAS_CTRL2 & ANADIG_PMU_PMU_BIAS_CTRL2_WB_OK_MASK) !=\n                       ANADIG_PMU_PMU_BIAS_CTRL2_WB_OK_MASK)\n                {\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    else\n    {\n        base->PMU_BIAS_CTRL2 &=\n            ~(ANADIG_PMU_PMU_BIAS_CTRL2_WB_PWR_SW_EN_1P8_MASK | ANADIG_PMU_PMU_BIAS_CTRL2_WB_EN_MASK);\n    }\n}\nvoid PMU_GPCEnableBodyBias(pmu_body_bias_name_t name, uint32_t setpointMap)\n{\n    uint32_t bodyBiasEnableRegArray[] = PMU_BODY_BIAS_ENABLE_REGISTERS;\n    (*(volatile uint32_t *)bodyBiasEnableRegArray[(uint8_t)name]) = ~setpointMap;\n}\nvoid PMU_GPCEnableBodyBiasStandbyMode(pmu_body_bias_name_t name, uint32_t setpointMap)\n{\n    uint32_t BBStandbyEnableRegArray[] = PMU_BODY_BIAS_STBY_EN_REGISTERS;\n    (*(volatile uint32_t *)BBStandbyEnableRegArray[(uint8_t)name]) = setpointMap;\n}\nvoid PMU_GPCGetBodyBiasDefaultConfig(pmu_gpc_body_bias_config_t *config)\n{\n    assert(config != NULL);\n    config->PWELLRegulatorSize = 1U;\n    config->NWELLRegulatorSize = 1U;\n    config->oscillatorSize     = 7U;\n    config->regulatorStrength  = 5U;\n}\nvoid PMU_GPCSetBodyBiasConfig(pmu_body_bias_name_t name, const pmu_gpc_body_bias_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t bodyBiasConfigRegArray[] = PMU_BODY_BIAS_CONFIGURE_REGISTERS;\n    uint32_t temp32;\n    temp32 = (*(volatile uint32_t *)bodyBiasConfigRegArray[(uint8_t)name]);\n    temp32 &=\n        (ANADIG_PMU_RBB_SOC_CONFIGURE_WB_CFG_PW_MASK | ANADIG_PMU_RBB_SOC_CONFIGURE_WB_CFG_NW_MASK |\n         ANADIG_PMU_RBB_SOC_CONFIGURE_OSCILLATOR_BITS_MASK | ANADIG_PMU_RBB_SOC_CONFIGURE_REGULATOR_STRENGTH_MASK);\n    temp32 |= ANADIG_PMU_RBB_SOC_CONFIGURE_WB_CFG_PW(config->PWELLRegulatorSize) |\n              ANADIG_PMU_RBB_SOC_CONFIGURE_WB_CFG_NW(config->NWELLRegulatorSize) |\n              ANADIG_PMU_RBB_SOC_CONFIGURE_OSCILLATOR_BITS(config->oscillatorSize) |\n              ANADIG_PMU_RBB_SOC_CONFIGURE_REGULATOR_STRENGTH(config->regulatorStrength);\n    (*(volatile uint32_t *)bodyBiasConfigRegArray[(uint8_t)name]) = temp32;\n}'"
"('Prompt: Can you provide a code snippet that prints the results of an automated test in a formatted manner, based on the given test structure? The output should include the test ID, execution time, pass/fail status, number of passed/failed checks, percentage passed, and the test name. The function should account for ignored tests and display appropriate messages.","//...\ntypedef struct {\n    unsigned int id;                \n    autotest_function_t * api;      \n    const char* name;               \n    long unsigned int num_checks;   \n    long unsigned int num_passed;   \n    long unsigned int num_failed;   \n    long unsigned int num_warnings; \n    float percent_passed;           \n    int executed;                   \n    int pass;                       \n    double extime;                  \n} autotest_t;\nvoid print_autotest_results(autotest_t * _test)\n{\n    printf(""  %4u"", _test->id);\n    if (!_test->executed) {\n        printf(""[     -     ] IGNORED  "");\n    } else {\n        printf(""[%8.2f ms] %8s "", _test->extime*1e3f, _test->pass ? ""  PASS  "" : ""<<FAIL>>"");\n    }\n    printf(""passed %4lu/%4lu checks (%5.1f%%) %s\\n"",\n            _test->num_passed,\n            _test->num_checks,\n            _test->percent_passed,\n            _test->name);\n}\n//...')
"
"('Prompt: Develop a software-defined radio (SDR) receiver using FSK demodulation with frame synchronization and decoding capabilities. The receiver should be able to detect the frame, receive the header, and decode the payload. Additionally, provide debugging functionality for signal processing analysis.. . Code:. ```c. #define DEBUG_FSKFRAMESYNC             1. #define DEBUG_FSKFRAMESYNC_PRINT       0. #define DEBUG_FSKFRAMESYNC_FILENAME    ""fskframesync_debug.m"". #define DEBUG_FSKFRAMESYNC_BUFFER_LEN  (2000). int fskframesync_execute_detectframe(fskframesync _q, float complex _x);. int fskframesync_execute_rxheader(   fskframesync _q, float complex _x);. int fskframesync_execute_rxpayload(  fskframesync _q, float complex _x);. int fskframesync_decode_header(fskframesync _q);. // Structure definition and initialization function. struct f","#define DEBUG_FSKFRAMESYNC             1\n#define DEBUG_FSKFRAMESYNC_PRINT       0\n#define DEBUG_FSKFRAMESYNC_FILENAME    ""fskframesync_debug.m""\n#define DEBUG_FSKFRAMESYNC_BUFFER_LEN  (2000)\nint fskframesync_execute_detectframe(fskframesync _q, float complex _x);\nint fskframesync_execute_rxheader(   fskframesync _q, float complex _x);\nint fskframesync_execute_rxpayload(  fskframesync _q, float complex _x);\nint fskframesync_decode_header(fskframesync _q);\nstruct fskframesync_s {\n    unsigned int    m;                  \n    unsigned int    k;                  \n    float           bandwidth;          \n    unsigned int    M;                  \n    fskdem          dem_header;         \n    fskdem          dem;                \n    float complex * buf;                \n    framesync_callback  callback;       \n    void *              userdata;       \n    framesyncstats_s    framestats;     \n    firpfb_crcf     pfb;                \n    unsigned int    npfb;               \n    unsigned int    pfb_index;          \n    nco_crcf        nco;                \n    firfilt_rrrf    detector;           \n    windowcf        buf_rx;             \n    windowf         buf_LLR2;           \n    float           rxy[3];             \n#if 0\n    unsigned int    header_dec_len;     \n    crc_scheme      header_crc;         \n    fec_scheme      header_fec0;        \n    fec_scheme      header_fec1;        \n    packetizer      header_decoder;     \n    unsigned int    header_enc_len;     \n    unsigned char * header_dec;         \n    unsigned char * header_enc;         \n    unsigned int    header_sym_len;     \n#else\n    unsigned int    header_dec_len;     \n    unsigned int    header_sym_len;     \n    unsigned char * header_dec;         \n    unsigned char * header_sym;         \n    qpacketmodem    header_decoder;     \n#endif\n#if 0\n    unsigned int    payload_dec_len;    \n    crc_scheme      payload_crc;        \n    fec_scheme      payload_fec0;       \n    fec_scheme      payload_fec1;       \n    packetizer      payload_decoder;    \n    unsigned int    payload_enc_len;    \n    unsigned char * payload_enc;        \n    unsigned int    payload_sym_len;    \n#else\n    unsigned int    payload_dec_len;    \n    crc_scheme      payload_crc;        \n    fec_scheme      payload_fec0;       \n    fec_scheme      payload_fec1;       \n    unsigned int    payload_sym_len;    \n    unsigned char * payload_sym;        \n    unsigned char * payload_dec;        \n    qpacketmodem    payload_decoder;    \n#endif\n    enum {\n                    STATE_DETECTFRAME=0,\n                    STATE_RXHEADER,     \n                    STATE_RXPAYLOAD,    \n    }               state;\n    int             frame_assembled;    \n    int             frame_detected;     \n    unsigned int    sample_counter;     \n    unsigned int    symbol_counter;     \n    unsigned int    timer;              \n#if DEBUG_FSKFRAMESYNC\n    int             debug_enabled;          \n    int             debug_objects_created;  \n    windowcf        debug_x;                \n#endif\n};\nfskframesync fskframesync_create(framesync_callback _callback,\n                                 void *             _userdata)\n{\n    fskframesync q = (fskframesync) malloc(sizeof(struct fskframesync_s));\n    q->callback  = _callback;\n    q->userdata  = _userdata;\n    q->m         = 4;\n    q->M         = 1 << q->m;\n    q->k         = 2 << q->m;\n    q->bandwidth = 0.25f;\n    q->dem_header = fskdem_create(   1, q->k, q->bandwidth);\n    q->dem        = fskdem_create(q->m, q->k, q->bandwidth);\n    q->buf        = (float complex*) malloc( q->k * sizeof(float complex) );\n    q->npfb = 64;\n    q->pfb  = firpfb_crcf_create_kaiser(q->npfb, 5, 0.45f, 40.0f);\n    q->nco = nco_crcf_create(LIQUID_VCO);\n    q->buf_rx = windowcf_create(q->k);\n    msequence preamble_ms = msequence_create(6, 0x6d, 1);\n    unsigned int preamble_sym_len = 63; \n    float * preamble = (float*) malloc( 2*preamble_sym_len*sizeof(float) );\n    unsigned int i;\n    for (i=0; i<preamble_sym_len; i++) {\n        float v = msequence_advance(preamble_ms) ? 1.0f : -1.0f;\n        preamble[2*preamble_sym_len - (2*i+0) - 1] = v;\n        preamble[2*preamble_sym_len - (2*i+1) - 1] = v;\n    }\n    q->detector = firfilt_rrrf_create(preamble, 2*preamble_sym_len);\n    free(preamble);\n    msequence_destroy(preamble_ms);\n    q->buf_LLR2 = windowf_create(2*preamble_sym_len);\n#if 0\n    q->header_dec_len   = 10;\n    q->header_crc       = LIQUID_CRC_32;\n    q->header_fec0      = LIQUID_FEC_NONE;\n    q->header_fec1      = LIQUID_FEC_GOLAY2412;\n    q->header_decoder   = packetizer_create(q->header_dec_len,\n                                            q->header_crc,\n                                            q->header_fec0,\n                                            q->header_fec1);\n    q->header_enc_len   = packetizer_get_dec_msg_len(q->header_decoder);\n    q->header_dec       = (unsigned char*)malloc(q->header_dec_len*sizeof(unsigned char));\n    q->header_enc       = (unsigned char*)malloc(q->header_enc_len*sizeof(unsigned char));\n    q->header_sym_len   = q->header_enc_len * 8 / q->m;\n#else\n    q->header_dec_len   = 10;\n    q->header_dec       = (unsigned char*)malloc(q->header_dec_len*sizeof(unsigned char));\n    q->header_decoder   = qpacketmodem_create();\n    qpacketmodem_configure(q->header_decoder,\n                           q->header_dec_len,\n                           LIQUID_CRC_32,\n                           LIQUID_FEC_NONE,\n                           LIQUID_FEC_GOLAY2412,\n                           LIQUID_MODEM_BPSK);\n    q->header_sym_len   = qpacketmodem_get_frame_len(q->header_decoder);\n    q->header_sym       = (unsigned char*)malloc(q->header_sym_len*sizeof(unsigned char));\n#endif\n#if 0\n    q->payload_dec_len  = 10;\n    q->payload_crc      = LIQUID_CRC_32;\n    q->payload_fec0     = LIQUID_FEC_NONE;\n    q->payload_fec1     = LIQUID_FEC_GOLAY2412;\n    q->payload_decoder  = packetizer_create(q->payload_dec_len,\n                                            q->payload_crc,\n                                            q->payload_fec0,\n                                            q->payload_fec1);\n    q->payload_enc_len  = packetizer_get_dec_msg_len(q->payload_decoder);\n    q->payload_enc      = (unsigned char*)malloc(q->payload_enc_len*sizeof(unsigned char));\n    q->payload_sym_len  = 0;    \n#else\n    q->payload_dec_len  = 200;\n    q->payload_crc      = LIQUID_CRC_32;\n    q->payload_fec0     = LIQUID_FEC_NONE;\n    q->payload_fec1     = LIQUID_FEC_HAMMING128;\n    q->payload_decoder  = qpacketmodem_create();\n    qpacketmodem_configure(q->payload_decoder,\n                           q->payload_dec_len,\n                           q->payload_crc,\n                           q->payload_fec0,\n                           q->payload_fec1,\n                           LIQUID_MODEM_QAM16);  \n    q->payload_sym_len  = qpacketmodem_get_frame_len(q->payload_decoder);\n    q->payload_sym      = (unsigned char*)malloc(q->payload_sym_len*sizeof(unsigned char));\n    q->payload_dec      = (unsigned char*)malloc(q->payload_dec_len*sizeof(unsigned char));\n#endif\n#if DEBUG_FSKFRAMESYNC\n    q->debug_enabled         = 0;\n    q->debug_objects_created = 0;\n    q->debug_x               = NULL;\n#endif\n    fskframesync_reset(q);\n    return q;\n}\nint fskframesync_destroy(fskframesync _q)\n{\n#if DEBUG_FSKFRAMESYNC\n    if (_q->debug_objects_created) {\n        windowcf_destroy(_q->debug_x);\n    }\n#endif\n    fskdem_destroy(_q->dem_header);\n    fskdem_destroy(_q->dem);\n    free(_q->buf);\n    firpfb_crcf_destroy(_q->pfb);\n    nco_crcf_destroy(_q->nco);\n    windowcf_destroy(_q->buf_rx);\n    firfilt_rrrf_destroy(_q->detector);\n    windowf_destroy(_q->buf_LLR2);\n#if 0\n    free(_q->header_dec);\n    free(_q->header_enc);\n    packetizer_destroy(_q->header_decoder);\n#else\n    free(_q->header_dec);\n    free(_q->header_sym);\n    qpacketmodem_destroy(_q->header_decoder);\n#endif\n#if 0\n    free(_q->payload_enc);\n    packetizer_destroy(_q->payload_decoder);\n#else\n    free(_q->payload_sym);\n    free(_q->payload_dec);\n    qpacketmodem_destroy(_q->payload_decoder);\n#endif\n    free(_q);\n    return LIQUID_OK;\n}\nint fskframesync_print(fskframesync _q)\n{\n    printf(""fskframesync:\\n"");\n    printf(""  physical properties\\n"");\n    printf(""    bits/symbol     :   %u\\n"", _q->m);\n    printf(""    samples/symbol  :   %u\\n"", _q->k);\n    printf(""    bandwidth       :   %-8.3f\\n"", _q->bandwidth);\n    printf(""  framing properties\\n"");\n    printf(""    preamble        :   %-4u symbols\\n"", 0); \n    printf(""    header          :   %-4u symbols, %-4u bytes\\n"", _q->header_sym_len, _q->header_dec_len);\n    printf(""    payload         :   %-4u symbols, %-4u bytes\\n"", _q->payload_sym_len, _q->payload_dec_len);\n    printf(""  packet properties\\n"");\n    printf(""    crc             :   %s\\n"", crc_scheme_str[_q->payload_crc ][1]);\n    printf(""    fec (inner)     :   %s\\n"", fec_scheme_str[_q->payload_fec0][1]);\n    printf(""    fec (outer)     :   %s\\n"", fec_scheme_str[_q->payload_fec1][1]);\n    printf(""  total samples     :   %-4u samples\\n"", 0);\n    return LIQUID_OK;\n}\nint fskframesync_reset(fskframesync _q)\n{\n    firpfb_crcf_reset(_q->pfb);\n    nco_crcf_reset(_q->nco);\n    windowcf_reset(_q->buf_rx);\n    firfilt_rrrf_reset(_q->detector);\n    _q->state            = STATE_DETECTFRAME;\n    _q->frame_detected   = 0;\n    _q->sample_counter   = 0;\n    _q->symbol_counter   = 0;\n    _q->timer            = _q->k - 1;\n    _q->pfb_index        = 0;\n    return LIQUID_OK;\n}\nint fskframesync_execute(fskframesync  _q,\n                         float complex _x)\n{\n#if DEBUG_FSKFRAMESYNC\n    if (_q->debug_enabled)\n        windowcf_push(_q->debug_x, _x);\n#endif\n    switch (_q->state) {\n    case STATE_DETECTFRAME: return fskframesync_execute_detectframe(_q, _x);\n    case STATE_RXHEADER:    return fskframesync_execute_rxheader   (_q, _x);\n    case STATE_RXPAYLOAD:   return fskframesync_execute_rxpayload  (_q, _x);\n    default:;\n    }\n    return liquid_error(LIQUID_EINT,""fskframesync_execute(), invalid internal mode"");\n}\nint fskframesync_execute_block(fskframesync    _q,\n                                float complex * _x,\n                                unsigned int    _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        if (fskframesync_execute(_q, _x[i]))\n            return liquid_error(LIQUID_EINT,""fskframesync_execute_block(), invalid internal mode"");\n    }\n    return LIQUID_OK;\n}\nint fskframesync_execute_detectframe(fskframesync  _q,\n                                     float complex _x)\n{\n#if 0\n    float complex y;\n    firpfb_crcf_push(_q->pfb, _x);\n    firpfb_crcf_execute(_q->pfb, 0, &y);\n    windowcf_push(_q->buf_rx, y);\n#else\n    windowcf_push(_q->buf_rx, _x);\n#endif\n    _q->timer--;\n    if (_q->timer)\n        return LIQUID_OK;\n    _q->timer = _q->k;\n    float complex * r;\n    windowcf_read(_q->buf_rx, &r);\n    fskdem_demodulate(_q->dem_header, r);\n    int fft_bin_range = 2;\n    float v0 = fskdem_get_symbol_energy(_q->dem_header, 0, fft_bin_range); \n    float v1 = fskdem_get_symbol_energy(_q->dem_header, 1, fft_bin_range); \n    float LLR = logf( (v1+1e-9f)/(v0+1e-9f) );\n    float v;\n    firfilt_rrrf_push(   _q->detector, LLR);\n    firfilt_rrrf_execute(_q->detector, &v);\n    windowf_push(_q->buf_LLR2, LLR*LLR);\n    float * rf;\n    windowf_read(_q->buf_LLR2, &rf);\n    float g = 0.0f;\n    unsigned int i;\n    unsigned int n = 126;\n    for (i=0; i<n; i++)\n        g += rf[i];\n    float rxy = v / ((float)n * (1e-6f + sqrtf(g/(float)n)));\n    _q->rxy[0] = _q->rxy[1];\n    _q->rxy[1] = _q->rxy[2];\n    _q->rxy[2] = rxy;\n    if (!_q->frame_detected) {\n        if (rxy > 0.5f) {\n            _q->frame_detected = 1;\n        }\n    } else {\n        if (_q->rxy[1] > _q->rxy[2]) {\n#if 0\n            float gamma = (_q->rxy[2] - _q->rxy[0]) / _q->rxy[1];\n            float p2 = 9.54907046918287e-01f;\n            float p1 = 8.87465224972323e-02;\n            float xf      = fabsf(gamma);\n            float tau_hat = copysignf(p2*xf*xf + p1*xf, gamma);\n            int   num_samples = round(tau_hat * _q->k);\n            printf(""timing offset estimate  : %12.8f -> %12.8f (%d samples)\\n"",\n                    gamma, tau_hat, num_samples);\n#endif\n            _q->timer = 2*_q->k;\n            _q->state = STATE_RXHEADER;\n        } else {\n        }\n    }\n    return LIQUID_OK;\n}\nint fskframesync_execute_rxheader(fskframesync  _q,\n                                  float complex _x)\n{\n#if 0\n    float complex y;\n    firpfb_crcf_push(_q->pfb, _x);\n    firpfb_crcf_execute(_q->pfb, 0, &y);\n    windowcf_push(_q->buf_rx, y);\n#else\n    windowcf_push(_q->buf_rx, _x);\n#endif\n    _q->timer--;\n    if (_q->timer)\n        return LIQUID_OK;\n    _q->timer = _q->k;\n    float complex * r;\n    windowcf_read(_q->buf_rx, &r);\n    unsigned char sym = fskdem_demodulate(_q->dem_header, r);\n    _q->header_sym[_q->symbol_counter++] = sym;\n    if (_q->symbol_counter == _q->header_sym_len) {\n        int header_valid = qpacketmodem_decode_syms(_q->header_decoder,\n                                                    _q->header_sym,\n                                                    _q->header_dec);\n#if 0\n        printf(""rx header symbols (%u):\\n"", _q->header_sym_len);\n        unsigned int i;\n        for (i=0; i<_q->header_sym_len; i++)\n            printf(""%1x"", _q->header_sym[i]);\n        printf(""\\n"");\n        printf(""rx header decoded (%u):\\n"", _q->header_dec_len);\n        for (i=0; i<_q->header_dec_len; i++)\n            printf("" %.2x"", _q->header_dec[i]);\n        printf(""\\n"");\n        printf(""header: %s\\n"", header_valid ? ""valid"" : ""INVALID"");\n#endif\n        if (header_valid) {\n            _q->symbol_counter = 0;\n            _q->state = STATE_RXPAYLOAD;\n            return LIQUID_OK;\n        }\n        if (_q->callback != NULL) {\n            _q->framestats.evm           = 0.0f; \n            _q->framestats.rssi          = 0.0f; \n            _q->framestats.cfo           = 0.0f; \n            _q->framestats.framesyms     = NULL;\n            _q->framestats.num_framesyms = 0;\n            _q->framestats.mod_scheme    = LIQUID_MODEM_UNKNOWN;\n            _q->framestats.mod_bps       = 0;\n            _q->framestats.check         = LIQUID_CRC_UNKNOWN;\n            _q->framestats.fec0          = LIQUID_FEC_UNKNOWN;\n            _q->framestats.fec1          = LIQUID_FEC_UNKNOWN;\n            _q->callback(_q->header_dec,\n                         0,     \n                         NULL,  \n                         0,     \n                         0,     \n                         _q->framestats,\n                         _q->userdata);\n        }\n        fskframesync_reset(_q);\n    }\n    return LIQUID_OK;\n}\nint fskframesync_execute_rxpayload(fskframesync  _q,\n                                   float complex _x)\n{\n#if 0\n    float complex y;\n    firpfb_crcf_push(_q->pfb, _x);\n    firpfb_crcf_execute(_q->pfb, 0, &y);\n    windowcf_push(_q->buf_rx, y);\n#else\n    windowcf_push(_q->buf_rx, _x);\n#endif\n    _q->timer--;\n    if (_q->timer)\n        return LIQUID_OK;\n    _q->timer = _q->k;\n    float complex * r;\n    windowcf_read(_q->buf_rx, &r);\n    unsigned char sym = fskdem_demodulate(_q->dem, r);\n    _q->payload_sym[_q->symbol_counter++] = sym;\n    if (_q->symbol_counter == _q->payload_sym_len) {\n#if 0\n        printf(""rx payload symbols (%u)\\n"", _q->payload_sym_len);\n        unsigned int i;\n        for (i=0; i<_q->payload_sym_len; i++)\n            printf(""%1x%s"", _q->payload_sym[i], ((i+1)%64)==0 ? ""\\n"" : """");\n        printf(""\\n"");\n#endif\n        int payload_valid = qpacketmodem_decode_syms(_q->payload_decoder,\n                                                     _q->payload_sym,\n                                                     _q->payload_dec);\n        if (_q->callback != NULL) {\n            _q->framestats.evm           = 0.0f; \n            _q->framestats.rssi          = 0.0f; \n            _q->framestats.cfo           = 0.0f; \n            _q->framestats.framesyms     = NULL;\n            _q->framestats.num_framesyms = 0;\n            _q->framestats.mod_scheme    = LIQUID_MODEM_UNKNOWN;\n            _q->framestats.mod_bps       = 0;\n            _q->framestats.check         = _q->payload_crc;\n            _q->framestats.fec0          = _q->payload_fec0;\n            _q->framestats.fec1          = _q->payload_fec1;\n            _q->callback(_q->header_dec,        \n                         1,                     \n                         _q->payload_dec,       \n                         _q->payload_dec_len,   \n                         payload_valid,         \n                         _q->framestats,\n                         _q->userdata);\n        }\n        return fskframesync_reset(_q);\n    }\n    return LIQUID_OK;\n}\nint fskframesync_decode_header(fskframesync _q)\n{\n    return LIQUID_OK;\n}\nint fskframesync_debug_enable(fskframesync _q)\n{\n#if DEBUG_FSKFRAMESYNC\n    if (!_q->debug_objects_created) {\n        _q->debug_x  = windowcf_create(DEBUG_FSKFRAMESYNC_BUFFER_LEN);\n    }\n    _q->debug_enabled = 1;\n    _q->debug_objects_created = 1;\n    return LIQUID_OK;\n#else\n    return liquid_error(LIQUID_EICONFIG,""fskframesync_debug_enable(), compile-time debugging disabled\\n"");\n#endif\n}\nint fskframesync_debug_disable(fskframesync _q)\n{\n#if DEBUG_FSKFRAMESYNC\n    _q->debug_enabled = 0;\n    return LIQUID_OK;\n#else\n    return liquid_error(LIQUID_EICONFIG,""fskframesync_debug_disable(), compile-time debugging disabled\\n"");\n#endif\n}\nint fskframesync_debug_export(fskframesync _q,\n                               const char * _filename)\n{\n#if DEBUG_FSKFRAMESYNC\n    if (!_q->debug_objects_created)\n        return liquid_error(LIQUID_EICONFIG,""fskframe_debug_print(), debugging objects don\'t exist; enable debugging first"");\n    FILE* fid = fopen(_filename,""w"");\n    if (fid == NULL)\n        return liquid_error(LIQUID_EIO,""fskframesync_debug_print(), could not open \'%s\' for writing"", _filename);\n    fprintf(fid,""%% %s: auto-generated file"", _filename);\n    fprintf(fid,""\\n\\n"");\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n\\n"");\n    fprintf(fid,""num_samples = %u;\\n"", DEBUG_FSKFRAMESYNC_BUFFER_LEN);\n    fprintf(fid,""t = 0:(num_samples-1);\\n"");\n    unsigned int i;\n    float complex * rc;\n    fprintf(fid,""x = zeros(1,num_samples);\\n"");\n    windowcf_read(_q->debug_x, &rc);\n    for (i=0; i<DEBUG_FSKFRAMESYNC_BUFFER_LEN; i++)\n        fprintf(fid,""x(%4u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(rc[i]), cimagf(rc[i]));\n    fprintf(fid,""\\n\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""plot(1:length(x),real(x), 1:length(x),imag(x));\\n"");\n    fprintf(fid,""ylabel(\'received signal, x\');\\n"");\n    fprintf(fid,""\\n\\n"");\n    fclose(fid);\n    printf(""fskframesync/debug: results written to \'%s\'\\n"", _filename);\n    return LIQUID_OK;\n#else\n    return liquid_error(LIQUID_EICONFIG,""fskframesync_debug_print(), compile-time debugging disabled\\n"");\n#endif\n}')
"
"'Give me the scenario in which you need to set up and configure the PDM hardware voice activity detector (HWVAD) functionality in a microcontroller. You need to initialize the HWVAD with specific configurations, including the noise filter, signal filter, and zero-cross detector settings. Moreover, you also need to handle the HWVAD interrupts for voice detection and errors.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.pdm""\n#endif\ntypedef void (*pdm_isr_t)(PDM_Type *base, pdm_handle_t *pdmHandle);\n#if !(defined FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV && FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV)\nstatic status_t PDM_ValidateSrcClockRate(uint32_t channelMask,\n                                         pdm_df_quality_mode_t qualityMode,\n                                         uint8_t osr,\n                                         uint32_t regDiv);\n#endif\nstatic PDM_Type *const s_pdmBases[] = PDM_BASE_PTRS;\nstatic pdm_handle_t *s_pdmHandle[ARRAY_SIZE(s_pdmBases)];\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_pdmClock[] = PDM_CLOCKS;\n#endif \n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n#if defined(FSL_PDM_HAS_FILTER_CLOCK_GATE) && FSL_PDM_HAS_FILTER_CLOCK_GATE\nstatic const clock_ip_name_t s_pdmFilterClock[] = PDM_FILTER_CLOCKS;\n#endif\n#endif \nstatic pdm_isr_t s_pdmIsr;\n#if !(defined(FSL_FEATURE_PDM_HAS_NO_HWVAD) && FSL_FEATURE_PDM_HAS_NO_HWVAD)\nstatic pdm_hwvad_notification_t s_pdm_hwvad_notification[ARRAY_SIZE(s_pdmBases)];\n#endif\nuint32_t PDM_GetInstance(PDM_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_pdmBases); instance++)\n    {\n        if (s_pdmBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_pdmBases));\n    return instance;\n}\nvoid PDM_ReadFifo(\n    PDM_Type *base, uint32_t startChannel, uint32_t channelNums, void *buffer, size_t size, uint32_t dataWidth)\n{\n    uint32_t i = 0, j = 0U;\n    uint32_t *dataAddr = (uint32_t *)buffer;\n    for (i = 0U; i < size; i++)\n    {\n        for (j = 0; j < channelNums; j++)\n        {\n#if defined(FSL_FEATURE_PDM_FIFO_WIDTH) && (FSL_FEATURE_PDM_FIFO_WIDTH != 2U)\n            *dataAddr = base->DATACH[startChannel + j] >> (dataWidth == 4U ? 0U : 8U);\n            dataAddr  = (uint32_t *)((uint32_t)dataAddr + dataWidth);\n#else\n            *dataAddr = base->DATACH[startChannel + j];\n            dataAddr  = (uint32_t *)((uint32_t)dataAddr + 2U);\n#endif\n        }\n    }\n}\n#if defined(FSL_FEATURE_PDM_FIFO_WIDTH) && (FSL_FEATURE_PDM_FIFO_WIDTH == 2U)\nvoid PDM_ReadNonBlocking(PDM_Type *base, uint32_t startChannel, uint32_t channelNums, int16_t *buffer, size_t size)\n{\n    uint32_t i = 0, j = 0U;\n    for (i = 0U; i < size; i++)\n    {\n        for (j = 0; j < channelNums; j++)\n        {\n            *buffer++ = (int16_t)base->DATACH[startChannel + j];\n        }\n    }\n}\n#endif\n#if !(defined FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV && FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV)\nstatic status_t PDM_ValidateSrcClockRate(uint32_t channelMask,\n                                         pdm_df_quality_mode_t qualityMode,\n                                         uint8_t osr,\n                                         uint32_t regDiv)\n{\n    uint32_t enabledChannel = 0U, i = 0U, factor = 0U, k = 0U;\n    for (i = 0U; i < (uint32_t)FSL_FEATURE_PDM_CHANNEL_NUM; i++)\n    {\n        if (((channelMask >> i) & 0x01U) != 0U)\n        {\n            enabledChannel++;\n        }\n    }\n    switch (qualityMode)\n    {\n        case kPDM_QualityModeMedium:\n            factor = FSL_FEATURE_PDM_HIGH_QUALITY_CLKDIV_FACTOR;\n            k      = 2U;\n            break;\n        case kPDM_QualityModeHigh:\n            factor = FSL_FEATURE_PDM_HIGH_QUALITY_CLKDIV_FACTOR;\n            k      = 1U;\n            break;\n        case kPDM_QualityModeLow:\n            factor = FSL_FEATURE_PDM_HIGH_QUALITY_CLKDIV_FACTOR;\n            k      = 4U;\n            break;\n        case kPDM_QualityModeVeryLow0:\n            factor = FSL_FEATURE_PDM_VERY_LOW_QUALITY_CLKDIV_FACTOR;\n            k      = 2U;\n            break;\n        case kPDM_QualityModeVeryLow1:\n            factor = FSL_FEATURE_PDM_VERY_LOW_QUALITY_CLKDIV_FACTOR;\n            k      = 4U;\n            break;\n        case kPDM_QualityModeVeryLow2:\n            factor = FSL_FEATURE_PDM_VERY_LOW_QUALITY_CLKDIV_FACTOR;\n            k      = 8U;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n    if (((regDiv * k) / 2U * 100U) < (((10U + factor * enabledChannel) * 100U / (8U * osr)) * k / 2U))\n    {\n        return kStatus_Fail;\n    }\n    return kStatus_Success;\n}\n#endif\nstatus_t PDM_SetSampleRateConfig(PDM_Type *base, uint32_t sourceClock_HZ, uint32_t sampleRate_HZ)\n{\n    uint32_t osr = (base->CTRL_2 & PDM_CTRL_2_CICOSR_MASK) >> PDM_CTRL_2_CICOSR_SHIFT;\n#if !(defined FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV && FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV)\n    pdm_df_quality_mode_t qualityMode =\n        (pdm_df_quality_mode_t)(uint32_t)((base->CTRL_2 & PDM_CTRL_2_QSEL_MASK) >> PDM_CTRL_2_QSEL_SHIFT);\n    uint32_t enabledChannelMask = base->CTRL_1 & (uint32_t)kPDM_EnableChannelAll;\n#endif\n    uint32_t pdmClockRate = 0U;\n    uint32_t regDiv       = 0U;\n    osr          = 16U - osr;\n    pdmClockRate = sampleRate_HZ * osr * 8U;\n    regDiv       = sourceClock_HZ / pdmClockRate;\n    if (regDiv > PDM_CTRL_2_CLKDIV_MASK)\n    {\n        return kStatus_Fail;\n    }\n#if !(defined FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV && FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV)\n    if (PDM_ValidateSrcClockRate(enabledChannelMask, qualityMode, (uint8_t)osr, regDiv) == kStatus_Fail)\n    {\n        return kStatus_Fail;\n    }\n#endif\n    base->CTRL_2 = (base->CTRL_2 & (~PDM_CTRL_2_CLKDIV_MASK)) | PDM_CTRL_2_CLKDIV(regDiv);\n    return kStatus_Success;\n}\nstatus_t PDM_SetSampleRate(\n    PDM_Type *base, uint32_t enableChannelMask, pdm_df_quality_mode_t qualityMode, uint8_t osr, uint32_t clkDiv)\n{\n#if !(defined FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV && FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV)\n    uint8_t realOsr = 16U - (osr & (PDM_CTRL_2_CICOSR_MASK >> PDM_CTRL_2_CICOSR_SHIFT));\n#endif\n    uint32_t regDiv = clkDiv >> 1U;\n    switch (qualityMode)\n    {\n        case kPDM_QualityModeHigh:\n            regDiv <<= 1U;\n            break;\n        case kPDM_QualityModeLow:\n        case kPDM_QualityModeVeryLow1:\n            regDiv >>= 1U;\n            break;\n        case kPDM_QualityModeVeryLow2:\n            regDiv >>= 2U;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n#if !(defined FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV && FSL_FEATURE_PDM_HAS_NO_MINIMUM_CLKDIV)\n    if (PDM_ValidateSrcClockRate(enableChannelMask, qualityMode, realOsr, regDiv) == kStatus_Fail)\n    {\n        return kStatus_Fail;\n    }\n#endif\n    assert(regDiv <= PDM_CTRL_2_CLKDIV_MASK);\n    base->CTRL_2 = (base->CTRL_2 & (~PDM_CTRL_2_CLKDIV_MASK)) | PDM_CTRL_2_CLKDIV(regDiv);\n    return kStatus_Success;\n}\nvoid PDM_Init(PDM_Type *base, const pdm_config_t *config)\n{\n    assert(config != NULL);\n    assert(config->fifoWatermark <= PDM_FIFO_CTRL_FIFOWMK_MASK);\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(s_pdmClock[PDM_GetInstance(base)]);\n#if defined(FSL_PDM_HAS_FILTER_CLOCK_GATE) && FSL_PDM_HAS_FILTER_CLOCK_GATE\n    CLOCK_EnableClock(s_pdmFilterClock[PDM_GetInstance(base)]);\n#endif\n#endif \n    base->CTRL_1 &=\n        ~(PDM_CTRL_1_MDIS_MASK | PDM_CTRL_1_PDMIEN_MASK | PDM_CTRL_1_ERREN_MASK | (uint32_t)kPDM_EnableChannelAll);\n    while ((base->STAT & PDM_STAT_BSY_FIL_MASK) != 0U)\n    {\n    }\n    base->CTRL_1 |= PDM_CTRL_1_SRES_MASK;\n    base->CTRL_1 = (base->CTRL_1 & (~PDM_CTRL_1_DOZEN_MASK)) | PDM_CTRL_1_DOZEN(config->enableDoze);\n    base->CTRL_2 = (base->CTRL_2 & (~(PDM_CTRL_2_CICOSR_MASK | PDM_CTRL_2_QSEL_MASK))) |\n                   PDM_CTRL_2_CICOSR(config->cicOverSampleRate) | PDM_CTRL_2_QSEL(config->qualityMode);\n    base->FIFO_CTRL = PDM_FIFO_CTRL_FIFOWMK(config->fifoWatermark);\n}\nvoid PDM_Deinit(PDM_Type *base)\n{\n    PDM_Enable(base, false);\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_DisableClock(s_pdmClock[PDM_GetInstance(base)]);\n#if defined(FSL_PDM_HAS_FILTER_CLOCK_GATE) && FSL_PDM_HAS_FILTER_CLOCK_GATE\n    CLOCK_DisableClock(s_pdmFilterClock[PDM_GetInstance(base)]);\n#endif\n#endif \n}\nvoid PDM_EnableInterrupts(PDM_Type *base, uint32_t mask)\n{\n    if ((mask & (uint32_t)kPDM_FIFOInterruptEnable) != 0U)\n    {\n        base->CTRL_1 = (base->CTRL_1 & (~PDM_CTRL_1_DISEL_MASK)) | (uint32_t)kPDM_FIFOInterruptEnable;\n    }\n    if ((mask & (uint32_t)kPDM_ErrorInterruptEnable) != 0U)\n    {\n        base->CTRL_1 = (base->CTRL_1 & (~PDM_CTRL_1_ERREN_MASK)) | (uint32_t)kPDM_ErrorInterruptEnable;\n    }\n}\nvoid PDM_SetChannelConfig(PDM_Type *base, uint32_t channel, const pdm_channel_config_t *config)\n{\n    assert(config != NULL);\n    assert(channel <= (uint32_t)FSL_FEATURE_PDM_CHANNEL_NUM);\n    uint32_t dcCtrl = 0U;\n#if (defined(FSL_FEATURE_PDM_HAS_DC_OUT_CTRL) && (FSL_FEATURE_PDM_HAS_DC_OUT_CTRL))\n    dcCtrl = base->DC_OUT_CTRL;\n    dcCtrl &= ~((uint32_t)PDM_DC_OUT_CTRL_DCCONFIG0_MASK << (channel << 1U));\n    dcCtrl |= (uint32_t)config->outputCutOffFreq << (channel << 1U);\n    base->DC_OUT_CTRL = dcCtrl;\n#endif\n#if !(defined(FSL_FEATURE_PDM_DC_CTRL_VALUE_FIXED) && (FSL_FEATURE_PDM_DC_CTRL_VALUE_FIXED))\n    dcCtrl = base->DC_CTRL;\n    dcCtrl &= ~((uint32_t)PDM_DC_CTRL_DCCONFIG0_MASK << (channel << 1U));\n    dcCtrl |= (uint32_t)config->cutOffFreq << (channel << 1U);\n    base->DC_CTRL = dcCtrl;\n#endif\n    PDM_SetChannelGain(base, channel, config->gain);\n    base->CTRL_1 |= 1UL << channel;\n}\nvoid PDM_SetChannelGain(PDM_Type *base, uint32_t channel, pdm_df_output_gain_t gain)\n{\n    assert(channel <= (uint32_t)FSL_FEATURE_PDM_CHANNEL_NUM);\n#if defined(FSL_FEATURE_PDM_HAS_RANGE_CTRL) && FSL_FEATURE_PDM_HAS_RANGE_CTRL\n    uint32_t outCtrl = base->RANGE_CTRL;\n#else\n    uint32_t outCtrl = base->OUT_CTRL;\n#endif\n#if defined(FSL_FEATURE_PDM_HAS_RANGE_CTRL) && FSL_FEATURE_PDM_HAS_RANGE_CTRL\n    outCtrl &= ~((uint32_t)PDM_RANGE_CTRL_RANGEADJ0_MASK << (channel << 2U));\n#else\n    outCtrl &= ~((uint32_t)PDM_OUT_CTRL_OUTGAIN0_MASK << (channel << 2U));\n#endif\n    outCtrl |= (uint32_t)gain << (channel << 2U);\n#if defined(FSL_FEATURE_PDM_HAS_RANGE_CTRL) && FSL_FEATURE_PDM_HAS_RANGE_CTRL\n    base->RANGE_CTRL = outCtrl;\n#else\n    base->OUT_CTRL = outCtrl;\n#endif\n}\nstatus_t PDM_TransferSetChannelConfig(\n    PDM_Type *base, pdm_handle_t *handle, uint32_t channel, const pdm_channel_config_t *config, uint32_t format)\n{\n    assert(handle != NULL);\n    PDM_SetChannelConfig(base, channel, config);\n    handle->format = format;\n    if (handle->channelNums == 0U)\n    {\n        handle->startChannel = (uint8_t)channel;\n    }\n    handle->channelNums++;\n    if (handle->channelNums > (uint8_t)FSL_FEATURE_PDM_CHANNEL_NUM)\n    {\n        return kStatus_PDM_ChannelConfig_Failed;\n    }\n    return kStatus_Success;\n}\nvoid PDM_TransferCreateHandle(PDM_Type *base, pdm_handle_t *handle, pdm_transfer_callback_t callback, void *userData)\n{\n    assert(handle != NULL);\n    (void)memset(handle, 0, sizeof(*handle));\n    s_pdmHandle[PDM_GetInstance(base)] = handle;\n    handle->callback  = callback;\n    handle->userData  = userData;\n    handle->watermark = (uint8_t)(base->FIFO_CTRL & PDM_FIFO_CTRL_FIFOWMK_MASK);\n    s_pdmIsr = PDM_TransferHandleIRQ;\n    (void)EnableIRQ(PDM_EVENT_IRQn);\n#if !(defined FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ && FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ)\n    (void)EnableIRQ(PDM_ERROR_IRQn);\n#endif\n}\nstatus_t PDM_TransferReceiveNonBlocking(PDM_Type *base, pdm_handle_t *handle, pdm_transfer_t *xfer)\n{\n    assert(handle != NULL);\n    if (handle->pdmQueue[handle->queueUser].data != NULL)\n    {\n        return kStatus_PDM_QueueFull;\n    }\n    handle->transferSize[handle->queueUser]      = xfer->dataSize;\n    handle->pdmQueue[handle->queueUser].data     = xfer->data;\n    handle->pdmQueue[handle->queueUser].dataSize = xfer->dataSize;\n    handle->queueUser                            = (handle->queueUser + 1U) % PDM_XFER_QUEUE_SIZE;\n    handle->state = kStatus_PDM_Busy;\n    PDM_EnableInterrupts(base, (uint32_t)kPDM_FIFOInterruptEnable);\n    PDM_Enable(base, true);\n    return kStatus_Success;\n}\nvoid PDM_TransferAbortReceive(PDM_Type *base, pdm_handle_t *handle)\n{\n    assert(handle != NULL);\n    PDM_DisableInterrupts(base, (uint32_t)kPDM_FIFOInterruptEnable | (uint32_t)kPDM_ErrorInterruptEnable);\n    PDM_Enable(base, false);\n    handle->state = kStatus_PDM_Idle;\n    (void)memset(handle->pdmQueue, 0, sizeof(pdm_transfer_t) * PDM_XFER_QUEUE_SIZE);\n    handle->queueDriver = 0;\n    handle->queueUser   = 0;\n}\nvoid PDM_TransferHandleIRQ(PDM_Type *base, pdm_handle_t *handle)\n{\n    assert(handle != NULL);\n#if (defined FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ && FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ)\n    uint32_t status = 0U;\n#if (defined(FSL_FEATURE_PDM_HAS_STATUS_LOW_FREQ) && (FSL_FEATURE_PDM_HAS_STATUS_LOW_FREQ == 1U))\n    if (PDM_GetStatus(base) & PDM_STAT_LOWFREQF_MASK)\n    {\n        PDM_ClearStatus(base, PDM_STAT_LOWFREQF_MASK);\n        if (handle->callback != NULL)\n        {\n            (handle->callback)(base, handle, kStatus_PDM_CLK_LOW, handle->userData);\n        }\n    }\n#endif\n    status = PDM_GetFifoStatus(base);\n    if (status != 0U)\n    {\n        PDM_ClearFIFOStatus(base, status);\n        if (handle->callback != NULL)\n        {\n            (handle->callback)(base, handle, kStatus_PDM_FIFO_ERROR, handle->userData);\n        }\n    }\n#if !(defined(FSL_FEATURE_PDM_HAS_RANGE_CTRL) && FSL_FEATURE_PDM_HAS_RANGE_CTRL)\n    status = PDM_GetOutputStatus(base);\n    if (status != 0U)\n    {\n        PDM_ClearOutputStatus(base, status);\n        if (handle->callback != NULL)\n        {\n            (handle->callback)(base, handle, kStatus_PDM_Output_ERROR, handle->userData);\n        }\n    }\n#endif\n#endif\n    if (((base->STAT & 0xFFU) != 0U) && (handle->channelNums != 0U) &&\n        ((base->CTRL_1 & PDM_CTRL_1_DISEL_MASK) == (0x2UL << PDM_CTRL_1_DISEL_SHIFT)))\n    {\n        PDM_ClearStatus(base, 0xFFU);\n        uint8_t size = (uint8_t)MIN((handle->pdmQueue[handle->queueDriver].dataSize),\n                                    ((uint32_t)handle->watermark * handle->channelNums * handle->format));\n        PDM_ReadFifo(base, handle->startChannel, handle->channelNums,\n                     (uint8_t *)(uint32_t)handle->pdmQueue[handle->queueDriver].data,\n                     ((size_t)size / handle->channelNums / handle->format), handle->format);\n        handle->pdmQueue[handle->queueDriver].dataSize -= size;\n        handle->pdmQueue[handle->queueDriver].data = &(handle->pdmQueue[handle->queueDriver].data[size]);\n    }\n    if (handle->pdmQueue[handle->queueDriver].dataSize == 0U)\n    {\n        handle->pdmQueue[handle->queueDriver].data = NULL;\n        handle->queueDriver                        = (handle->queueDriver + 1U) % PDM_XFER_QUEUE_SIZE;\n        if (handle->callback != NULL)\n        {\n            (handle->callback)(base, handle, kStatus_PDM_Idle, handle->userData);\n        }\n    }\n    if (handle->pdmQueue[handle->queueDriver].data == NULL)\n    {\n        PDM_TransferAbortReceive(base, handle);\n    }\n}\n#if !(defined(FSL_FEATURE_PDM_HAS_NO_HWVAD) && FSL_FEATURE_PDM_HAS_NO_HWVAD)\nvoid PDM_SetHwvadInEnvelopeBasedMode(PDM_Type *base,\n                                     const pdm_hwvad_config_t *hwvadConfig,\n                                     const pdm_hwvad_noise_filter_t *noiseConfig,\n                                     const pdm_hwvad_zero_cross_detector_t *zcdConfig,\n                                     uint32_t signalGain)\n{\n    assert(hwvadConfig != NULL);\n    assert(noiseConfig != NULL);\n    uint32_t i = 0U;\n    PDM_SetHwvadConfig(base, hwvadConfig);\n    PDM_SetHwvadSignalFilterConfig(base, true, signalGain);\n    PDM_SetHwvadNoiseFilterConfig(base, noiseConfig);\n    PDM_EnableHwvad(base, true);\n    if (NULL != zcdConfig)\n    {\n        PDM_SetHwvadZeroCrossDetectorConfig(base, zcdConfig);\n    }\n    PDM_Enable(base, true);\n    while (PDM_GetHwvadInitialFlag(base) != 0U)\n    {\n    }\n    for (i = 0; i < 3U; i++)\n    {\n        PDM_SetHwvadInternalFilterStatus(base, kPDM_HwvadInternalFilterInitial);\n    }\n    PDM_SetHwvadInternalFilterStatus(base, kPDM_HwvadInternalFilterNormalOperation);\n}\nvoid PDM_SetHwvadInEnergyBasedMode(PDM_Type *base,\n                                   const pdm_hwvad_config_t *hwvadConfig,\n                                   const pdm_hwvad_noise_filter_t *noiseConfig,\n                                   const pdm_hwvad_zero_cross_detector_t *zcdConfig,\n                                   uint32_t signalGain)\n{\n    assert(hwvadConfig != NULL);\n    assert(noiseConfig != NULL);\n    PDM_SetHwvadConfig(base, hwvadConfig);\n    base->VAD0_SCONFIG = PDM_VAD0_SCONFIG_VADSGAIN(signalGain);\n    PDM_SetHwvadNoiseFilterConfig(base, noiseConfig);\n    PDM_EnableHwvad(base, true);\n    if (NULL != zcdConfig)\n    {\n        PDM_SetHwvadZeroCrossDetectorConfig(base, zcdConfig);\n    }\n    PDM_Enable(base, true);\n}\nvoid PDM_SetHwvadConfig(PDM_Type *base, const pdm_hwvad_config_t *config)\n{\n    assert(config != NULL);\n    uint32_t ctrl1 = base->VAD0_CTRL_1;\n    ctrl1 &= ~(PDM_VAD0_CTRL_1_VADCHSEL_MASK | PDM_VAD0_CTRL_1_VADCICOSR_MASK | PDM_VAD0_CTRL_1_VADINITT_MASK);\n    ctrl1 |= (PDM_VAD0_CTRL_1_VADCHSEL(config->channel) | PDM_VAD0_CTRL_1_VADCICOSR(config->cicOverSampleRate) |\n              PDM_VAD0_CTRL_1_VADINITT(config->initializeTime));\n    base->VAD0_CTRL_1 = ctrl1;\n    base->VAD0_CTRL_2 =\n        (PDM_VAD0_CTRL_2_VADFRENDIS((config->enableFrameEnergy == true) ? 0U : 1U) |\n         PDM_VAD0_CTRL_2_VADPREFEN(config->enablePreFilter) | PDM_VAD0_CTRL_2_VADFRAMET(config->frameTime) |\n         PDM_VAD0_CTRL_2_VADINPGAIN(config->inputGain) | PDM_VAD0_CTRL_2_VADHPF(config->cutOffFreq));\n}\nvoid PDM_SetHwvadSignalFilterConfig(PDM_Type *base, bool enableMaxBlock, uint32_t signalGain)\n{\n    uint32_t signalConfig = base->VAD0_SCONFIG;\n    signalConfig &= ~(PDM_VAD0_SCONFIG_VADSMAXEN_MASK | PDM_VAD0_SCONFIG_VADSGAIN_MASK);\n    signalConfig |= (PDM_VAD0_SCONFIG_VADSMAXEN(enableMaxBlock) | PDM_VAD0_SCONFIG_VADSGAIN(signalGain)) |\n                    PDM_VAD0_SCONFIG_VADSFILEN_MASK;\n    base->VAD0_SCONFIG = signalConfig;\n}\nvoid PDM_SetHwvadNoiseFilterConfig(PDM_Type *base, const pdm_hwvad_noise_filter_t *config)\n{\n    assert(config != NULL);\n    base->VAD0_NCONFIG =\n        (PDM_VAD0_NCONFIG_VADNFILAUTO(config->enableAutoNoiseFilter) |\n         PDM_VAD0_NCONFIG_VADNOREN(config->enableNoiseDetectOR) | PDM_VAD0_NCONFIG_VADNMINEN(config->enableNoiseMin) |\n         PDM_VAD0_NCONFIG_VADNDECEN(config->enableNoiseDecimation) |\n         PDM_VAD0_NCONFIG_VADNFILADJ(config->noiseFilterAdjustment) | PDM_VAD0_NCONFIG_VADNGAIN(config->noiseGain));\n}\nvoid PDM_SetHwvadZeroCrossDetectorConfig(PDM_Type *base, const pdm_hwvad_zero_cross_detector_t *config)\n{\n    assert(config != NULL);\n    uint32_t zcd = (base->VAD0_ZCD & (~(PDM_VAD0_ZCD_VADZCDTH_MASK | PDM_VAD0_ZCD_VADZCDADJ_MASK |\n                                        PDM_VAD0_ZCD_VADZCDAUTO_MASK | PDM_VAD0_ZCD_VADZCDAND_MASK)));\n    zcd |= (PDM_VAD0_ZCD_VADZCDTH(config->threshold) | PDM_VAD0_ZCD_VADZCDADJ(config->adjustmentThreshold) |\n            PDM_VAD0_ZCD_VADZCDAUTO(config->enableAutoThreshold) | PDM_VAD0_ZCD_VADZCDAND(config->zcdAnd)) |\n           PDM_VAD0_ZCD_VADZCDEN_MASK;\n    base->VAD0_ZCD = zcd;\n}\nvoid PDM_EnableHwvadInterruptCallback(PDM_Type *base, pdm_hwvad_callback_t vadCallback, void *userData, bool enable)\n{\n    uint32_t instance = PDM_GetInstance(base);\n    if (enable)\n    {\n        PDM_EnableHwvadInterrupts(base, (uint32_t)kPDM_HwvadErrorInterruptEnable | (uint32_t)kPDM_HwvadInterruptEnable);\n        NVIC_ClearPendingIRQ(PDM_HWVAD_EVENT_IRQn);\n        (void)EnableIRQ(PDM_HWVAD_EVENT_IRQn);\n#if !(defined FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ && FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ)\n        NVIC_ClearPendingIRQ(PDM_HWVAD_ERROR_IRQn);\n        (void)EnableIRQ(PDM_HWVAD_ERROR_IRQn);\n#endif\n        s_pdm_hwvad_notification[instance].callback = vadCallback;\n        s_pdm_hwvad_notification[instance].userData = userData;\n    }\n    else\n    {\n        PDM_DisableHwvadInterrupts(base,\n                                   (uint32_t)kPDM_HwvadErrorInterruptEnable | (uint32_t)kPDM_HwvadInterruptEnable);\n        (void)DisableIRQ(PDM_HWVAD_EVENT_IRQn);\n#if !(defined FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ && FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ)\n        (void)DisableIRQ(PDM_HWVAD_ERROR_IRQn);\n        NVIC_ClearPendingIRQ(PDM_HWVAD_ERROR_IRQn);\n#endif\n        s_pdm_hwvad_notification[instance].callback = NULL;\n        s_pdm_hwvad_notification[instance].userData = NULL;\n        NVIC_ClearPendingIRQ(PDM_HWVAD_EVENT_IRQn);\n    }\n}\n#if (defined PDM)\nvoid PDM_HWVAD_EVENT_DriverIRQHandler(void);\nvoid PDM_HWVAD_EVENT_DriverIRQHandler(void)\n{\n    if ((PDM_GetHwvadInterruptStatusFlags(PDM) & (uint32_t)kPDM_HwvadStatusVoiceDetectFlag) != 0U)\n    {\n        PDM_ClearHwvadInterruptStatusFlags(PDM, (uint32_t)kPDM_HwvadStatusVoiceDetectFlag);\n        if (s_pdm_hwvad_notification[0].callback != NULL)\n        {\n            s_pdm_hwvad_notification[0].callback(kStatus_PDM_HWVAD_VoiceDetected, s_pdm_hwvad_notification[0].userData);\n        }\n    }\n#if (defined FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ && FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ)\n    else\n    {\n        PDM_ClearHwvadInterruptStatusFlags(PDM, (uint32_t)kPDM_HwvadStatusInputSaturation);\n        if (s_pdm_hwvad_notification[0].callback != NULL)\n        {\n            s_pdm_hwvad_notification[0].callback(kStatus_PDM_HWVAD_Error, s_pdm_hwvad_notification[0].userData);\n        }\n    }\n#endif\n    SDK_ISR_EXIT_BARRIER;\n}\n#if !(defined FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ && FSL_FEATURE_PDM_HAS_NO_INDEPENDENT_ERROR_IRQ)\nvoid PDM_HWVAD_ERROR_DriverIRQHandler(void);\nvoid PDM_HWVAD_ERROR_DriverIRQHandler(void)\n{\n    PDM_ClearHwvadInterruptStatusFlags(PDM, (uint32_t)kPDM_HwvadStatusInputSaturation);\n    if (s_pdm_hwvad_notification[0].callback != NULL)\n    {\n        s_pdm_hwvad_notification[0].callback(kStatus_PDM_HWVAD_Error, s_pdm_hwvad_notification[0].userData);\n    }\n    SDK_ISR_EXIT_BARRIER;\n}\n#endif\n#endif\n#endif\n#if defined(PDM)\nvoid PDM_EVENT_DriverIRQHandler(void);\nvoid PDM_EVENT_DriverIRQHandler(void)\n{\n    assert(s_pdmHandle[0] != NULL);\n    s_pdmIsr(PDM, s_pdmHandle[0]);\n    SDK_ISR_EXIT_BARRIER;\n}\n#endif'"
"('Here is the prompt you could have given me:. . ""I need a C code snippet for implementing a Second-Order Section (SOS) Infinite Impulse Response (IIR) filter. The filter coefficients are defined by arrays `_b` and `_a`, and I want to be able to create, copy, destroy, reset, execute (both direct form 1 and direct form 2), and print this filter. Also, I would like the option to use dot product optimization if needed. Can you provide me with this code?""","#define LIQUID_IIRFILTSOS_USE_DOTPROD   (0)\nstruct IIRFILTSOS(_s) {\n    TC b[3];    \n    TC a[3];    \n    TI x[3];    \n    TO y[3];    \n    TO v[3];    \n#if LIQUID_IIRFILTSOS_USE_DOTPROD\n    DOTPROD() dpb;  \n    DOTPROD() dpa;  \n#endif\n};\nIIRFILTSOS() IIRFILTSOS(_create)(TC * _b,\n                                 TC * _a)\n{\n    IIRFILTSOS() q = (IIRFILTSOS()) malloc(sizeof(struct IIRFILTSOS(_s)));\n    IIRFILTSOS(_set_coefficients)(q, _b, _a);\n    IIRFILTSOS(_reset)(q);\n    return q;\n}\nint IIRFILTSOS(_set_coefficients)(IIRFILTSOS() _q,\n                                  TC *         _b,\n                                  TC *         _a)\n{\n    TC a0 = _a[0];\n    _q->b[0] = _b[0] / a0;\n    _q->b[1] = _b[1] / a0;\n    _q->b[2] = _b[2] / a0;\n    _q->a[0] = _a[0] / a0;  \n    _q->a[1] = _a[1] / a0;\n    _q->a[2] = _a[2] / a0;\n#if LIQUID_IIRFILTSOS_USE_DOTPROD\n    _q->dpa = DOTPROD(_create)(_q->a+1, 2);\n    _q->dpb = DOTPROD(_create)(_q->b,   3);\n#endif\n    return LIQUID_OK;\n}\nIIRFILTSOS() IIRFILTSOS(_copy)(IIRFILTSOS() q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""iirfiltsos_%s_copy(), object cannot be NULL"", EXTENSION_FULL);\n    IIRFILTSOS() q_copy = (IIRFILTSOS()) malloc(sizeof(struct IIRFILTSOS(_s)));\n    memmove(q_copy, q_orig, sizeof(struct IIRFILTSOS(_s)));\n#if LIQUID_IIRFILTSOS_USE_DOTPROD\n    q_copy->dpa = DOTPROD(_copy)(q_orig->dpa);\n    q_copy->dpb = DOTPROD(_copy)(q_orig->dpb);\n#endif\n    return q_copy;\n}\nint IIRFILTSOS(_destroy)(IIRFILTSOS() _q)\n{\n#if LIQUID_IIRFILTSOS_USE_DOTPROD\n    DOTPROD(_destroy)(_q->dpa);\n    DOTPROD(_destroy)(_q->dpb);\n#endif\n    free(_q);\n    return LIQUID_OK;\n}\nint IIRFILTSOS(_print)(IIRFILTSOS() _q)\n{\n    printf(""iir filter | sos:\\n"");\n    printf(""  b : "");\n    PRINTVAL_TC(_q->b[0],%12.8f); printf("","");\n    PRINTVAL_TC(_q->b[1],%12.8f); printf("","");\n    PRINTVAL_TC(_q->b[2],%12.8f); printf(""\\n"");\n    printf(""  a : "");\n    PRINTVAL_TC(_q->a[0],%12.8f); printf("","");\n    PRINTVAL_TC(_q->a[1],%12.8f); printf("","");\n    PRINTVAL_TC(_q->a[2],%12.8f); printf(""\\n"");\n    return LIQUID_OK;\n}\nint IIRFILTSOS(_reset)(IIRFILTSOS() _q)\n{\n    _q->v[0] = 0;\n    _q->v[1] = 0;\n    _q->v[2] = 0;\n    _q->x[0] = 0;\n    _q->x[1] = 0;\n    _q->x[2] = 0;\n    _q->y[0] = 0;\n    _q->y[1] = 0;\n    _q->y[2] = 0;\n    return LIQUID_OK;\n}\nint IIRFILTSOS(_execute)(IIRFILTSOS() _q,\n                         TI           _x,\n                         TO *         _y)\n{\n    return IIRFILTSOS(_execute_df2)(_q,_x,_y);\n}\nint IIRFILTSOS(_execute_df1)(IIRFILTSOS() _q,\n                             TI           _x,\n                             TO *         _y)\n{\n    _q->x[2] = _q->x[1];\n    _q->x[1] = _q->x[0];\n    _q->x[0] = _x;\n    _q->y[2] = _q->y[1];\n    _q->y[1] = _q->y[0];\n#if LIQUID_IIRFILTSOS_USE_DOTPROD\n    TI v;\n    DOTPROD(_execute)(_q->dpb, _q->x, &v);\n    TI y0;\n    DOTPROD(_execute)(_q->dpa, _q->y+1, &y0);\n    _q->y[0] = v - y0;\n#else\n    TI v = _q->x[0] * _q->b[0] +\n           _q->x[1] * _q->b[1] +\n           _q->x[2] * _q->b[2];\n    _q->y[0] = v -\n               _q->y[1] * _q->a[1] -\n               _q->y[2] * _q->a[2];\n#endif\n    *_y = _q->y[0];\n    return LIQUID_OK;\n}\nint IIRFILTSOS(_execute_df2)(IIRFILTSOS() _q,\n                             TI           _x,\n                             TO *         _y)\n{\n    _q->v[2] = _q->v[1];\n    _q->v[1] = _q->v[0];\n#if LIQUID_IIRFILTSOS_USE_DOTPROD\n    TI v0;\n    DOTPROD(_execute)(_q->dpa, _q->v+1, &v0);\n    v0 = _x - v0;\n    _q->v[0] = v0;\n    DOTPROD(_execute)(_q->dpb, _q->v, _y);\n#else\n    _q->v[0] = _x -\n               _q->a[1]*_q->v[1] -\n               _q->a[2]*_q->v[2];\n    *_y = _q->b[0]*_q->v[0] +\n          _q->b[1]*_q->v[1] +\n          _q->b[2]*_q->v[2];\n#endif\n    return LIQUID_OK;\n}\nfloat IIRFILTSOS(_groupdelay)(IIRFILTSOS() _q,\n                              float        _fc)\n{\n    float b[3];\n    float a[3];\n    unsigned int i;\n    for (i=0; i<3; i++) {\n        b[i] = crealf(_q->b[i]);\n        a[i] = crealf(_q->a[i]);\n    }\n    return iir_group_delay(b, 3, a, 3, _fc) + 2.0;\n}')
"
"('Please provide a code snippet for an automated test scenario that involves generating FSK frames, adding noise, and performing frame synchronization to test header and payload validity. The code should include a callback function `callback_fskframesync_autotest` that updates a counter based on the validity of the header and payload, and a test function `autotest_fskframesync` that sets up the FSK frame generation, noise addition, and synchronization process. The test should ensure that a single frame is successfully recovered with valid header and payload.","static int callback_fskframesync_autotest(\n    unsigned char *  _header,\n    int              _header_valid,\n    unsigned char *  _payload,\n    unsigned int     _payload_len,\n    int              _payload_valid,\n    framesyncstats_s _stats,\n    void *           _userdata)\n{\n    *((int*)(_userdata)) += _header_valid && _payload_valid ? 1 : 0;\n    return 0;\n}\nvoid autotest_fskframesync()\n{\n    float SNRdB       =  20.0f; \n    float noise_floor = -20.0f; \n    crc_scheme check         = LIQUID_CRC_32;   \n    fec_scheme fec0          = LIQUID_FEC_NONE; \n    fec_scheme fec1          = LIQUID_FEC_NONE; \n    float nstd  = powf(10.0f, noise_floor/20.0f);         \n    float gamma = powf(10.0f, (SNRdB+noise_floor)/20.0f); \n    unsigned int i;\n    int frames_recovered = 0;\n    fskframegen fg = fskframegen_create();\n    fskframesync fs = fskframesync_create(callback_fskframesync_autotest,\n            (void*)&frames_recovered);\n    unsigned char header [  8];\n    unsigned char payload[200];\n    for (i=0; i<  8; i++) header [i] = i;\n    for (i=0; i<200; i++) payload[i] = rand() & 0xff;\n    fskframegen_assemble(fg, header, payload, 200, check, fec0, fec1);\n    unsigned int  buf_len = 256;\n    float complex buf_tx[buf_len];  \n    float complex buf_rx[buf_len];  \n    int frame_complete = 0;\n    while (!frame_complete)\n    {\n        frame_complete = fskframegen_write_samples(fg, buf_tx, buf_len);\n        for (i=0; i<buf_len; i++)\n            buf_rx[i] = buf_tx[i]*gamma + nstd*(randnf() + randnf()*_Complex_I)*M_SQRT1_2;\n        fskframesync_execute_block(fs, buf_rx, buf_len);\n    }\n    CONTEND_EQUALITY( frames_recovered, 1 );\n#if 0\n    framedatastats_s stats = fskframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received, 64);\n#endif\n    fskframegen_destroy(fg);\n    fskframesync_destroy(fs);\n}')
"
"'Sure, the prompt could have been:. ""I need functions to enable, disable, reset, select slot and set the bus width for a High Speed MultiMedia Card Interface (HSMCI). Additionally, functions to configure mode, enable proof, control PADV, enable/disable FByte, set clock and power division, enable/disable interrupts, configure transfer and data timeouts, send commands, read/write data, get status, configure DMA, enable/disable DMA, enable/disable High-Speed mode, configure write protection, and get write protection status. Can you provide me with these functions?""","extern void HSMCI_Enable(Hsmci *pRMci)\n{\n\tpRMci->HSMCI_CR = HSMCI_CR_MCIEN;\n}\nextern void HSMCI_Disable(Hsmci *pRMci)\n{\n\tpRMci->HSMCI_CR = HSMCI_CR_MCIDIS;\n}\nextern void HSMCI_Reset(Hsmci *pRMci, uint8_t bBackup)\n{\n\tif (bBackup) {\n\t\tuint32_t mr    = pRMci->HSMCI_MR;\n\t\tuint32_t dtor  = pRMci->HSMCI_DTOR;\n\t\tuint32_t sdcr  = pRMci->HSMCI_SDCR;\n\t\tuint32_t cstor = pRMci->HSMCI_CSTOR;\n\t\tuint32_t dma   = pRMci->HSMCI_DMA;\n\t\tuint32_t cfg   = pRMci->HSMCI_CFG;\n\t\tpRMci->HSMCI_CR = HSMCI_CR_SWRST;\n\t\tpRMci->HSMCI_MR    = mr;\n\t\tpRMci->HSMCI_DTOR  = dtor;\n\t\tpRMci->HSMCI_SDCR  = sdcr;\n\t\tpRMci->HSMCI_CSTOR = cstor;\n\t\tpRMci->HSMCI_DMA   = dma;\n\t\tpRMci->HSMCI_CFG   = cfg;\n\t} else\n\t\tpRMci->HSMCI_CR = HSMCI_CR_SWRST;\n}\nextern void HSMCI_Select(Hsmci *pRMci, uint8_t bSlot, uint8_t bBusWidth)\n{\n\tuint32_t dwSdcr;\n\tdwSdcr = (HSMCI_SDCR_SDCSEL_Msk & bSlot);\n\tswitch (bBusWidth) {\n\tcase 1:\n\t\tpRMci->HSMCI_SDCR = dwSdcr | HSMCI_SDCR_SDCBUS_1;\n\t\tbreak;\n\tcase 4:\n\t\tpRMci->HSMCI_SDCR = dwSdcr | HSMCI_SDCR_SDCBUS_4;\n\t\tbreak;\n\tcase 8:\n\t\tpRMci->HSMCI_SDCR = dwSdcr | HSMCI_SDCR_SDCBUS_8;\n\t\tbreak;\n\t}\n}\nextern void HSMCI_SetSlot(Hsmci *pRMci, uint8_t bSlot)\n{\n\tuint32_t dwSdcr = pRMci->HSMCI_SDCR & ~HSMCI_SDCR_SDCSEL_Msk;\n\tpRMci->HSMCI_SDCR = dwSdcr | (HSMCI_SDCR_SDCSEL_Msk & bSlot);\n}\nextern void HSMCI_SetBusWidth(Hsmci *pRMci, uint8_t bBusWidth)\n{\n\tuint32_t dwSdcr = pRMci->HSMCI_SDCR & ~HSMCI_SDCR_SDCBUS_Msk;\n\tswitch (bBusWidth) {\n\tcase 1:\n\t\tpRMci->HSMCI_SDCR = dwSdcr | HSMCI_SDCR_SDCBUS_1;\n\t\tbreak;\n\tcase 4:\n\t\tpRMci->HSMCI_SDCR = dwSdcr | HSMCI_SDCR_SDCBUS_4;\n\t\tbreak;\n\tcase 8:\n\t\tpRMci->HSMCI_SDCR = dwSdcr | HSMCI_SDCR_SDCBUS_8;\n\t\tbreak;\n\t}\n}\nextern uint8_t HSMCI_GetBusWidth(Hsmci *pRMci)\n{\n\tswitch (pRMci->HSMCI_SDCR & HSMCI_SDCR_SDCBUS_Msk) {\n\tcase HSMCI_SDCR_SDCBUS_1: return 1;\n\tcase HSMCI_SDCR_SDCBUS_4: return 4;\n\tcase HSMCI_SDCR_SDCBUS_8: return 8;\n\t}\n\treturn 0;\n}\nextern void HSMCI_ConfigureMode(Hsmci *pRMci, uint32_t dwMode)\n{\n\tpRMci->HSMCI_MR = dwMode;\n}\nextern uint32_t HSMCI_GetMode(Hsmci *pRMci)\n{\n\treturn pRMci->HSMCI_MR;\n}\nextern void HSMCI_ProofEnable(Hsmci *pRMci, uint8_t bRdProof, uint8_t bWrProof)\n{\n\tuint32_t mr = pRMci->HSMCI_MR;\n\tpRMci->HSMCI_MR = (mr & (~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF)))\n\t\t\t\t\t  | (bRdProof ? HSMCI_MR_RDPROOF : 0)\n\t\t\t\t\t  | (bWrProof ? HSMCI_MR_WRPROOF : 0)\n\t\t\t\t\t ;\n}\nextern void HSMCI_PadvCtl(Hsmci *pRMci, uint8_t bPadv)\n{\n\tif (bPadv)\n\t\tpRMci->HSMCI_MR |= HSMCI_MR_PADV;\n\telse\n\t\tpRMci->HSMCI_MR &= ~HSMCI_MR_PADV;\n}\nextern void HSMCI_FByteEnable(Hsmci *pRMci, uint8_t bFByteEn)\n{\n\tif (bFByteEn)\n\t\tpRMci->HSMCI_MR |= HSMCI_MR_FBYTE;\n\telse\n\t\tpRMci->HSMCI_MR &= ~HSMCI_MR_FBYTE;\n}\nextern uint8_t HSMCI_IsFByteEnabled(Hsmci *pRMci)\n{\n\treturn ((pRMci->HSMCI_MR & HSMCI_MR_FBYTE) > 0);\n}\nextern void HSMCI_DivCtrl(Hsmci *pRMci, uint32_t bClkDiv, uint8_t bPwsDiv)\n{\n\tuint32_t mr = pRMci->HSMCI_MR;\n\tuint32_t clkdiv , clkodd;\n\tclkdiv = bClkDiv - 2;\n\tclkodd = (bClkDiv & 1) ? HSMCI_MR_CLKODD : 0;\n\tclkdiv = clkdiv >> 1;\n\tpRMci->HSMCI_MR = (mr & ~(HSMCI_MR_CLKDIV_Msk | HSMCI_MR_PWSDIV_Msk))\n\t\t\t\t\t  | HSMCI_MR_CLKDIV(clkdiv)\n\t\t\t\t\t  | HSMCI_MR_PWSDIV(bPwsDiv)\n\t\t\t\t\t  | clkodd\n\t\t\t\t\t ;\n}\nextern void HSMCI_EnableIt(Hsmci *pRMci, uint32_t dwSources)\n{\n\tpRMci->HSMCI_IER = dwSources;\n}\nextern void HSMCI_DisableIt(Hsmci *pRMci, uint32_t dwSources)\n{\n\tpRMci->HSMCI_IDR = dwSources;\n}\nextern uint32_t HSMCI_GetItMask(Hsmci *pRMci)\n{\n\treturn (pRMci->HSMCI_IMR);\n}\nextern void HSMCI_ConfigureTransfer(Hsmci *pRMci,\n\t\t\t\t\t\t\t\t\tuint16_t wBlkLen,\n\t\t\t\t\t\t\t\t\tuint16_t wCnt)\n{\n\tpRMci->HSMCI_BLKR = (wBlkLen << 16) | wCnt;\n}\nextern void HSMCI_SetBlockLen(Hsmci *pRMci, uint16_t wBlkSize)\n{\n\tpRMci->HSMCI_BLKR = wBlkSize << 16;\n}\nextern void HSMCI_SetBlockCount(Hsmci *pRMci, uint16_t wBlkCnt)\n{\n\tpRMci->HSMCI_BLKR |= wBlkCnt;\n}\nextern void HSMCI_ConfigureCompletionTO(Hsmci *pRMci, uint32_t dwConfigure)\n{\n\tpRMci->HSMCI_CSTOR = dwConfigure;\n}\nextern void HSMCI_ConfigureDataTO(Hsmci *pRMci, uint32_t dwConfigure)\n{\n\tpRMci->HSMCI_DTOR = dwConfigure;\n}\nextern void HSMCI_SendCmd(Hsmci *pRMci, uint32_t dwCmd, uint32_t dwArg)\n{\n\tpRMci->HSMCI_ARGR = dwArg;\n\tpRMci->HSMCI_CMDR = dwCmd;\n}\nextern uint32_t HSMCI_GetResponse(Hsmci *pRMci)\n{\n\treturn pRMci->HSMCI_RSPR[0];\n}\nextern uint32_t HSMCI_Read(Hsmci *pRMci)\n{\n\treturn pRMci->HSMCI_RDR;\n}\nextern void HSMCI_ReadFifo(Hsmci *pRMci, uint8_t *pdwData, uint32_t dwSize)\n{\n\tvolatile uint32_t *pFIFO = (volatile uint32_t *)(pRMci->HSMCI_FIFO);\n\tregister uint32_t c4, c1;\n\tif (dwSize == 0)\n\t\treturn;\n\tc4 = dwSize >> 2;\n\tc1 = dwSize & 0x3;\n\tfor (; c4; c4 --) {\n\t\t*pdwData ++ = *pFIFO ++;\n\t\t*pdwData ++ = *pFIFO ++;\n\t\t*pdwData ++ = *pFIFO ++;\n\t\t*pdwData ++ = *pFIFO ++;\n\t}\n\tfor (; c1; c1 --)\n\t\t*pdwData ++ = *pFIFO ++;\n}\nextern void HSMCI_Write(Hsmci *pRMci, uint32_t dwData)\n{\n\tpRMci->HSMCI_TDR = dwData;\n}\nextern void HSMCI_WriteFifo(Hsmci *pRMci, uint8_t *pdwData, uint32_t dwSize)\n{\n\tvolatile uint32_t *pFIFO = (volatile uint32_t *)(pRMci->HSMCI_FIFO);\n\tregister uint32_t c4, c1;\n\tif (dwSize == 0)\n\t\treturn;\n\tc4 = dwSize >> 2;\n\tc1 = dwSize & 0x3;\n\tfor (; c4; c4 --) {\n\t\t*pFIFO ++ = *pdwData ++;\n\t\t*pFIFO ++ = *pdwData ++;\n\t\t*pFIFO ++ = *pdwData ++;\n\t\t*pFIFO ++ = *pdwData ++;\n\t}\n\tfor (; c1; c1 --)\n\t\t*pFIFO ++ = *pdwData ++;\n}\nextern uint32_t HSMCI_GetStatus(Hsmci *pRMci)\n{\n\treturn pRMci->HSMCI_SR;\n}\nextern void HSMCI_ConfigureDma(Hsmci *pRMci, uint32_t dwConfigure)\n{\n\tpRMci->HSMCI_DMA = dwConfigure;\n}\nextern void HSMCI_EnableDma(Hsmci *pRMci, uint8_t bEnable)\n{\n\tif (bEnable) {\n\t\tpRMci->HSMCI_DMA |= HSMCI_DMA_DMAEN;\n\t} else\n\t\tpRMci->HSMCI_DMA &= ~HSMCI_DMA_DMAEN;\n}\nextern void HSMCI_Configure(Hsmci *pRMci, uint32_t dwConfigure)\n{\n\tpRMci->HSMCI_CFG = dwConfigure;\n}\nextern void HSMCI_HsEnable(Hsmci *pRMci, uint8_t bHsEnable)\n{\n\tif (bHsEnable)\n\t\tpRMci->HSMCI_CFG |= HSMCI_CFG_HSMODE;\n\telse\n\t\tpRMci->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;\n}\nextern uint8_t HSMCI_IsHsEnabled(Hsmci *pRMci)\n{\n\treturn ((pRMci->HSMCI_CFG & HSMCI_CFG_HSMODE) > 0);\n}\nextern void HSMCI_ConfigureWP(Hsmci *pRMci, uint32_t dwConfigure)\n{\n\tpRMci->HSMCI_WPMR = dwConfigure;\n}\nextern uint32_t HSMCI_GetWPStatus(Hsmci *pRMci)\n{\n\treturn pRMci->HSMCI_WPSR;\n}'"
"('Prompt: Can you provide a code snippet for a function that generates a random float value using an inline function call within a C++ program? In this scenario, the inline function should return a random float value.","//...\nfloat randf() {\n    return randf_inline();\n}\n//...')
"
"'Please provide a description of the technical scenario where you need to initialize a JFFS2 filesystem on a Xilinx ZynqMP NAND flash memory. In this scenario, you have a custom flash control structure (`flash_control`) that includes a reference to a Xilinx NAND flash controller (`XNandPsu`), as well as mutex for access control. You also have functions for reading, writing, erasing, checking bad blocks, marking bad blocks, and handling out-of-band data on the flash memory.. . Given this scenario, you need to initialize the JFFS2 filesystem on the NAND flash memory by calling the `xilinx_zynqmp_nand_jffs2_initialize` function. This function initializes the `flash_instance` with necessary information about the NAND flash geometry and sets up the necessary mutex lock for access control. It then mounts the JFFS2 filesystem on a specified directory using the provided mount data.. . Please provide me with the necessary information, including the mount","typedef struct {\n  rtems_jffs2_flash_control super;\n  XNandPsu *nandpsu;\n  rtems_mutex access_lock;\n} flash_control;\nstatic flash_control *get_flash_control(rtems_jffs2_flash_control *super)\n{\n  return (flash_control *) super;\n}\nstatic int flash_read(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset,\n  unsigned char *buffer,\n  size_t size_of_buffer\n)\n{\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  rtems_status_code sc;\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  sc = XNandPsu_Read(nandpsu, offset, size_of_buffer, buffer);\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  if (sc) {\n    return -EIO;\n  }\n  return 0;\n}\nstatic int flash_write(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset,\n  const unsigned char *buffer,\n  size_t size_of_buffer\n)\n{\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  rtems_status_code sc;\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  sc = XNandPsu_Write(nandpsu, offset, size_of_buffer, (void *)buffer);\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  if (sc) {\n    return -EIO;\n  }\n  return 0;\n}\nstatic int flash_erase(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset\n)\n{\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  rtems_status_code sc;\n  uint64_t BlockSize = nandpsu->Geometry.BlockSize;\n  if (offset > nandpsu->Geometry.DeviceSize) {\n    return -EIO;\n  }\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  sc = XNandPsu_Erase(nandpsu, RTEMS_ALIGN_DOWN(offset, BlockSize), BlockSize);\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  if (sc ) {\n    return -EIO;\n  }\n  return 0;\n}\nstatic int flash_block_is_bad(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset,\n  bool *bad\n)\n{\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  uint32_t BlockIndex;\n  uint8_t BlockData;\n  uint8_t BlockShift;\n  uint8_t BlockType;\n  uint32_t BlockOffset;\n  assert(bad);\n  if (offset > nandpsu->Geometry.DeviceSize) {\n    return -EIO;\n  }\n  *bad = true;\n  BlockIndex = offset / nandpsu->Geometry.BlockSize;\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  BlockOffset = BlockIndex >> XNANDPSU_BBT_BLOCK_SHIFT;\n  BlockShift = XNandPsu_BbtBlockShift(BlockIndex);\n  BlockData = nandpsu->Bbt[BlockOffset];\n  BlockType = (BlockData >> BlockShift) & XNANDPSU_BLOCK_TYPE_MASK;\n  if (BlockType == XNANDPSU_BLOCK_GOOD) {\n    *bad = false;\n  }\n  int TargetBlockIndex = BlockIndex % nandpsu->Geometry.NumTargetBlocks;\n  if (nandpsu->Geometry.NumTargetBlocks - TargetBlockIndex <= 4) {\n    *bad = true;\n  }\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  return 0;\n}\nstatic int flash_block_mark_bad(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset\n)\n{\n  rtems_status_code sc;\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  uint32_t BlockIndex;\n  if (offset > nandpsu->Geometry.DeviceSize) {\n    return -EIO;\n  }\n  BlockIndex = offset / nandpsu->Geometry.BlockSize;\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  sc = XNandPsu_MarkBlockBad(nandpsu, BlockIndex);\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  if ( sc != XST_SUCCESS ) {\n    return -EIO;\n  }\n  return RTEMS_SUCCESSFUL;\n}\nstatic int flash_read_oob_locked(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset,\n  uint8_t *oobbuf,\n  uint32_t ooblen\n)\n{\n  uint8_t *spare_bytes;\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  uint32_t SpareBytesPerPage = nandpsu->Geometry.SpareBytesPerPage;\n  if (offset > nandpsu->Geometry.DeviceSize) {\n    return -EIO;\n  }\n  if (ooblen > SpareBytesPerPage * nandpsu->Geometry.PagesPerBlock) {\n    return -EIO;\n  }\n  uint32_t PageIndex = offset / nandpsu->Geometry.BytesPerPage;\n  spare_bytes = rtems_malloc(SpareBytesPerPage);\n  if (spare_bytes == NULL) {\n    return -ENOMEM;\n  }\n  while (ooblen) {\n    int rv = XNandPsu_ReadSpareBytes(nandpsu, PageIndex, spare_bytes);\n    uint32_t readlen = SpareBytesPerPage;\n    if (ooblen < readlen) {\n\t    readlen = ooblen;\n    }\n    if (rv) {\n      free(spare_bytes);\n      return -EIO;\n    }\n    memcpy(oobbuf, spare_bytes, readlen);\n    PageIndex++;\n    ooblen -= readlen;\n    oobbuf += readlen;\n  }\n  free(spare_bytes);\n  return RTEMS_SUCCESSFUL;\n}\nstatic int flash_read_oob(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset,\n  uint8_t *oobbuf,\n  uint32_t ooblen\n)\n{\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  int ret = flash_read_oob_locked(super, offset, oobbuf, ooblen);\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  return ret;\n}\nstatic int flash_write_oob(\n  rtems_jffs2_flash_control *super,\n  uint32_t offset,\n  uint8_t *oobbuf,\n  uint32_t ooblen\n)\n{\n  rtems_status_code sc;\n  uint8_t *spare_bytes;\n  uint8_t *buffer = oobbuf;\n  XNandPsu *nandpsu = get_flash_control(super)->nandpsu;\n  uint32_t SpareBytesPerPage = nandpsu->Geometry.SpareBytesPerPage;\n  if (offset > nandpsu->Geometry.DeviceSize) {\n    return -EIO;\n  }\n  if (ooblen > SpareBytesPerPage) {\n    return -EIO;\n  }\n  spare_bytes = rtems_malloc(SpareBytesPerPage);\n  if (spare_bytes == NULL) {\n    return -ENOMEM;\n  }\n  rtems_mutex_lock(&(get_flash_control(super)->access_lock));\n  if (ooblen < SpareBytesPerPage) {\n    int rv = flash_read_oob_locked(super, offset, spare_bytes, SpareBytesPerPage);\n    if (rv) {\n      free(spare_bytes);\n      rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n      return rv;\n    }\n    buffer = spare_bytes;\n    memcpy(buffer, oobbuf, ooblen);\n  }\n  uint32_t PageIndex = offset / nandpsu->Geometry.BytesPerPage;\n  sc = XNandPsu_WriteSpareBytes(nandpsu, PageIndex, buffer);\n  rtems_mutex_unlock(&(get_flash_control(super)->access_lock));\n  free(spare_bytes);\n  if ( sc != XST_SUCCESS ) {\n    return -EIO;\n  }\n  return RTEMS_SUCCESSFUL;\n}\nstatic uint32_t flash_get_oob_size(\n  rtems_jffs2_flash_control *super\n)\n{\n  flash_control *self = get_flash_control(super);\n  return self->nandpsu->Geometry.SpareBytesPerPage;\n}\nstatic flash_control flash_instance = {\n  .super = {\n    .read = flash_read,\n    .write = flash_write,\n    .erase = flash_erase,\n    .block_is_bad = flash_block_is_bad,\n    .block_mark_bad = flash_block_mark_bad,\n    .oob_read = flash_read_oob,\n    .oob_write = flash_write_oob,\n    .get_oob_size = flash_get_oob_size,\n  }\n};\nstatic rtems_jffs2_compressor_control compressor_instance = {\n  .compress = rtems_jffs2_compressor_rtime_compress,\n  .decompress = rtems_jffs2_compressor_rtime_decompress\n};\nstatic rtems_jffs2_mount_data mount_data;\nint xilinx_zynqmp_nand_jffs2_initialize(\n  const char *mount_dir,\n  XNandPsu *NandInstPtr\n)\n{\n  flash_instance.super.block_size = NandInstPtr->Geometry.BlockSize;\n  uint64_t max_size = 0x100000000LU - flash_instance.super.block_size;\n  if (NandInstPtr->Geometry.DeviceSize > max_size) {\n    flash_instance.super.flash_size = max_size;\n  } else {\n    flash_instance.super.flash_size = NandInstPtr->Geometry.DeviceSize;\n  }\n  flash_instance.super.write_size = NandInstPtr->Geometry.BytesPerPage;\n  flash_instance.nandpsu = NandInstPtr;\n  rtems_mutex_init(&flash_instance.access_lock, ""XNandPsu JFFS2 adapter lock"");\n  mount_data.flash_control = &flash_instance.super;\n  mount_data.compressor_control = &compressor_instance;\n  int rv = 0;\n  rv = mount(\n    NULL,\n    mount_dir,\n    RTEMS_FILESYSTEM_TYPE_JFFS2,\n    RTEMS_FILESYSTEM_READ_WRITE,\n    &mount_data\n  );\n  if ( rv != 0 ) {\n    return rv;\n  }\n  return 0;\n}'"
"('Please provide a prompt for testing the GMSK modem modulating and demodulating process using specific parameters, including the modulation index, shaping filter samples per symbol, and BT product. The scenario should include creating a GMSK modulator and demodulator, generating symbols with a maximum likely delay, modulating the symbols, demodulating them, and then comparing the input and output symbols. Lastly, you should also mention the creation and destruction of the modulation sequence.","//...\nvoid gmskmodem_test_mod_demod(unsigned int _k,\n                              unsigned int _m,\n                              float        _bt)\n{\n    gmskmod mod = gmskmod_create(_k, _m, _bt);\n    gmskdem dem = gmskdem_create(_k, _m, _bt);\n    unsigned int delay = _m + _m;\n    unsigned int  num_symbols = 80 + delay; \n    msequence ms = msequence_create_default(7);\n    float complex buf[_k];      \n    unsigned int  sym_in [num_symbols]; \n    unsigned int  sym_out[num_symbols]; \n    unsigned int i;\n    for (i=0; i<num_symbols; i++) {\n        sym_in[i] = msequence_generate_symbol(ms, 1);\n        gmskmod_modulate(mod, sym_in[i], buf);\n        gmskdem_demodulate(dem, buf, sym_out + i);\n    }\n    for (i=0; i<num_symbols; i++) {\n        if (i >= delay) {\n#if 0\n            if (liquid_autotest_verbose) {\n                printf(""  %3u : input = %2u, output = %2u %s\\n"",\n                        i, sym_in[i-delay], sym_out[i],\n                        (sym_in[i-delay] == sym_out[i]) ? """" : ""*"");\n            }\n#endif\n            CONTEND_EQUALITY(sym_in[i-delay], sym_out[i]);\n        }\n    }\n    msequence_destroy(ms);\n    gmskmod_destroy(mod);\n    gmskdem_destroy(dem);\n}\nvoid autotest_gmskmodem_k4_m3_b033() { gmskmodem_test_mod_demod( 4, 3, 0.25f); }\n//...')
"
"('You need to simulate a finite impulse response (FIR) filter using a Kaiser window for a given filter length, cutoff frequency, and stopband attenuation. The filter needs to be designed and applied to a signal composed of two cosine components with different frequencies. After filtering the input signal, you need to compute and plot the frequency response of the filter. The output results, including input, output, and frequency response plots, need to be saved in a MATLAB script file named ""firfilt_rrrf_example.m"".","#define OUTPUT_FILENAME ""firfilt_rrrf_example.m""\nint main() {\n    unsigned int h_len = 65;    \n    float        fc    = 0.1f;  \n    float        As    = 60.0f; \n    unsigned int n     = 240;   \n    firfilt_rrrf q = firfilt_rrrf_create_kaiser(h_len, fc, As, 0.0f);\n    firfilt_rrrf_set_scale(q, 2.0f*fc);\n    float x[n], y[n]; \n    unsigned int wlen = (unsigned int)roundf(0.75*n);\n    unsigned int i;\n    for (i=0; i<n; i++) {\n        x[i] = 0.7f*cosf(2*M_PI*0.057f*i) +\n               0.3f*cosf(2*M_PI*0.357f*i);\n        x[i] *= i < wlen ? liquid_hamming(i,wlen) : 0;\n        firfilt_rrrf_push(q, x[i]);\n        firfilt_rrrf_execute(q, &y[i]);\n    }\n    unsigned int nfft = 1024;\n    float complex H[nfft];\n    for (i=0; i<nfft; i++) {\n        float freq = ((float)i - 0.5f*(float)nfft) / (float)nfft;\n        firfilt_rrrf_freqresponse(q, freq, &H[i]);\n    }\n    firfilt_rrrf_destroy(q);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n"");\n    fprintf(fid,""\\n"");\n    fprintf(fid,""h_len=%u;\\n"", h_len);\n    fprintf(fid,""n=%u;\\n"",n);\n    fprintf(fid,""nfft=%u;\\n"",nfft);\n    fprintf(fid,""x=zeros(1,n);\\n"");\n    fprintf(fid,""y=zeros(1,n);\\n"");\n    fprintf(fid,""H=zeros(1,nfft);\\n"");\n    for (i=0; i<n; i++) {\n        fprintf(fid,""x(%4u) = %12.4e;\\n"", i+1, x[i]);\n        fprintf(fid,""y(%4u) = %12.4e;\\n"", i+1, y[i]);\n    }\n    for (i=0; i<nfft; i++)\n        fprintf(fid,""H(%4u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(H[i]), cimagf(H[i]));\n    fprintf(fid,""tx=0:(n-1);\\n"");\n    fprintf(fid,""ty=tx - (h_len-1)/2;\\n"");\n    fprintf(fid,""figure(\'position\',[100 100 600 800]);\\n"");\n    fprintf(fid,""subplot(3,1,1);\\n"");\n    fprintf(fid,""  plot(tx,real(x),\'-\',\'Color\',[1 1 1]*0.5,\'LineWidth\',1,...\\n"");\n    fprintf(fid,""       ty,real(y),\'-\',\'Color\',[0 0.5 0.25],\'LineWidth\',2);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'real\');\\n"");\n    fprintf(fid,""  legend(\'input\',\'filtered output\',\'location\',\'northeast\');\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""f = [0:(nfft-1)]/nfft - 0.5;\\n"");\n    fprintf(fid,""g = 1/sum(abs(x));\\n"");\n    fprintf(fid,""X = 20*log10(abs(fftshift(fft(x*g,nfft))));\\n"");\n    fprintf(fid,""Y = 20*log10(abs(fftshift(fft(y*g,nfft))));\\n"");\n    fprintf(fid,""subplot(3,1,2:3);\\n"");\n    fprintf(fid,""plot(f,X,\'Color\',[1 1 1]*0.5,\'LineWidth\',1,...\\n"");\n    fprintf(fid,""     f,Y,\'Color\',[0 0.5 0.25],\'LineWidth\',2,...\\n"");\n    fprintf(fid,""     f,20*log10(abs(H)),\'Color\',[0 0.25 0.5],\'LineWidth\',1);\\n"");\n    fprintf(fid,""axis([-0.5 0.5 -120 20]);\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""xlabel(\'Normalized Frequency [f/F_s]\');\\n"");\n    fprintf(fid,""ylabel(\'Power Spectral Density [dB]\');\\n"");\n    fprintf(fid,""legend(\'input\',\'output\',\'filter\',\'location\',\'northeast\');\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"(""Prompt: Develop a testbench function that tests a Butterworth lowpass IIR filter design with the following parameters: filter order = 5, cutoff frequency = 0.20, sampling frequency = 0.40. Ensure the filter design meets certain specifications regarding passband and stopband ripple. The testbench should output the filter's frequency response and validate it against predefined regions for passband and stopband. Ensure the testbench function destroys the filter object after testing.","//...\nvoid testbench_iirdes_butter_lowpass(unsigned int _n,  \n                                     float        _fc, \n                                     float        _fs) \n{\n    float        tol  = 1e-3f;  \n    unsigned int nfft = 800;    \n    iirfilt_crcf q = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_BUTTER, LIQUID_IIRDES_LOWPASS, LIQUID_IIRDES_SOS,\n        _n,_fc,0.0f,1,60);\n    if (liquid_autotest_verbose)\n        iirfilt_crcf_print(q);\n    float H0 = 0.0f, H1 = -3, H2 = -60.0f;\n    unsigned int i;\n    float H[nfft]; \n    for (i=0; i<nfft; i++)\n        H[i] = iirfilt_crcf_get_psd(q, (float)i/(float)nfft-0.5f);\n    autotest_psd_s regions[] = {\n      {.fmin=0.0f, .fmax=0.98*_fc, .pmin=H1-tol, .pmax=H0+tol, .test_lo=1, .test_hi=1},\n      {.fmin=_fs,  .fmax=+0.5f,    .pmin=0,      .pmax=H2+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(H, nfft, regions, 2,\n        liquid_autotest_verbose ? ""autotest/logs/iirdes_butter_lowpass.m"" : NULL);\n    iirfilt_crcf_destroy(q);\n}\nvoid autotest_iirdes_butter_lowpass_0(){ testbench_iirdes_butter_lowpass( 5,0.20f,0.40f); }\n//...')
"
"('Prompt: You are working on developing a digital signal processing application and need to test the performance of a Finite Impulse Response (FIR) filter function with complex coefficients. You have a set of test data with a filter of length 7 and input data of length 16. Write a function that calls the `firfilt_cccf_test` function to test the filter with the provided data `firfilt_cccf_data_h7x16_h`, `firfilt_cccf_data_h7x16_x`, and `firfilt_cccf_data_h7x16_y`.","//...\nvoid autotest_firfilt_cccf_data_h7x16()\n{\n    firfilt_cccf_test(firfilt_cccf_data_h7x16_h, 7,\n                      firfilt_cccf_data_h7x16_x, 16,\n                      firfilt_cccf_data_h7x16_y, 16);\n}\n//...')
"
"('Please provide a function that tests a FIR filter implemented using complex numbers. The function should take input values for the filter coefficients, input signal, and expected output signal. It should initialize the FIR filter, process the input signal, compare the output with the expected result within a tolerance level of 0.001, and then destroy the filter.","//...\nvoid firfilt_cccf_test(float complex * _h,\n                       unsigned int    _h_len,\n                       float complex * _x,\n                       unsigned int    _x_len,\n                       float complex * _y,\n                       unsigned int    _y_len)\n{\n    float tol = 0.001f;\n    firfilt_cccf q = firfilt_cccf_create(_h, _h_len);\n    float complex y_test[_y_len];\n    unsigned int i;\n    for (i=0; i<_x_len; i++) {\n        firfilt_cccf_push(q, _x[i]);\n        firfilt_cccf_execute(q, &y_test[i]);\n        CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );\n        CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );\n    }\n    firfilt_cccf_destroy(q);\n}\n//...')
"
"('Prompt: You need to test the `msresamp_crcf_get_num_output()` function with a specific rate value. The function should create a `msresamp_crcf` object with the given rate and a fixed As value of 60.0. You need to iterate over different input sizes and compare the number of output samples obtained from the `msresamp_crcf_get_num_output()` function with the actual number of samples written by executing the resampler. You should print the results for each iteration and make sure the number of output samples matches the number of samples written.. . ```c. void testbench_msresamp_crcf_num_output(float _rate). {.     if (liquid_autotest_verbose).         printf(""testing msresamp_crcf_get_num_output() with r=%g\\n"", _rate);.     float As = 60.0f;.     msresamp_crcf q = msresamp_crcf_create(_rate, As);.     unsigned int s =","//...\nvoid testbench_msresamp_crcf(float r, float As)\n{\n    unsigned int n=800000;      \n    float bw = 0.2f; \n    unsigned int nfft = 800;\n    float tol = 0.5f;\n    spgramcf     q   = spgramcf_create(nfft, LIQUID_WINDOW_HANN, nfft/2, nfft/4);\n    symstreamrcf gen = symstreamrcf_create_linear(LIQUID_FIRFILT_KAISER,r*bw,25,0.2f,LIQUID_MODEM_QPSK);\n    symstreamrcf_set_gain(gen, sqrtf(bw));\n    msresamp_crcf resamp = msresamp_crcf_create(r,As);\n    unsigned int  buf_len = 256;\n    float complex buf_0[buf_len]; \n    float complex buf_1[buf_len]; \n    while (spgramcf_get_num_samples_total(q) < n) {\n        symstreamrcf_write_samples(gen, buf_0, buf_len);\n        unsigned int nw = 0;\n        msresamp_crcf_execute(resamp, buf_0, buf_len, buf_1, &nw);\n        spgramcf_write(q, buf_1, nw);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/msresamp_crcf_r%.3u_a%.2u_autotest.m"", (int)(r*1000), (int)(As));\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    spgramcf_destroy(q);\n    symstreamrcf_destroy(gen);\n    msresamp_crcf_destroy(resamp);\n}\nvoid testbench_msresamp_crcf_num_output(float _rate)\n{\n    if (liquid_autotest_verbose)\n        printf(""testing msresamp_crcf_get_num_output() with r=%g\\n"", _rate);\n    float As = 60.0f;\n    msresamp_crcf q = msresamp_crcf_create(_rate, As);\n    unsigned int s = _rate < 0.1f ? 131 : 1; \n    unsigned int sizes[10] = {1*s, 2*s, 3*s, 20*s, 7*s, 64*s, 4*s, 4*s, 4*s, 27*s};\n    unsigned int max_input = 64*s;\n    unsigned int max_output = 16 + (unsigned int)(4.0f * max_input * _rate);\n    printf(""max_input : %u, max_output : %u\\n"", max_input, max_output);\n    float complex buf_0[max_input];\n    float complex buf_1[max_output];\n    unsigned int i;\n    for (i=0; i<max_input; i++)\n        buf_0[i] = 0.0f;\n    unsigned int b;\n    for (b=0; b<8; b++) {\n        for (i=0; i<10; i++) {\n            unsigned int num_input  = sizes[i];\n            unsigned int num_output = msresamp_crcf_get_num_output(q, num_input);\n            unsigned int num_written;\n            msresamp_crcf_execute(q, buf_0, num_input, buf_1, &num_written);\n            if (liquid_autotest_verbose) {\n                printf("" b[%2u][%2u], num_input:%5u, num_output:%5u, num_written:%5u\\n"",\n                        b, i, num_input, num_output, num_written);\n            }\n            CONTEND_EQUALITY(num_output, num_written)\n        }\n    }\n    msresamp_crcf_destroy(q);\n}\nvoid autotest_msresamp_crcf_num_output_7(){ testbench_msresamp_crcf_num_output(expf(-8.f)); }\n//...')
"
"('Given the code you provided, the scenario could be testing matrix multiplication and matrix-vector multiplication functions in a software library that deals with sparse matrices. The prompt could ask you to demonstrate testing for matrix multiplication and matrix-vector multiplication functions using pre-defined test matrices and vectors. The scenario involves creating sparse matrices `a`, `b`, and `c` using specified data arrays, then multiplying `a` and `b` and comparing the result with a pre-defined answer. Additionally, the prompt could ask you to set up a scenario where you create a sparse matrix `A` and a vector `x`, perform matrix-vector multiplication, and compare the result with a pre-defined answer using a specified tolerance.","//...\nvoid autotest_smatrixb_mul()\n{\n    unsigned char a_test[96] = {\n        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,\n        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0};\n    unsigned char b_test[60] = {\n        1, 1, 0, 0, 0,\n        0, 0, 0, 0, 1,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 1,\n        0, 0, 0, 1, 0,\n        0, 0, 0, 1, 0,\n        0, 0, 0, 0, 0,\n        0, 1, 0, 0, 1,\n        1, 0, 0, 1, 0,\n        0, 1, 0, 0, 0};\n    unsigned char c_test[40] = {\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0,\n        0, 0, 0, 0, 1,\n        0, 0, 0, 1, 0};\n    smatrixb a = smatrixb_create_array(a_test,  8,12);\n    smatrixb b = smatrixb_create_array(b_test, 12, 5);\n    smatrixb c = smatrixb_create(8, 5);\n    smatrixb_mul(a,b,c);\n    if (liquid_autotest_verbose) {\n        printf(""a:\\n""); smatrixb_print_expanded(a);\n        printf(""b:\\n""); smatrixb_print_expanded(b);\n        printf(""c:\\n""); smatrixb_print_expanded(c);\n    }\n    unsigned int i;\n    unsigned int j;\n    for (i=0; i<8; i++) {\n        for (j=0; j<5; j++) {\n            CONTEND_EQUALITY( smatrixb_get(c,i,j), c_test[i*5+j]);\n        }\n    }\n    smatrixb_destroy(a);\n    smatrixb_destroy(b);\n    smatrixb_destroy(c);\n}\nvoid autotest_smatrixb_mulf()\n{\n    float tol = 1e-6f;\n    smatrixb A = smatrixb_create(8,12);\n    smatrixb_set(A,0,0,  1);\n    smatrixb_set(A,2,0,  1);\n    smatrixb_set(A,6,0,  1);\n    smatrixb_set(A,3,2,  1);\n    smatrixb_set(A,6,2,  1);\n    smatrixb_set(A,7,2,  1);\n    smatrixb_set(A,1,3,  1);\n    smatrixb_set(A,7,5,  1);\n    smatrixb_set(A,3,6,  1);\n    smatrixb_set(A,5,6,  1);\n    smatrixb_set(A,7,6,  1);\n    smatrixb_set(A,3,7,  1);\n    smatrixb_set(A,2,8,  1);\n    smatrixb_set(A,5,8,  1);\n    smatrixb_set(A,2,9,  1);\n    smatrixb_set(A,5,10, 1);\n    smatrixb_set(A,6,10, 1);\n    smatrixb_set(A,6,11, 1);\n    float x[36] = {\n      -4.3,  -0.7,   3.7,\n      -1.7,   2.8,   4.3,\n       2.0,   1.9,   0.6,\n       3.6,   1.0,  -3.7,\n       4.3,   0.7,   2.1,\n       4.6,   0.5,   0.8,\n       1.6,  -3.8,  -0.8,\n      -1.9,  -2.1,   2.8,\n      -1.5,   2.5,   0.8,\n       8.4,   1.5,  -3.1,\n      -5.8,   0.0,   2.5,\n      -4.9,  -2.1,  -1.5};\n    float y_test[24] = {\n       -4.3,   -0.7,    3.7,\n        3.6,    1.0,   -3.7,\n        2.6,    3.3,    1.4,\n        1.7,   -4.0,    2.6,\n        0.0,    0.0,    0.0,\n       -5.7,   -1.3,    2.5,\n      -13.0,   -0.9,    5.3,\n        8.2,   -1.4,    0.6};\n    float y[24];\n    smatrixb_mulf(A,\n                  x,12,3,\n                  y, 8,3);\n    unsigned int i;\n    for (i=0; i<24; i++)\n        CONTEND_DELTA( y[i], y_test[i], tol );\n    if (liquid_autotest_verbose) {\n        printf(""A:\\n"");\n        smatrixb_print_expanded(A);\n        printf(""x = [\\n"");\n        for (i=0; i<36; i++) printf(""%6.2f%s"", x[i], ((i+1)%3)==0 ? ""\\n"" : """");\n        printf("" ];\\n"");\n        printf(""y = [\\n"");\n        for (i=0; i<24; i++) printf(""%6.2f%s"", y[i], ((i+1)%3)==0 ? ""\\n"" : """");\n        printf("" ];\\n"");\n        printf(""y_test = [\\n"");\n        for (i=0; i<24; i++) printf(""%6.2f%s"", y_test[i], ((i+1)%3)==0 ? ""\\n"" : """");\n        printf("" ];\\n"");\n    }\n    smatrixb_destroy(A);\n}\n//...')
"
"('Prompt: You are tasked with writing a C program that designs a low-pass filter using the function `firdespm_lowpass` and generates a MATLAB file for visualization. The program should take command line arguments for filter length, cutoff frequency, and stop-band attenuation. Output the filter coefficients and plot the filter response in MATLAB. The output MATLAB file should be named ""firdespm_lowpass_example.m"". Provide a `-h` option to display usage information.","#define OUTPUT_FILENAME ""firdespm_lowpass_example.m""\nvoid usage()\n{\n    printf(""firdespm_lowpass_example:\\n"");\n    printf(""  -h        : print usage/help\\n"");\n    printf(""  -n <len>  : filter length,              1 < n        default: 57\\n"");\n    printf(""  -f <freq> : filter cutoff frequency,    0 < f < 0.5, default: 0.2\\n"");\n    printf(""  -s <atten>: stop-band attenuation [dB], 0 < s,       default: 60\\n"");\n}\nint main(int argc, char*argv[]) {\n    unsigned int n  =  57;      \n    float        fc = 0.2f;     \n    float        As = 60.0f;    \n    int dopt;\n    while ((dopt = getopt(argc,argv,""hn:f:s:"")) != EOF) {\n        switch (dopt) {\n        case \'h\': usage();           return 0;\n        case \'n\': n  = atoi(optarg); break;\n        case \'f\': fc = atof(optarg); break;\n        case \'s\': As = atof(optarg); break;\n        default: return -1;\n        }\n    }\n    unsigned int i;\n    printf(""filter design parameters\\n"");\n    printf(""  length                : %12u\\n"",      n);\n    printf(""  cutoff frequency      : %12.8f Fs\\n"", fc);\n    printf(""  stop-band attenuation : %12.3f dB\\n"", As);\n    float h[n];\n    firdespm_lowpass(n,fc,As,0,h);\n#if 0\n    for (i=0; i<n; i++)\n        printf(""h(%4u) = %16.12f;\\n"", i+1, h[i]);\n#endif\n    FILE*fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all;\\n"");\n    fprintf(fid,""close all;\\n\\n"");\n    fprintf(fid,""h_len=%u;\\n"", n);\n    fprintf(fid,""fc=%12.4e;\\n"",fc);\n    fprintf(fid,""As=%12.4e;\\n"",As);\n    for (i=0; i<n; i++)\n        fprintf(fid,""h(%4u) = %20.8e;\\n"", i+1, h[i]);\n    fprintf(fid,""nfft=1024;\\n"");\n    fprintf(fid,""H=20*log10(abs(fftshift(fft(h,nfft))));\\n"");\n    fprintf(fid,""f=[0:(nfft-1)]/nfft-0.5;\\n"");\n    fprintf(fid,""figure; plot(f,H,\'Color\',[0 0.5 0.25],\'LineWidth\',2);\\n"");\n    fprintf(fid,""grid on;\\n"");\n    fprintf(fid,""xlabel(\'normalized frequency\');\\n"");\n    fprintf(fid,""ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""title([\'Filter design (firdespm) f_c: %.3f, S_L: %.3f, h: %u\']);\\n"",\n            fc, -As, n);\n    fprintf(fid,""axis([-0.5 0.5 -As-20 10]);\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"", OUTPUT_FILENAME);\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: You need a function that tests a forward error correction codec for a specific FEC scheme with a given message length. The function should create the FEC object, encode a random message, introduce an error in the encoded message, decode it, and compare the original and decoded messages. If the required FEC library is not enabled, it should output a warning message. Additionally, you need two auto-tests for FEC scheme V29 with and without puncturing for a message length of 64.","//...\nvoid fec_test_codec(fec_scheme _fs, unsigned int _n, void * _opts)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    fec q = fec_create(_fs,_opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,_n);\n    unsigned char msg[_n];          \n    unsigned char msg_enc[n_enc];   \n    unsigned char msg_dec[_n];      \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        msg[i] = rand() & 0xff;\n        msg_dec[i] = 0;\n    }\n    fec_encode(q,_n,msg,msg_enc);\n    msg_enc[0] ^= 0x01;\n    fec_decode(q,_n,msg_enc,msg_dec);\n    CONTEND_SAME_DATA(msg,msg_dec,_n);\n    fec_destroy(q);\n}\nvoid autotest_fec_v29()     { fec_test_codec(LIQUID_FEC_CONV_V29,      64, NULL); }\nvoid autotest_fec_v29p23()  { fec_test_codec(LIQUID_FEC_CONV_V29P23,   64, NULL); }\n//...')
"
"'You are working on implementing sorting algorithms in C, specifically heap sort and bubble sort. You have already defined a macro `print_array` to print arrays of different types. Your goal is to test both sorting algorithms on integer and float arrays. Your scenario involves testing the sorting algorithms on arrays of various sizes and data types, and checking if they are sorted correctly after sorting.","#define print_array(type, format, array) \\\n    do {\\\n        size_t len = sizeof(array)/sizeof(array[0]);\\\n        int _i = 0;\\\n        for (_i = 0; _i < len; ++_i) {\\\n            printf(format, (type)(*((type *)array+_i)));\\\n        }\\\n        printf(""\\n"");\\\n    } while (0)\nint float_compare(const void *a, const void *b, size_t size)\n{\n    if (!size) return 0;\n    const float esp = 0.0001;\n    const float *p = (const float *)a;\n    const float *q = (const float *)b;\n    float d = *p - *q;\n    if (d < esp && d > -esp) return 0;\n    if (d < 0) return -1;\n    return 1;\n}\nvoid test_heapsort()\n{\n    int a[]={4,1,2,5,3, 2, 2, 2, 1};\n    print_array(int, ""%d\\t"", a);\n    heap_sort(a, sizeof(a)/sizeof(a[0]), sizeof(int), 0);\n    print_array(int, ""%d\\t"", a);\n    int b[]={8,1,2,5,3};\n    print_array(int, ""%d\\t"", b);\n    heap_sort(b, sizeof(b)/sizeof(b[0]), sizeof(int), 0);\n    print_array(int, ""%d\\t"", b);\n    float f[]={1.1,2.2,4.2,3.0};\n    print_array(float, ""%f\\t"", f);\n    heap_sort(f, sizeof(f)/sizeof(f[0]), sizeof(float), float_compare);\n    print_array(float, ""%f\\t"", f);\n}\nvoid test_bsort()\n{\n#if 1\n    int a[]={4,1,2,5,3};\n    print_array(int, ""%d\\t"", a);\n    bubble_sort(a, sizeof(a)/sizeof(a[0]), sizeof(int), 0);\n    print_array(int, ""%d\\t"", a);\n    int b[]={8,1,2,5,3};\n    print_array(int, ""%d\\t"", b);\n    bubble_sort(b, sizeof(b)/sizeof(b[0]), sizeof(int), 0);\n    print_array(int, ""%d\\t"", b);\n#endif\n    float f[]={1.1,2.2,4.2,3.0};\n    print_array(float, ""%f\\t"", f);\n    bubble_sort(f, sizeof(f)/sizeof(f[0]), sizeof(float), float_compare);\n    print_array(float, ""%f\\t"", f);\n}\nint main(int argc, char **argv)\n{\n    test_bsort();\n    test_heapsort();\n    return 0;\n}'"
"('Prompt: You are working on a optimization algorithm that requires evaluating the Wolfe conditions to ensure convergence. You need to implement a function that checks these conditions based on certain parameters. The code you should provide includes calculation of gradients, utility values, and checking two specific Wolfe conditions.","//...\n    for (i=0; i<n; i++) x[i] = 0.5f;\n        alpha = alpha_min;\n    for (i=0; i<n; i++) x[i] = 0.5f;\n    for (i=0; i<n; i++) gradient1[i] = 0.0f;\n    float u = myutility(x, n);\n        printf("" %-3u : x =       {"", t);\n    for (t=0; t<num_iterations; t++) {\n        float u0 = myutility(x, n);\n            float u1 = myutility(x_prime, n);\n    return 0;\nint check_wolfe_conditions(float _alpha,\n                           float _u0,\n                           float _u1,\n                           float _gamma0,\n                           float _gamma1)\n{\n    float c1 = 1e-4f;\n    float c2 = 0.9f;\n    int cond1 = (_u1 <= _u0 + c1*_alpha*_gamma0) ? 1 : 0;\n    int cond2 = ( fabsf(_gamma1) <= c2*fabsf(_gamma0) ) ? 1 : 0;\n#if 0\n    printf(""(g0: %12.8f g1: %12.8f) [%c %c]"",\n            _gamma0,\n            _gamma1,\n            cond1 ? \'1\' : \'0\',\n            cond2 ? \'1\' : \'0\');\n#endif\n    return cond1 && cond2;\n}\nvoid estimate_gradient(float * _x,\n                       unsigned int _n,\n                       utility _u,\n                       float * _gradient)\n{\n    float x_prime[_n];\n    float dx = 1e-6f;\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        x_prime[i] = _x[i];\n    float f0 = _u(x_prime, _n);\n    float f1 = 0.0f;\n    for (i=0; i<_n; i++) {\n        x_prime[i] = _x[i] + dx;\n        f1 = _u(x_prime, _n);\n        x_prime[i] = _x[i];\n        _gradient[i] = (f1 - f0) / dx;\n    }\n}\nint check_wolfe_conditions2(float * _x,\n                            float * _p,\n                            unsigned int _n,\n                            float _alpha,\n                            utility _u)\n{\n    float grad0[_n];\n    float grad1[_n];\n    float x_prime[_n];\n    float u0 = _u(_x,_n);\n    estimate_gradient(_x,_n,_u,grad0);\n    unsigned int i;\n    for (i=0; i<_n; i++)\n        x_prime[i] = _x[i] + _alpha*_p[i];\n    float u1 = _u(x_prime, _n);\n    estimate_gradient(x_prime, _n, _u, grad1);\n    float gamma0 = 0.0f;\n    for (i=0; i<_n; i++)\n        gamma0 += _p[i] * grad0[i];\n    float gamma1 = 0.0f;\n    for (i=0; i<_n; i++)\n        gamma1 += _p[i] * grad1[i];\n    return check_wolfe_conditions(_alpha, u0, u1, gamma0, gamma1);\n}\n//...')
"
('Prompt: You are tasked with creating a function to initialize default properties for a flexible frame generator in a software-defined radio program. The function should copy default properties from a predefined structure to the provided flexframegenprops_s pointer. The flexframegenprops_s structure contains configuration parameters for the flexible frame generator module. The default properties should be copied using the memmove function. The macro DEBUG_FLEXFRAMEGEN is defined as 1 in the source code for debugging purposes. Implement the flexframegenprops_init_default function to meet these requirements.,"//...\n#define DEBUG_FLEXFRAMEGEN 1\n    unsigned int    m;                  \n    flexframegenprops_s props;          \nint flexframegenprops_init_default(flexframegenprops_s * _props)\n{\n    memmove(_props, &flexframegenprops_default, sizeof(flexframegenprops_s));\n    return LIQUID_OK;\n}\n//...')
"
"'Prompt: Please provide a code snippet for creating a calendar interface with highlighted dates and event handling. The calendar should have a dropdown header feature if available, or fallback to arrow navigation for the header. The code should also include a function for logging the clicked date in the calendar.. . Scenario: You are tasked with implementing a calendar interface with specific highlighted dates and event handling in an embedded system UI. The calendar should display a dropdown header for navigation if supported by the framework, otherwise, it should use arrow navigation. Additionally, you need to log the date clicked by the user in the calendar.","#if LV_USE_CALENDAR && LV_BUILD_EXAMPLES\nstatic void event_handler(lv_event_t * e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_current_target(e);\n    if(code == LV_EVENT_VALUE_CHANGED) {\n        lv_calendar_date_t date;\n        if(lv_calendar_get_pressed_date(obj, &date)) {\n            LV_LOG_USER(""Clicked date: %02d.%02d.%d"", date.day, date.month, date.year);\n        }\n    }\n}\nvoid lv_example_calendar_1(void)\n{\n    lv_obj_t  * calendar = lv_calendar_create(lv_screen_active());\n    lv_obj_set_size(calendar, 185, 230);\n    lv_obj_align(calendar, LV_ALIGN_CENTER, 0, 27);\n    lv_obj_add_event_cb(calendar, event_handler, LV_EVENT_ALL, NULL);\n    lv_calendar_set_today_date(calendar, 2021, 02, 23);\n    lv_calendar_set_showed_date(calendar, 2021, 02);\n    static lv_calendar_date_t highlighted_days[3];       \n    highlighted_days[0].year = 2021;\n    highlighted_days[0].month = 02;\n    highlighted_days[0].day = 6;\n    highlighted_days[1].year = 2021;\n    highlighted_days[1].month = 02;\n    highlighted_days[1].day = 11;\n    highlighted_days[2].year = 2022;\n    highlighted_days[2].month = 02;\n    highlighted_days[2].day = 22;\n    lv_calendar_set_highlighted_dates(calendar, highlighted_days, 3);\n#if LV_USE_CALENDAR_HEADER_DROPDOWN\n    lv_calendar_header_dropdown_create(calendar);\n#elif LV_USE_CALENDAR_HEADER_ARROW\n    lv_calendar_header_arrow_create(calendar);\n#endif\n}\n#endif'"
('Prompt: Your task is to create a function that performs conjugate gradient method to solve a linear system of equations. Write the code for an automated test function that uses this function to solve a system with a given matrix A and vector b. Print out the results and compare them with expected values with a given tolerance.,"//...\nvoid autotest_matrixf_cgsolve()\n{\n    float tol = 0.01;  \n    float x[8];\n    matrixf_cgsolve(matrixf_data_cgsolve_A, 8,\n                    matrixf_data_cgsolve_b,\n                    x, NULL);\n    if (liquid_autotest_verbose) {\n        printf(""cgsolve:\\n"");\n        printf(""  A: "");        matrixf_print(matrixf_data_cgsolve_A, 8, 8);\n        printf(""  b: "");        matrixf_print(matrixf_data_cgsolve_b, 8, 1);\n        printf(""  expected: ""); matrixf_print(matrixf_data_cgsolve_x, 8, 1);\n        printf(""  x: "");        matrixf_print(x,                      8, 1);\n    }\n    unsigned int i;\n    for (i=0; i<8; i++)\n        CONTEND_DELTA( matrixf_data_cgsolve_x[i], x[i], tol );\n}\n//...')
"
"'""Can you please provide me with a code snippet that demonstrates how to create an animation for a switch using LittlevGL library with the LV_USE_SWITCH and LV_BUILD_EXAMPLES options enabled? The animation should change the size and x position of an object from 10 to 240 and 10 to 50 respectively.""","#if LV_BUILD_EXAMPLES && LV_USE_SWITCH\nstatic void anim_x_cb(void * var, int32_t v)\n{\n    lv_obj_set_x(var, v);\n}\nstatic void anim_size_cb(void * var, int32_t v)\n{\n    lv_obj_set_size(var, v, v);\n}\nvoid lv_example_anim_2(void)\n{\n    lv_obj_t * obj = lv_obj_create(lv_screen_active());\n    lv_obj_set_style_bg_color(obj, lv_palette_main(LV_PALETTE_RED), 0);\n    lv_obj_set_style_radius(obj, LV_RADIUS_CIRCLE, 0);\n    lv_obj_align(obj, LV_ALIGN_LEFT_MID, 10, 0);\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, obj);\n    lv_anim_set_values(&a, 10, 50);\n    lv_anim_set_duration(&a, 1000);\n    lv_anim_set_playback_delay(&a, 100);\n    lv_anim_set_playback_duration(&a, 300);\n    lv_anim_set_repeat_delay(&a, 500);\n    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n    lv_anim_set_path_cb(&a, lv_anim_path_ease_in_out);\n    lv_anim_set_exec_cb(&a, anim_size_cb);\n    lv_anim_start(&a);\n    lv_anim_set_exec_cb(&a, anim_x_cb);\n    lv_anim_set_values(&a, 10, 240);\n    lv_anim_start(&a);\n}\n#endif'"
"('Prompt: You are working on a software-defined radio project and need to implement a flexframe synchronization algorithm. The algorithm involves decoding headers and payloads, demodulating signals, and handling various modulation schemes and error correction codes. Can you provide the code for the flexframe synchronization algorithm that includes functions for decoding headers, executing preamble and payload processing, and resetting the synchronization state? It should also include debugging options for printing and handling errors.","//...\n    unsigned int    m;                  \n    qdetector_cccf  detector;           \n#define DEBUG_FLEXFRAMESYNC         1\n#define DEBUG_FLEXFRAMESYNC         1\n    int         debug_qdetector_flush;  \n    windowcf    debug_x;                \nint flexframesync_decode_header(flexframesync _q)\n{\n    qpilotsync_execute(_q->header_pilotsync, _q->header_sym, _q->header_mod);\n    if (_q->header_soft) {\n        _q->header_valid = qpacketmodem_decode_soft(_q->header_decoder,\n                                                    _q->header_mod,\n                                                    _q->header_dec);\n    } else {\n        _q->header_valid = qpacketmodem_decode(_q->header_decoder,\n                                               _q->header_mod,\n                                               _q->header_dec);\n    }\n    if (!_q->header_valid)\n        return LIQUID_OK;\n    float dphi_hat = qpilotsync_get_dphi(_q->header_pilotsync);\n    float  phi_hat = qpilotsync_get_phi (_q->header_pilotsync);\n    nco_crcf_set_frequency(_q->pll, dphi_hat);\n    nco_crcf_set_phase    (_q->pll, phi_hat + dphi_hat * _q->header_sym_len);\n    unsigned int n = _q->header_user_len;\n    unsigned int protocol = _q->header_dec[n+0];\n    if (protocol != FLEXFRAME_PROTOCOL) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EICONFIG,""flexframesync_decode_header(), invalid framing protocol %u (expected %u)"", protocol, FLEXFRAME_PROTOCOL);\n    }\n    unsigned int payload_dec_len = (_q->header_dec[n+1] << 8) | (_q->header_dec[n+2]);\n    _q->payload_dec_len = payload_dec_len;\n    unsigned int mod_scheme = _q->header_dec[n+3];\n    unsigned int check = (_q->header_dec[n+4] >> 5 ) & 0x07;\n    unsigned int fec0  = (_q->header_dec[n+4]      ) & 0x1f;\n    unsigned int fec1  = (_q->header_dec[n+5]      ) & 0x1f;\n    if (mod_scheme == 0 || mod_scheme >= LIQUID_MODEM_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EICONFIG,""flexframesync_decode_header(), invalid modulation scheme"");\n    } else if (check == LIQUID_CRC_UNKNOWN || check >= LIQUID_CRC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EICONFIG,""flexframesync_decode_header(), decoded CRC exceeds available"");\n    } else if (fec0 == LIQUID_FEC_UNKNOWN || fec0 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EICONFIG,""flexframesync_decode_header(), decoded FEC (inner) exceeds available"");\n    } else if (fec1 == LIQUID_FEC_UNKNOWN || fec1 >= LIQUID_FEC_NUM_SCHEMES) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EICONFIG,""flexframesync_decode_header(), decoded FEC (outer) exceeds available"");\n    }\n    _q->payload_demod = modemcf_recreate(_q->payload_demod, mod_scheme);\n    qpacketmodem_configure(_q->payload_decoder,\n                           payload_dec_len, check, fec0, fec1, mod_scheme);\n    _q->payload_sym_len = qpacketmodem_get_frame_len(_q->payload_decoder);\n    _q->payload_sym = (float complex*) realloc(_q->payload_sym, (_q->payload_sym_len)*sizeof(float complex));\n    _q->payload_dec = (unsigned char*) realloc(_q->payload_dec, (_q->payload_dec_len)*sizeof(unsigned char));\n    if (_q->payload_sym == NULL || _q->payload_dec == NULL) {\n        _q->header_valid = 0;\n        return liquid_error(LIQUID_EIMEM,""flexframesync_decode_header(), could not re-allocate payload arrays"");\n    }\n#if DEBUG_FLEXFRAMESYNC_PRINT\n    printf(""flexframesync_decode_header():\\n"");\n    printf(""    header crc      : %s\\n"", _q->header_valid ? ""pass"" : ""FAIL"");\n    printf(""    check           : %s\\n"", crc_scheme_str[check][1]);\n    printf(""    fec (inner)     : %s\\n"", fec_scheme_str[fec0][1]);\n    printf(""    fec (outer)     : %s\\n"", fec_scheme_str[fec1][1]);\n    printf(""    mod scheme      : %s\\n"", modulation_types[mod_scheme].name);\n    printf(""    payload sym len : %u\\n"", _q->payload_sym_len);\n    printf(""    payload dec len : %u\\n"", _q->payload_dec_len);\n    printf(""    user data       :"");\n    unsigned int i;\n    for (i=0; i<_q->header_user_len; i++)\n        printf("" %.2x"", _q->header_dec[i]);\n    printf(""\\n"");\n#endif\n    return LIQUID_OK;\n}\nint flexframesync_execute_rxpreamble(flexframesync _q,\n                                     float complex _x)\n{\n    float complex mf_out = 0.0f;\n    int sample_available = flexframesync_step(_q, _x, &mf_out);\n    if (sample_available) {\n#if FLEXFRAMESYNC_ENABLE_EQ\n        unsigned int delay = 2*_q->m + 3; \n#else\n        unsigned int delay = 2*_q->m;     \n#endif\n        if (_q->preamble_counter >= delay) {\n            unsigned int index = _q->preamble_counter-delay;\n            _q->preamble_rx[index] = mf_out;\n#if FLEXFRAMESYNC_ENABLE_EQ\n            eqlms_cccf_step(_q->equalizer, _q->preamble_pn[index], mf_out);\n#endif\n        }\n        _q->preamble_counter++;\n        if (_q->preamble_counter == 64 + delay)\n            _q->state = FLEXFRAMESYNC_STATE_RXHEADER;\n    }\n    return LIQUID_OK;\n}\nint flexframesync_execute_rxheader(flexframesync _q,\n                                   float complex _x)\n{\n    float complex mf_out = 0.0f;\n    int sample_available = flexframesync_step(_q, _x, &mf_out);\n    if (sample_available) {\n        _q->header_sym[_q->symbol_counter] = mf_out;\n        _q->symbol_counter++;\n        if (_q->symbol_counter == _q->header_sym_len) {\n            flexframesync_decode_header(_q);\n            if (_q->header_valid) {\n                _q->symbol_counter = 0;\n                _q->state = FLEXFRAMESYNC_STATE_RXPAYLOAD;\n                return LIQUID_OK;\n            }\n            _q->framedatastats.num_frames_detected++;\n            if (_q->callback != NULL) {\n                _q->framesyncstats.evm           = 0.0f; \n                _q->framesyncstats.rssi          = 20*log10f(_q->gamma_hat);\n                _q->framesyncstats.cfo           = nco_crcf_get_frequency(_q->mixer);\n                _q->framesyncstats.framesyms     = NULL;\n                _q->framesyncstats.num_framesyms = 0;\n                _q->framesyncstats.mod_scheme    = LIQUID_MODEM_UNKNOWN;\n                _q->framesyncstats.mod_bps       = 0;\n                _q->framesyncstats.check         = LIQUID_CRC_UNKNOWN;\n                _q->framesyncstats.fec0          = LIQUID_FEC_UNKNOWN;\n                _q->framesyncstats.fec1          = LIQUID_FEC_UNKNOWN;\n                _q->callback(_q->header_dec,\n                             _q->header_valid,\n                             NULL,  \n                             0,     \n                             0,     \n                             _q->framesyncstats,\n                             _q->userdata);\n            }\n            return flexframesync_reset(_q);\n        }\n    }\n    return LIQUID_OK;\n}\nint flexframesync_execute(flexframesync   _q,\n                          float complex * _x,\n                          unsigned int    _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n#if DEBUG_FLEXFRAMESYNC\n        if (_q->debug_enabled && !_q->debug_qdetector_flush)\n            windowcf_push(_q->debug_x, _x[i]);\n#endif\n        switch (_q->state) {\n        case FLEXFRAMESYNC_STATE_DETECTFRAME:\n            flexframesync_execute_seekpn(_q, _x[i]);\n            break;\n        case FLEXFRAMESYNC_STATE_RXPREAMBLE:\n            flexframesync_execute_rxpreamble(_q, _x[i]);\n            break;\n        case FLEXFRAMESYNC_STATE_RXHEADER:\n            flexframesync_execute_rxheader(_q, _x[i]);\n            break;\n        case FLEXFRAMESYNC_STATE_RXPAYLOAD:\n            flexframesync_execute_rxpayload(_q, _x[i]);\n            break;\n        default:\n            return liquid_error(LIQUID_EINT,""flexframesync_exeucte(), unknown/unsupported internal state"");\n        }\n    }\n    return LIQUID_OK;\n}\nint flexframesync_step(flexframesync   _q,\n                       float complex   _x,\n                       float complex * _y)\n{\n    float complex v;\n    nco_crcf_mix_down(_q->mixer, _x, &v);\n    nco_crcf_step    (_q->mixer);\n    firpfb_crcf_push   (_q->mf, v);\n    firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);\n#if FLEXFRAMESYNC_ENABLE_EQ\n    eqlms_cccf_push(_q->equalizer, v);\n#endif\n    _q->mf_counter++;\n    int sample_available = (_q->mf_counter >= 1) ? 1 : 0;\n    if (sample_available) {\n#if FLEXFRAMESYNC_ENABLE_EQ\n        eqlms_cccf_execute(_q->equalizer, &v);\n#endif\n        *_y = v;\n        _q->mf_counter -= 2;\n    }\n    return sample_available;\n}\nint flexframesync_execute_seekpn(flexframesync _q,\n                                  float complex _x)\n{\n    float complex * v = qdetector_cccf_execute(_q->detector, _x);\n    if (v == NULL)\n        return LIQUID_OK;\n    _q->tau_hat   = qdetector_cccf_get_tau  (_q->detector);\n    _q->gamma_hat = qdetector_cccf_get_gamma(_q->detector);\n    _q->dphi_hat  = qdetector_cccf_get_dphi (_q->detector);\n    _q->phi_hat   = qdetector_cccf_get_phi  (_q->detector);\n#if DEBUG_FLEXFRAMESYNC_PRINT\n    printf(""***** frame detected! tau-hat:%8.4f, dphi-hat:%8.4f, gamma:%8.2f dB\\n"",\n            _q->tau_hat, _q->dphi_hat, 20*log10f(_q->gamma_hat));\n#endif\n    if (_q->tau_hat > 0) {\n        _q->pfb_index = (unsigned int)(      _q->tau_hat  * _q->npfb) % _q->npfb;\n        _q->mf_counter = 0;\n    } else {\n        _q->pfb_index = (unsigned int)((1.0f+_q->tau_hat) * _q->npfb) % _q->npfb;\n        _q->mf_counter = 1;\n    }\n    firpfb_crcf_set_scale(_q->mf, 0.5f / _q->gamma_hat);\n    nco_crcf_set_frequency(_q->mixer, _q->dphi_hat);\n    nco_crcf_set_phase    (_q->mixer, _q->phi_hat );\n    _q->state = FLEXFRAMESYNC_STATE_RXPREAMBLE;\n#if DEBUG_FLEXFRAMESYNC\n    _q->debug_qdetector_flush = 1;\n#endif\n    unsigned int buf_len = qdetector_cccf_get_buf_len(_q->detector);\n    flexframesync_execute(_q, v, buf_len);\n#if DEBUG_FLEXFRAMESYNC\n    _q->debug_qdetector_flush = 0;\n#endif\n    return LIQUID_OK;\n}\nint flexframesync_reset(flexframesync _q)\n{\n    qdetector_cccf_reset(_q->detector);\n    nco_crcf_reset(_q->mixer);\n    nco_crcf_reset(_q->pll);\n    firpfb_crcf_reset(_q->mf);\n    _q->state           = FLEXFRAMESYNC_STATE_DETECTFRAME;\n    _q->preamble_counter= 0;\n    _q->symbol_counter  = 0;\n    _q->framesyncstats.evm = 0.0f;\n    return LIQUID_OK;\n}\nint flexframesync_execute_rxpayload(flexframesync _q,\n                                    float complex _x)\n{\n    float complex mf_out = 0.0f;\n    int sample_available = flexframesync_step(_q, _x, &mf_out);\n    if (sample_available) {\n        nco_crcf_mix_down(_q->pll, mf_out, &mf_out);\n        unsigned int sym;\n        modemcf_demodulate(_q->payload_demod, mf_out, &sym);\n        float phase_error = modemcf_get_demodulator_phase_error(_q->payload_demod);\n        float evm         = modemcf_get_demodulator_evm        (_q->payload_demod);\n        nco_crcf_pll_step(_q->pll, phase_error);\n        nco_crcf_step(_q->pll);\n        _q->framesyncstats.evm += evm*evm;\n        _q->payload_sym[_q->symbol_counter] = mf_out;\n        _q->symbol_counter++;\n        if (_q->symbol_counter == _q->payload_sym_len) {\n            if (_q->payload_soft) {\n                _q->payload_valid = qpacketmodem_decode_soft(_q->payload_decoder,\n                                                             _q->payload_sym,\n                                                             _q->payload_dec);\n            } else {\n                _q->payload_valid = qpacketmodem_decode(_q->payload_decoder,\n                                                        _q->payload_sym,\n                                                        _q->payload_dec);\n            }\n            _q->framedatastats.num_frames_detected++;\n            _q->framedatastats.num_headers_valid++;\n            if (_q->payload_valid) {\n                _q->framedatastats.num_payloads_valid += 1;\n                _q->framedatastats.num_bytes_received += _q->payload_dec_len;\n            }\n            if (_q->callback != NULL) {\n                int ms = qpacketmodem_get_modscheme(_q->payload_decoder);\n                _q->framesyncstats.evm           = 10*log10f(_q->framesyncstats.evm / (float)_q->payload_sym_len);\n                _q->framesyncstats.rssi          = 20*log10f(_q->gamma_hat);\n                _q->framesyncstats.cfo           = nco_crcf_get_frequency(_q->mixer);\n                _q->framesyncstats.framesyms     = _q->payload_sym;\n                _q->framesyncstats.num_framesyms = _q->payload_sym_len;\n                _q->framesyncstats.mod_scheme    = ms;\n                _q->framesyncstats.mod_bps       = modulation_types[ms].bps;\n                _q->framesyncstats.check         = qpacketmodem_get_crc(_q->payload_decoder);\n                _q->framesyncstats.fec0          = qpacketmodem_get_fec0(_q->payload_decoder);\n                _q->framesyncstats.fec1          = qpacketmodem_get_fec1(_q->payload_decoder);\n                _q->callback(_q->header_dec,\n                             _q->header_valid,\n                             _q->payload_dec,\n                             _q->payload_dec_len,\n                             _q->payload_valid,\n                             _q->framesyncstats,\n                             _q->userdata);\n            }\n            return flexframesync_reset(_q);\n        }\n    }\n    return LIQUID_OK;\n}\nint flexframesync_execute(flexframesync   _q,\n                          float complex * _x,\n                          unsigned int    _n)\n{\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n#if DEBUG_FLEXFRAMESYNC\n        if (_q->debug_enabled && !_q->debug_qdetector_flush)\n            windowcf_push(_q->debug_x, _x[i]);\n#endif\n        switch (_q->state) {\n        case FLEXFRAMESYNC_STATE_DETECTFRAME:\n            flexframesync_execute_seekpn(_q, _x[i]);\n            break;\n        case FLEXFRAMESYNC_STATE_RXPREAMBLE:\n            flexframesync_execute_rxpreamble(_q, _x[i]);\n            break;\n        case FLEXFRAMESYNC_STATE_RXHEADER:\n            flexframesync_execute_rxheader(_q, _x[i]);\n            break;\n        case FLEXFRAMESYNC_STATE_RXPAYLOAD:\n            flexframesync_execute_rxpayload(_q, _x[i]);\n            break;\n        default:\n            return liquid_error(LIQUID_EINT,""flexframesync_exeucte(), unknown/unsupported internal state"");\n        }\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: ""We need to test the spwaterfall functionality with invalid configurations and check for errors. The configurations include FFT size, window type, window length, delay, and time parameters. Additionally, we need to test the spwaterfall operation, copying of spwaterfall objects, checking noise levels, and generate a gnuplot waterfall plot. Can you please provide code for these tests?""","void autotest_spwaterfall_invalid_config()\n{\n#ifdef LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""spwaterfall test not run with strict mode enabled"");\n    return;\n#endif\n    AUTOTEST_WARN(""testing spwaterfall invalid configurations; ignore printed errors"");\n    unsigned int nfft  = 1200;\n    int          wtype = LIQUID_WINDOW_HAMMING;\n    unsigned int wlen  =  800;\n    unsigned int delay =  200;\n    unsigned int time  =  960;\n    CONTEND_ISNULL(spwaterfallcf_create(   1, wtype,   wlen, delay, time))\n    CONTEND_ISNULL(spwaterfallcf_create(nfft, wtype,      0, delay, time))\n    CONTEND_ISNULL(spwaterfallcf_create(nfft, wtype, nfft+1, delay, time))\n    CONTEND_ISNULL(spwaterfallcf_create(nfft, LIQUID_WINDOW_KBD, 801, delay, time))\n    CONTEND_ISNULL(spwaterfallcf_create(nfft, wtype,   wlen,     0, time))\n    CONTEND_ISNULL(spwaterfallcf_create(nfft, wtype,   wlen, delay,    0))\n    CONTEND_ISNULL(spwaterfallcf_create_default(   0, time))\n    CONTEND_ISNULL(spwaterfallcf_create_default(nfft,    0))\n    spwaterfallcf q = spwaterfallcf_create_default(540, 320);\n    CONTEND_INEQUALITY(LIQUID_OK, spwaterfallcf_set_rate(q, -10e6))\n    spwaterfallcf_destroy(q);\n}\nint testbench_spwaterfallcf_compare(const void * _v0, const void * _v1)\n    { return *(float*)_v0 > *(float*)_v1 ? 1 : -1; }\nvoid testbench_spwaterfallcf_noise(unsigned int _nfft,\n                                   unsigned int _window_len,\n                                   unsigned int _delay,\n                                   unsigned int _time,\n                                   float        _noise_floor)\n{\n    unsigned int num_samples = 4*_nfft*_time;  \n    float        nstd        = powf(10.0f,_noise_floor/20.0f); \n    float        tol         = 4.0f; \n    int _wtype = LIQUID_WINDOW_HAMMING;\n    spwaterfallcf q = spwaterfallcf_create(_nfft, _wtype, _window_len, _delay, _time);\n    unsigned int i;\n    for (i=0; i<num_samples; i++)\n        spwaterfallcf_push(q, nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q), num_samples);\n    const float * psd = spwaterfallcf_get_psd(q);\n    unsigned int time = spwaterfallcf_get_num_time(q);\n#if 0\n    FILE * fid = fopen(""spwaterfallcf_testbench.m"", ""w"");\n    fprintf(fid,""clear all; close all; psd=zeros(%u,%u);\\n"", _nfft, time);\n    for (i=0; i<_nfft*time; i++)\n        fprintf(fid,""psd(%u) = %g;\\n"", i+1, psd[i]);\n    fclose(fid);\n#endif\n    float * v = (float*) malloc(_nfft*time*sizeof(float));\n    memmove(v, psd, _nfft*time*sizeof(float));\n    qsort(v, _nfft*time, sizeof(float), &testbench_spwaterfallcf_compare);\n    float median = v[_nfft*time/2];\n    if (liquid_autotest_verbose) {\n        printf(""  spwaterfallcf_test(noise): nfft:%4u, wtype:%s, n0:%6.1f, est:%6.1f, tol:%5.2f\\n"",\n                _nfft, liquid_window_str[_wtype][1], _noise_floor, median, tol);\n    }\n    CONTEND_DELTA(median, _noise_floor, tol)\n    free(v);\n    spwaterfallcf_destroy(q);\n}\nvoid autotest_spwaterfallcf_noise_440()  { testbench_spwaterfallcf_noise( 440, 320, 100, 240, -80.0); }\nvoid autotest_spwaterfallcf_noise_1024() { testbench_spwaterfallcf_noise( 680, 480, 150, 640, -80.0); }\nvoid autotest_spwaterfallcf_noise_1200() { testbench_spwaterfallcf_noise(1200, 800, 400, 800, -80.0); }\nvoid autotest_spwaterfall_operation()\n{\n    spwaterfallcf q = spwaterfallcf_create(1200, LIQUID_WINDOW_HAMMING, 800, 10, 960);\n    spwaterfallcf_print(q);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_freq(q), 1200);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_time(q),    0);\n    CONTEND_EQUALITY(spwaterfallcf_get_window_len(q),800);\n    CONTEND_EQUALITY(spwaterfallcf_get_delay(q),      10);\n    CONTEND_EQUALITY(spwaterfallcf_get_wtype(q), LIQUID_WINDOW_HAMMING);\n    spwaterfallcf_push(q, randnf() + _Complex_I*randnf());\n    spwaterfallcf_push(q, randnf() + _Complex_I*randnf());\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q), 2);\n    spwaterfallcf_clear(q);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q), 2);\n    spwaterfallcf_reset(q);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q), 0);\n    float complex buf[12];\n    unsigned int i;\n    for (i=0; i<12; i++)\n        buf[i] = randnf() + _Complex_I*randnf();\n    spwaterfallcf_write(q, buf, 12);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q), 12);\n    spwaterfallcf_destroy(q);\n}\nvoid autotest_spwaterfall_copy()\n{\n    unsigned int nfft =  240;   \n    unsigned int time =  192;   \n    float        nstd =  0.1f;  \n    spwaterfallcf q0 = spwaterfallcf_create(nfft, LIQUID_WINDOW_KAISER, 217, 137, time);\n    unsigned int i;\n    unsigned int num_samples = 17 * nfft * time;\n    for (i=0; i<num_samples; i++) {\n        float complex v = 0.1f + nstd * (randnf() + _Complex_I*randnf());\n        spwaterfallcf_push(q0, v);\n    }\n    spwaterfallcf q1 = spwaterfallcf_copy(q0);\n    for (i=0; i<num_samples; i++) {\n        float complex v = 0.1f + nstd * (randnf() + _Complex_I*randnf());\n        spwaterfallcf_push(q0, v);\n        spwaterfallcf_push(q1, v);\n    }\n    CONTEND_EQUALITY(spwaterfallcf_get_num_freq         (q0),spwaterfallcf_get_num_freq         (q1));\n    CONTEND_EQUALITY(spwaterfallcf_get_num_time         (q0),spwaterfallcf_get_num_time         (q1));\n    CONTEND_EQUALITY(spwaterfallcf_get_window_len       (q0),spwaterfallcf_get_window_len       (q1));\n    CONTEND_EQUALITY(spwaterfallcf_get_delay            (q0),spwaterfallcf_get_delay            (q1));\n    CONTEND_EQUALITY(spwaterfallcf_get_wtype            (q0),spwaterfallcf_get_wtype            (q1));\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q0),spwaterfallcf_get_num_samples_total(q1));\n    const float * psd_0 = spwaterfallcf_get_psd(q0);\n    const float * psd_1 = spwaterfallcf_get_psd(q1);\n    unsigned int nt = spwaterfallcf_get_num_time(q0);\n    CONTEND_SAME_DATA(psd_0, psd_1, nfft*nt*sizeof(float));\n    spwaterfallcf_destroy(q0);\n    spwaterfallcf_destroy(q1);\n}\nvoid autotest_spwaterfall_gnuplot()\n{\n    spwaterfallcf q = spwaterfallcf_create_default(540, 320);\n    unsigned int i;\n    for (i=0; i<800000; i++)\n        spwaterfallcf_push(q, randnf() + _Complex_I*randnf());\n    CONTEND_EQUALITY(LIQUID_OK,spwaterfallcf_export(q,""autotest/logs/spwaterfall""))\n    CONTEND_EQUALITY(LIQUID_OK,spwaterfallcf_set_freq(q, 100e6))\n    CONTEND_EQUALITY(LIQUID_OK,spwaterfallcf_set_rate(q,  20e6))\n    CONTEND_EQUALITY(LIQUID_OK,spwaterfallcf_set_dims(q, 640, 480))\n    CONTEND_EQUALITY(LIQUID_OK, spwaterfallcf_set_commands(q,NULL))\n    CONTEND_EQUALITY(LIQUID_OK,spwaterfallcf_set_commands(q,""set title \'waterfall\'""))\n    CONTEND_EQUALITY(LIQUID_OK,spwaterfallcf_export(q,""autotest/logs/spwaterfall""))\n    spwaterfallcf_destroy(q);\n}')
"
"('Prompt: You are working on a program that requires the calculation of the dot product of two complex float arrays. You need to implement a function that computes the dot product of two complex float arrays and returns the result as a complex float number. The function should also provide a structured way to create, execute, and destroy instances of the dot product calculation. Can you provide the C code for this scenario?","int main() {\n    float complex x[] = { 1 + 1 * _Complex_I,\n                          2 + 1 * _Complex_I,\n                          3 + 1 * _Complex_I,\n                          4 + 1 * _Complex_I,\n                          5 + 1 * _Complex_I};\n    float complex h[] = { 1 + 1 * _Complex_I,\n                         -1 + 1 * _Complex_I,\n                          1 + 1 * _Complex_I,\n                         -1 + 1 * _Complex_I,\n                          1 + 1 * _Complex_I};\n    float complex y;\n    dotprod_cccf_run(x,h,5,&y);\n    printf(""dotprod_cccf              : %8.2f + j%8.2f\\n"", crealf(y), cimagf(y));\n    dotprod_cccf q = dotprod_cccf_create(x,5);\n    dotprod_cccf_execute(q,h,&y);\n    printf(""dotprod_cccf (structured) : %8.2f + j%8.2f\\n"", crealf(y), cimagf(y));\n    dotprod_cccf_destroy(q);\n    return 0;\n}')
"
"'Prompt:. . You are working on a project that involves controlling the reset behavior of various components within a system-on-chip (SoC). You need to implement functions to release core resets, set global system reset modes, assert software resets on specific slices, lock slice modes, configure setpoints and domain modes for slices, and retrieve the reset state of a slice. Can you provide the necessary C code for these functions? . . Response:. ```c. #ifndef FSL_COMPONENT_ID. #define FSL_COMPONENT_ID ""platform.drivers.soc_src"". #endif. . #define SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_MASK (0x3U). #define SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_CONFIG(resetSource, resetMode) \\.     ((uint32_t)(resetMode) << (uint32_t)(resetSource)). . #define SRC_SLICE_CTRL_SW_RESET_MASK (0x1U). . void SRC_ReleaseCoreReset(SRC_Type *base, src_core_name_t coreName). {.     uint32_t coreMaskArray","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.soc_src""\n#endif\n#define SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_MASK (0x3U)\n#define SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_CONFIG(resetSource, resetMode) \\\n    ((uint32_t)(resetMode) << (uint32_t)(resetSource))\n#define SRC_SLICE_CTRL_SW_RESET_MASK (0x1U)\nvoid SRC_ReleaseCoreReset(SRC_Type *base, src_core_name_t coreName)\n{\n    uint32_t coreMaskArray[] = {SRC_SCR_BT_RELEASE_M7_MASK, SRC_SCR_BT_RELEASE_M4_MASK};\n    uint32_t regValue;\n    regValue = base->SCR;\n    if ((regValue & coreMaskArray[((uint32_t)coreName) - 1UL]) == 0UL)\n    {\n        base->SCR |= coreMaskArray[((uint32_t)coreName) - 1UL];\n    }\n}\nvoid SRC_SetGlobalSystemResetMode(SRC_Type *base,\n                                  src_global_system_reset_source_t resetSource,\n                                  src_global_system_reset_mode_t resetMode)\n{\n    uint32_t regValue;\n    regValue = base->SRMR;\n    regValue &= ~SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_CONFIG(resetSource, SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_MASK);\n    regValue |= SRC_GLOBAL_SYSTEM_RESET_BEHAVIOR_CONFIG(resetSource, resetMode);\n    base->SRMR = regValue;\n}\nvoid SRC_AssertSliceSoftwareReset(SRC_Type *base, src_reset_slice_name_t sliceName)\n{\n    uint32_t regAddress;\n    uint32_t sliceStatusRegAddress;\n    regAddress            = SRC_GET_SLICE_REGISTER_ADDRESS(base, sliceName, SRC_SLICE_CONTROL_REGISTER_OFFSET);\n    sliceStatusRegAddress = SRC_GET_SLICE_REGISTER_ADDRESS(base, sliceName, SRC_SLICE_STATUS_REGISTER_OFFSET);\n    *(volatile uint32_t *)regAddress |= SRC_SLICE_CTRL_SW_RESET_MASK;\n    while (((*(volatile uint32_t *)sliceStatusRegAddress) & SRC_SLICE_STAT_UNDER_RST_MASK) != 0UL)\n    {\n        ;\n    }\n}\nvoid SRC_LockSliceMode(SRC_Type *base, src_reset_slice_name_t sliceName)\n{\n    uint32_t authenticationRegAddress;\n    authenticationRegAddress =\n        SRC_GET_SLICE_REGISTER_ADDRESS(base, sliceName, SRC_SLICE_AUTHENTICATION_REGISTER_OFFSET);\n    *(volatile uint32_t *)authenticationRegAddress |= SRC_SLICE_AUTHEN_LOCK_MODE_MASK;\n}\nvoid SRC_SetSliceSetPointConfig(SRC_Type *base, src_reset_slice_name_t sliceName, uint32_t setpointConfig)\n{\n    uint32_t setpointConfigRegAddress;\n    setpointConfigRegAddress =\n        SRC_GET_SLICE_REGISTER_ADDRESS(base, sliceName, SRC_SLICE_SETPOINT_CONFIG_REGISTER_OFFSET);\n    if (setpointConfig != 0UL)\n    {\n        *(volatile uint32_t *)setpointConfigRegAddress = setpointConfig;\n    }\n}\nvoid SRC_SetSliceDomainModeConfig(SRC_Type *base, src_reset_slice_name_t sliceName, uint32_t domainConfig)\n{\n    uint32_t domainConfigRegAddress;\n    domainConfigRegAddress = SRC_GET_SLICE_REGISTER_ADDRESS(base, sliceName, SRC_SLICE_DOMAIN_CONFIG_REGISTER_OFFSET);\n    if (domainConfig != 0UL)\n    {\n        *(volatile uint32_t *)domainConfigRegAddress = domainConfig;\n    }\n}\nsrc_slice_reset_state_t SRC_GetSliceResetState(SRC_Type *base, src_reset_slice_name_t sliceName)\n{\n    uint32_t statusRegAddress;\n    src_slice_reset_state_t ret;\n    statusRegAddress = SRC_GET_SLICE_REGISTER_ADDRESS(base, sliceName, SRC_SLICE_STATUS_REGISTER_OFFSET);\n    if (((*(uint32_t *)statusRegAddress) & SRC_SLICE_STAT_UNDER_RST_MASK) != 0UL)\n    {\n        ret = kSRC_SliceResetInProcess;\n    }\n    else\n    {\n        ret = kSRC_SliceResetFinished;\n    }\n    return ret;\n}'"
"('Prompt: You are working on a digital communication system that uses frame synchronization. You need to create a default frame synchronization statistics structure with specific default values for certain parameters. Additionally, you need to initialize this default structure and print out the statistics of a given frame synchronization stats structure. Please provide the code for initializing the default frame synchronization stats structure and a function that prints out the statistics.","framesyncstats_s framesyncstats_default = {\n    0.0f,                   \n    0.0f,                   \n    0.0f,                   \n    NULL,                   \n    0,                      \n    LIQUID_MODEM_UNKNOWN,   \n    0,                      \n    LIQUID_CRC_UNKNOWN,     \n    LIQUID_FEC_UNKNOWN,     \n    LIQUID_FEC_UNKNOWN      \n};\nint framesyncstats_init_default(framesyncstats_s * _stats)\n{\n    memmove(_stats, &framesyncstats_default, sizeof(framesyncstats_s));\n    return LIQUID_OK;\n}\nint framesyncstats_print(framesyncstats_s * _stats)\n{\n    if (_stats->mod_scheme >= LIQUID_MODEM_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""framesyncstats_print(), invalid modulation scheme"");\n     if (_stats->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""framesyncstats_print(), invalid CRC scheme"");\n     if (_stats->fec0 >= LIQUID_FEC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""framesyncstats_print(), invalid FEC scheme (inner)"");\n     if (_stats->fec1 >= LIQUID_FEC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""framesyncstats_print(), invalid FEC scheme (outer)"");\n    printf(""    EVM                 :   %12.8f dB\\n"", _stats->evm);\n    printf(""    rssi                :   %12.8f dB\\n"", _stats->rssi);\n    printf(""    carrier offset      :   %12.8f Fs\\n"", _stats->cfo);\n    printf(""    num symbols         :   %u\\n"", _stats->num_framesyms);\n    printf(""    mod scheme          :   %s (%u bits/symbol)\\n"",\n            modulation_types[_stats->mod_scheme].name,\n            _stats->mod_bps);\n    printf(""    validity check      :   %s\\n"", crc_scheme_str[_stats->check][0]);\n    printf(""    fec (inner)         :   %s\\n"", fec_scheme_str[_stats->fec0][0]);\n    printf(""    fec (outer)         :   %s\\n"", fec_scheme_str[_stats->fec1][0]);\n    return LIQUID_OK;\n}')
"
"('Prompt: Design an Infinite Impulse Response (IIR) filter with a 5th order numerator and 5th order denominator. Given the filter coefficients for both the numerator (b) and the denominator (a), apply the filter to a given input signal (x) to obtain the output signal (y). Use the provided data arrays for b, a, x, and y to implement the filter in C code.. Code:. ```c. #include <liquid/liquid.h>. . // Define the filter length. #define DATA_LEN 64. . int main() {.     // Create filter objects.     iirfilt_rrrf q = iirfilt_rrrf_create(iirfilt_rrrf_data_h5x64_b, 5, iirfilt_rrrf_data_h5x64_a, 5);. .     // Create arrays for input and output data.     float x[DATA_LEN];.     float y[DATA_LEN];. .     // Copy input data to x array.     for (int","float iirfilt_rrrf_data_h5x64_b[] = {\n    0.004824343358,\n    0.019297373431,\n    0.028946060146,\n    0.019297373431,\n    0.004824343358};\nfloat iirfilt_rrrf_data_h5x64_a[] = {\n    1.000000000000,\n   -2.369513007182,\n    2.313988414416,\n   -1.054665405879,\n    0.187379492368};\nfloat iirfilt_rrrf_data_h5x64_x[] = {\n   -0.071435037288,\n   -0.013824638625,\n    0.000604766808,\n   -0.157245338765,\n   -0.148499909731,\n    0.036854467235,\n   -0.092170127241,\n   -0.030750688358,\n   -0.256687046040,\n   -0.011293794477,\n   -0.152735111898,\n   -0.039350864050,\n   -0.026481755383,\n    0.026344708916,\n   -0.165804900216,\n    0.075110855166,\n    0.169733039664,\n    0.112960857425,\n    0.102855045747,\n   -0.058065586616,\n   -0.019482689014,\n   -0.069631526814,\n    0.080391768879,\n   -0.148962611101,\n   -0.063224959929,\n    0.177207853044,\n    0.064119106525,\n    0.182006292285,\n    0.032851335390,\n    0.025859709218,\n    0.012249245529,\n    0.020538703403,\n   -0.010050632447,\n    0.157918073531,\n    0.155799289392,\n    0.161618591338,\n   -0.061931920946,\n   -0.002480403144,\n   -0.080860681406,\n   -0.119527652190,\n    0.041981586004,\n    0.049388453948,\n   -0.119534817516,\n   -0.004446996769,\n   -0.010415835934,\n    0.070065217532,\n    0.016956615378,\n    0.196554086088,\n   -0.089159910224,\n    0.005262040310,\n    0.025380561695,\n   -0.190719045717,\n   -0.137704432243,\n   -0.012169688901,\n   -0.072683558269,\n    0.115787622162,\n   -0.013755488460,\n    0.060139162368,\n    0.002047451288,\n    0.123978241358,\n    0.006962698789,\n   -0.019071948553,\n   -0.062140245356,\n   -0.111724700578};\nfloat iirfilt_rrrf_data_h5x64_y[] = {\n   -0.000344627148,\n   -0.002261801903,\n   -0.006893530299,\n   -0.013989605147,\n   -0.023862607597,\n   -0.038312044528,\n   -0.056089194368,\n   -0.071280615399,\n   -0.079550560246,\n   -0.083028835474,\n   -0.086748998983,\n   -0.092533693567,\n   -0.097949600919,\n   -0.098429082259,\n   -0.090466124573,\n   -0.075337575372,\n   -0.056782281433,\n   -0.034261954387,\n   -0.004056342067,\n    0.032512857031,\n    0.065692345386,\n    0.082703529450,\n    0.076861903089,\n    0.052102523397,\n    0.018224928933,\n   -0.015275405731,\n   -0.038407046800,\n   -0.040894489472,\n   -0.018910631091,\n    0.020295410235,\n    0.061246521124,\n    0.088475490616,\n    0.094228350367,\n    0.080859234115,\n    0.059352937798,\n    0.044593577702,\n    0.046274753880,\n    0.061145236873,\n    0.075354763624,\n    0.074888924042,\n    0.054105775368,\n    0.018945116326,\n   -0.016551695165,\n   -0.040692464489,\n   -0.050718972892,\n   -0.049083944974,\n   -0.038287527306,\n   -0.019928604327,\n    0.004267855964,\n    0.029703630925,\n    0.048181600553,\n    0.052618134862,\n    0.039776735477,\n    0.010021908144,\n   -0.029959006998,\n   -0.066860943714,\n   -0.086821708742,\n   -0.082569377253,\n   -0.056991021236,\n   -0.020344296462,\n    0.016435506907,\n    0.045346639362,\n    0.060576452509,\n    0.058193434336};')
"
"'""Create a simple authentication system with a password input field and a log out button. Implement a label that displays login status messages. Additionally, add a slider button to start an engine. Ensure the components are properly enabled/disabled based on authentication status.""","#if LV_USE_OBSERVER && LV_USE_SLIDER && LV_USE_LABEL && LV_BUILD_EXAMPLES\nstatic lv_subject_t engine_subject;\nstatic void app_init(void);\nstatic void ui_init(void);\nvoid lv_example_observer_2(void)\n{\n    lv_subject_init_int(&engine_subject, 0);\n    app_init();\n    ui_init();\n}\nstatic void engine_state_observer_cb(lv_observer_t * observer, lv_subject_t * subject)\n{\n    LV_UNUSED(observer);\n    int32_t v = lv_subject_get_int(subject);\n    LV_UNUSED(v);\n    LV_LOG_USER(""Engine state: %"" LV_PRId32, v);\n}\nstatic void app_init(void)\n{\n    lv_subject_add_observer(&engine_subject, engine_state_observer_cb, NULL);\n}\ntypedef enum {\n    LOGGED_OUT,\n    LOGGED_IN,\n    AUTH_FAILED,\n} auth_state_t;\nstatic lv_subject_t auth_state_subject;\nstatic void textarea_event_cb(lv_event_t * e)\n{\n    lv_obj_t * ta = lv_event_get_target(e);\n    if(strcmp(lv_textarea_get_text(ta), ""hello"") == 0) {\n        lv_subject_set_int(&auth_state_subject, LOGGED_IN);\n    }\n    else {\n        lv_subject_set_int(&auth_state_subject, AUTH_FAILED);\n    }\n}\nstatic void info_label_observer_cb(lv_observer_t * observer, lv_subject_t * subject)\n{\n    lv_obj_t * label = lv_observer_get_target(observer);\n    switch(lv_subject_get_int(subject)) {\n        case LOGGED_IN:\n            lv_label_set_text(label, ""Login successful"");\n            break;\n        case LOGGED_OUT:\n            lv_label_set_text(label, ""Logged out"");\n            break;\n        case AUTH_FAILED:\n            lv_label_set_text(label, ""Login failed"");\n            break;\n    }\n}\nstatic void log_out_click_event_cb(lv_event_t * e)\n{\n    LV_UNUSED(e);\n    lv_subject_set_int(&auth_state_subject, LOGGED_OUT);\n}\nstatic void ui_init(void)\n{\n    lv_subject_init_int(&auth_state_subject, LOGGED_OUT);\n    lv_obj_t * ta = lv_textarea_create(lv_screen_active());\n    lv_obj_set_pos(ta, 10, 10);\n    lv_obj_set_width(ta, 200);\n    lv_textarea_set_one_line(ta, true);\n    lv_textarea_set_password_mode(ta, true);\n    lv_textarea_set_placeholder_text(ta, ""The password is: hello"");\n    lv_obj_add_event_cb(ta, textarea_event_cb, LV_EVENT_READY, NULL);\n    lv_obj_bind_state_if_eq(ta, &auth_state_subject, LV_STATE_DISABLED, LOGGED_IN);\n    lv_obj_t * kb = lv_keyboard_create(lv_screen_active());\n    lv_keyboard_set_textarea(kb, ta);\n    lv_obj_t * btn;\n    lv_obj_t * label;\n    btn = lv_button_create(lv_screen_active());\n    lv_obj_set_pos(btn, 220, 10);\n    lv_obj_add_event_cb(btn, log_out_click_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_bind_state_if_not_eq(btn, &auth_state_subject, LV_STATE_DISABLED, LOGGED_IN);\n    label = lv_label_create(btn);\n    lv_label_set_text(label, ""LOG OUT"");\n    label = lv_label_create(lv_screen_active());\n    lv_obj_set_pos(label, 10, 60);\n    lv_subject_add_observer_obj(&auth_state_subject, info_label_observer_cb, label, NULL);\n    btn = lv_button_create(lv_screen_active());\n    lv_obj_set_pos(btn, 10, 80);\n    lv_obj_add_flag(btn, LV_OBJ_FLAG_CHECKABLE);\n    lv_obj_bind_state_if_not_eq(btn, &auth_state_subject, LV_STATE_DISABLED, LOGGED_IN);\n    lv_button_bind_checked(btn, &engine_subject);\n    label = lv_label_create(btn);\n    lv_label_set_text(label, ""START ENGINE"");\n}\n#endif'"
'Prompt: You are working on a multi-threaded application and you need to determine the number of processors available on the system in order to optimize thread allocation. Write a function in C that uses pthreads to find the number of processors available on the system. Make sure to handle any errors that may occur during the process.,#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\nint\npthread_num_processors_np (void)\n{\n  int count;\n  if (__ptw32_getprocessors (&count) != 0)\n    {\n      count = 1;\n    }\n  return (count);\n}'
"'Prompt: Create an example function in LVGL using checkboxes. The function should set up a column layout with checkboxes for ""Apple"", ""Banana"", ""Lemon"", and ""Melon"" with different states (checked, unchecked, disabled). When a checkbox is clicked and its state changes, log the text of the checkbox and its new state (checked or unchecked). . . Response: . ```c. #if LV_USE_CHECKBOX && LV_BUILD_EXAMPLES. static void event_handler(lv_event_t * e). {.     lv_event_code_t code = lv_event_get_code(e);.     lv_obj_t * obj = lv_event_get_target(e);.     if(code == LV_EVENT_VALUE_CHANGED) {.         LV_UNUSED(obj);.         const char * txt = lv_checkbox_get_text(obj);.         const char * state = lv_obj_get_state(obj) & LV_STATE_CHECKED ? ""Checked"" : ""Unchecked"";.         LV_UNUSED(txt);.         LV_UNUSED(state);.         LV_LOG_USER(""%s:","#if LV_USE_CHECKBOX && LV_BUILD_EXAMPLES\nstatic void event_handler(lv_event_t * e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_VALUE_CHANGED) {\n        LV_UNUSED(obj);\n        const char * txt = lv_checkbox_get_text(obj);\n        const char * state = lv_obj_get_state(obj) & LV_STATE_CHECKED ? ""Checked"" : ""Unchecked"";\n        LV_UNUSED(txt);\n        LV_UNUSED(state);\n        LV_LOG_USER(""%s: %s"", txt, state);\n    }\n}\nvoid lv_example_checkbox_1(void)\n{\n    lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_COLUMN);\n    lv_obj_set_flex_align(lv_screen_active(), LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER);\n    lv_obj_t * cb;\n    cb = lv_checkbox_create(lv_screen_active());\n    lv_checkbox_set_text(cb, ""Apple"");\n    lv_obj_add_event_cb(cb, event_handler, LV_EVENT_ALL, NULL);\n    cb = lv_checkbox_create(lv_screen_active());\n    lv_checkbox_set_text(cb, ""Banana"");\n    lv_obj_add_state(cb, LV_STATE_CHECKED);\n    lv_obj_add_event_cb(cb, event_handler, LV_EVENT_ALL, NULL);\n    cb = lv_checkbox_create(lv_screen_active());\n    lv_checkbox_set_text(cb, ""Lemon"");\n    lv_obj_add_state(cb, LV_STATE_DISABLED);\n    lv_obj_add_event_cb(cb, event_handler, LV_EVENT_ALL, NULL);\n    cb = lv_checkbox_create(lv_screen_active());\n    lv_obj_add_state(cb, LV_STATE_CHECKED | LV_STATE_DISABLED);\n    lv_checkbox_set_text(cb, ""Melon\\nand a new line"");\n    lv_obj_add_event_cb(cb, event_handler, LV_EVENT_ALL, NULL);\n    lv_obj_update_layout(cb);\n}\n#endif'"
"('Provide a prompt that involves determining the encoded message length for various forward error correction (FEC) schemes based on the input parameters. This prompt should ask for a function that calculates the encoded message length given the input block size, output block size, and message length, as well as handle different FEC schemes including Reed-Solomon, Hamming, Golay, and convolutional codes.","//...\nconst char * fec_scheme_str[LIQUID_FEC_NUM_SCHEMES][2] = {\nunsigned int fec_block_get_enc_msg_len(unsigned int _dec_msg_len,\n                                       unsigned int _m,\n                                       unsigned int _k)\n{\n    if (_m == 0) {\n        fprintf(stderr,""fec_block_get_enc_msg_len(), input block size cannot be zero\\n"");\n        return 0;\n    } else if (_k < _m) {\n        fprintf(stderr,""fec_block_get_enc_msg_len(), output block size cannot be smaller than input\\n"");\n        return 0;\n    }\n    unsigned int num_bits_in = _dec_msg_len*8;\n    unsigned int num_blocks = num_bits_in / _m + (num_bits_in%_m ? 1 : 0);\n    unsigned int num_bits_out = num_blocks * _k;\n    unsigned int num_bytes_out = num_bits_out/8 + (num_bits_out%8 ? 1 : 0);\n#if 0\n    printf(""fec_block_get_enc_msg_len(%u,%u,%u)\\n"", _dec_msg_len, _m, _k);\n    printf(""    dec msg len :   %u bytes\\n"", _dec_msg_len);\n    printf(""    m           :   %u bits\\n"", _m);\n    printf(""    k           :   %u bits\\n"", _k);\n    printf(""    num bits in :   %u bits\\n"", num_bits_in);\n    printf(""    num blocks  :   %u\\n"", num_blocks);\n    printf(""    num bits out:   %u bits\\n"", num_bits_out);\n    printf(""    enc msg len :   %u bytes\\n"", num_bytes_out);\n#endif\n    return num_bytes_out;\n}\nunsigned int fec_rs_get_enc_msg_len(unsigned int _dec_msg_len,\n                                    unsigned int _nroots,\n                                    unsigned int _nn,\n                                    unsigned int _kk)\n{\n    if (_dec_msg_len == 0) {\n        liquid_error(LIQUID_EICONFIG,""fec_rs_get_enc_msg_len(), _dec_msg_len must be greater than 0"");\n        return 0;\n    }\n    div_t d;\n    d = div(_dec_msg_len, _kk);\n    unsigned int num_blocks = d.quot + (d.rem==0 ? 0 : 1);\n    d = div(_dec_msg_len, num_blocks);\n    unsigned int dec_block_len = d.quot + (d.rem == 0 ? 0 : 1);\n    unsigned int enc_block_len = dec_block_len + _nroots;\n    unsigned int enc_msg_len = enc_block_len * num_blocks;\n#if 0\n    printf(""dec_msg_len     :   %u\\n"", _dec_msg_len);\n    printf(""num_blocks      :   %u\\n"",  num_blocks);\n    printf(""dec_block_len   :   %u\\n"",  dec_block_len);\n    printf(""enc_block_len   :   %u\\n"",  enc_block_len);\n    printf(""enc_msg_len     :   %u\\n"",  enc_msg_len);\n#endif\n    return enc_msg_len;\n}\nunsigned int fec_conv_get_enc_msg_len(unsigned int _dec_msg_len,\n                                      unsigned int _K,\n                                      unsigned int _p)\n{\n    unsigned int num_bits_in = _dec_msg_len*8;\n    unsigned int n = num_bits_in + _K - 1;\n    unsigned int num_bits_out = n + (n+_p-1)/_p;\n    unsigned int num_bytes_out = num_bits_out/8 + (num_bits_out%8 ? 1 : 0);\n#if 0\n    printf(""msg len :       %3u\\n"", _dec_msg_len);\n    printf(""num bits in :   %3u\\n"", num_bits_in);\n    printf(""n (constraint): %3u\\n"", n);\n    printf(""num bits out:   %3u"", num_bits_out);\n    printf("" = n+(n+p-1)/p = %u+(%u+%u-1)/%u\\n"", n,n,_p,_p);\n    printf(""num bytes out:  %3u\\n"", num_bytes_out);\n#endif\n    return num_bytes_out;\n}\nunsigned int fec_get_enc_msg_length(fec_scheme   _scheme,\n                                    unsigned int _msg_len)\n{\n    switch (_scheme) {\n    case LIQUID_FEC_UNKNOWN:        return 0;\n    case LIQUID_FEC_NONE:           return _msg_len;\n    case LIQUID_FEC_REP3:           return 3*_msg_len;\n    case LIQUID_FEC_REP5:           return 5*_msg_len;\n    case LIQUID_FEC_HAMMING74:      return fec_block_get_enc_msg_len(_msg_len,4,7);\n    case LIQUID_FEC_HAMMING84:      return fec_block_get_enc_msg_len(_msg_len,4,8);\n    case LIQUID_FEC_HAMMING128:     return fec_block_get_enc_msg_len(_msg_len,8,12);\n    case LIQUID_FEC_GOLAY2412:      return fec_block_get_enc_msg_len(_msg_len,12,24);\n    case LIQUID_FEC_SECDED2216:     return _msg_len + _msg_len/2 + ((_msg_len%2) ? 1 : 0);\n    case LIQUID_FEC_SECDED3932:     return _msg_len + _msg_len/4 + ((_msg_len%4) ? 1 : 0);\n    case LIQUID_FEC_SECDED7264:     return _msg_len + _msg_len/8 + ((_msg_len%8) ? 1 : 0);\n#if LIBFEC_ENABLED\n    case LIQUID_FEC_CONV_V27:       return 2*_msg_len + 2;  \n    case LIQUID_FEC_CONV_V29:       return 2*_msg_len + 2;  \n    case LIQUID_FEC_CONV_V39:       return 3*_msg_len + 3;  \n    case LIQUID_FEC_CONV_V615:      return 6*_msg_len + 11; \n    case LIQUID_FEC_CONV_V27P23:    return fec_conv_get_enc_msg_len(_msg_len,7,2);\n    case LIQUID_FEC_CONV_V27P34:    return fec_conv_get_enc_msg_len(_msg_len,7,3);\n    case LIQUID_FEC_CONV_V27P45:    return fec_conv_get_enc_msg_len(_msg_len,7,4);\n    case LIQUID_FEC_CONV_V27P56:    return fec_conv_get_enc_msg_len(_msg_len,7,5);\n    case LIQUID_FEC_CONV_V27P67:    return fec_conv_get_enc_msg_len(_msg_len,7,6);\n    case LIQUID_FEC_CONV_V27P78:    return fec_conv_get_enc_msg_len(_msg_len,7,7);\n    case LIQUID_FEC_CONV_V29P23:    return fec_conv_get_enc_msg_len(_msg_len,9,2);\n    case LIQUID_FEC_CONV_V29P34:    return fec_conv_get_enc_msg_len(_msg_len,9,3);\n    case LIQUID_FEC_CONV_V29P45:    return fec_conv_get_enc_msg_len(_msg_len,9,4);\n    case LIQUID_FEC_CONV_V29P56:    return fec_conv_get_enc_msg_len(_msg_len,9,5);\n    case LIQUID_FEC_CONV_V29P67:    return fec_conv_get_enc_msg_len(_msg_len,9,6);\n    case LIQUID_FEC_CONV_V29P78:    return fec_conv_get_enc_msg_len(_msg_len,9,7);\n    case LIQUID_FEC_RS_M8:          return fec_rs_get_enc_msg_len(_msg_len,32,255,223);\n#else\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n        liquid_error(LIQUID_EUMODE,""fec_get_enc_msg_length(), convolutional codes unavailable (install libfec)"");\n    case LIQUID_FEC_RS_M8:\n        liquid_error(LIQUID_EUMODE,""fec_get_enc_msg_length(), Reed-Solomon codes unavailable (install libfec)"");\n#endif\n    default:\n        liquid_error(LIQUID_EIMODE,""fec_get_enc_msg_length(), unknown/unsupported scheme: %d\\n"", _scheme);\n    }\n    return 0;\n}\n//...')
"
"('Prompt: You are tasked to write a testbench function for copying an IIR filter prototype using Liquid DSP library. The scenario involves creating an IIR filter prototype with specific parameters, executing the filter on randomly generated samples, copying the filter, and comparing the outputs of the original and copied filters on the same set of samples. Lastly, make sure to destroy both filters after the test.","//...\nvoid testbench_iirfilt_copy(liquid_iirdes_format _format)\n{\n    iirfilt_crcf q0 = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_ELLIP, LIQUID_IIRDES_LOWPASS, _format,\n        9,0.2f,0.0f,0.1f,60.0f);\n    unsigned int i, num_samples = 80;\n    float complex y0, y1;\n    for (i=0; i<num_samples; i++) {\n        float complex v = randnf() + _Complex_I*randnf();\n        iirfilt_crcf_execute(q0, v, &y0);\n    }\n    iirfilt_crcf q1 = iirfilt_crcf_copy(q0);\n    for (i=0; i<num_samples; i++) {\n        float complex v = randnf() + _Complex_I*randnf();\n        iirfilt_crcf_execute(q0, v, &y0);\n        iirfilt_crcf_execute(q1, v, &y1);\n        CONTEND_EQUALITY(y0, y1);\n    }\n    iirfilt_crcf_destroy(q0);\n    iirfilt_crcf_destroy(q1);\n}\n//...')
"
"('Prompt: You are working on a matrix library that supports complex numbers, and you need to write a function that performs matrix multiplication for complex floats. The function should take two matrices, matrix X of size 5x4 and matrix Y of size 4x3, and return the result in matrix Z of size 5x3. Write a C function `autotest_matrixcf_mul()` that performs this matrix multiplication using the provided input matrices `matrixcf_data_mul_x`, `matrixcf_data_mul_y`, and stores the result in array `z`. Please ensure the function includes error tolerance handling and prints out the matrices involved in the multiplication for debugging purposes.","//...\nvoid autotest_matrixcf_mul()\n{\n    float tol = 1e-6f;\n    float complex z[35];\n    matrixcf_mul(matrixcf_data_mul_x, 5, 4,\n                 matrixcf_data_mul_y, 4, 3,\n                 z,                   5, 3);\n    if (liquid_autotest_verbose) {\n        printf(""multiplication:\\n"");\n        printf(""  x: "");        matrixcf_print(matrixcf_data_mul_x,5,4);\n        printf(""  y: "");        matrixcf_print(matrixcf_data_mul_y,4,3);\n        printf(""  expected: ""); matrixcf_print(matrixcf_data_mul_z,5,3);\n        printf(""  z: "");        matrixcf_print(z,5,3);\n    }\n    unsigned int i;\n    for (i=0; i<15; i++) {\n        CONTEND_DELTA( crealf(matrixcf_data_mul_z[i]), crealf(z[i]), tol );\n        CONTEND_DELTA( cimagf(matrixcf_data_mul_z[i]), cimagf(z[i]), tol );\n    }\n}\n//...')
"
"'Prompt: You are working on a project that requires implementing a Red-Black Tree data structure in C. Please provide the code for the Red-Black Tree implementation located in the file ""librbtree.c"" within the ""gear-lib"" directory of the project.",../gear-lib/librbtree/librbtree.c'
"('Prompt: Can you provide me with a function that performs a test for a finite impulse response (FIR) decimator with a length of 4 on a complex floating-point input data set, where the input data consists of 40 samples and the output data should have 10 samples? The function should use the provided data arrays firdecim_crcf_data_M4h13x40_h, firdecim_crcf_data_M4h13x40_x, and firdecim_crcf_data_M4h13x40_y.","//...\nvoid autotest_firdecim_crcf_data_M4h13x40()\n{\n    firdecim_crcf_test(4,\n                       firdecim_crcf_data_M4h13x40_h, 13,\n                       firdecim_crcf_data_M4h13x40_x, 40,\n                       firdecim_crcf_data_M4h13x40_y, 10);\n}\n//...')
"
"'You are working on a multi-threaded application using the Pthreads library in C, and you have encountered a scenario where you need to determine the state of a robust mutex. The prompt I could have given you for the following code as a response is:. . ""Given a pthread mutex pointer, please provide a function that checks the state of the robust mutex it points to. This function should return 0 if the mutex state is consistent, EOWNERDEAD if the mutex state is inconsistent with the owning thread having died (potentially due to EOWNERDEAD error), and ENOTRECOVERABLE if the mutex state is not recoverable. Also, assume that the pthread definition used here includes a field \'robustNode\' which points to a robust node structure within the mutex.""","//...\nINLINE\nint\n__ptw32_robust_mutex_inherit(pthread_mutex_t * mutex)\n{\n  int result;\n  pthread_mutex_t mx = *mutex;\n  __ptw32_robust_node_t* robust = mx->robustNode;\n  switch ((LONG)__PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(\n             (__PTW32_INTERLOCKED_LONGPTR)&robust->stateInconsistent,\n             (__PTW32_INTERLOCKED_LONG)__PTW32_ROBUST_INCONSISTENT,\n             (__PTW32_INTERLOCKED_LONG)-1 ))\n    {\n      case -1L:\n          result = EOWNERDEAD;\n          break;\n      case (LONG)__PTW32_ROBUST_NOTRECOVERABLE:\n          result = ENOTRECOVERABLE;\n          break;\n      default:\n          result = 0;\n          break;\n    }\n  return result;\n}\n//...'"
('I would need the prompt related to updating the configuration and generating a frame in a software-defined radio (SDR) system using the OFDM modulation scheme.,"//...\n    unsigned int M;         \n    unsigned char * p;      \n    float complex * X;          \n    unsigned int num_symbols_header;    \n    unsigned int header_user_len; \n    packetizer p_payload;               \n    unsigned int payload_dec_len;       \n    unsigned char * payload_enc;        \n    unsigned char * payload_mod;        \n    unsigned int payload_enc_len;       \n    unsigned int payload_mod_len;       \n    int frame_assembled;                \n    ofdmflexframegenprops_s props;\nint ofdmflexframegen_reconfigure(ofdmflexframegen _q)\n{\n    _q->p_payload = packetizer_recreate(_q->p_payload,\n                                        _q->payload_dec_len,\n                                        _q->props.check,\n                                        _q->props.fec0,\n                                        _q->props.fec1);\n    _q->payload_enc_len = packetizer_get_enc_msg_len(_q->p_payload);\n    _q->payload_enc = (unsigned char*) realloc(_q->payload_enc,\n                                               _q->payload_enc_len*sizeof(unsigned char));\n#if DEBUG_OFDMFLEXFRAMEGEN\n#endif\n    _q->mod_payload = modemcf_recreate(_q->mod_payload, _q->props.mod_scheme);\n    unsigned int bps = modulation_types[_q->props.mod_scheme].bps;\n    div_t d = div(8*_q->payload_enc_len, bps);\n    _q->payload_mod_len = d.quot + (d.rem ? 1 : 0);\n    _q->payload_mod = (unsigned char*)realloc(_q->payload_mod,\n                                              _q->payload_mod_len*sizeof(unsigned char));\n    d = div(_q->payload_mod_len, _q->M_data);\n    _q->num_symbols_payload = d.quot + (d.rem ? 1 : 0);\n    return LIQUID_OK;\n}\nint ofdmflexframegen_reset(ofdmflexframegen _q)\n{\n    _q->symbol_number        = 0;\n    _q->state = OFDMFLEXFRAMEGEN_STATE_S0a;\n    _q->frame_assembled      = 0;\n    _q->frame_complete       = 0;\n    _q->header_symbol_index  = 0;\n    _q->payload_symbol_index = 0;\n    _q->buf_index            = _q->frame_len;\n    return ofdmframegen_reset(_q->fg);\n}\nint ofdmflexframegen_encode_header(ofdmflexframegen _q)\n{\n    unsigned int n = _q->header_user_len;\n    _q->header[n+0] = OFDMFLEXFRAME_PROTOCOL;\n    _q->header[n+1] = (_q->payload_dec_len >> 8) & 0xff;\n    _q->header[n+2] = (_q->payload_dec_len     ) & 0xff;\n    _q->header[n+3]  = _q->props.mod_scheme;\n    _q->header[n+4]  = (_q->props.check & 0x07) << 5;\n    _q->header[n+4] |= (_q->props.fec0) & 0x1f;\n    _q->header[n+5]  = (_q->props.fec1) & 0x1f;\n    packetizer_encode(_q->p_header, _q->header, _q->header_enc);\n    scramble_data(_q->header_enc, _q->header_enc_len);\n#if 0\n    unsigned int i;\n    printf(""header tx (dec) : "");\n    for (i=0; i<OFDMFLEXFRAME_H_DEC; i++)\n        printf(""%.2X "", _q->header[i]);\n    printf(""\\n"");\n    printf(""header tx (enc) : "");\n    for (i=0; i<OFDMFLEXFRAME_H_ENC; i++)\n        printf(""%.2X "", _q->header_enc[i]);\n    printf(""\\n"");\n#endif\n    return LIQUID_OK;\n}\nint ofdmflexframegen_modulate_header(ofdmflexframegen _q)\n{\n    unsigned int bps = modulation_types[_q->header_props.mod_scheme].bps;\n    unsigned int num_written;\n    liquid_repack_bytes(_q->header_enc, 8,   _q->header_enc_len,\n                        _q->header_mod, bps, _q->header_sym_len,\n                        &num_written);\n    return LIQUID_OK;\n}\nint ofdmflexframegen_assemble(ofdmflexframegen      _q,\n                              const unsigned char * _header,\n                              const unsigned char * _payload,\n                              unsigned int          _payload_len)\n{\n    ofdmflexframegen_reset(_q);\n    if (_payload_len != _q->payload_dec_len) {\n        _q->payload_dec_len = _payload_len;\n        ofdmflexframegen_reconfigure(_q);\n    }\n    _q->frame_assembled = 1;\n    if (_header == NULL)\n        memset(_q->header, 0x00, _q->header_user_len*sizeof(unsigned char));\n    else\n        memmove(_q->header, _header, _q->header_user_len*sizeof(unsigned char));\n    ofdmflexframegen_encode_header(_q);\n    ofdmflexframegen_modulate_header(_q);\n    packetizer_encode(_q->p_payload, _payload, _q->payload_enc);\n    memset(_q->payload_mod, 0x00, _q->payload_mod_len);\n    unsigned int bps = modulation_types[_q->props.mod_scheme].bps;\n    unsigned int num_written;\n    liquid_repack_bytes(_q->payload_enc,  8,  _q->payload_enc_len,\n                        _q->payload_mod, bps, _q->payload_mod_len,\n                        &num_written);\n#if DEBUG_OFDMFLEXFRAMEGEN\n    printf(""wrote %u symbols (expected %u)\\n"", num_written, _q->payload_mod_len);\n#endif\n    return LIQUID_OK;\n}\n//...')
"
('Prompt: Imagine you have a 1D search algorithm implemented using a QuickSearch algorithm (qs1dsearch). How would you design a function that returns the number of steps (num_steps) taken by the search algorithm?,"//...\nunsigned int qs1dsearch_get_num_steps(qs1dsearch _q)\n{\n    return _q->num_steps;\n}\n//...')
"
"('Prompt: Please write a function in C that conducts a frequency test on a numerically controlled oscillator (NCO). The function should take in parameters such as the type of NCO, initial phase, target frequency, an array of complex sine and cosine values, the number of samples to test, and a tolerance value. The function should initialize the NCO, set its phase and frequency according to the input parameters, then iterate over the samples comparing the generated complex output with the input values within the specified tolerance. If the test passes, the NCO is stepped forward. If not, the test fails. Finally, the NCO is destroyed before exiting the function.","//...\nvoid nco_crcf_frequency_test(int             _type,\n                             float           _phase,\n                             float           _frequency,\n                             float complex * _sincos,\n                             unsigned int    _num_samples,\n                             float           _tol)\n{\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase(nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    unsigned int i;\n    for (i=0; i<_num_samples; i++) {\n        float complex y_test;\n        nco_crcf_cexpf(nco, &y_test);\n        float complex y = _sincos[i];\n        CONTEND_DELTA( crealf(y_test), crealf(y), _tol );\n        CONTEND_DELTA( cimagf(y_test), cimagf(y), _tol );\n        nco_crcf_step(nco);\n    }\n    nco_crcf_destroy(nco);\n}\n//...')
"
"'Prompt: You are working on a project where you need to configure the Supply Controller (SUPC) on a microcontroller to select an external 32KHz crystal, disable voltage regulation, configure supply monitoring, enable/disable brownout detection with reset, back up SRAM in low power mode, bypass the external crystal oscillator, set up wakeup modes and debounce periods, and enable/disable wakeup inputs. Additionally, you need to check if the slow clock is sourced from the external crystal and read the status register of the SUPC. Can you provide the code to implement these functions in C?","void SUPC_SelectExtCrystal32K(void)\n{\n\tPMC_EnableXT32KFME();\n\tif ((SUPC->SUPC_SR & SUPC_SR_OSCSEL) != SUPC_SR_OSCSEL_CRYST) {\n\t\tSUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL_CRYSTAL_SEL;\n\t\twhile (!(SUPC->SUPC_SR & SUPC_SR_OSCSEL));\n\t}\n}\nvoid SUPC_DisableVoltageReg(void)\n{\n\tSUPC->SUPC_CR |= SUPC_CR_KEY_PASSWD | SUPC_CR_VROFF;\n}\nvoid SUPC_ConfigSupplyMonitor(uint32_t Config)\n{\n\tSUPC->SUPC_SMMR = Config;\n}\nvoid SUPC_DisableSupplyMonitor(void)\n{\n\tSUPC->SUPC_SMMR = SUPC_SMMR_SMSMPL_SMD;\n}\nvoid SUPC_BrownoutDetectEnable(uint8_t enable)\n{\n\tif (enable)\n\t\tSUPC->SUPC_MR = (SUPC_MR_BODDIS_ENABLE | SUPC_MR_KEY_PASSWD);\n\telse\n\t\tSUPC->SUPC_MR = (SUPC_MR_BODDIS_DISABLE | SUPC_MR_KEY_PASSWD);\n}\nvoid SUPC_BrownoutResetEnable(void)\n{\n\tSUPC->SUPC_MR = (SUPC_MR_BODRSTEN_ENABLE | SUPC_MR_KEY_PASSWD);\n}\nvoid SUPC_SramBackupMode(uint8_t enable)\n{\n\tif (enable)\n\t\tSUPC->SUPC_MR = ((1 << 17) | SUPC_MR_KEY_PASSWD);\n\telse\n\t\tSUPC->SUPC_MR = ((0 << 17) | SUPC_MR_KEY_PASSWD);\n}\nvoid SUPC_BypassXtal32KOsc(void)\n{\n\tSUPC->SUPC_MR = (SUPC_MR_OSCBYPASS_BYPASS | SUPC_MR_KEY_PASSWD);\n}\nvoid SUPC_EnablesWakeupMode(uint32_t Regs, uint8_t enable)\n{\n\tif (enable)\n\t\tSUPC->SUPC_WUMR |= Regs;\n\telse\n\t\tSUPC->SUPC_WUMR &= ~(uint32_t)Regs;\n}\nvoid SUPC_SetWakeupDebounce(uint8_t period)\n{\n\tSUPC->SUPC_WUMR |= ((period << SUPC_WUMR_WKUPDBC_Pos) & SUPC_WUMR_WKUPDBC_Msk);\n}\nvoid SUPC_SetLowPowerDebounce(uint8_t period)\n{\n\tSUPC->SUPC_WUMR |= ((period << SUPC_WUMR_LPDBC_Pos) & SUPC_WUMR_LPDBC_Msk);\n}\nvoid SUPC_EnablesWakeupInput(uint32_t Input, uint8_t enable)\n{\n\tif (enable)\n\t\tSUPC->SUPC_WUIR |= Input;\n\telse\n\t\tSUPC->SUPC_WUIR &= ~(uint32_t)Input;\n}\nuint8_t SUPC_IsSlowClkExtCrystal32K(void)\n{\n\treturn ((SUPC->SUPC_SR & SUPC_SR_OSCSEL) >> 7);\n}\nuint8_t SUPC_Read_Status(uint32_t status)\n{\n\treturn (SUPC->SUPC_SR & status);\n}'"
"('Prompt: ""I am working on designing a digital signal processing system to implement a decimation filter with a decimation factor of 4. I have defined the impulse response coefficients of the filter (M=13) in an array named \'firdecim_rrrf_data_M4h13x40_h\'. I also have a sequence of input samples in an array named \'firdecim_rrrf_data_M4h13x40_x\'. Could you provide me with the output samples after passing the input through the filter, which are stored in the array \'firdecim_rrrf_data_M4h13x40_y\'?""","float firdecim_rrrf_data_M4h13x40_h[] = {\n   -0.050178519704,\n    0.099634819705,\n    0.087767256514,\n    0.031474342328,\n   -0.161835107291,\n    0.031896126939,\n   -0.240761793751,\n   -0.044460468897,\n    0.019656280155,\n    0.150308997913,\n   -0.145260671043,\n    0.044691633752,\n   -0.228340355042};\nfloat firdecim_rrrf_data_M4h13x40_x[] = {\n   -0.006034368030,\n   -0.171592529075,\n   -0.063780807965,\n    0.013676314399,\n    0.116628260211,\n    0.119863895134,\n    0.111602959230,\n    0.130154286756,\n    0.038035316610,\n    0.059453633879,\n   -0.109240225614,\n    0.077742393809,\n   -0.021666946122,\n    0.067622802572,\n   -0.058137116614,\n   -0.069171140610,\n    0.067330056503,\n    0.087258333681,\n    0.042012179512,\n   -0.025556605587,\n   -0.111286144010,\n   -0.040760608600,\n    0.127330790275,\n    0.033399307914,\n   -0.005634951089,\n    0.043243872564,\n    0.038979737383,\n   -0.045742865035,\n   -0.193432344744,\n   -0.020574800494,\n   -0.065306698326,\n   -0.101479446471,\n   -0.016230721248,\n    0.000392179194,\n   -0.065936759641,\n    0.032965659365,\n    0.057788436776,\n   -0.268236198963,\n   -0.077821704788,\n   -0.125842807499};\nfloat firdecim_rrrf_data_M4h13x40_y[] = {\n    0.000302795655,\n   -0.014511652270,\n    0.029055193091,\n   -0.025764218622,\n   -0.000775391175,\n    0.028459415706,\n    0.024044484393,\n   -0.040542156850,\n    0.012864586577,\n   -0.002482554609};')
"
"'Prompt: You need to implement a ROM API for a flash memory driver in a bootloader. The API should include functions for initializing, programming, reading, erasing, updating LUT, and waiting for busy status of a FlexSPI NOR flash memory. The bootloader should have a function to run the bootloader and use the ROM API functions for flash memory operations. Additionally, the API should support features like getting config, erasing all, erasing sector, and erasing block. . . Response: . ```c. #ifndef FSL_COMPONENT_ID. #define FSL_COMPONENT_ID ""driver.romapi"". #endif. . typedef status_t (*clearCacheCommand_t)(uint32_t instance);. . typedef union _standard_version. {.     struct.     {.         uint8_t bugfix; .         uint8_t minor;  .         uint8_t major;  .         char name;      .     };.     uint32_t version; . . #if defined(__cplusplus).     StandardVersion() : version(0).     {.    ","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""driver.romapi""\n#endif\ntypedef status_t (*clearCacheCommand_t)(uint32_t instance);\ntypedef union _standard_version\n{\n    struct\n    {\n        uint8_t bugfix; \n        uint8_t minor;  \n        uint8_t major;  \n        char name;      \n    };\n    uint32_t version; \n#if defined(__cplusplus)\n    StandardVersion() : version(0)\n    {\n    }\n    StandardVersion(uint32_t version) : version(version)\n    {\n    }\n#endif\n} standard_version_t;\ntypedef struct\n{\n    uint32_t version;\n    status_t (*init)(uint32_t instance, flexspi_nor_config_t *config);\n    status_t (*page_program)(uint32_t instance, flexspi_nor_config_t *config, uint32_t dst_addr, const uint32_t *src);\n    status_t (*erase_all)(uint32_t instance, flexspi_nor_config_t *config);\n    status_t (*erase)(uint32_t instance, flexspi_nor_config_t *config, uint32_t start, uint32_t length);\n    status_t (*read)(uint32_t instance, flexspi_nor_config_t *config, uint32_t *dst, uint32_t start, uint32_t bytes);\n    void (*clear_cache)(uint32_t instance);\n    status_t (*xfer)(uint32_t instance, flexspi_xfer_t *xfer);\n    status_t (*update_lut)(uint32_t instance, uint32_t seqIndex, const uint32_t *lutBase, uint32_t numberOfSeq);\n    status_t (*get_config)(uint32_t instance, flexspi_nor_config_t *config, serial_nor_config_option_t *option);\n    status_t (*erase_sector)(uint32_t instance, flexspi_nor_config_t *config, uint32_t address);\n    status_t (*erase_block)(uint32_t instance, flexspi_nor_config_t *config, uint32_t address);\n    const uint32_t reserved0; \n    status_t (*wait_busy)(uint32_t instance, flexspi_nor_config_t *config, bool isParallelMode, uint32_t address);\n    const uint32_t reserved1[2]; \n} flexspi_nor_driver_interface_t;\ntypedef struct\n{\n    void (*runBootloader)(void *arg);                       \n    standard_version_t version;                             \n    const char *copyright;                                  \n    const flexspi_nor_driver_interface_t *flexSpiNorDriver; \n    const uint32_t reserved[8];                             \n} bootloader_api_entry_t;\n#if defined(FSL_FEATURE_BOOT_ROM_HAS_ROMAPI) && FSL_FEATURE_BOOT_ROM_HAS_ROMAPI\n#define g_bootloaderTree ((bootloader_api_entry_t *)*(uint32_t *)0x0021001cU)\n#if defined(FSL_ROM_HAS_RUNBOOTLOADER_API) && FSL_ROM_HAS_RUNBOOTLOADER_API\nvoid ROM_RunBootloader(void *arg)\n{\n    g_bootloaderTree->runBootloader(arg);\n}\n#endif \n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_GET_CONFIG) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_GET_CONFIG\nstatus_t ROM_FLEXSPI_NorFlash_GetConfig(uint32_t instance,\n                                        flexspi_nor_config_t *config,\n                                        serial_nor_config_option_t *option)\n{\n    return g_bootloaderTree->flexSpiNorDriver->get_config(instance, config, option);\n}\n#endif \nstatus_t ROM_FLEXSPI_NorFlash_Init(uint32_t instance, flexspi_nor_config_t *config)\n{\n    return g_bootloaderTree->flexSpiNorDriver->init(instance, config);\n}\nstatus_t ROM_FLEXSPI_NorFlash_ProgramPage(uint32_t instance,\n                                          flexspi_nor_config_t *config,\n                                          uint32_t dst_addr,\n                                          const uint32_t *src)\n{\n    return g_bootloaderTree->flexSpiNorDriver->page_program(instance, config, dst_addr, src);\n}\n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_READ) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_READ\nstatus_t ROM_FLEXSPI_NorFlash_Read(\n    uint32_t instance, flexspi_nor_config_t *config, uint32_t *dst, uint32_t start, uint32_t lengthInBytes)\n{\n    return g_bootloaderTree->flexSpiNorDriver->read(instance, config, dst, start, lengthInBytes);\n}\n#endif \nstatus_t ROM_FLEXSPI_NorFlash_Erase(uint32_t instance, flexspi_nor_config_t *config, uint32_t start, uint32_t length)\n{\n    return g_bootloaderTree->flexSpiNorDriver->erase(instance, config, start, length);\n}\n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_ERASE_SECTOR) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_ERASE_SECTOR\nstatus_t ROM_FLEXSPI_NorFlash_EraseSector(uint32_t instance, flexspi_nor_config_t *config, uint32_t start)\n{\n    return g_bootloaderTree->flexSpiNorDriver->erase_sector(instance, config, start);\n}\n#endif \n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_ERASE_BLOCK) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_ERASE_BLOCK\nstatus_t ROM_FLEXSPI_NorFlash_EraseBlock(uint32_t instance, flexspi_nor_config_t *config, uint32_t start)\n{\n    return g_bootloaderTree->flexSpiNorDriver->erase_block(instance, config, start);\n}\n#endif \n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_ERASE_ALL) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_ERASE_ALL\nstatus_t ROM_FLEXSPI_NorFlash_EraseAll(uint32_t instance, flexspi_nor_config_t *config)\n{\n    return g_bootloaderTree->flexSpiNorDriver->erase_all(instance, config);\n}\n#endif \n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_CMD_XFER) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_CMD_XFER\nstatus_t ROM_FLEXSPI_NorFlash_CommandXfer(uint32_t instance, flexspi_xfer_t *xfer)\n{\n    return g_bootloaderTree->flexSpiNorDriver->xfer(instance, xfer);\n}\n#endif \n#if defined(FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_UPDATE_LUT) && FSL_ROM_FLEXSPINOR_API_HAS_FEATURE_UPDATE_LUT\nstatus_t ROM_FLEXSPI_NorFlash_UpdateLut(uint32_t instance,\n                                        uint32_t seqIndex,\n                                        const uint32_t *lutBase,\n                                        uint32_t seqNumber)\n{\n    return g_bootloaderTree->flexSpiNorDriver->update_lut(instance, seqIndex, lutBase, seqNumber);\n}\n#endif \nvoid ROM_FLEXSPI_NorFlash_ClearCache(uint32_t instance)\n{\n    uint32_t clearCacheFunctionAddress = 0x0021a3b7U;\n    clearCacheCommand_t clearCacheCommand;\n    MISRA_CAST(clearCacheCommand_t, clearCacheCommand, uint32_t, clearCacheFunctionAddress);\n    (void)clearCacheCommand(instance);\n}\nstatus_t ROM_FLEXSPI_NorFlash_WaitBusy(uint32_t instance,\n                                       flexspi_nor_config_t *config,\n                                       bool isParallelMode,\n                                       uint32_t address)\n{\n    return g_bootloaderTree->flexSpiNorDriver->wait_busy(instance, config, isParallelMode, address);\n}\n#endif '"
"'Give me a code that includes a thread function called `keep_alive` that runs an infinite loop with a 30-second sleep inside it. Additionally, include a function called `recv_msg` that receives data from a socket connection and prints out the received message along with the source and destination IP addresses and port numbers. Make sure to handle any potential errors that may occur during the socket communication.","//...\n    int fd = tmp->fd;\n    char *ip = tmp->ip;\n#define MAX_EPOLL_EVENT 16\n    char buf[1024] = {0};\n    int ret, i;\n#define MAX_EPOLL_EVENT 16\nstatic void *keep_alive(void *args)\n{\n    while (1) {\n        sleep(30);\n    }\n    return NULL;\n}\nstatic void recv_msg(int fd)\n{\n    int ret;\n    char buf[1024] = {0};\n#if 0\n    ret = recv(fd, buf, sizeof(buf), 0);\n    if (ret == -1) {\n        printf(""%s:%d: errno = %d: %s\\n"", __func__, __LINE__, errno, strerror(errno));\n    }\n#endif\n    struct sockaddr_in si, si2;\n    socklen_t si_len = sizeof(si);\n    memset(&si, 0, sizeof(si));\n    memset(&si2, 0, sizeof(si));\n    ret = recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr *)&si, &si_len);\n    if (ret == -1) {\n        printf(""%s:%d: errno = %d: %s\\n"", __func__, __LINE__, errno, strerror(errno));\n    }\n    if (-1 == getsockname(fd, (struct sockaddr *)&si2, &si_len)) {\n        perror(""getsockname failed!\\n"");\n    }\n    printf(""\\nrecv from ip = %s port = %d to ip = %s port = %d msg > %s\\n"", inet_ntoa(si.sin_addr), ntohs(si.sin_port), inet_ntoa(si2.sin_addr), ntohs(si2.sin_port), buf);\n}\n//...'"
"('Prompt: ""You need a function in C that calculates the sum of squares of an array of floats. The function should be optimized for performance using AVX instructions. Can you write this function for me, considering that AVX-512 instructions are available for use?""","//...\nfloat liquid_sumsqf_avxu(float *      _v,\n                         unsigned int _n)\n{\n    __m512 v0, v1, v2, v3;   \n    __m512 s0, s1, s2, s3;   \n    __m512 sum = _mm512_setzero_ps(); \n    unsigned int t = (_n >> 6) << 4;\n    unsigned int i;\n    for (i=0; i<t; i+=16) {\n        v0 = _mm512_loadu_ps(&_v[4*i+ 0]);\n        v1 = _mm512_loadu_ps(&_v[4*i+16]);\n        v2 = _mm512_loadu_ps(&_v[4*i+32]);\n        v3 = _mm512_loadu_ps(&_v[4*i+48]);\n        s0 = _mm512_mul_ps(v0, v0);\n        s1 = _mm512_mul_ps(v1, v1);\n        s2 = _mm512_mul_ps(v2, v2);\n        s3 = _mm512_mul_ps(v3, v3);\n        sum = _mm512_add_ps( sum, s0 );\n        sum = _mm512_add_ps( sum, s1 );\n        sum = _mm512_add_ps( sum, s2 );\n        sum = _mm512_add_ps( sum, s3 );\n    }\n    float total = _mm512_reduce_add_ps(sum);\n    for (i=4*t; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf_avx(float *      _v,\n                        unsigned int _n)\n{\n    __m512 v;   \n    __m512 s;   \n    __m512 sum = _mm512_setzero_ps(); \n    unsigned int t = (_n >> 4) << 4;\n    unsigned int i;\n    for (i=0; i<t; i+=16) {\n        v = _mm512_loadu_ps(&_v[i]);\n        s = _mm512_mul_ps(v, v);\n        sum = _mm512_add_ps( sum, s );\n    }\n    float total = _mm512_reduce_add_ps(sum);\n    for (; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    if (_n < 64) {\n        return liquid_sumsqf_avx(_v, _n);\n    }\n    return liquid_sumsqf_avxu(_v, _n);\n}\nfloat liquid_sumsqf_avx(float *      _v,\n                        unsigned int _n)\n{\n    __m512 v;   \n    __m512 s;   \n    __m512 sum = _mm512_setzero_ps(); \n    unsigned int t = (_n >> 4) << 4;\n    unsigned int i;\n    for (i=0; i<t; i+=16) {\n        v = _mm512_loadu_ps(&_v[i]);\n        s = _mm512_mul_ps(v, v);\n        sum = _mm512_add_ps( sum, s );\n    }\n    float total = _mm512_reduce_add_ps(sum);\n    for (; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\n//...')
"
"('Prompt: You are working on a software implementation of a digital communication system that includes a Gaussian Minimum Shift Keying (GMSK) modulation module. Please provide a function that destroys the GMSK modulation module instance, including cleaning up any resources allocated during its creation. The function should deallocates memory for the interpolator and filter coefficients, and finally free the GMSK modulator instance itself.","//...\nint gmskmod_destroy(gmskmod _q)\n{\n    firinterp_rrrf_destroy(_q->interp_tx);\n    free(_q->h);\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: ""I need a function that performs a benchmarking test with a specified number of iterations, utilizing the getrusage function to measure resource usage before and after the test. The function should take in pointers to structs rusage for start and finish times, as well as a pointer to an unsigned long int for the number of iterations. The function should multiply the number of iterations by 100, then perform a series of bitwise operations on a variable x within a loop based on the number of iterations. Finally, the function should check a condition based on the final value of x and increment the number of iterations accordingly. Can you provide me with such a function?""","void benchmark_null(struct rusage *_start,\n                    struct rusage *_finish,\n                    unsigned long int *_num_iterations)\n{\n    unsigned long int i;\n    *_num_iterations *= 100;\n    getrusage(RUSAGE_SELF, _start);\n    unsigned int x = 0;\n    for (i=0; i<*_num_iterations; i++) {\n        x <<= 1;\n        x |= 1;\n        x &= 0xff;\n        x ^= 0xff;\n    }\n    *_num_iterations += (x & 0x1234) ? 0 : 1;\n    getrusage(RUSAGE_SELF, _finish);\n}')
"
"('Prompt: . You are developing a digital signal processing application that involves filtering a signal using a finite impulse response (FIR) filter with a raised cosine Nyquist prototype. You need to implement a testbench function that performs various calculations and comparisons to evaluate the filter performance. The testbench function should take parameters such as filter type, filter length, symbol rate, beta value, and sampling interval. The function should calculate metrics like autocorrelation peak, root mean square (RMS) intersymbol interference (ISI), and stopband attenuation. After performing the calculations, the function should output the results along with expected values for some of the metrics. Can you provide a code snippet for this testbench function implementing the required functionality?. . Response: . ```c. void testbench_firfilt_rnyquist(int          _ftype,.                                 unsigned int _k,    .                                 unsigned int _m,    .                                 float        _beta, .                                 float        _dt)   . {.     unsigned int i;. ","//...\nvoid testbench_firfilt_rnyquist(int          _ftype,\n                                unsigned int _k,    \n                                unsigned int _m,    \n                                float        _beta, \n                                float        _dt)   \n{\n    unsigned int i;\n    unsigned int h_len  = 2*_k*_m+1;  \n    unsigned int hc_len = 4*_k*_m+1;  \n    float ht[h_len];    \n    float hr[h_len];    \n    float hc[hc_len];   \n    liquid_firdes_prototype(_ftype, _k, _m, _beta, _dt, ht);\n    if (_ftype == LIQUID_FIRFILT_GMSKTX)\n        liquid_firdes_prototype(LIQUID_FIRFILT_GMSKRX, _k, _m, _beta, _dt, hr);\n    else\n        memcpy(hr, ht, h_len*sizeof(float));\n    for (i=0; i<hc_len; i++) {\n        int lag = (int)i - (int)(2*_k*_m);\n        hc[i] = liquid_filter_crosscorr(ht,h_len, hr,h_len, lag);\n    }\n    float rxx0 = hc[2*_k*_m];\n    float isi_rms=0;\n    for (i=1; i<2*_m; i++) {\n        float e = hc[i*_k] / rxx0;  \n        isi_rms += e*e;             \n    }\n    isi_rms = 10.0f*log10f( isi_rms / (float)(2*_m-1) );\n    unsigned int nfft = 2048;\n    float As = 20*log10f( liquid_filter_energy(ht, h_len, 0.5f*(1.0f + _beta)/(float)_k, nfft) );\n    if (liquid_autotest_verbose) {\n        printf(""ftype: %s, k: %u, m: %u, beta: %.3f, dt: %.3f\\n"",\n            liquid_firfilt_type_str[_ftype][0], _k, _m, _beta, _dt);\n#if 0\n        for (i=0; i<h_len; i++)\n            printf(""  %3d: ht = %12.8f, hr = %12.8f\\n"", (int)i - 2*(int)_m, ht[i], hr[i]);\n        printf(""composite:\\n"");\n        for (i=0; i<hc_len; i++)\n            printf(""  %3d: hc = %12.8f%s\\n"", (int)i - 4*(int)_m, hc[i], i%_k ? """" : "" *"");\n#endif\n        printf(""  rxx[0]    : %12.8f (expected %u)\\n"", rxx0, _k);\n        printf(""  isi (rms) : %12.8f dB\\n"", isi_rms);\n        printf(""  As        : %12.8f dB\\n"", As);\n    }\n    CONTEND_DELTA    ( rxx0,   (float)_k, 0.01f );\n    CONTEND_LESS_THAN( isi_rms, -50.0f );\n    CONTEND_LESS_THAN( As,      -50.0f );\n}\nvoid autotest_firfilt_rnyquist_0(){ testbench_firfilt_rnyquist(LIQUID_FIRFILT_ARKAISER, 2, 4,0.33f,0.0f); }\n//...')
"
('Prompt: You are working on testing a function `liquid_besselif` that calculates Bessel functions. Please write a series of test cases with expected values using a tolerance of 1e-3. Each test case should test the function with different input values for two parameters and verify the output against expected values within the defined tolerance.,"//...\nvoid autotest_besselif()\n{\n    float tol = 1e-3f;\n    CONTEND_DELTA(liquid_besselif(0.0f,0.0f), 1.0f, tol);\n    CONTEND_DELTA(liquid_besselif(0.0f,0.1f), 1.00250156293410f, tol);\n    CONTEND_DELTA(liquid_besselif(0.0f,0.2f), 1.01002502779515f, tol);\n    CONTEND_DELTA(liquid_besselif(0.0f,0.5f), 1.06348337074132f, tol);\n    CONTEND_DELTA(liquid_besselif(0.0f,1.0f), 1.26606587775201f, tol);\n    CONTEND_DELTA(liquid_besselif(0.0f,2.0f), 2.27958530233607f, tol);\n    CONTEND_DELTA(liquid_besselif(0.0f,3.0f), 4.88079258586503f, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,0.0f), 0.000000000000000, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,0.1f), 0.252733984600132, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,0.2f), 0.359208417583362, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,0.5f), 0.587993086790417, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,1.0f), 0.937674888245489, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,2.0f), 2.046236863089057, tol);\n    CONTEND_DELTA(liquid_besselif(0.5f,3.0f), 4.614822903407577, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,0.0f), 0.000000000000000, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,0.1f), 0.017465030873157, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,0.2f), 0.043144293848607, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,0.5f), 0.145248507279042, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,1.0f), 0.387392350983796, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,2.0f), 1.290819215135879, tol);\n    CONTEND_DELTA(liquid_besselif(1.3f,3.0f), 3.450680420553085, tol);\n}\n//...')
"
"('Prompt: You are tasked with creating an automated test function for a digital communication system. The test involves using a DC blocking filter to create a notch filter. The test function should initialize the required parameters such as filter length, stopband attenuation, and FFT size. It should then generate a notch filter using the liquid_firdes_notch function, apply the filter to a time-domain complex buffer, and perform an FFT to obtain a frequency domain representation. The test function should verify that the frequency response of the filter meets certain specifications by checking the magnitude response at specific frequency points. Kindly provide the code for this automated test function.","//...\nvoid autotest_liquid_firdes_dcblock()\n{\n    unsigned int m   = 20;      \n    float        as  = 60.0f;   \n    unsigned int h_len = 2*m+1;\n    float h[h_len];\n    liquid_firdes_notch(m,0,as,h);\n    unsigned int  nfft = 1200;\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    unsigned int i;\n    for (i=0; i<nfft; i++)\n        buf_time[i] = i < h_len ? h[i] : 0;\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    float tol = 2*powf(10.0f, -as/20.0f); \n    CONTEND_DELTA(cabsf(buf_freq[       0]), 0.0f, tol);   \n    CONTEND_DELTA(cabsf(buf_freq[  nfft/4]), 1.0f, tol);   \n    CONTEND_DELTA(cabsf(buf_freq[2*nfft/4]), 1.0f, tol);   \n    CONTEND_DELTA(cabsf(buf_freq[3*nfft/4]), 1.0f, tol);   \n}\n//...')
"
('Please provide the prompt where you need assistance with testing a set of liquid firdes configurations and validating the expected outcomes with specific input parameters for various functions in the code snippet provided.,"//...\nvoid autotest_liquid_firdes_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping firdes config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_EQUALITY( estimate_req_filter_len(-0.1f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len( 0.0f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len( 0.6f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len( 0.2f, -1.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len( 0.2f,  0.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Kaiser(-0.1f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Kaiser( 0.0f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Kaiser( 0.6f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Kaiser( 0.2f, -1.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Kaiser( 0.2f,  0.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Herrmann(-0.1f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Herrmann( 0.0f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Herrmann( 0.6f, 60.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Herrmann( 0.2f, -1.0f), 0 ); \n    CONTEND_EQUALITY( estimate_req_filter_len_Herrmann( 0.2f,  0.0f), 0 ); \n    unsigned int m     =  4;\n    unsigned int h_len = 2*m+1;\n    float        h[h_len];\n    int          wtype = LIQUID_WINDOW_HAMMING;\n    CONTEND_EQUALITY(liquid_firdes_windowf(wtype, h_len, 0.2f, 0, h), LIQUID_OK      );\n    CONTEND_EQUALITY(liquid_firdes_windowf(wtype,     0, 0.2f, 0, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_windowf(wtype, h_len,-0.1f, 0, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_windowf(wtype, h_len, 0.0f, 0, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_windowf(wtype, h_len, 0.6f, 0, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_kaiser(h_len, 0.2f, 60.0f, 0.0f, h), LIQUID_OK      );\n    CONTEND_EQUALITY(liquid_firdes_kaiser(    0, 0.2f, 60.0f, 0.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_kaiser(h_len,-0.1f, 60.0f, 0.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_kaiser(h_len, 0.0f, 60.0f, 0.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_kaiser(h_len, 0.6f, 60.0f, 0.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_kaiser(h_len, 0.2f, 60.0f,-0.7f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_kaiser(h_len, 0.2f, 60.0f, 0.7f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_notch(m, 0.2f, 60.0f, h), LIQUID_OK);\n    CONTEND_EQUALITY(liquid_firdes_notch(0, 0.2f, 60.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_notch(m,-0.7f, 60.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_notch(m, 0.7f, 60.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_notch(m, 0.2f, -8.0f, h), LIQUID_EICONFIG);\n    CONTEND_EQUALITY(liquid_firdes_prototype(LIQUID_FIRFILT_UNKNOWN,2,2,0.3f,0.0f,h),LIQUID_EICONFIG);\n    liquid_firdes_windowf(wtype, h_len, 0.2f, 0, h);\n    CONTEND_EQUALITY(liquid_filter_energy(h,h_len,-0.1f,1200), 0.0f);\n    CONTEND_EQUALITY(liquid_filter_energy(h,h_len, 0.7f,1200), 0.0f);\n    CONTEND_EQUALITY(liquid_filter_energy(h,h_len, 0.3f,   0), 0.0f);\n    CONTEND_EQUALITY( liquid_getopt_str2firfilt(""unknown-filter-type"" ), LIQUID_FIRFILT_UNKNOWN);\n}\n//...')
"
('Please provide a prompt detailing a technical scenario where you would like to test a function that performs dot product calculations between complex vectors using random input data with a specific set of complex numbers and expect a specified tolerance for the results.,"//...\nvoid autotest_dotprod_crcf_rand01()\n{\n    float h[16] = {\n      5.5375e-02,  -6.5857e-01,  -1.7657e+00,   7.7444e-01, \n      8.0730e-01,  -5.1340e-01,  -9.3437e-02,  -5.6301e-01, \n     -6.6480e-01,  -2.1673e+00,   9.0269e-01,   3.5284e+00, \n     -9.7835e-01,  -6.9512e-01,  -1.2958e+00,   1.1628e+00\n    };\n    float complex x[16] = {\n      1.3164e+00+  5.4161e-01*_Complex_I,   1.8295e-01+ -9.0284e-02*_Complex_I, \n      1.3487e+00+ -1.8148e+00*_Complex_I,  -7.4696e-01+ -4.1792e-01*_Complex_I, \n     -9.0551e-01+ -4.4294e-01*_Complex_I,   6.0591e-01+ -1.5383e+00*_Complex_I, \n     -7.5393e-01+ -3.5691e-01*_Complex_I,  -4.5733e-01+  1.1926e-01*_Complex_I, \n     -1.4744e-01+ -4.7676e-02*_Complex_I,  -1.2422e+00+ -2.0213e+00*_Complex_I, \n      3.3208e-02+ -1.3756e+00*_Complex_I,  -4.8573e-01+  1.0977e+00*_Complex_I, \n      1.5053e+00+  2.1141e-01*_Complex_I,  -8.4062e-01+ -1.0211e+00*_Complex_I, \n     -1.3932e+00+ -4.8491e-01*_Complex_I,  -1.4234e+00+  2.0333e-01*_Complex_I\n    };\n    float complex y;\n    float complex test     = -3.35346556487224 + 11.78023318618137*_Complex_I;\n    float complex test_rev =  3.655541203500000 + 4.26531912591000*_Complex_I;\n    float tol = 1e-3f;\n    dotprod_crcf_run(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_run4(h,x,16,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf q = dotprod_crcf_create(h,16);\n    dotprod_crcf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    q = dotprod_crcf_recreate_rev(q,h,16);\n    dotprod_crcf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test_rev), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test_rev), tol);\n    q = dotprod_crcf_recreate(q,h,16);\n    dotprod_crcf_execute(q,x,&y);\n    CONTEND_DELTA( crealf(y), crealf(test), tol);\n    CONTEND_DELTA( cimagf(y), cimagf(test), tol);\n    dotprod_crcf_destroy(q);\n}\n//...')
"
"('Prompt: You are working on a project that involves modulating signals using a modem in C. You need a function that takes a modem object, an unsigned integer and a pointer to a complex float array as parameters, and returns the result of modulating the signal using the given modem object. Can you provide me with a code snippet that fulfills this requirement?","//...\nint modem_modulate(modem _q, unsigned int _s, float complex * _y)\n    { return modemcf_modulate(_q, _s, _y); }\n//...')
"
"'Prompt: ""You have a project where you need to create two objects with shadows on a graphical user interface. Please provide a code snippet that demonstrates how to create two objects with shadows using the LittlevGL library. The objects should be aligned in the center of the screen, with one object positioned -60 pixels to the left and -30 pixels above the center, and the other object positioned 60 pixels to the right and 30 pixels below the center.""","#if LV_BUILD_EXAMPLES\nvoid lv_example_obj_1(void)\n{\n    lv_obj_t * obj1;\n    obj1 = lv_obj_create(lv_screen_active());\n    lv_obj_set_size(obj1, 100, 50);\n    lv_obj_align(obj1, LV_ALIGN_CENTER, -60, -30);\n    static lv_style_t style_shadow;\n    lv_style_init(&style_shadow);\n    lv_style_set_shadow_width(&style_shadow, 10);\n    lv_style_set_shadow_spread(&style_shadow, 5);\n    lv_style_set_shadow_color(&style_shadow, lv_palette_main(LV_PALETTE_BLUE));\n    lv_obj_t * obj2;\n    obj2 = lv_obj_create(lv_screen_active());\n    lv_obj_add_style(obj2, &style_shadow, 0);\n    lv_obj_align(obj2, LV_ALIGN_CENTER, 60, 30);\n}\n#endif'"
"('Prompt: ""You are designing a testbench to validate the functionality of a multi-stage resampler with a cascaded complex bandpass filter. The resampler has a decimation factor \'r\' and a stopband attenuation \'As\'. Design a C function that creates a test environment to validate the resampler\'s output. Your function should initialize the necessary parameters such as the number of samples, bandwidth, FFT size, and create the resampler instance. Furthermore, execute the resampler on generated complex samples and calculate the Power Spectral Density (PSD) using a spectral density estimator. Finally, validate the resulting PSD against predefined regions and save the test results in a logfile."". . Response: . . ```c. void testbench_msresamp_crcf(float r, float As). {.     unsigned int n=800000;.     float bw = 0.2f;.     unsigned int nfft = 800;.     float tol = 0.5f;.     spgramcf q   =","//...\nvoid testbench_msresamp_crcf(float r, float As)\n{\n    unsigned int n=800000;      \n    float bw = 0.2f; \n    unsigned int nfft = 800;\n    float tol = 0.5f;\n    spgramcf     q   = spgramcf_create(nfft, LIQUID_WINDOW_HANN, nfft/2, nfft/4);\n    symstreamrcf gen = symstreamrcf_create_linear(LIQUID_FIRFILT_KAISER,r*bw,25,0.2f,LIQUID_MODEM_QPSK);\n    symstreamrcf_set_gain(gen, sqrtf(bw));\n    msresamp_crcf resamp = msresamp_crcf_create(r,As);\n    unsigned int  buf_len = 256;\n    float complex buf_0[buf_len]; \n    float complex buf_1[buf_len]; \n    while (spgramcf_get_num_samples_total(q) < n) {\n        symstreamrcf_write_samples(gen, buf_0, buf_len);\n        unsigned int nw = 0;\n        msresamp_crcf_execute(resamp, buf_0, buf_len, buf_1, &nw);\n        spgramcf_write(q, buf_1, nw);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax= 0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-As+tol, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/msresamp_crcf_r%.3u_a%.2u_autotest.m"", (int)(r*1000), (int)(As));\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n    spgramcf_destroy(q);\n    symstreamrcf_destroy(gen);\n    msresamp_crcf_destroy(resamp);\n}\nvoid testbench_msresamp_crcf_num_output(float _rate)\n{\n    if (liquid_autotest_verbose)\n        printf(""testing msresamp_crcf_get_num_output() with r=%g\\n"", _rate);\n    float As = 60.0f;\n    msresamp_crcf q = msresamp_crcf_create(_rate, As);\n    unsigned int s = _rate < 0.1f ? 131 : 1; \n    unsigned int sizes[10] = {1*s, 2*s, 3*s, 20*s, 7*s, 64*s, 4*s, 4*s, 4*s, 27*s};\n    unsigned int max_input = 64*s;\n    unsigned int max_output = 16 + (unsigned int)(4.0f * max_input * _rate);\n    printf(""max_input : %u, max_output : %u\\n"", max_input, max_output);\n    float complex buf_0[max_input];\n    float complex buf_1[max_output];\n    unsigned int i;\n    for (i=0; i<max_input; i++)\n        buf_0[i] = 0.0f;\n    unsigned int b;\n    for (b=0; b<8; b++) {\n        for (i=0; i<10; i++) {\n            unsigned int num_input  = sizes[i];\n            unsigned int num_output = msresamp_crcf_get_num_output(q, num_input);\n            unsigned int num_written;\n            msresamp_crcf_execute(q, buf_0, num_input, buf_1, &num_written);\n            if (liquid_autotest_verbose) {\n                printf("" b[%2u][%2u], num_input:%5u, num_output:%5u, num_written:%5u\\n"",\n                        b, i, num_input, num_output, num_written);\n            }\n            CONTEND_EQUALITY(num_output, num_written)\n        }\n    }\n    msresamp_crcf_destroy(q);\n}\nvoid autotest_msresamp_crcf_num_output_6(){ testbench_msresamp_crcf_num_output(expf(8.0f)); }\n//...')
"
"'Please provide a prompt that involves initializing and setting up a Raspberry Pi SPI interface for bidirectional communication, including clock rate calculation, transfer mode setup, read/write operations, and event handling.","#define SPI_POLLING(condition)                  \\\n  while ( condition ) {                         \\\n    ;                                           \\\n  }\ntypedef struct\n{\n  int initialized;\n  uint8_t bytes_per_char;\n  uint8_t bit_shift;\n  uint32_t dummy_char;\n  uint32_t current_slave_addr;\n  rtems_id task_id;\n  int irq_write;\n} rpi_spi_softc_t;\ntypedef struct\n{\n  rtems_libi2c_bus_t bus_desc;\n  rpi_spi_softc_t softc;\n} rpi_spi_desc_t;\nstatic bool bidirectional = false;\nstatic rtems_status_code rpi_spi_calculate_clock_divider(\n  uint32_t clock_hz,\n  uint16_t *clock_divider\n) {\n  uint16_t divider;\n  uint32_t clock_rate;\n  assert( clock_hz > 0 );\n  divider = GPU_CORE_CLOCK_RATE / clock_hz;\n  --divider;\n  divider |= (divider >> 1);\n  divider |= (divider >> 2);\n  divider |= (divider >> 4);\n  divider |= (divider >> 8);\n  ++divider;\n  clock_rate = GPU_CORE_CLOCK_RATE / divider;\n  while ( clock_rate > clock_hz ) {\n    divider = (divider << 1);\n    clock_rate = GPU_CORE_CLOCK_RATE / divider;\n  }\n  *clock_divider = divider;\n  return RTEMS_SUCCESSFUL;\n}\nstatic rtems_status_code rpi_spi_set_tfr_mode(\n  rtems_libi2c_bus_t *bushdl,\n  const rtems_libi2c_tfr_mode_t *tfr_mode\n) {\n  rpi_spi_softc_t *softc_ptr = &(((rpi_spi_desc_t *)(bushdl))->softc);\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  uint16_t clock_divider;\n  softc_ptr->dummy_char = tfr_mode->idle_char;\n  sc = rpi_spi_calculate_clock_divider(tfr_mode->baudrate, &clock_divider);\n  if ( sc != RTEMS_SUCCESSFUL ) {\n    return sc;\n  }\n  BCM2835_REG(BCM2835_SPI_CLK) = clock_divider;\n  switch ( tfr_mode->bits_per_char ) {\n    case 8:\n    case 16:\n    case 24:\n    case 32:\n      softc_ptr->bytes_per_char = tfr_mode->bits_per_char / 8;\n      break;\n    default:\n      return RTEMS_INVALID_NUMBER;\n  }\n  if ( tfr_mode->lsb_first ) {\n    softc_ptr->bit_shift = 32 - tfr_mode->bits_per_char;\n  }\n  else {\n    softc_ptr->bit_shift = 0;\n  }\n  if ( tfr_mode->clock_inv ) {\n    BCM2835_REG(BCM2835_SPI_CS) &= ~(1 << 3);\n  }\n  else {\n    BCM2835_REG(BCM2835_SPI_CS) |= (1 << 3);\n  }\n  if ( tfr_mode->clock_phs ) {\n    BCM2835_REG(BCM2835_SPI_CS) |= (1 << 2);\n  }\n  else {\n    BCM2835_REG(BCM2835_SPI_CS) &= ~(1 << 2);\n  }\n  return sc;\n}\nstatic int rpi_spi_read_write(\n  rtems_libi2c_bus_t * bushdl,\n  unsigned char *rd_buf,\n  const unsigned char *wr_buf,\n  int buffer_size\n) {\n  rpi_spi_softc_t *softc_ptr = &(((rpi_spi_desc_t *)(bushdl))->softc);\n  uint8_t bytes_per_char = softc_ptr->bytes_per_char;\n  uint8_t bit_shift =  softc_ptr->bit_shift;\n  uint32_t dummy_char = softc_ptr->dummy_char;\n  uint32_t bytes_sent = buffer_size;\n  uint32_t fifo_data;\n  BCM2835_REG(BCM2835_SPI_CS) |= (3 << 4);\n  BCM2835_REG(BCM2835_SPI_CS) |= (1 << 7);\n#if SPI_IO_MODE == 1\n  softc_ptr->irq_write = 1;\n  BCM2835_REG(BCM2835_SPI_CS) |= (1 << 9);\n  if ( rtems_event_transient_receive(RTEMS_WAIT, 0) != RTEMS_SUCCESSFUL ) {\n    rtems_event_transient_clear();\n    return -1;\n  }\n#else\n  SPI_POLLING((BCM2835_REG(BCM2835_SPI_CS) & (1 << 18)) == 0);\n#endif\n  while ( buffer_size >= bytes_per_char ) {\n    if ( rd_buf != NULL ) {\n      BCM2835_REG(BCM2835_SPI_FIFO) = dummy_char;\n    }\n    else {\n      switch ( bytes_per_char ) {\n        case 1:\n          BCM2835_REG(BCM2835_SPI_FIFO) = (((*wr_buf) & 0xFF) << bit_shift);\n          break;\n        case 2:\n          BCM2835_REG(BCM2835_SPI_FIFO) = (((*wr_buf) & 0xFFFF) << bit_shift);\n          break;\n        case 3:\n          BCM2835_REG(BCM2835_SPI_FIFO) = (((*wr_buf) & 0xFFFFFF) << bit_shift);\n          break;\n        case 4:\n          BCM2835_REG(BCM2835_SPI_FIFO) = ((*wr_buf) << bit_shift);\n          break;\n        default:\n          return -1;\n      }\n      wr_buf += bytes_per_char;\n      buffer_size -= bytes_per_char;\n    }\n    if ( bidirectional ) {\n      BCM2835_REG(BCM2835_SPI_CS) |= (1 << 12);\n    }\n#if SPI_IO_MODE == 1\n    softc_ptr->irq_write = 0;\n    BCM2835_REG(BCM2835_SPI_CS) |= (1 << 9);\n    if ( rtems_event_transient_receive(RTEMS_WAIT, 0) != RTEMS_SUCCESSFUL ) {\n      rtems_event_transient_clear();\n      return -1;\n    }\n#else\n    SPI_POLLING((BCM2835_REG(BCM2835_SPI_CS) & (1 << 16)) == 0);\n    SPI_POLLING((BCM2835_REG(BCM2835_SPI_CS) & (1 << 17)) == 0);\n#endif\n    if ( rd_buf == NULL ) {\n      fifo_data = BCM2835_REG(BCM2835_SPI_FIFO) & 0xFF;\n    }\n    if ( rd_buf != NULL ) {\n      switch ( bytes_per_char ) {\n        case 1:\n          fifo_data = BCM2835_REG(BCM2835_SPI_FIFO) & 0xFF;\n          (*rd_buf) = (fifo_data >> bit_shift);\n          break;\n        case 2:\n          fifo_data = BCM2835_REG(BCM2835_SPI_FIFO) & 0xFFFF;\n          (*rd_buf) = (fifo_data >> bit_shift);\n          break;\n        case 3:\n          fifo_data = BCM2835_REG(BCM2835_SPI_FIFO) & 0xFFFFFF;\n          (*rd_buf) = (fifo_data >> bit_shift);\n          break;\n        case 4:\n          fifo_data = BCM2835_REG(BCM2835_SPI_FIFO);\n          (*rd_buf) = (fifo_data >> bit_shift);\n          break;\n        default:\n          return -1;\n      }\n      rd_buf += bytes_per_char;\n      buffer_size -= bytes_per_char;\n    }\n    if ( bidirectional ) {\n      BCM2835_REG(BCM2835_SPI_CS) &= ~(1 << 12);\n    }\n  }\n#if SPI_IO_MODE == 1\n  softc_ptr->irq_write = 1;\n  BCM2835_REG(BCM2835_SPI_CS) |= (1 << 9);\n  if ( rtems_event_transient_receive(RTEMS_WAIT, 0) != RTEMS_SUCCESSFUL ) {\n    rtems_event_transient_clear();\n    return -1;\n  }\n#else\n  SPI_POLLING((BCM2835_REG(BCM2835_SPI_CS) & (1 << 16)) == 0);\n#endif\n  bytes_sent -= buffer_size;\n  return bytes_sent;\n}\n#if SPI_IO_MODE == 1\nstatic void spi_handler(void* arg)\n{\n  rpi_spi_softc_t *softc_ptr = (rpi_spi_softc_t *) arg;\n  if (\n      ( softc_ptr->irq_write == 1 &&\n        (BCM2835_REG(BCM2835_SPI_CS) & (1 << 18)) != 0\n      ) ||\n      ( softc_ptr->irq_write == 0 &&\n        (BCM2835_REG(BCM2835_SPI_CS) & (1 << 17)) != 0\n      )\n  ) {\n    BCM2835_REG(BCM2835_SPI_CS) &= ~(1 << 9);\n    rtems_event_transient_send(softc_ptr->task_id);\n  }\n}\n#endif\nstatic rtems_status_code rpi_libi2c_spi_init(rtems_libi2c_bus_t * bushdl)\n{\n  rpi_spi_softc_t *softc_ptr = &(((rpi_spi_desc_t *)(bushdl))->softc);\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  if ( softc_ptr->initialized == 1 ) {\n    return sc;\n  }\n  softc_ptr->initialized = 1;\n#if SPI_IO_MODE == 1\n  softc_ptr->task_id = rtems_task_self();\n  sc = rtems_interrupt_handler_install(\n         BCM2835_IRQ_ID_SPI,\n         NULL,\n         RTEMS_INTERRUPT_UNIQUE,\n         (rtems_interrupt_handler) spi_handler,\n         softc_ptr\n       );\n#endif\n  return sc;\n}\nstatic rtems_status_code rpi_libi2c_spi_send_start(rtems_libi2c_bus_t * bushdl)\n{\n  return RTEMS_SUCCESSFUL;\n}\nstatic rtems_status_code rpi_libi2c_spi_stop(rtems_libi2c_bus_t * bushdl)\n{\n  rpi_spi_softc_t *softc_ptr = &(((rpi_spi_desc_t *)(bushdl))->softc);\n  uint32_t addr = softc_ptr->current_slave_addr;\n  uint32_t chip_select_bit = 21 + addr;\n  BCM2835_REG(BCM2835_SPI_CS) &= ~(1 << 7);\n  switch ( addr ) {\n    case 0:\n    case 1:\n      BCM2835_REG(BCM2835_SPI_CS) |= (1 << chip_select_bit);\n      break;\n    default:\n      return RTEMS_INVALID_ADDRESS;\n  }\n  return RTEMS_SUCCESSFUL;\n}\nstatic rtems_status_code rpi_libi2c_spi_send_addr(\n  rtems_libi2c_bus_t * bushdl,\n  uint32_t addr,\n  int rw\n) {\n  rpi_spi_softc_t *softc_ptr = &(((rpi_spi_desc_t *)(bushdl))->softc);\n  uint32_t chip_select_bit = 21 + addr;\n  softc_ptr->current_slave_addr = addr;\n  switch ( addr ) {\n    case 0:\n    case 1:\n      BCM2835_REG(BCM2835_SPI_CS) &= ~(1 << chip_select_bit);\n      break;\n    default:\n      return RTEMS_INVALID_ADDRESS;\n  }\n  return RTEMS_SUCCESSFUL;\n}\nstatic int rpi_libi2c_spi_read_bytes(\n  rtems_libi2c_bus_t * bushdl,\n  unsigned char *bytes,\n  int nbytes\n) {\n  return rpi_spi_read_write(bushdl, bytes, NULL, nbytes);\n}\nstatic int rpi_libi2c_spi_write_bytes(\n  rtems_libi2c_bus_t * bushdl,\n  unsigned char *bytes,\n  int nbytes\n) {\n  return rpi_spi_read_write(bushdl, NULL, bytes, nbytes);\n}\nstatic int rpi_libi2c_spi_ioctl(rtems_libi2c_bus_t * bushdl, int cmd, void *arg)\n{\n  switch ( cmd ) {\n    case RTEMS_LIBI2C_IOCTL_SET_TFRMODE:\n      return rpi_spi_set_tfr_mode(\n               bushdl,\n               (const rtems_libi2c_tfr_mode_t *)arg\n             );\n    default:\n      return -1;\n  }\n  return 0;\n}\nstatic rtems_libi2c_bus_ops_t rpi_spi_ops = {\n  .init = rpi_libi2c_spi_init,\n  .send_start = rpi_libi2c_spi_send_start,\n  .send_stop = rpi_libi2c_spi_stop,\n  .send_addr = rpi_libi2c_spi_send_addr,\n  .read_bytes = rpi_libi2c_spi_read_bytes,\n  .write_bytes = rpi_libi2c_spi_write_bytes,\n  .ioctl = rpi_libi2c_spi_ioctl\n};\nstatic rpi_spi_desc_t rpi_spi_bus_desc = {\n  {\n    .ops = &rpi_spi_ops,\n    .size = sizeof(rpi_spi_bus_desc)\n  },\n  {\n    .initialized = 0\n  }\n};\nint rpi_spi_init(bool bidirectional_mode)\n{\n  rtems_libi2c_initialize();\n  rtems_gpio_initialize();\n  assert ( rpi_gpio_select_spi() == RTEMS_SUCCESSFUL );\n  bidirectional = bidirectional_mode;\n  BCM2835_REG(BCM2835_SPI_CS) = (3 << 4);\n  return rtems_libi2c_register_bus(""/dev/spi"", &(rpi_spi_bus_desc.bus_desc));\n}'"
"('Prompt: You are developing a testing framework for a digital signal processing library. Your task is to create a testbench function that generates a prototype filter using the Parks-McClellan algorithm. The function should take in parameters such as the type of filter, filter order, transition width factor, and stopband attenuation. Additionally, it should generate a frequency domain representation of the filter and write it to a file for later analysis. Write a function that accomplishes this task. . . Response:. ```c. void testbench_firdes_prototype(const char * _type,.                                 unsigned int _k,.                                 unsigned int _m,.                                 float        _beta,.                                 float        _as). {.     unsigned int h_len = 2*_k*_m+1;.     float        h[h_len];.     liquid_firfilt_type type = liquid_getopt_str2firfilt(_type);.     if (type == LIQUID_FIRFILT_UNKNOWN) {.         AUTOTEST","//...\nvoid testbench_firdes_prototype(const char * _type,\n                                unsigned int _k,\n                                unsigned int _m,\n                                float        _beta,\n                                float        _as)\n{\n    unsigned int h_len = 2*_k*_m+1;\n    float        h[h_len];\n    liquid_firfilt_type type = liquid_getopt_str2firfilt(_type);\n    if (type == LIQUID_FIRFILT_UNKNOWN) {\n        AUTOTEST_FAIL(""invalid configuration"");\n        return;\n    }\n    liquid_firdes_prototype(type, _k, _m, _beta, 0.0f, h);\n    liquid_vectorf_mulscalar(h, h_len, 1.0f/(float)_k, h);\n    float bw = 1.0f / (float)_k;\n    float f0 = 0.45*bw*(1-_beta);\n    float f1 = 0.55*bw*(1+_beta);\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5,.fmax=-f1, .pmin= 0, .pmax=-_as, .test_lo=0, .test_hi=1},\n      {.fmin=-f0, .fmax= f0, .pmin=-1, .pmax=+1,   .test_lo=1, .test_hi=1},\n      {.fmin= f1, .fmax=+0.5,.pmin= 0, .pmax=-_as, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/firdes_prototype_%s.m"", _type);\n    liquid_autotest_validate_psd_signalf(h, h_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\nvoid autotest_firdes_prototype_pm       (){ testbench_firdes_prototype(""pm"",       4, 12, 0.3f, 80.0f); }\n//...')
"
'Please provide a prompt or technical scenario where you need to implement a file system in an embedded system using RTEMS with a Translated File System (TFS) driver.,"#ifdef RTEMS_TFS_DRIVER_DEBUG\n#define RTEMS_TFS_DEBUG 1\n#else\n#define RTEMS_TFS_DEBUG 0\n#endif\n#define MAXFILESIZE 0x4000\n#define MAXTFDS  15\n#ifndef newlib_tfdlock\n#define newlib_tfdlock()\n#endif\n#ifndef newlib_tfdunlock\n#define newlib_tfdunlock()\n#endif\nstruct tfdinfo {\n  int   inuse;\n  int   tfd;\n  char *buf;\n  char  name[TFSNAMESIZE+1];\n  char  info[TFSNAMESIZE+1];\n} tfdtable[MAXTFDS];\nchar TFS_PATHNAME_PREFIX[128];\nstatic const rtems_filesystem_operations_table  rtems_tfs_ops;\nstatic const rtems_filesystem_file_handlers_r   rtems_tfs_handlers;\nstatic bool rtems_tfs_is_directory(\n    const char *path,\n    size_t pathlen\n)\n{\n    return path [pathlen - 1] == \'/\';\n}\nstatic int rtems_tfs_mount_me(\n  rtems_filesystem_mount_table_entry_t *mt_entry,\n  const void                           *data\n)\n{\n  char *root_path = strdup(""/"");\n  if (root_path == NULL) {\n    rtems_set_errno_and_return_minus_one(ENOMEM);\n  }\n  mt_entry->ops = &rtems_tfs_ops;\n  mt_entry->mt_fs_root->location.handlers = &rtems_tfs_handlers;\n  mt_entry->mt_fs_root->location.node_access = root_path;\n  return 0;\n}\nint rtems_initialize_tfs_filesystem(\n  const char *path\n)\n{\n  int status;\n  if (!path) {\n    printk( ""TFS: No mount point specified\\n"" );\n    return -1;\n  }\n  strncpy( TFS_PATHNAME_PREFIX, path, sizeof(TFS_PATHNAME_PREFIX) );\n  status = mkdir( TFS_PATHNAME_PREFIX, S_IRWXU | S_IRWXG | S_IRWXO );\n  if ( status == -1 ) {\n    printk( ""TFS: Unable to mkdir %s\\n"", TFS_PATHNAME_PREFIX );\n    return status;\n  }\n  if (rtems_filesystem_register( ""tfs"", rtems_tfs_mount_me ) < 0)\n    return -1;\n  status = mount( ""umon"", TFS_PATHNAME_PREFIX, ""tfs"", RTEMS_FILESYSTEM_READ_WRITE, NULL);\n  if (status < 0) {\n    printk( ""TFS: Unable to mount on %s\\n"", TFS_PATHNAME_PREFIX );\n    perror(""TFS mount failed"");\n  }\n  return(status);\n}\nstatic void fixPath(char *path)\n{\n  char *inp, *outp, *base;\n  outp = inp = path;\n  base = NULL;\n  for (;;) {\n    if (inp[0] == \'.\') {\n      if (inp[1] == \'\\0\')\n          break;\n      if (inp[1] == \'/\') {\n          inp += 2;\n          continue;\n      }\n      if (inp[1] == \'.\') {\n        if (inp[2] == \'\\0\') {\n          if ((base != NULL) && (outp > base)) {\n            outp--;\n            while ((outp > base) && (outp[-1] != \'/\'))\n              outp--;\n          }\n          break;\n        }\n        if (inp[2] == \'/\') {\n          inp += 3;\n          if (base == NULL)\n            continue;\n          if (outp > base) {\n            outp--;\n            while ((outp > base) && (outp[-1] != \'/\'))\n              outp--;\n          }\n          continue;\n        }\n      }\n    }\n    if (base == NULL)\n      base = inp;\n    while (inp[0] != \'/\') {\n      if ((*outp++ = *inp++) == \'\\0\')\n        return;\n    }\n    *outp++ = \'/\';\n    while (inp[0] == \'/\')\n      inp++;\n  }\n  *outp = \'\\0\';\n}\nstatic void rtems_tfs_eval_path(rtems_filesystem_eval_path_context_t *self)\n{\n  int eval_flags = rtems_filesystem_eval_path_get_flags(self);\n  if ((eval_flags & RTEMS_FS_MAKE) == 0) {\n    int rw = RTEMS_FS_PERMS_READ | RTEMS_FS_PERMS_WRITE;\n    if ((eval_flags & rw) != rw) {\n      rtems_filesystem_location_info_t *currentloc =\n        rtems_filesystem_eval_path_get_currentloc(self);\n      char *current = currentloc->node_access;\n      size_t currentlen = strlen(current);\n      const char *path = rtems_filesystem_eval_path_get_path(self);\n      size_t pathlen = rtems_filesystem_eval_path_get_pathlen(self);\n      size_t len = currentlen + pathlen;\n      rtems_filesystem_eval_path_clear_path(self);\n      current = realloc(current, len + 1);\n      if (current != NULL) {\n        memcpy(current + currentlen, path, pathlen);\n        current [len] = \'\\0\';\n        if (!rtems_tfs_is_directory(current, len)) {\n          fixPath (current);\n        }\n        currentloc->node_access = current;\n      } else {\n        rtems_filesystem_eval_path_error(self, ENOMEM);\n      }\n    } else {\n      rtems_filesystem_eval_path_error(self, EINVAL);\n    }\n  } else {\n    rtems_filesystem_eval_path_error(self, EIO);\n  }\n}\nstatic int rtems_tfs_open_worker(\n  rtems_libio_t *iop,\n  char          *path,\n  int            oflag,\n  mode_t         mode\n)\n{\n  static int beenhere = 0;\n  long flagmode;\n  int  tfdidx, tfd;\n  struct tfdinfo *tip;\n  char *buf, *fstr, *istr, *bstr, pathcopy[TFSNAMESIZE*3+1];\n  if (RTEMS_TFS_DEBUG)\n    printk(""_open_r(%s,0x%x,0x%"" PRIx32 "")\\n"",path,oflag,mode);\n  if (!beenhere) {\n    newlib_tfdlock();\n    for(tfdidx=0;tfdidx<MAXTFDS;tfdidx++)\n      tfdtable[tfdidx].inuse = 0;\n    tfdtable[0].inuse = 1;    \n    tfdtable[1].inuse = 1;    \n    tfdtable[2].inuse = 1;    \n    newlib_tfdunlock();\n    beenhere = 1;\n  }\n  istr = fstr = bstr = buf = (char *)0;\n  if (strlen(path) > TFSNAMESIZE*3) {\n    return(ENAMETOOLONG);\n  }\n  strcpy(pathcopy,path);\n  fstr = strchr(pathcopy,\',\');\n  if (fstr)  {\n    *fstr++ = 0;\n    istr = strchr(fstr,\',\');\n    if (istr) {\n      *istr++ = 0;\n      bstr = strchr(istr,\',\');\n      if (bstr)\n        *bstr++ = 0;\n    }\n  }\n  if (strlen(pathcopy) > TFSNAMESIZE) {\n    return(ENAMETOOLONG);\n  }\n  if (istr) {\n    if (strlen(istr) > TFSNAMESIZE) {\n      return(ENAMETOOLONG);\n    }\n  }\n  if ((oflag & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) {\n    if (mon_tfsstat((char *)pathcopy)) {\n      return(EEXIST);\n    }\n  }\n  switch(oflag & O_ACCMODE) {\n    case O_RDONLY:\n      flagmode = TFS_RDONLY;\n      break;\n    case O_WRONLY|O_APPEND:\n      flagmode = TFS_APPEND;\n      break;\n    case O_WRONLY|O_TRUNC:\n    case O_WRONLY|O_CREAT|O_TRUNC:\n      mon_tfsunlink((char *)pathcopy);\n      flagmode = TFS_CREATE|TFS_APPEND;\n      break;\n    case O_WRONLY|O_CREAT:\n    case O_WRONLY|O_CREAT|O_APPEND:\n      flagmode = TFS_CREATE|TFS_APPEND;\n      break;\n    case O_RDWR:\n    case O_WRONLY|O_CREAT|O_EXCL:\n      flagmode = TFS_CREATE|TFS_APPEND;\n      break;\n    default:\n      printk(""_open_r(): flag 0x%i not supported\\n"",oflag);\n      return(ENOTSUP);\n  }\n  newlib_tfdlock();\n  for(tfdidx=0;tfdidx<MAXTFDS;tfdidx++) {\n    if (tfdtable[tfdidx].inuse == 0)\n      break;\n  }\n  if (tfdidx == MAXTFDS) {\n    newlib_tfdunlock();\n    return(EMFILE);\n  }\n  tip = &tfdtable[tfdidx];\n  tip->inuse = 1;\n  newlib_tfdunlock();\n  if (flagmode == TFS_RDONLY) {\n    buf = (char *)0;\n  } else {\n    if (bstr)\n      buf = (char *)strtol(bstr,0,0);\n    else\n      buf = malloc(MAXFILESIZE);\n    if (!buf) {\n      newlib_tfdlock();\n      tip->inuse = 0;\n      newlib_tfdunlock();\n      return(ENOMEM);\n    }\n  }\n  if (fstr) {\n    long bflag;\n    bflag = mon_tfsctrl(TFS_FATOB,(long)fstr,0);\n    if (bflag == -1) {\n      return(EINVAL);\n    }\n    flagmode |= bflag;\n  }\n  if (istr)\n    strcpy(tip->info,istr);\n  else\n    tip->info[0] = 0;\n  tfd = mon_tfsopen((char *)pathcopy,flagmode,buf);\n  if (tfd >= 0) {\n    tip->tfd = tfd;\n    tip->buf = buf;\n    strcpy(tip->name,pathcopy);\n    iop->data0 = (uint32_t)tfdidx;\n    return(0);\n  } else {\n    printk(""%s: %s\\n"",pathcopy,\n      (char *)mon_tfsctrl(TFS_ERRMSG,tfd,0));\n  }\n  if (buf)\n    free(buf);\n  newlib_tfdlock();\n  tip->inuse = 0;\n  newlib_tfdunlock();\n  return(EINVAL);\n}\nstatic int rtems_tfs_open(\n  rtems_libio_t *iop,\n  const char    *new_name,\n  int            oflag,\n  mode_t         mode\n)\n{\n  char *full_path_name;\n  int err;\n  full_path_name = iop->pathinfo.node_access;\n  if (RTEMS_TFS_DEBUG)\n    printk(""rtems_tfs_open(%s)\\n"",full_path_name);\n  if (rtems_tfs_is_directory(full_path_name, strlen(full_path_name))) {\n    rtems_set_errno_and_return_minus_one (ENOTSUP);\n  }\n  err = rtems_tfs_open_worker (iop, full_path_name, oflag, mode);\n  if (err != 0) {\n     rtems_set_errno_and_return_minus_one (err);\n  }\n  return err;\n}\nstatic ssize_t rtems_tfs_read(\n  rtems_libio_t *iop,\n  void          *buffer,\n  size_t         count\n)\n{\n  int  ret, fd;\n  fd = (int) iop->data0;\n  if (RTEMS_TFS_DEBUG)\n    printk(""_read_r(%d,%zi)\\n"",fd,count);\n  if ((fd < 3) || (fd >= MAXTFDS))\n    return(EBADF);\n  ret = mon_tfsread(tfdtable[fd].tfd,buffer,count);\n  if (ret == TFSERR_EOF)\n    ret = 0;\n  return(ret);\n}\nstatic int rtems_tfs_close(\n  rtems_libio_t *iop\n)\n{\n  int  fd;\n  char *info;\n  struct tfdinfo *tip;\n  fd = (int)iop->data0;\n  if (RTEMS_TFS_DEBUG)\n    printk(""rtems_tfs_close(%d)\\n"",fd);\n  if ((fd < 3) || (fd >= MAXTFDS)) {\n    rtems_set_errno_and_return_minus_one (EBADF);\n  }\n  tip = &tfdtable[fd];\n  if (tip->info[0])\n    info = tip->info;\n  else\n    info = (char *)0;\n  mon_tfsclose(tip->tfd,info);\n  if (tip->buf)\n    free(tip->buf);\n  newlib_tfdlock();\n  tip->inuse = 0;\n  newlib_tfdunlock();\n  return RTEMS_SUCCESSFUL;\n}\nstatic ssize_t rtems_tfs_write(\n  rtems_libio_t *iop,\n  const void    *buffer,\n  size_t         count\n)\n{\n  int  ret, fd;\n  fd = (int) iop->data0;\n  if (RTEMS_TFS_DEBUG)\n    printk(""rtems_tfs_write(%d,%zi)\\n"",fd,count);\n  if ((fd <= 0) || (fd >= MAXTFDS)) {\n    rtems_set_errno_and_return_minus_one (EBADF);\n  }\n  ret = mon_tfswrite(tfdtable[fd].tfd,(char *)buffer,count);\n  if (ret < 0)\n    return(-1);\n  return(ret);\n}\nstatic off_t rtems_tfs_lseek(\n  rtems_libio_t *iop,\n  off_t          offset,\n  int            whence\n)\n{\n  int ret, fd;\n  fd = (int) iop->data0;\n  if (RTEMS_TFS_DEBUG)\n    printk(""rtems_tfs_lseek(%d,%ld,%d)\\n"",fd,(long)offset,whence);\n  switch (whence) {\n    case SEEK_END:\n      printk(""rtems_tfs_lseek doesn\'t support SEEK_END\\n"");\n      return(-1);\n    case SEEK_CUR:\n      whence = TFS_CURRENT;\n      break;\n    case SEEK_SET:\n      whence = TFS_BEGIN;\n      break;\n  }\n  ret = mon_tfsseek(tfdtable[fd].tfd,offset,whence);\n  if (ret < 0)\n    return(-1);\n  return (off_t)ret;\n}\nstatic int rtems_tfs_ftruncate(\n  rtems_libio_t *iop,\n  off_t          count\n)\n{\n  int ret, fd;\n  fd = (int) iop->data0;\n  ret = mon_tfstruncate(tfdtable[fd].tfd,count);\n  if (ret != TFS_OKAY)\n    return(-1);\n  return(0);\n}\nstatic int rtems_tfs_ioctl(\n  rtems_libio_t *iop,\n  uint32_t       cmd,\n  void          *buf\n)\n{\n  int ret;\n  ret = mon_tfsctrl(cmd,(long)buf,0);\n  if (ret != TFS_OKAY)\n    return(-1);\n  return(0);\n}\nstatic int rtems_tfs_fstat(\n  const rtems_filesystem_location_info_t *loc,\n  struct stat *buf\n)\n{\n  const char *path = loc->node_access;\n  size_t pathlen = strlen(path);\n  buf->st_mode = S_IRWXU | S_IRWXG | S_IRWXO\n    | (rtems_tfs_is_directory(path, pathlen) ?  S_IFDIR : S_IFREG);\n  return 0;\n}\nstatic int rtems_tfs_clone_node_info(\n  rtems_filesystem_location_info_t *loc\n)\n{\n  int rv = 0;\n  loc->node_access = strdup(loc->node_access);\n  if (loc->node_access == NULL) {\n    errno = ENOMEM;\n    rv = -1;\n  }\n  return rv;\n}\nstatic void rtems_tfs_free_node_info(\n  const rtems_filesystem_location_info_t *loc\n)\n{\n  free(loc->node_access);\n}\nstatic bool rtems_tfs_are_nodes_equal(\n  const rtems_filesystem_location_info_t *a,\n  const rtems_filesystem_location_info_t *b\n)\n{\n  return strcmp(a->node_access, b->node_access) == 0;\n}\nstatic const rtems_filesystem_operations_table  rtems_tfs_ops = {\n  .lock_h = rtems_filesystem_default_lock,\n  .unlock_h = rtems_filesystem_default_unlock,\n  .eval_path_h = rtems_tfs_eval_path,\n  .link_h = rtems_filesystem_default_link,\n  .are_nodes_equal_h = rtems_tfs_are_nodes_equal,\n  .mknod_h = rtems_filesystem_default_mknod,\n  .rmnod_h = rtems_filesystem_default_rmnod,\n  .fchmod_h = rtems_filesystem_default_fchmod,\n  .chown_h = rtems_filesystem_default_chown,\n  .clonenod_h = rtems_tfs_clone_node_info,\n  .freenod_h = rtems_tfs_free_node_info,\n  .mount_h = rtems_filesystem_default_mount,\n  .unmount_h = rtems_filesystem_default_unmount,\n  .fsunmount_me_h = rtems_filesystem_default_fsunmount,\n  .utimens_h = rtems_filesystem_default_utimens,\n  .symlink_h = rtems_filesystem_default_symlink,\n  .readlink_h = rtems_filesystem_default_readlink,\n  .rename_h = rtems_filesystem_default_rename,\n  .statvfs_h = rtems_filesystem_default_statvfs\n};\nstatic const rtems_filesystem_file_handlers_r rtems_tfs_handlers = {\n  .open_h = rtems_tfs_open,\n  .close_h = rtems_tfs_close,\n  .read_h = rtems_tfs_read,\n  .write_h = rtems_tfs_write,\n  .ioctl_h = rtems_tfs_ioctl,\n  .lseek_h = rtems_tfs_lseek,\n  .fstat_h = rtems_tfs_fstat,\n  .ftruncate_h = rtems_tfs_ftruncate,\n  .fsync_h = rtems_filesystem_default_fsync_or_fdatasync,\n  .fdatasync_h = rtems_filesystem_default_fsync_or_fdatasync,\n  .fcntl_h = rtems_filesystem_default_fcntl,\n  .kqfilter_h = rtems_filesystem_default_kqfilter,\n  .poll_h = rtems_filesystem_default_poll,\n  .readv_h = rtems_filesystem_default_readv,\n  .writev_h = rtems_filesystem_default_writev\n};'"
"('Prompt: You are working on a project where you need to implement a callback function in C that takes in various parameters including header, payload, statistics, and a file name for writing. The function should open a file with the provided filename and write the real and imaginary parts of each element in the statistics array in a specific format. Can you provide me with the code for such a callback function?","//...\nstatic int callback(unsigned char *  _header,\n                    int              _header_valid,\n                    unsigned char *  _payload,\n                    unsigned int     _payload_len,\n                    int              _payload_valid,\n                    framesyncstats_s _stats,\n                    void *           _userdata)\n{\n    const char * filename = (const char*)_userdata;\n    FILE * fid = fopen(filename,""w"");\n    if (fid == NULL) {\n        printf(""could not open \'%s\' for writing\\n"", filename);\n        return 0;\n    }\n    unsigned int i;\n    for (i=0; i<_stats.num_framesyms; i++)\n        fprintf(fid,""%12.8f %12.8f\\n"", crealf(_stats.framesyms[i]), cimagf(_stats.framesyms[i]));\n    fclose(fid);\n    return 0;\n}\n//...')
"
"('Prompt: Design a set of functions to create, manipulate, and analyze modems in a software-defined radio system. The modems will support different modulation schemes and provide functions for modulating, demodulating, and analyzing signal quality. The functions should include creating a modem with a specific modulation scheme, recreating a modem with a new scheme, destroying a modem, printing modem information, resetting a modem, generating random symbols, getting the bits per second, getting the modulation scheme, modulating a symbol, demodulating a symbol, demodulating a symbol with soft bits, getting a demodulator sample, getting the demodulator phase error, and getting the demodulator error vector magnitude (EVM).","modem modem_create(modulation_scheme _scheme)\n    { return modemcf_create(_scheme); }\nmodem modem_create_arbitrary(float complex * _table, unsigned int _M)\n    { return modemcf_create_arbitrary(_table, _M); }\nmodem modem_recreate(modem _q, modulation_scheme _scheme)\n    { return modemcf_recreate(_q, _scheme); }\nint modem_destroy(modem _q)\n    { return modemcf_destroy(_q); }\nint modem_print(modem _q)\n    { return modemcf_print(_q); }\nint modem_reset(modem _q)\n    { return modemcf_reset(_q); }\nunsigned int modem_gen_rand_sym(modem _q)\n    { return modemcf_gen_rand_sym(_q); }\nunsigned int modem_get_bps(modem _q)\n    { return modemcf_get_bps(_q); }\nmodulation_scheme modem_get_scheme(modem _q)\n    { return modemcf_get_scheme(_q); }\nint modem_modulate(modem _q, unsigned int _s, float complex * _y)\n    { return modemcf_modulate(_q, _s, _y); }\nint modem_demodulate(modem _q, float complex _x, unsigned int * _s)\n    { return modemcf_demodulate(_q, _x, _s); }\nint modem_demodulate_soft(modem _q, float complex _x,\n        unsigned int * _s, unsigned char * _soft_bits)\n    { return modemcf_demodulate_soft(_q, _x, _s, _soft_bits); }\nint modem_get_demodulator_sample(modem _q, float complex * _x_hat)\n    { return modemcf_get_demodulator_sample(_q, _x_hat); }\nfloat modem_get_demodulator_phase_error(modem _q)\n    { return modemcf_get_demodulator_phase_error(_q); }\nfloat modem_get_demodulator_evm(modem _q)\n    { return modemcf_get_demodulator_evm(_q); }')
"
"'Prompt: In a multi-threaded program using pthreads, you need to retrieve the current concurrency level. How can you implement a function to return the current concurrency level using pthreads?",//...\nint\npthread_getconcurrency (void)\n{\n  return __ptw32_concurrency;\n}\n//...'
"('Please write a function called benchmark_flexframesync that measures the performance of a flexframesync system. The function should take as input parameters a struct rusage pointer for the start time, a struct rusage pointer for the finish time, and an unsigned long int pointer for the number of iterations to be performed. Within the function, perform the following steps:. 1. Divide the number of iterations by 128.. 2. Initialize flexframegen properties with default values.. 3. Set the properties for check, FEC, and modulation scheme.. 4. Create a flexframegen object.. 5. Define the length of the payload and create header and payload arrays.. 6. Assemble the flexframe.. 7. Get the length of the frame.. 8. Generate samples for the frame and add noise to each sample.. 9. Create a flexframesync object.. 10. Get the start time using getrusage.. 11. Execute flexframesync for the specified number of iterations.. 12. Get the","//...\nvoid benchmark_flexframesync(\n    struct rusage *_start,\n    struct rusage *_finish,\n    unsigned long int *_num_iterations)\n{\n    *_num_iterations /= 128;\n    unsigned long int i;\n    flexframegenprops_s fgprops;\n    flexframegenprops_init_default(&fgprops);\n    fgprops.check      = LIQUID_CRC_32;\n    fgprops.fec0       = LIQUID_FEC_NONE;\n    fgprops.fec1       = LIQUID_FEC_NONE;\n    fgprops.mod_scheme = LIQUID_MODEM_QPSK;\n    flexframegen fg = flexframegen_create(&fgprops);\n    unsigned int payload_len = 8;\n    unsigned char header[14];\n    unsigned char payload[payload_len];\n    flexframegen_assemble(fg, header, payload, payload_len);\n    unsigned int frame_len = flexframegen_getframelen(fg);\n    float complex frame[frame_len];\n    flexframegen_write_samples(fg, frame, frame_len);\n    for (i=0; i<frame_len; i++)\n        frame[i] += 0.02f*(randnf() + _Complex_I*randnf());\n    flexframesync fs = flexframesync_create(NULL, NULL);\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        flexframesync_execute(fs, frame, frame_len);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    flexframegen_destroy(fg);\n    flexframesync_destroy(fs);\n}\n//...')
"
"('Provide a prompt for a scenario where you need to create and test a GMSK modem equalizer in C:. . ""You are tasked with implementing and testing a GMSK modem equalizer in C. The equalizer should have specific parameters such as the modulation index, beta value, number of symbols, and FFT size defined. Additionally, you need to use filters and create plots based on the equalizer\'s performance. Write a C program that creates the GMSK modem equalizer and conducts the necessary testing and plotting. Include functions for modulation, filtering, equalizing, and plotting the results. Make sure to save the results to an output file named \'gmskmodem_equalizer_test.m\'. Provide detailed comments and explanations for each major step in your code.""","#define OUTPUT_FILENAME ""gmskmodem_equalizer_test.m""\nint main(int argc, char*argv[]) {\n    unsigned int k      =     4;    \n    float        beta   =  0.3f;    \n    unsigned int p      =     3;    \n    float        mu     = 0.50f;    \n    unsigned int num_symbols = 240000;\n    unsigned int nfft        = 1200;\n    gmskmod mod = gmskmod_create(k, 3, beta);\n    unsigned int i;\n    float fc = 0.4f;\n#if 0\n    unsigned int m=12;\n    float h[2*m];\n    for (i=0; i<2*m; i++) {\n        float t = (float)i - (float)m + 0.5f;\n        h[i] = sincf(2*fc*t);\n        printf(""h(%2u) = %12.8f;\\n"", i+1, h[i]);\n    }\n    firfilt_crcf filt = firfilt_crcf_create(h,2*m);\n#else\n    firfilt_crcf filt = firfilt_crcf_create_kaiser(17, fc, 60.0f, 0.5f);\n#endif\n    firfilt_crcf_set_scale(filt, 2*fc);\n    eqlms_cccf eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER, k, p, beta, 0.0f);\n    eqlms_cccf_set_bw(eq, mu);\n    unsigned int buf_len = 800; \n    windowcf sym_buf = windowcf_create(buf_len);\n    spgramcf q = spgramcf_create_default(nfft);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""k = %u;\\n"", k);\n    fprintf(fid,""num_symbols = %u;\\n"", num_symbols);\n    fprintf(fid,""nfft = %u;\\n"", nfft);\n    fprintf(fid,""psd  = zeros(1,nfft);\\n"");\n    float complex buf[k];\n    for (i=0; i<num_symbols; i++)\n    {\n        gmskmod_modulate(mod, rand() & 1, buf);\n        firfilt_crcf_execute_block(filt, buf, k, buf);\n        eqlms_cccf_push_block(eq, buf, k);\n        float complex d_hat;\n        eqlms_cccf_execute(eq, &d_hat);\n        spgramcf_write(q, buf, k);\n        windowcf_push(sym_buf, d_hat);\n        if (i < p) continue;\n        float complex d_prime = (crealf(d_hat) > 0 ? 1 : -1) * M_SQRT1_2 +\n                                (cimagf(d_hat) > 0 ? 1 : -1) * M_SQRT1_2 * _Complex_I;\n        eqlms_cccf_step(eq, d_prime, d_hat);\n    }\n    printf(""mu = %12.4e\\n"", mu);\n    unsigned int hp_len = 2*k*p+1;   \n    float complex hp[hp_len];           \n    eqlms_cccf_copy_coefficients(eq, hp);\n    fprintf(fid,""hp = zeros(1,%u);\\n"", hp_len);\n    for (i=0; i<hp_len; i++)\n        fprintf(fid,""hp(%3u) = %12.4e + %12.4ej;\\n"", i+1, crealf(hp[i]), cimagf(hp[i]));\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    for (i=0; i<nfft; i++)\n        fprintf(fid,""psd(%6u) = %12.4e;\\n"", i+1, psd[i]);\n    float complex * rc;\n    windowcf_read(sym_buf, &rc);\n    fprintf(fid,""syms = zeros(1,%u);\\n"", buf_len);\n    for (i=0; i<buf_len; i++)\n        fprintf(fid,""syms(%3u) = %12.8f + j*%12.8f;\\n"", i+1, crealf(rc[i]), cimagf(rc[i]));\n    fprintf(fid,""np = round(0.75*num_symbols);\\n"");\n    fprintf(fid,""figure(\'color\',\'white\',\'position\',[100 100 800 800]);\\n"");\n    fprintf(fid,""f=[0:(nfft-1)]/nfft-0.5;\\n"");\n    fprintf(fid,""subplot(2,1,1);\\n"");\n    fprintf(fid,""plot(f, psd-10*log10(k), f, 20*log10(abs(fftshift(fft(hp,nfft)))));\\n"");\n    fprintf(fid,""axis([-0.5 0.5 -80 20]); grid on;\\n"");\n    fprintf(fid,""xlabel(\'Normalized Frequency\'); ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""subplot(2,1,2);\\n"");\n    fprintf(fid,""k=%u; p=%u; th=[(-k*p):(k*p)]/k;\\n"", k, p);\n    fprintf(fid,""plot(th, real(hp),\'-x\',th, imag(hp),\'-x\');\\n"");\n    fprintf(fid,""axis([(-p) (p) -0.8 1.5]); grid on;\\n"");\n    fprintf(fid,""%%xlabel(\'Normalized Frequency\'); ylabel(\'PSD [dB]\');\\n"");\n    fprintf(fid,""figure(\'color\',\'white\',\'position\',[100 100 600 600]);\\n"");\n    fprintf(fid,""plot(real(syms),imag(syms),\'x\',\'MarkerSize\',4);\\n"");\n    fprintf(fid,""  axis square;\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""  axis([-1 1 -1 1]*1.0);\\n"");\n    fprintf(fid,""  xlabel(\'In-phase\');\\n"");\n    fprintf(fid,""  ylabel(\'Quadrature\');\\n"");\n    fprintf(fid,""  title(\'Last %u symbols\');\\n"", buf_len);\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    gmskmod_destroy(mod);\n    firfilt_crcf_destroy(filt);\n    eqlms_cccf_destroy(eq);\n    spgramcf_destroy(q);\n    windowcf_destroy(sym_buf);\n    return 0;\n}')
"
"'Prompt: You are working on a benchmarking tool for a Raspberry Pi project and need to implement a function to measure the time taken by different operations. Your goal is to initialize a benchmark timer, read the timer value, and optionally subtract the average overhead. The timer is based on the BCM2835 GPU timer. Please provide code for initializing the timer, reading the timer value, and allowing the subtraction of average overhead based on a boolean flag.",static bool benchmark_timer_find_average_overhead = false;\nstatic uint64_t benchmark_timer_base;\nvoid benchmark_timer_initialize( void )\n{\n  benchmark_timer_base = BCM2835_REG( BCM2835_GPU_TIMER_CLO );\n}\nbenchmark_timer_t benchmark_timer_read( void )\n{\n  uint32_t delta = BCM2835_REG( BCM2835_GPU_TIMER_CLO ) - benchmark_timer_base;\n  if ( benchmark_timer_find_average_overhead ) {\n    return delta;\n  } else {\n    return BCM2835_REG( BCM2835_GPU_TIMER_CLO );\n  }\n}\nvoid benchmark_timer_disable_subtracting_average_overhead(\n  bool find_average_overhead )\n{\n  benchmark_timer_find_average_overhead = find_average_overhead;\n}'
"('Prompt: You work for a software development company that is testing a new library for digital signal processing. You are tasked with conducting automated tests for the function `testbench_nco_crcf_mix`, which mixes signals from a Numerically Controlled Oscillator (NCO) using a given phase and frequency. Write a test function to verify the behavior when the NCO type is set to `LIQUID_NCO`, phase is 0.000, and frequency is -0.123. . . Response: . ```c. void autotest_nco_crcf_mix_nco_8() { testbench_nco_crcf_mix(LIQUID_NCO,  0.000f, -0.123f); }. ```","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_nco_8() { testbench_nco_crcf_mix(LIQUID_NCO,  0.000f, -0.123f); }\n//...')
"
"('Prompt: A scenario where you need to test the FFT function with an input size of 9 elements. You want to write an automated test function that compares the FFT output with the expected result and checks if it matches for the given input data. The function should be named `autotest_fft_9` and should call the `fft_test` function with input arrays `fft_test_x9` and `fft_test_y9`, and the size parameter set to 9.","//...\nvoid autotest_fft_9()       { fft_test( fft_test_x9,   fft_test_y9,      9);     }\n//...')
"
"('Prompt: ""I need a function that will perform automatic tests for the \'liquid_uppergammaf\' function using a tolerance of 1e-3f. The function should test the output of \'liquid_uppergammaf\' with different input values and compare them with the expected results. The expected results are provided in the form of floating-point values for each input value. The function should use the \'CONTEND_DELTA\' macro to check if the calculated output is within the specified tolerance of the expected result. In case of any mismatches, the function should indicate a test failure. Can you provide me with the code for this test function?""","//...\nvoid autotest_uppergamma()\n{\n    float tol = 1e-3f;\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.001f), 1.04649f,  tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.01f),  1.04646f,  tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.1f),   1.04295f,  tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.2f),   1.03231f,  tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.3f),   1.01540f,  tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.4f),   0.993237f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.5f),   0.966782f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.6f),   0.936925f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.7f),   0.904451f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.8f),   0.870053f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 0.9f),   0.834330f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 1.0f),   0.797796f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 2.0f),   0.455589f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 3.0f),   0.229469f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 4.0f),   0.107786f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 5.0f),   0.0484292f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 6.0f),   0.0211006f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 7.0f),   0.00898852f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 8.0f),   0.00376348f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 9.0f),   0.00155445f, tol);\n    CONTEND_DELTA(liquid_uppergammaf(2.1f, 10.0f),  0.000635002f, tol);\n}\n//...')
"
"('Prompt: Can you provide a function that generates a simulated stream of complex symbols and calculates the power spectral density (PSD) of the signal? It should use a QPSK modulation scheme with a specific set of parameters. Additionally, please include a validation step that compares the PSD against predefined regions for testing purposes, and save the results in a file if the validation fails.","//...\nvoid testbench_symstreamcf_psd(unsigned int _k,\n                               unsigned int _m,\n                               float        _beta)\n{\n    int ftype = LIQUID_FIRFILT_ARKAISER;\n    int ms    = LIQUID_MODEM_QPSK;\n    symstreamcf gen = symstreamcf_create_linear(ftype,_k,_m,_beta,ms);\n    symstreamcf_set_gain(gen, 1.0f/sqrtf(_k));\n    unsigned int nfft        =   2400;      \n    unsigned int num_samples = 192000*_k;   \n    spgramcf periodogram = spgramcf_create_default(nfft);\n    unsigned int buf_len = 1337;\n    float complex buf[buf_len];\n    unsigned int n = 0;\n    while (n < num_samples) {\n        symstreamcf_write_samples(gen, buf, buf_len);\n        n += buf_len;\n        spgramcf_write(periodogram, buf, buf_len);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(periodogram, psd);\n    symstreamcf_destroy(gen);\n    spgramcf_destroy(periodogram);\n    float f0 = 0.5 * (1.0f - _beta) / (float)_k;\n    float f1 = 0.5 * (1.0f + _beta) / (float)_k;\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5, .fmax=-f1,  .pmin=  0-0, .pmax=-80.0, .test_lo=0, .test_hi=1},\n      {.fmin=-f0,  .fmax= f0,  .pmin= -1.0, .pmax=  1.0, .test_lo=1, .test_hi=1},\n      {.fmin= f1,  .fmax= 0.5, .pmin=  0.0, .pmax=-80.0, .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/symstreamcf_psd_k%u_m%u_b%.3u_autotest.m"",\n            _k, _m, (int)(_beta*100));\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\n//...')
"
"('Prompt: You need to write a function that computes the sum of squares of elements in an array of floating-point numbers using SSE (Streaming SIMD Extensions) instructions. The function should be optimized for performance, taking advantage of vectorization. The function should have two versions: one for processing up to 4 elements at a time and another for processing up to 16 elements at a time. The function should dynamically choose between these versions based on the size of the input array. Write the code for these functions and handle cases where SSE3 instructions are available versus not available.","//...\nfloat liquid_sumsqf_sse(float *      _v,\n                        unsigned int _n)\n{\n    __m128 v;   \n    __m128 s;   \n    __m128 sum = _mm_setzero_ps(); \n    unsigned int t = (_n >> 2) << 2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        v = _mm_loadu_ps(&_v[i]);\n        s = _mm_mul_ps(v, v);\n        sum = _mm_add_ps( sum, s );\n    }\n    float w[4] __attribute__((aligned(16)));\n#if HAVE_SSE3\n    __m128 z = _mm_setzero_ps();\n    sum = _mm_hadd_ps(sum, z);\n    sum = _mm_hadd_ps(sum, z);\n    _mm_store_ss(w, sum);\n    float total = w[0];\n#else\n    _mm_store_ps(w, sum);\n    float total = w[0] + w[1] + w[2] + w[3];\n#endif\n    for (; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf(float *      _v,\n                    unsigned int _n)\n{\n    if (_n < 16) {\n        return liquid_sumsqf_sse(_v, _n);\n    }\n    return liquid_sumsqf_sseu(_v, _n);\n}\nfloat liquid_sumsqf_sseu(float *      _v,\n                         unsigned int _n)\n{\n    __m128 v0, v1, v2, v3;   \n    __m128 s0, s1, s2, s3;   \n    __m128 sum = _mm_setzero_ps(); \n    unsigned int t = (_n >> 4) << 2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        v0 = _mm_loadu_ps(&_v[4*i+ 0]);\n        v1 = _mm_loadu_ps(&_v[4*i+ 4]);\n        v2 = _mm_loadu_ps(&_v[4*i+ 8]);\n        v3 = _mm_loadu_ps(&_v[4*i+12]);\n        s0 = _mm_mul_ps(v0, v0);\n        s1 = _mm_mul_ps(v1, v1);\n        s2 = _mm_mul_ps(v2, v2);\n        s3 = _mm_mul_ps(v3, v3);\n        sum = _mm_add_ps( sum, s0 );\n        sum = _mm_add_ps( sum, s1 );\n        sum = _mm_add_ps( sum, s2 );\n        sum = _mm_add_ps( sum, s3 );\n    }\n    float w[4] __attribute__((aligned(16)));\n#if HAVE_SSE3\n    __m128 z = _mm_setzero_ps();\n    sum = _mm_hadd_ps(sum, z);\n    sum = _mm_hadd_ps(sum, z);\n    _mm_store_ss(w, sum);\n    float total = w[0];\n#else\n    _mm_store_ps(w, sum);\n    float total = w[0] + w[1] + w[2] + w[3];\n#endif\n    for (i=4*t; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\nfloat liquid_sumsqf_sseu(float *      _v,\n                         unsigned int _n)\n{\n    __m128 v0, v1, v2, v3;   \n    __m128 s0, s1, s2, s3;   \n    __m128 sum = _mm_setzero_ps(); \n    unsigned int t = (_n >> 4) << 2;\n    unsigned int i;\n    for (i=0; i<t; i+=4) {\n        v0 = _mm_loadu_ps(&_v[4*i+ 0]);\n        v1 = _mm_loadu_ps(&_v[4*i+ 4]);\n        v2 = _mm_loadu_ps(&_v[4*i+ 8]);\n        v3 = _mm_loadu_ps(&_v[4*i+12]);\n        s0 = _mm_mul_ps(v0, v0);\n        s1 = _mm_mul_ps(v1, v1);\n        s2 = _mm_mul_ps(v2, v2);\n        s3 = _mm_mul_ps(v3, v3);\n        sum = _mm_add_ps( sum, s0 );\n        sum = _mm_add_ps( sum, s1 );\n        sum = _mm_add_ps( sum, s2 );\n        sum = _mm_add_ps( sum, s3 );\n    }\n    float w[4] __attribute__((aligned(16)));\n#if HAVE_SSE3\n    __m128 z = _mm_setzero_ps();\n    sum = _mm_hadd_ps(sum, z);\n    sum = _mm_hadd_ps(sum, z);\n    _mm_store_ss(w, sum);\n    float total = w[0];\n#else\n    _mm_store_ps(w, sum);\n    float total = w[0] + w[1] + w[2] + w[3];\n#endif\n    for (i=4*t; i<_n; i++)\n        total += _v[i] * _v[i];\n    return total;\n}\n//...')
"
"('Prompt: Imagine a scenario where you need to test the autocorrelation functionality of a generated binary sequence based on a specific M-sequence. Write a function that takes an unsigned integer _m as input, creates two binary sequences of length n generated from the same M-sequence, and performs autocorrelation tests. Make sure to include functionality to push new elements into one of the binary sequences during the autocorrelation testing. Finally, create an auto-test function that calls the main autocorrelation test function with a specific value of _m (e.g., 10) for testing purposes.","//...\nvoid msequence_test_autocorrelation(unsigned int _m)\n{\n    msequence ms = msequence_create_default(_m);\n    unsigned int n = msequence_get_length(ms);\n    bsequence bs1 = bsequence_create(n);\n    bsequence_init_msequence(bs1, ms);\n    bsequence bs2 = bsequence_create(n);\n    bsequence_init_msequence(bs2, ms);\n    CONTEND_EQUALITY( bsequence_get_length(bs1), n )\n    CONTEND_EQUALITY( bsequence_get_length(bs2), n )\n    signed int rxy;\n    rxy = bsequence_correlate(bs1, bs2);\n    CONTEND_EQUALITY( rxy, n )\n    unsigned int i;\n    for (i=0; i<n-1; i++) {\n        bsequence_push(bs2, msequence_advance(ms));\n        rxy = 2*bsequence_correlate(bs1, bs2) - n;\n        CONTEND_EQUALITY( rxy, -1 );\n    }\n    bsequence_destroy(bs1);\n    bsequence_destroy(bs2);\n    msequence_destroy(ms);\n}\nvoid autotest_msequence_xcorr_m10() { msequence_test_autocorrelation(10); }\n//...')
"
"('Prompt: As part of performance testing for our receiver system, we need to benchmark the timing synchronization process for receiving OFDM frames with a symbol length of 128. Can you provide a function that can be used to benchmark the processing time for this specific scenario?","//...\nvoid benchmark_ofdmframesync_rxsymbol_n128  O\n//...')
"
"('Create a test case to verify the functionality of a block mixing operation (nco_crcf_mix_block_down) in a Numerically Controlled Oscillator (NCO) framework. The scenario involves generating a complex sinusoidal signal with a given frequency and phase, then mixing blocks of this signal down using the NCO function.. . Specifically, this test case should involve setting a frequency, phase, and tolerance values. It should then create two arrays of complex numbers, x and y, allocate memory for them, fill array x with the generated signal, create an NCO object, mix blocks of the signal down using the NCO function, and then verify that the output signal y has been mixed down correctly by checking the real and imaginary parts against expected values within a specified tolerance.. . The code snippet should be a function called autotest_nco_block_mixing that performs the described scenario. The function should utilize the NCO functions for setting frequency and phase, mixing blocks down, and destroying the NCO","//...\nvoid autotest_nco_block_mixing()\n{\n    float f = 0.1f;\n    float phi = M_PI;\n    float tol = 0.05f;\n    unsigned int i;\n    unsigned int num_samples = 1024;\n    float complex * x = (float complex*)malloc(num_samples*sizeof(float complex));\n    float complex * y = (float complex*)malloc(num_samples*sizeof(float complex));\n    for (i=0; i<num_samples; i++)\n        x[i] = cexpf(_Complex_I*(f*i + phi));\n    nco_crcf p = nco_crcf_create(LIQUID_NCO);\n    nco_crcf_set_frequency(p, f);\n    nco_crcf_set_phase(p, phi);\n    unsigned int num_remaining = num_samples;\n    i = 0;\n    while (num_remaining > 0) {\n        unsigned int n = 7 < num_remaining ? 7 : num_remaining;\n        nco_crcf_mix_block_down(p, &x[i], &y[i], n);\n        i += n;\n        num_remaining -= n;\n    }\n    for (i=0; i<num_samples; i++) {\n        CONTEND_DELTA( crealf(y[i]), 1.0f, tol );\n        CONTEND_DELTA( cimagf(y[i]), 0.0f, tol );\n    }\n    free(x);\n    free(y);\n    nco_crcf_destroy(p);\n}\n//...')
"
"('Prompt: You are working on a digital communication system simulation and need to add Additive White Gaussian Noise (AWGN) to the received signal. Implement functions for generating random numbers from a normal distribution, adding AWGN to a signal, generating complex random numbers following a normal distribution, adding AWGN to a complex signal, calculating the probability density function (PDF) of a normal distribution, and calculating the cumulative distribution function (CDF) of a normal distribution.","float randnf()\n{\n    float u1, u2;\n    do {\n        u1 = randf();\n    } while (u1 == 0.0f);\n    u2 = randf();\n    return sqrtf(-2*logf(u1)) * sinf(2*M_PI*u2);\n}\nvoid awgn(float *_x, float _nstd)\n{\n    *_x += randnf()*_nstd;\n}\nvoid crandnf(float complex * _y)\n{\n    float u1, u2;\n    do {\n        u1 = randf();\n    } while (u1 == 0.0f);\n    u2 = randf();\n    *_y = sqrtf(-2*logf(u1)) * cexpf(_Complex_I*2*M_PI*u2);\n}\nfloat complex icrandnf()\n{\n    float complex y;\n    crandnf(&y);\n    return y;\n}\nvoid cawgn(float complex *_x, float _nstd)\n{\n    *_x += icrandnf()*_nstd*0.707106781186547f;\n}\nfloat randnf_pdf(float _x,\n                 float _eta,\n                 float _sig)\n{\n    if (_sig <= 0.0f) {\n        liquid_error(LIQUID_EICONFIG,""randnf_pdf(), standard deviation must be greater than zero"");\n        return 0.0f;\n    }\n    float t  = _x - _eta;\n    float s2 = _sig * _sig;\n    return expf(-t*t/(2.0f*s2)) / sqrtf(2.0f*M_PI*s2);\n}\nfloat randnf_cdf(float _x,\n                 float _eta,\n                 float _sig)\n{\n    return 0.5 + 0.5*erff( M_SQRT1_2*(_x-_eta)/_sig );\n}')
"
"('Please provide a scenario in which you need to test the `modemcf_demodulate_soft` function for a specific modulation scheme, specifically SQAM128, by comparing the output symbols with the input symbols after modulation and ensure that the soft bits returned are packed correctly.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_sqam128()   { modemcf_test_demodsoft(LIQUID_MODEM_SQAM128);   }\n//...')
"
"('Prompt: You are working on a software-defined radio project that involves testing modem functionality. Write a function that tests the copying of a modem configuration for a specific modulation scheme. The function should create a modem with the given modulation scheme, perform modulation and demodulation operations, create a copy of the modem, and verify that the copy accurately reproduces the original behavior. Include print statements for the input modulation scheme and the schemes of the original and copied modems. Finally, destroy the modems after testing.","//...\nvoid modemcf_test_copy(modulation_scheme _ms)\n{\n    modemcf modem_0 = modemcf_create(_ms);\n    unsigned int i, s0, s1, M = 1 << modemcf_get_bps(modem_0);\n    float complex x0, x1;\n    for (i=0; i<10; i++) {\n        modemcf_modulate(modem_0, rand() % M, &x0);\n        modemcf_demodulate(modem_0, randnf() + _Complex_I*randnf(), &s0);\n    }\n    modemcf modem_1 = modemcf_copy(modem_0);\n    if (liquid_autotest_verbose) {\n        printf(""input: %20s, 0: %20s, 1:%20s\\n"",\n                modulation_types[_ms                        ].name,\n                modulation_types[modemcf_get_scheme(modem_0)].name,\n                modulation_types[modemcf_get_scheme(modem_1)].name);\n    }\n    for (i=0; i<10; i++) {\n        unsigned int s = rand() % M;\n        modemcf_modulate(modem_0, s, &x0);\n        modemcf_modulate(modem_1, s, &x1);\n        CONTEND_EQUALITY(x0, x1);\n        float complex x = randnf() + _Complex_I*randnf();\n        modemcf_demodulate(modem_0, x, &s0);\n        modemcf_demodulate(modem_1, x, &s1);\n        CONTEND_EQUALITY(s0, s1)\n    }\n    modemcf_destroy(modem_0);\n    modemcf_destroy(modem_1);\n}\nvoid autotest_modem_copy_psk16()     { modemcf_test_copy(LIQUID_MODEM_PSK16);     }\n//...')
"
"('Prompt: You are developing a software program for a communication system that utilizes OFDM technology. You need a function that calculates the total frame length in bytes for a given OFDM frame generator object. The frame length is determined by adding 2 bytes for synchronization, 1 byte for length metadata, and the total number of symbols in the header and payload sections. . . Please provide a C function that takes an OFDM frame generator object as an input parameter and returns the total frame length in bytes. The OFDM frame generator object contains the following attributes: unsigned int num_symbols_header representing the number of symbols in the header section, unsigned int num_symbols_payload representing the number of symbols in the payload section.","//...\n    unsigned char * p;      \n    unsigned int num_symbols_header;    \n    unsigned int num_symbols_payload;   \n    unsigned int num_symbols_header;    \nunsigned int ofdmflexframegen_getframelen(ofdmflexframegen _q)\n{\n    return  2 + \n            1 + \n            _q->num_symbols_header +\n            _q->num_symbols_payload;\n}\n//...')
"
"('Prompt: You are tasked with creating an automated test for a static fixed-size buffer library. The library provides functionality for creating, writing to, reading from, and zeroing out buffers. You need to test this library using the provided macro SBUFFER_AUTOTEST_DEFINE_API. The macro takes two arguments - X and T. X is a function name prefix and T is the data type of the buffer. Your task is to write test functions that will create buffers, write data to them, read data from them, and compare the results with expected values. Write test functions autotest_fbuffer_static and autotest_cfbuffer_static using the macro with BUFFER_MANGLE_FLOAT and BUFFER_MANGLE_CFLOAT as arguments respectively. Remember to include appropriate test data and assertions in your test functions. You can also use the template provided in the macro for reference.","#define SBUFFER_AUTOTEST_DEFINE_API(X,T)        \\\n    T v[] = {1, 2, 3, 4, 5, 6, 7, 8};           \\\n    T test1[] = {1, 2, 3, 4};                   \\\n    T test2[] = {1, 2, 3, 4, 5, 6, 7, 8};       \\\n    T test3[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; \\\n    T *r;                                       \\\n    unsigned int n;                             \\\n                                                \\\n    X() cb = X(_create)(STATIC,10);             \\\n                                                \\\n    X(_write)(cb, v, 4);                        \\\n    n = 4;                                      \\\n    X(_read)(cb, &r, &n);                       \\\n                                                \\\n    CONTEND_EQUALITY(n,4);                      \\\n    CONTEND_SAME_DATA(r,test1,4*sizeof(T));     \\\n                                                \\\n    X(_release)(cb, 0);                         \\\n    X(_write)(cb, v, 8);                        \\\n    n = 8;                                      \\\n    X(_read)(cb, &r, &n);                       \\\n    CONTEND_EQUALITY(n,8);                      \\\n    CONTEND_SAME_DATA(r,test2,8*sizeof(T));     \\\n                                                \\\n    X(_zero)(cb);                               \\\n    n = 10;                                     \\\n    X(_read)(cb, &r, &n);                       \\\n    CONTEND_EQUALITY(n,10);                     \\\n    CONTEND_SAME_DATA(r,test3,10*sizeof(T));    \\\n                                                \\\n    X(_destroy)(cb);\nvoid autotest_fbuffer_static()\n{\n    SBUFFER_AUTOTEST_DEFINE_API(BUFFER_MANGLE_FLOAT, float)\n}\nvoid autotest_cfbuffer_static()\n{\n    SBUFFER_AUTOTEST_DEFINE_API(BUFFER_MANGLE_CFLOAT, float complex)\n}\n#if 0\nvoid xautotest_uibuffer_static()\n{\n    SBUFFER_AUTOTEST_DEFINE_API(BUFFER_MANGLE_UINT, unsigned int)\n}\n#endif')
"
"('Prompt: You are working on a signal processing application and need a function to calculate the Doppler channel frequency response of a liquid. The function should take in parameters including the number of samples, Doppler frequency, Doppler frequency shift, angle of arrival, and an array to store the resulting channel. The function should implement a specific computation involving Bessel functions and Kaiser windows. Can you provide the code for this function?","//...\nint liquid_firdes_doppler(unsigned int _n,\n                          float        _fd,\n                          float        _K,\n                          float        _theta,\n                          float *      _h)\n{\n    float t, J, r, w;\n    float beta = 4; \n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        t = (float)i - (float)(_n-1)/2;\n        J = 1.5*liquid_besselj0f(fabsf((float)(2*M_PI*_fd*t)));\n        r = 1.5*_K/(_K+1)*cosf(2*M_PI*_fd*t*cosf(_theta));\n        w = liquid_kaiser(i, _n, beta);\n        _h[i] = (J+r)*w;\n    }\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: ""I need you to create a function that tests the demodulator statistics for a given modulation scheme in a modem communication system. The function should create two modems with the same modulation scheme, modulate a symbol, apply a phase shift to the modulated symbol, demodulate it, and check if the output symbol matches the original symbol. If it does not match, it should output a warning. The function should also check the demodulator phase error and ensure it meets certain criteria. Finally, the function should destroy the modems at the end of the test. The specific modulation scheme to test should be LIQUID_MODEM_ARB256OPT. Can you handle this scenario?""","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_arb256opt(){ modemcf_test_demodstats(LIQUID_MODEM_ARB256OPT);}\n//...')
"
"('Prompt: You are tasked with benchmarking the performance of a function called `presync_cccf_bench` that takes in the following parameters: `_start` and `_finish` which are `struct rusage` pointers, `_num_iterations` which is an `unsigned long int` pointer, `_n` and `_m` which are unsigned integers. The function performs several calculations with float complex numbers and utilizes functions like `presync_cccf_create`, `presync_cccf_push`, `presync_cccf_execute`, and `presync_cccf_destroy`. Write a benchmark function `benchmark_presync_cccf_16` that can be used to measure the performance of `presync_cccf_bench` when called 16 times consecutively. The benchmark function should properly time the execution and return relevant benchmarking data.","//...\nvoid benchmark_presync_cccf_16   P\nvoid presync_cccf_bench(struct rusage *     _start,\n                        struct rusage *     _finish,\n                        unsigned long int * _num_iterations,\n                        unsigned int        _n,\n                        unsigned int        _m)\n{\n    *_num_iterations *= 4;\n    *_num_iterations /= _n;\n    *_num_iterations /= _m;\n    float complex h[_n];\n    unsigned long int i;\n    for (i=0; i<_n; i++) {\n        h[i] = (rand() % 2 ? 1.0f : -1.0f) +\n               (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;\n    }\n    presync_cccf q = presync_cccf_create(h, _n, 0.1f, _m);\n    float complex x[7];\n    for (i=0; i<7; i++) {\n        x[i] = (rand() % 2 ? 1.0f : -1.0f) +\n               (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;\n    }\n    float complex rxy;\n    float dphi_hat;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        presync_cccf_push(q, x[0]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n        presync_cccf_push(q, x[1]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n        presync_cccf_push(q, x[2]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n        presync_cccf_push(q, x[3]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n        presync_cccf_push(q, x[4]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n        presync_cccf_push(q, x[5]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n        presync_cccf_push(q, x[6]);  presync_cccf_execute(q, &rxy, &dphi_hat);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 7;\n    presync_cccf_destroy(q);\n}\n//...')
"
"('Prompt: You are designing a digital filter and need to calculate the filter coefficients. Provide a C code snippet that calculates the filter coefficients using elliptic functions and displays the results. The filter specifications are as follows: passband frequency = 4.0 Hz, stopband frequency = 4.5 Hz, passband ripple = 0.95 dB, stopband attenuation = 0.05 dB, filter order = 7.","int main() {\n    float fp = 4.0f;\n    float fs = 4.5f;\n    float Gp = 0.95f;\n    float Gs = 0.05f;\n    unsigned int n=7;   \n    float Wp = 2*M_PI*fp;\n    float Ws = 2*M_PI*fs;\n    float ep = sqrtf(1.0f/(Gp*Gp) - 1.0f);\n    float es = sqrtf(1.0f/(Gs*Gs) - 1.0f);\n    printf(""ep, es      : %12.8f, %12.8f\\n"", ep, es);\n    float k  = Wp/Ws;           \n    float k1 = ep/es;           \n    float K,  Kp;\n    float K1, K1p;\n    ellipkf(k, n, &K,  &Kp);    \n    ellipkf(k1,n, &K1, &K1p);   \n    printf(""K,  Kp      : %12.8f, %12.8f\\n"", K,  Kp);\n    printf(""K1, K1p     : %12.8f, %12.8f\\n"", K1, K1p);\n    float Nexact = (K1p/K1)/(Kp/K); \n    float N = ceilf(Nexact);        \n    printf(""N (exact)   : %12.8f\\n"", Nexact);\n    printf(""N           : %12.8f\\n"", N);\n    k = ellipdegf(N,k1,n);      \n    printf(""k           : %12.8f\\n"", k);\n    float fs_new = fp/k;        \n    printf(""fs_new      : %12.8f\\n"", fs_new);\n    unsigned int L = (unsigned int)(floorf(N/2.0f)); \n    float u[L];\n    unsigned int i;\n    for (i=0; i<L; i++) {\n        float t = (float)i + 1.0f;\n        u[i] = (2.0f*t - 1.0f)/N;\n        printf(""u[%3u]      : %12.8f\\n"", i, u[i]);\n    }\n    float complex zeta[L];\n    for (i=0; i<L; i++) {\n        zeta[i] = ellip_cdf(u[i],k,n);\n        printf(""zeta[%3u]   : %12.8f + j*%12.8f\\n"", i, crealf(zeta[i]), cimagf(zeta[i]));\n    }\n    float complex za[L];\n    for (i=0; i<L; i++) {\n        za[i] = _Complex_I * Wp / (k*zeta[i]);\n        printf(""za[%3u]     : %12.8f + j*%12.8f\\n"", i, crealf(za[i]), cimagf(za[i]));\n    }\n    float complex v0 = -_Complex_I*ellip_asnf(_Complex_I/ep, k1, n)/N;\n    printf(""v0          : %12.8f + j*%12.8f\\n"", crealf(v0), cimagf(v0));\n    float complex pa[L];\n    for (i=0; i<L; i++) {\n        pa[i] = Wp*_Complex_I*ellip_cdf(u[i]-_Complex_I*v0, k, n);\n        printf(""pa[%3u]     : %12.8f + j*%12.8f\\n"", i, crealf(pa[i]), cimagf(pa[i]));\n    }\n    float complex pa0 = Wp * _Complex_I*ellip_snf(_Complex_I*v0, k, n);\n    printf(""pa0         : %12.8f + j*%12.8f\\n"", crealf(pa0), cimagf(pa0));\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: You are designing a software-defined radio application that supports multiple modulation schemes. Your task is to implement a function that will determine if a given modulation scheme is of the APSK type. Write a C function called `liquid_modem_is_apsk` that takes a parameter `_ms` of type `modulation_scheme` and returns 1 if the modulation scheme is APSK (Amplitude Phase Shift Keying) and 0 otherwise. The function should handle APSK schemes of 4, 8, 16, 32, 64, 128, and 256 constellations. Ensure to use a `switch` statement in your code.","//...\nint liquid_modem_is_apsk(modulation_scheme _ms)\n{\n    switch (_ms) {\n    case LIQUID_MODEM_APSK4:\n    case LIQUID_MODEM_APSK8:\n    case LIQUID_MODEM_APSK16:\n    case LIQUID_MODEM_APSK32:\n    case LIQUID_MODEM_APSK64:\n    case LIQUID_MODEM_APSK128:\n    case LIQUID_MODEM_APSK256:\n        return 1;\n    default:\n        return 0;\n    }\n    return 0;\n}\n//...')
"
"('Prompt: You are developing a software-defined radio application and want to verify the correctness of your modulation and demodulation functions for a specific modulation scheme. Write a function that tests the modulation and demodulation process for the 32-symbol square amplitude modulation (SQAM32) scheme. Ensure that the demodulated symbols match the original symbols, and check for phase error and error vector magnitude. Additionally, calculate and check the average energy per symbol for the modulated signal. Use appropriate testing macros to validate the results.","//...\nvoid modemcf_test_mod_demod(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float e = 0.0f;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate(demod, x, &s);\n        CONTEND_EQUALITY(s, i);\n        CONTEND_DELTA( modemcf_get_demodulator_phase_error(demod), 0.0f, 1e-3f);\n        CONTEND_DELTA( modemcf_get_demodulator_evm(demod), 0.0f, 1e-3f);\n        e += crealf(x*conjf(x));\n    }\n    e = sqrtf(e / (float)M);\n    CONTEND_DELTA(e,1.0f,1e-3f);\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_mod_demod_sqam32()    { modemcf_test_mod_demod(LIQUID_MODEM_SQAM32);    }\n//...')
"
"('Prompt: Can you provide a code snippet that demonstrates how to perform vector-matrix multiplication using a sparse binary matrix in C?. Scenario: You are looking to implement a function that performs vector-matrix multiplication using a sparse binary matrix in C. The matrix A is created with dimensions 8x12 and populated with certain non-zero values at specific indices. The input vector x is defined with 12 elements and the expected output vector y_test is provided. The function should perform the multiplication and compare the output with the expected result. Additionally, you want to print out the matrix, vector inputs, and outputs for verification.","//...\nvoid autotest_smatrixb_vmul()\n{\n    smatrixb A = smatrixb_create(8,12);\n    smatrixb_set(A,0,0,  1);\n    smatrixb_set(A,2,0,  1);\n    smatrixb_set(A,6,0,  1);\n    smatrixb_set(A,3,2,  1);\n    smatrixb_set(A,6,2,  1);\n    smatrixb_set(A,7,2,  1);\n    smatrixb_set(A,1,3,  1);\n    smatrixb_set(A,7,5,  1);\n    smatrixb_set(A,3,6,  1);\n    smatrixb_set(A,5,6,  1);\n    smatrixb_set(A,7,6,  1);\n    smatrixb_set(A,3,7,  1);\n    smatrixb_set(A,2,8,  1);\n    smatrixb_set(A,5,8,  1);\n    smatrixb_set(A,2,9,  1);\n    smatrixb_set(A,5,10, 1);\n    smatrixb_set(A,6,10, 1);\n    smatrixb_set(A,6,11, 1);\n    unsigned char x[12]     = {1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1};\n    unsigned char y_test[8] = {1, 0, 1, 1, 0, 1, 0, 0};\n    unsigned char y[8];\n    smatrixb_vmul(A,x,y);\n    CONTEND_EQUALITY( y[0], y_test[0] );\n    CONTEND_EQUALITY( y[1], y_test[1] );\n    CONTEND_EQUALITY( y[2], y_test[2] );\n    CONTEND_EQUALITY( y[3], y_test[3] );\n    CONTEND_EQUALITY( y[4], y_test[4] );\n    CONTEND_EQUALITY( y[5], y_test[5] );\n    CONTEND_EQUALITY( y[6], y_test[6] );\n    CONTEND_EQUALITY( y[7], y_test[7] );\n    if (liquid_autotest_verbose) {\n        printf(""\\ncompact form:\\n"");\n        smatrixb_print(A);\n        printf(""\\nexpanded form:\\n"");\n        smatrixb_print_expanded(A);\n        unsigned int i;\n        unsigned int j;\n        printf(""x = ["");\n        for (j=0; j<12; j++) printf(""%2u"", x[j]);\n        printf("" ];\\n"");\n        printf(""y      = ["");\n        for (i=0; i<8; i++) printf(""%2u"", y[i]);\n        printf("" ];\\n"");\n        printf(""y_test = ["");\n        for (i=0; i<8; i++) printf(""%2u"", y_test[i]);\n        printf("" ];\\n"");\n    }\n    smatrixb_destroy(A);\n}\nvoid autotest_smatrixb_vmulf()\n{\n    float tol = 1e-6f;\n    smatrixb A = smatrixb_create(8,12);\n    smatrixb_set(A,0,0,  1);\n    smatrixb_set(A,2,0,  1);\n    smatrixb_set(A,6,0,  1);\n    smatrixb_set(A,3,2,  1);\n    smatrixb_set(A,6,2,  1);\n    smatrixb_set(A,7,2,  1);\n    smatrixb_set(A,1,3,  1);\n    smatrixb_set(A,7,5,  1);\n    smatrixb_set(A,3,6,  1);\n    smatrixb_set(A,5,6,  1);\n    smatrixb_set(A,7,6,  1);\n    smatrixb_set(A,3,7,  1);\n    smatrixb_set(A,2,8,  1);\n    smatrixb_set(A,5,8,  1);\n    smatrixb_set(A,2,9,  1);\n    smatrixb_set(A,5,10, 1);\n    smatrixb_set(A,6,10, 1);\n    smatrixb_set(A,6,11, 1);\n    float x[12] = {\n        3.4,  -5.7,   0.3,   2.3,   1.9,   3.9,\n        2.3,  -4.0,  -0.5,   1.5,  -0.6,  -1.0};\n    float y_test[8] = {\n        3.4,   2.3,   4.4,  -1.4,   0.0,   1.2,   2.1,   6.5};\n    float y[8];\n    smatrixb_vmulf(A,x,y);\n    CONTEND_DELTA( y[0], y_test[0], tol );\n    CONTEND_DELTA( y[1], y_test[1], tol );\n    CONTEND_DELTA( y[2], y_test[2], tol );\n    CONTEND_DELTA( y[3], y_test[3], tol );\n    CONTEND_DELTA( y[4], y_test[4], tol );\n    CONTEND_DELTA( y[5], y_test[5], tol );\n    CONTEND_DELTA( y[6], y_test[6], tol );\n    CONTEND_DELTA( y[7], y_test[7], tol );\n    if (liquid_autotest_verbose) {\n        printf(""\\ncompact form:\\n"");\n        smatrixb_print(A);\n        printf(""\\nexpanded form:\\n"");\n        smatrixb_print_expanded(A);\n        unsigned int i;\n        unsigned int j;\n        printf(""x = ["");\n        for (j=0; j<12; j++) printf(""%8.4f"", x[j]);\n        printf("" ];\\n"");\n        printf(""y      = ["");\n        for (i=0; i<8; i++) printf(""%8.4f"", y[i]);\n        printf("" ];\\n"");\n        printf(""y_test = ["");\n        for (i=0; i<8; i++) printf(""%8.4f"", y_test[i]);\n        printf("" ];\\n"");\n    }\n    smatrixb_destroy(A);\n}\n//...')
"
'Scenario: You are working on a project that requires sorting a list of numbers in descending order using Python.. . Prompt: Can you provide me with a Python code snippet to sort a list of numbers in descending order?,'
"('Write a function `testbench_eqlms` that simulates an adaptive equalizer using the Least Mean Squares (LMS) algorithm. The function should take parameters for the equalizer configuration, including tap length `k`, delay `m`, Beta coefficient, initialization method, oversampling ratio `p`, step size `mu`, number of symbols, update method, and modulation scheme `ms`. The function will generate random symbols, modulate them, pass them through a channel with known impulse response `h`, and adaptively equalize the received symbols using the LMS algorithm. The function should calculate the Root Mean Square Error (RMSE) and should print the result in dB. Additionally, the function should conduct a test to ensure the RMSE is less than -20 dB. Remember to create and destroy the necessary objects like the modem, filters, and equalizer at the beginning and end of the function.","//...\nvoid testbench_eqlms(unsigned int k, unsigned int m, float beta, int init,\n                     unsigned int p, float mu, unsigned int num_symbols,\n                     int update, int ms)\n{\n    unsigned int   i;\n    modemcf        mod    = modemcf_create(ms);\n    firinterp_crcf interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,k,m,beta,0);\n    float complex h[5] = {\n         1.00f +  0.00f*_Complex_I,\n         0.00f + -0.01f*_Complex_I,\n        -0.11f +  0.02f*_Complex_I,\n         0.02f +  0.01f*_Complex_I,\n        -0.09f + -0.04f*_Complex_I };\n    firfilt_cccf fchannel = firfilt_cccf_create(h,5);\n    float complex hp[2*k*p+1];\n    for (i=0; i<2*k*p+1; i++)\n        hp[i] = sincf( (float)i/(float)k - p) * liquid_hamming(i,2*k*p+1) / k;\n    eqlms_cccf eq;\n    switch (init) {\n    case 0: eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_ARKAISER,k,p,beta,0); break;\n    case 1: eq = eqlms_cccf_create_lowpass (2*k*p+1, 0.5f/(float)k); break;\n    case 2: eq = eqlms_cccf_create         (hp, 2*k*p+1); break; \n    default:eq = eqlms_cccf_create         (NULL, 2*k*p+1); break; \n    }\n    eqlms_cccf_set_bw(eq, mu);\n    float complex buf[k];                   \n    float complex sym_in, sym_out;          \n    wdelaycf buf_sym = wdelaycf_create(m+p);\n    float rmse = 0.0f; \n    for (i=0; i<2*num_symbols; i++) {\n        unsigned int sym = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod, sym, &sym_in);\n        wdelaycf_push(buf_sym, sym_in);\n        firinterp_crcf_execute(interp, sym_in, buf);\n        firfilt_cccf_execute_block(fchannel, buf, k, buf);\n        eqlms_cccf_decim_execute(eq, buf, &sym_out, k);\n        if (i < m + p) continue;\n        wdelaycf_read(buf_sym, &sym_in);\n        if (i < num_symbols) {\n            float complex d_hat;\n            unsigned int  index;\n            switch (update) {\n            case 0: eqlms_cccf_step(eq, sym_in, sym_out); break; \n            case 1: eqlms_cccf_step_blind(eq, sym_out);   break; \n            case 2:\n                modemcf_demodulate(mod, sym_out, &index);\n                modemcf_get_demodulator_sample(mod, &d_hat);\n                eqlms_cccf_step(eq, d_hat, sym_out);\n                break;\n            default:;\n            }\n            continue;\n        }\n        float error = cabsf(sym_in-sym_out);\n        rmse += error * error;\n#if 0\n        if (liquid_autotest_verbose) {\n            printf(""%3u : x = {%12.8f,%12.8f}, y = {%12.8f,%12.8f}, error=%12.8f %s\\n"",\n                    i, crealf(sym_in ), cimagf(sym_in ), crealf(sym_out), cimagf(sym_out),\n                    error, error > tol ? ""*"" : """");\n        }\n#endif\n    }\n    rmse = 10*log10f( rmse/num_symbols );\n    printf(""rmse : %.3f dB\\n"", rmse);\n    CONTEND_LESS_THAN(rmse, -20.0f);\n    wdelaycf_destroy(buf_sym);\n    firfilt_cccf_destroy(fchannel);\n    firinterp_crcf_destroy(interp);\n    eqlms_cccf_destroy(eq);\n    modemcf_destroy(mod);\n}\n//...')
"
"('Prompt: You are working on a gradient search algorithm in C, and you need to implement a line search function that takes a utility function, user data, direction, number of elements, array of input values, array of search directions, and an initial step size as parameters. The function should perform a line search by updating the input values based on the search directions and the step size, evaluating the utility function at each step, and adjusting the step size accordingly to find the optimal value. Additionally, the function should include debug output for monitoring the process. Can you provide the C code for the `gradsearch_linesearch` function as described?","//...\nfloat gradsearch_linesearch(utility_function _utility,\n                            void  *          _userdata,\n                            int              _direction,\n                            unsigned int     _n,\n                            float *          _x,\n                            float *          _p,\n                            float            _alpha)\n{\n#if DEBUG_GRADSEARCH\n    unsigned int i;\n    printf(""  linesearch v: {"");\n    for (i=0; i<_n; i++)\n        printf(""%8.4f"", _x[i]);\n    printf(""}\\n"");\n    printf(""  linesearch g: {"");\n    for (i=0; i<_n; i++)\n        printf(""%8.4f"", _p[i]);\n    printf(""}\\n"");\n#endif\n    float u0 = _utility(_userdata, _x, _n);\n    float alpha = _alpha;\n    float dir = _direction == LIQUID_OPTIM_MINIMIZE ? 1.0f : -1.0f;\n    float x_prime[_n];\n    int continue_running = 1;\n    unsigned int num_iterations = 0;\n    unsigned int max_iterations = 250;\n    float gamma = 2.00;\n    while (continue_running) {\n        num_iterations++;\n        unsigned int i;\n        for (i=0; i<_n; i++)\n            x_prime[i] = _x[i] - dir*alpha*_p[i];\n        float uls = _utility(_userdata, x_prime, _n);\n#if DEBUG_GRADSEARCH\n        printf(""  linesearch %6u : alpha=%12.6f, u0=%12.8f, uls=%12.8f\\n"", num_iterations, alpha, u0, uls);\n#endif\n        if ( (_direction == LIQUID_OPTIM_MINIMIZE && uls > u0) ||\n             (_direction == LIQUID_OPTIM_MAXIMIZE && uls < u0) )\n        {\n            alpha *= 1.0f/gamma;\n            continue_running = 0;\n        } else if ( num_iterations >= max_iterations ) {\n            continue_running = 0;\n        } else {\n            u0 = uls;\n            alpha *= gamma;\n        }\n    }\n    return alpha;\n}\n//...')
"
"('Here is a prompt for the code you provided:. . ""Imagine you are working on a digital communication system that uses FEC Golay encoding. You have a set of parameters, matrices, and vectors defined in the code. Your task is to simulate the encoding and decoding process using Golay encoding to correct errors. Can you write a C program that takes an original message, encodes it, introduces errors, decodes the received message, and estimates the error vector to correct the errors?""","#define DEBUG_FEC_GOLAY 1\nunsigned int P[12] = {\n    0x08ed, 0x01db, 0x03b5, 0x0769,\n    0x0ed1, 0x0da3, 0x0b47, 0x068f,\n    0x0d1d, 0x0a3b, 0x0477, 0x0ffe};\n#if 0\nunsigned int G[12] = {\n    0x008ed800, 0x001db400, 0x003b5200, 0x00769100,\n    0x00ed1080, 0x00da3040, 0x00b47020, 0x0068f010,\n    0x00d1d008, 0x00a3b004, 0x00477002, 0x00ffe001};\n#endif\nunsigned int Gt[24] = {\n    0x08ed, 0x01db, 0x03b5, 0x0769, 0x0ed1, 0x0da3, 0x0b47, 0x068f, \n    0x0d1d, 0x0a3b, 0x0477, 0x0ffe, 0x0800, 0x0400, 0x0200, 0x0100, \n    0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004, 0x0002, 0x0001};\nunsigned int H[12] = {\n    0x008008ed, 0x004001db, 0x002003b5, 0x00100769,\n    0x00080ed1, 0x00040da3, 0x00020b47, 0x0001068f,\n    0x00008d1d, 0x00004a3b, 0x00002477, 0x00001ffe};\nvoid print_bitstring(unsigned int _x,\n                     unsigned int _n)\n{\n    unsigned int i;\n    printf(""    "");\n    for (i=0; i<_n; i++)\n        printf(""%1u "", (_x >> (_n-i-1)) & 1);\n    printf(""\\n"");\n}\nint main(int argc, char*argv[])\n{\n    unsigned int i;\n    unsigned int err = 0x00000d00;\n    unsigned int m  = 0x0bcd;\n    unsigned int v;     \n    unsigned int e;     \n    unsigned int r;     \n    unsigned int s;     \n    unsigned int e_hat; \n    unsigned int v_hat; \n    unsigned int m_hat; \n    printf(""m (original message):\\n"");\n    print_bitstring(m,12);\n    v = 0;\n    for (i=0; i<24; i++) {\n        v <<= 1;\n        v |= liquid_count_ones_mod2(Gt[i] & m);\n    }\n    printf(""v (encoded/transmitted message):\\n"");\n    print_bitstring(v,24);\n    e = err;\n    printf(""e (error vector):\\n"");\n    print_bitstring(e,24);\n    r = v ^ e;\n    printf(""r (received vector):\\n"");\n    print_bitstring(r,24);\n    s = 0;\n    for (i=0; i<12; i++) {\n        s <<= 1;\n        s |= liquid_count_ones_mod2(H[i] & r);\n    }\n    printf(""s (syndrome vector):\\n"");\n    print_bitstring(s,12);\n    unsigned int ws = liquid_count_ones(s);\n    printf(""w(s) = %u\\n"", ws);\n    e_hat = 0;\n    if (ws <= 3) {\n        printf(""    w(s) <= 3: estimating error vector as [s, 0(12)]\\n"");\n        e_hat = s << 12;\n    } else {\n        printf(""    searching for w(s + p_i) <= 2...\\n"");\n        unsigned int j;\n        unsigned int spj;\n        int flag3 = 0;\n        unsigned int p3_index = 0;\n        for (j=0; j<12; j++) {\n            spj = s ^ P[j];\n            unsigned int wj = liquid_count_ones(spj);\n            printf(""    w(s + p[%2u]) = %2u%s\\n"", j, wj, wj <= 2 ? "" *"" : """");\n            if (wj <= 2) {\n                flag3 = 1;\n                p3_index = j;\n                break;\n            }\n        }\n        if (flag3) {\n            printf(""    w(s + p[%2u]) <= 2: estimating error vector as [s+p[%2u],u[%2u]]\\n"", p3_index, p3_index, p3_index);\n            e_hat = ((s ^ P[p3_index]) << 12) | (1 << (11-p3_index));\n        } else {\n            unsigned int sP = 0;\n            for (i=0; i<12; i++) {\n                sP <<= 1;\n                sP |= liquid_count_ones_mod2(s & P[i]);\n            }\n            printf(""s*P:\\n"");\n            print_bitstring(sP,12);\n            unsigned int wsP = liquid_count_ones(sP);\n            printf(""w(s*P) = %u\\n"", wsP);\n            if (wsP == 2 || wsP == 3) {\n                printf(""    w(s*P) in [2,3]: estimating error vector as [0(12), s*P]\\n"");\n                e_hat = sP;\n            } else {\n                printf(""    searching for w(s*P + p_i) == 2...\\n"");\n                unsigned int j;\n                unsigned int sPpj;\n                int flag6 = 0;\n                unsigned int p6_index = 0;\n                for (j=0; j<12; j++) {\n                    sPpj = sP ^ P[j];\n                    unsigned int wj = liquid_count_ones(sPpj);\n                    printf(""    w(s*P + p[%2u]) = %2u%s\\n"", j, wj, wj == 2 ? "" *"" : """");\n                    if (wj == 2) {\n                        flag6 = 1;\n                        p6_index = j;\n                        break;\n                    }\n                }\n                if (flag6) {\n                    printf(""    w(s*P + p[%2u]) == 2: estimating error vector as [u[%2u],s*P+p[%2u]]\\n"", p6_index, p6_index, p6_index);\n                    e_hat = (1 << (23-p6_index)) | (sP ^ P[p6_index]);\n                } else {\n                    printf(""  **** decoding error\\n"");\n                }\n            }\n        }\n    }\n    printf(""e-hat (estimated error vector):\\n"");\n    print_bitstring(e_hat,24);\n    v_hat = r ^ e_hat;\n    printf(""v-hat (estimated transmitted vector):\\n"");\n    print_bitstring(v_hat,24);\n    print_bitstring(v,    24);\n    printf(""decoding errors (encoded)  : %2u / 24\\n"", count_bit_errors(v, v_hat));\n    m_hat = v_hat & ((1<<12)-1);\n    printf(""decoding errors (original) : %2u / 12\\n"", count_bit_errors(m, m_hat));\n    return 0;\n}')
"
"('Create a utility function named `utility_max_autotest` that takes in a void pointer `_userdata`, an array of floats `_v`, and an unsigned integer `_n`. The function should first check if `_n` is equal to 0 and return 0.0f with an error message if so. Then, it should calculate a value `t` and `sigma` and iterate over the elements of `_v` to update `t` and `sigma` accordingly. Finally, return the exponential of `-t` as the result of the function.","//...\nfloat utility_max_autotest(void *       _userdata,\n                           float *      _v,\n                           unsigned int _n)\n{\n    if (_n == 0) {\n        liquid_error(LIQUID_EICONFIG,""liquid_invgauss(), input vector length cannot be zero"");\n        return 0.0f;\n    }\n    float t = 0.0f;\n    float sigma = 1.0f;\n    unsigned int i;\n    for (i=0; i<_n; i++) {\n        t += (_v[i]-1.0f)*(_v[i]-1.0f) / (sigma*sigma);\n        sigma *= 1.5f;\n    }\n    return expf(-t);\n}\n//...')
"
"('Prompt: ""I need a function that performs benchmarking for a FIR Hilbert-Huang transform decimation with a decimation factor of 9. Can you provide me with the code for that function?""","//...\nvoid benchmark_firhilbf_decim_m9    F\n//...')
"
"('Please provide a function that creates a maximal-length sequence generator. The generator should have parameters to define the feedback taps (_m, _g), as well as an initial state (_a). The function should return a pointer to a struct that stores these parameters and additional metadata. Ensure that the provided feedback taps are within a specified range and bound the initial state based on the polynomial.","//...\nstruct msequence_s {\n    unsigned int m;     \n    unsigned int g;     \n    unsigned int a;     \n    unsigned int n;     \n    unsigned int state; \n};\nmsequence msequence_create(unsigned int _m,\n                           unsigned int _g,\n                           unsigned int _a)\n{\n    if (_m > LIQUID_MAX_MSEQUENCE_M || _m < LIQUID_MIN_MSEQUENCE_M)\n        return liquid_error_config(""msequence_create(), m (%u) not in range"", _m);\n    msequence ms = (msequence) malloc(sizeof(struct msequence_s));\n    ms->m = _m;         \n    ms->g = _g;         \n    ms->a = _a;         \n    ms->n = (1<<_m)-1;  \n    ms->state = ms->a;  \n    return ms;\n}\n//...')
"
"('Prompt: Design a test bench for a numerical controlled oscillator (NCO) with carrier recovery using continuous phase for mixing complex signals. The test bench should simulate modulator output with a randomly generated signal and then use the NCO to mix it up. Verify that the output is correct by comparing it to the expected result using a specified tolerance level. Finally, create an automated test for the scenario where the NCO is initialized with a voltage-controlled oscillator (VCO) type, phase of 0, and frequency of 0.","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_vco_0() { testbench_nco_crcf_mix(LIQUID_VCO,  0.000f,  0.000f); }\n//...')
"
"('Prompt: . You are developing a testbench for a symbolic tracking receiver in a communication system. The receiver uses a symbol stream generator, a channel model with AWGN and carrier offset, and a symbolic tracking algorithm to demodulate symbols. The testbench function `testbench_symtrack_cccf` takes inputs for the filter type, number of symbols, noise floor, SNR, bandwidth, phase offset, buffer length, and modulation scheme. It generates symbols, passes them through the channel, and runs the symbolic tracking algorithm. After processing all symbols, it calculates the Error Vector Magnitude (EVM) and prints the result. You need to implement autotest functions for BPSK and QPSK modulation schemes, as well as invalid and valid configuration tests for the symbolic tracking algorithm.","void testbench_symtrack_cccf(unsigned int _k, unsigned int _m, float _beta, int _ms)\n{\n    int          ftype       = LIQUID_FIRFILT_ARKAISER;\n    unsigned int num_symbols = 6000;    \n    float        noise_floor = -30.0f;  \n    float        SNRdB       = 30.0f;   \n    float        bandwidth   =  0.15f;  \n    float        dphi        =  0.02f;  \n    float        phi         =  2.1f;   \n    unsigned int    buf_len = 800;  \n    float complex   buf_0[buf_len]; \n    float complex   buf_1[buf_len]; \n    symstreamcf gen = symstreamcf_create_linear(ftype,_k,2*_m,_beta,_ms);\n    channel_cccf channel = channel_cccf_create();\n    channel_cccf_add_awgn          (channel, noise_floor, SNRdB);\n    channel_cccf_add_carrier_offset(channel, dphi, phi);\n    symtrack_cccf symtrack = symtrack_cccf_create(ftype,_k,_m,_beta,_ms);\n    symtrack_cccf_set_bandwidth(symtrack,bandwidth);\n    if (liquid_autotest_verbose)\n        symtrack_cccf_print(symtrack);\n    unsigned int total_samples = 0;\n    unsigned int num_symbols_evm = 0;\n    float        evm = 0.0f;\n    modemcf demod = modemcf_create(_ms); \n    while (total_samples < num_symbols * _k)\n    {\n        symstreamcf_write_samples(gen, buf_0, buf_len);\n        channel_cccf_execute_block(channel, buf_0, buf_len, buf_0);\n        unsigned int num_symbols_sync;\n        symtrack_cccf_execute_block(symtrack, buf_0, buf_len, buf_1, &num_symbols_sync);\n        total_samples += buf_len;\n        if (total_samples > 0.80 * num_symbols * _k) {\n            unsigned int i, sym;\n            for (i=0; i<num_symbols_sync; i++) {\n                modemcf_demodulate(demod, buf_1[i], &sym);\n                float err = modemcf_get_demodulator_evm(demod);\n                evm += err*err;\n            }\n            num_symbols_evm += num_symbols_sync;\n        }\n    }\n    symstreamcf_destroy  (gen);\n    channel_cccf_destroy (channel);\n    symtrack_cccf_destroy(symtrack);\n    modemcf_destroy(demod);\n    evm = 10*log10f(evm / (float)num_symbols_evm);\n    printf(""EVM: %12.8f, %u\\n"", evm, num_symbols_evm);\n    CONTEND_LESS_THAN(evm, -15.0f);\n}\nvoid autotest_symtrack_cccf_bpsk() { testbench_symtrack_cccf( 2,12,0.25f,LIQUID_MODEM_BPSK); }\nvoid autotest_symtrack_cccf_qpsk() { testbench_symtrack_cccf( 2,12,0.25f,LIQUID_MODEM_QPSK); }\nvoid autotest_symtrack_cccf_config_invalid()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping symtrack_cccf config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(symtrack_cccf_create(LIQUID_FIRFILT_RRC,   1, 12, 0.25f, LIQUID_MODEM_QPSK));\n    CONTEND_ISNULL(symtrack_cccf_create(LIQUID_FIRFILT_RRC,   2,  0, 0.25f, LIQUID_MODEM_QPSK));\n    CONTEND_ISNULL(symtrack_cccf_create(LIQUID_FIRFILT_RRC,   2, 12, 2.00f, LIQUID_MODEM_QPSK));\n    CONTEND_ISNULL(symtrack_cccf_create(LIQUID_FIRFILT_RRC,   2, 12, 0.25f, LIQUID_MODEM_UNKNOWN));\n    CONTEND_ISNULL(symtrack_cccf_create(LIQUID_FIRFILT_RRC,   2, 12, 0.25f, LIQUID_MODEM_NUM_SCHEMES));\n    symtrack_cccf q = symtrack_cccf_create_default();\n    CONTEND_INEQUALITY(LIQUID_OK, symtrack_cccf_set_modscheme(q, LIQUID_MODEM_NUM_SCHEMES))\n    CONTEND_INEQUALITY(LIQUID_OK, symtrack_cccf_set_bandwidth(q, -1.0f))\n    symtrack_cccf_destroy(q);\n}\nvoid autotest_symtrack_cccf_config_valid()\n{\n    symtrack_cccf q =\n        symtrack_cccf_create(LIQUID_FIRFILT_ARKAISER, 4, 12, 0.25f, LIQUID_MODEM_QAM64);\n    CONTEND_EQUALITY(LIQUID_OK, symtrack_cccf_adjust_phase(q, 0.1f) );\n    CONTEND_EQUALITY(LIQUID_OK, symtrack_cccf_set_eq_cm   (q      ) );\n    CONTEND_EQUALITY(LIQUID_OK, symtrack_cccf_set_eq_dd   (q      ) );\n    CONTEND_EQUALITY(LIQUID_OK, symtrack_cccf_set_eq_off  (q      ) );\n    CONTEND_EQUALITY(symtrack_cccf_get_k(q),    4);\n    CONTEND_EQUALITY(symtrack_cccf_get_m(q),    12);\n    CONTEND_EQUALITY(symtrack_cccf_get_beta(q), 0.25f);\n    CONTEND_EQUALITY(symtrack_cccf_get_ftype(q), LIQUID_FIRFILT_ARKAISER);\n    CONTEND_EQUALITY(symtrack_cccf_get_modscheme(q), LIQUID_MODEM_QAM64);\n    CONTEND_EQUALITY(symtrack_cccf_set_bandwidth(q,  0.1f), LIQUID_OK);\n    CONTEND_EQUALITY(symtrack_cccf_get_bandwidth(q), 0.1f);\n    CONTEND_EQUALITY(symtrack_cccf_set_modscheme(q, LIQUID_MODEM_APSK16), LIQUID_OK);\n    CONTEND_EQUALITY(symtrack_cccf_get_modscheme(q), LIQUID_MODEM_APSK16);\n    symtrack_cccf_destroy(q);\n}')
"
"('Prompt: Develop a C program that implements a communications system simulation using General Minimum Squared Error (GMSE) and Equalizer Least Mean Squares (EQLMS) algorithms for GMSK modulation. Include functionality to generate output results to a specific file, visualize signal data, and calculate Power Spectral Density (PSD). Ensure the program initializes necessary parameters like modulation index, beta, number of symbols, and FFT size. Make use of appropriate libraries and data structures for signal processing operations.","#define OUTPUT_FILENAME ""gmsk_eqlms_example.m""\nint main(int argc, char*argv[]) {\n    unsigned int k      =     4;    \n    float        beta   =  0.3f;    \n    unsigned int p      =     3;    \n    float        mu     = 0.08f;    \n    unsigned int num_symbols = 2400;\n    unsigned int nfft        = 1200;\n    gmskmod mod = gmskmod_create(k, 3, beta);\n    eqlms_cccf eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_GMSKRX, k, p, beta, 0.0f);\n    eqlms_cccf_set_bw(eq, mu);\n    spgramcf q = spgramcf_create_default(nfft);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""k = %u;\\n"", k);\n    fprintf(fid,""num_symbols = %u;\\n"", num_symbols);\n    fprintf(fid,""nfft = %u;\\n"", nfft);\n    fprintf(fid,""syms = zeros(1,num_symbols);\\n"");\n    fprintf(fid,""psd  = zeros(1,nfft);\\n"");\n    float complex buf[k];\n    unsigned int i;\n    for (i=0; i<num_symbols; i++)\n    {\n        gmskmod_modulate(mod, rand() & 1, buf);\n        eqlms_cccf_push_block(eq, buf, k);\n        float complex d_hat;\n        eqlms_cccf_execute(eq, &d_hat);\n        spgramcf_write(q, buf, k);\n        fprintf(fid,""syms(%4u) = %12.4e + %12.4ej;\\n"", i+1, crealf(d_hat), cimagf(d_hat));\n        if (i < p) continue;\n        float complex d_prime = (crealf(d_hat) > 0 ? 1 : -1) * M_SQRT1_2 +\n                                (cimagf(d_hat) > 0 ? 1 : -1) * M_SQRT1_2 * _Complex_I;\n        eqlms_cccf_step(eq, d_prime, d_hat);\n    }\n    unsigned int hp_len = 2*k*p+1;   \n    float complex hp[hp_len];           \n    eqlms_cccf_copy_coefficients(eq, hp);\n    fprintf(fid,""hp = zeros(1,%u);\\n"", hp_len);\n    for (i=0; i<hp_len; i++)\n        fprintf(fid,""hp(%3u) = %12.4e + %12.4ej;\\n"", i+1, crealf(hp[i]), cimagf(hp[i]));\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    for (i=0; i<nfft; i++)\n        fprintf(fid,""psd(%6u) = %12.4e;\\n"", i+1, psd[i]);\n    fprintf(fid,""np = round(0.75*num_symbols);\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""plot(syms(1:np),  \'x\',\'Color\',[1 1 1]*0.7,...\\n"");\n    fprintf(fid,""     syms(np:end),\'x\',\'Color\',[0 0.2 0.4]);\\n"");\n    fprintf(fid,""axis([-1 1 -1 1]*1.2); grid on; axis square;\\n"");\n    fprintf(fid,""xlabel(\'I\'); ylabel(\'Q\'); legend(\'first half\',\'last half\');\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""f=[0:(nfft-1)]/nfft-0.5;\\n"");\n    fprintf(fid,""plot(f, psd-10*log10(k), f, 20*log10(abs(fftshift(fft(hp,nfft)))));\\n"");\n    fprintf(fid,""axis([-0.5 0.5 -50 10]); grid on;\\n"");\n    fprintf(fid,""xlabel(\'Normalized Frequency\'); ylabel(\'PSD [dB]\');\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    gmskmod_destroy(mod);\n    eqlms_cccf_destroy(eq);\n    spgramcf_destroy(q);\n    return 0;\n}')
"
"('""Please provide a code snippet that tests symbol synchronizer function with specific parameters for a radio frequency receiver scenario. The test should use a raised-cosine filter for interpolation and decimation, with specified filter coefficients and symbol timing offset. The test should also validate the correct symbol synchronization by computing the error between received symbols and expected symbols within a specified tolerance. Additionally, the test should output the results for further analysis and verification. The testing scenario should involve symbol synchronization for a digital communication system.""","//...\nvoid symsync_rrrf_test(unsigned int _k,\n                       unsigned int _m,\n                       float        _beta,\n                       float        _tau,\n                       float        _rate)\n{\n    float        tol        =  0.2f;    \n    unsigned int k          =  _k;      \n    unsigned int m          =  _m;      \n    float        beta       =  _beta;   \n    unsigned int num_filters= 32;       \n    unsigned int num_symbols_init=200;  \n    unsigned int num_symbols_test=100;  \n    liquid_firfilt_type ftype_tx = LIQUID_FIRFILT_ARKAISER;\n    liquid_firfilt_type ftype_rx = LIQUID_FIRFILT_ARKAISER;\n    float bt    =  0.02f;               \n    float tau   =  _tau;                \n    float rate  =  _rate;               \n    unsigned int num_symbols = num_symbols_init + num_symbols_test;\n    unsigned int num_samples = k*num_symbols;\n    unsigned int num_samples_resamp = (unsigned int) ceilf(num_samples*rate*1.1f) + 4;\n    while (tau < 0) tau += 1.0f;    \n    float g = k*tau;                \n    int ds=floorf(g);               \n    float dt = (g - (float)ds);     \n    if (dt > 0.5f) {                \n        dt -= 1.0f;\n        ds++;\n    }\n    unsigned int i;\n    float s[num_symbols];           \n    float x[num_samples];           \n    float y[num_samples_resamp];    \n    float z[num_symbols + 64];      \n    msequence ms = msequence_create_default(10);\n    for (i=0; i<num_symbols; i++)\n        s[i] = (msequence_generate_symbol(ms,1) ? -1.0f : 1.0f);\n    msequence_destroy(ms);\n    firinterp_rrrf interp = firinterp_rrrf_create_prototype(ftype_tx,k,m,beta,dt);\n    firinterp_rrrf_execute_block(interp, s, num_symbols, x);\n    firinterp_rrrf_destroy(interp);\n    unsigned int resamp_len = 10*k; \n    float resamp_bw = 0.45f;        \n    float resamp_As = 60.0f;        \n    unsigned int resamp_npfb = 64;  \n    resamp_rrrf resamp = resamp_rrrf_create(rate, resamp_len, resamp_bw, resamp_As, resamp_npfb);\n    unsigned int ny;\n    resamp_rrrf_execute_block(resamp, x, num_samples, y, &ny);\n    resamp_rrrf_destroy(resamp);\n    symsync_rrrf sync = symsync_rrrf_create_rnyquist(ftype_rx, k, m, beta, num_filters);\n    symsync_rrrf_set_lf_bw(sync,bt);\n    unsigned int nz;\n    symsync_rrrf_execute(sync, y, ny, z, &nz);\n    symsync_rrrf_destroy(sync);\n    unsigned int delay = m + 10 + m;\n    if (liquid_autotest_verbose) {\n        printf(""symsync_rrrf_test(),\\n"");\n        printf(""    k       :   %u\\n"",      k);\n        printf(""    m       :   %u\\n"",      m);\n        printf(""    beta    :   %-8.4f\\n"",   beta);\n        printf(""    tau     :   %-8.4f\\n"",   tau);\n        printf(""    rate    :   %-12.8f\\n"",  rate);\n        printf(""output symbols:\\n"");\n    }\n    for (i=nz-num_symbols_test; i<nz; i++) {\n        float err = fabsf( z[i] - s[i-delay] );\n        CONTEND_LESS_THAN( err, tol );\n        if (liquid_autotest_verbose) {\n            printf(""  sym_out(%4u) = %8.4f; %% {%8.4f} e = %12.8f %s\\n"",\n                    i+1,\n                    z[i],\n                    s[i-delay],\n                    err, err < tol ? """" : ""*"");\n        }\n    }\n}\nvoid autotest_symsync_rrrf_scenario_0() { symsync_rrrf_test(2, 7, 0.35,  0.00, 1.0f    ); }\n//...')
"
"'Prompt: . You are creating a C program that interfaces with a UVC (USB Video Class) camera to capture video frames. The program needs to open and configure the UVC device, set resolution, frame rate, and format, and initialize the video stream. You also need to handle IOCTL commands for the UVC device. Please provide the code for initializing the UVC camera, handling IOCTL commands, and defining the operations related to the UVC device using the given structure.","//...\nstruct avcap_ops uvc_ops = {\n    ._open        = _uvc_open,\n    ._close       = _uvc_close,\n    .ioctl        = uvc_ioctl,\n    .start_stream = uvc_start_stream,\n    .stop_stream  = uvc_stop_stream,\n#if 0\n    .query_frame  = avcap_uvc_query_frame,\n#endif\n};\nstatic void *_uvc_open(struct avcap_ctx *avcap, const char *dev, struct avcap_config *avconf)\n{\n    uvc_error_t res;\n    struct videocap_config *conf = &avconf->video;\n    struct uvc_ctx *c = calloc(1, sizeof(struct uvc_ctx));\n    if (!c) {\n        printf(""malloc uvc_ctx failed!\\n"");\n        return NULL;\n    }\n    res = uvc_init(&c->uvc, NULL);\n    if (res < 0) {\n        uvc_perror(res, ""uvc_init"");\n        return NULL;\n    }\n    res = uvc_find_device(c->uvc, &c->dev, 0, 0, NULL);\n    if (res < 0) {\n        uvc_perror(res, ""uvc_find_device""); \n        return NULL;\n    }\n    res = uvc_open(c->dev, &c->devh);\n    if (res < 0) {\n        uvc_perror(res, ""uvc_open""); \n        return NULL;\n    }\n    avcap->conf.video.width = avconf->video.width;\n    avcap->conf.video.height = avconf->video.height;\n    avcap->conf.video.fps.num = avconf->video.fps.num;\n    avcap->conf.video.fps.den = avconf->video.fps.den;\n    avcap->conf.video.format = avconf->video.format;\n    res = uvc_get_stream_ctrl_format_size(\n                    c->devh, &c->ctrl, \n                    UVC_FRAME_FORMAT_YUYV, \n                    640, 480, 30 \n                    );\n    if (res < 0) {\n        uvc_perror(res, ""get_mode""); \n    }\n    uvc_print_stream_ctrl(&c->ctrl, stderr);\n    c->parent = avcap;\n    c->frame.type = MEDIA_TYPE_VIDEO;\n    video_frame_init(&c->frame.video, conf->format, conf->width, conf->height, MEDIA_MEM_SHALLOW);\n    return c;\n}\nstatic int uvc_ioctl(struct avcap_ctx *avcap, unsigned long int cmd, ...)\n{\n    printf(""uvc_ioctl unsupport cmd!\\n"");\n    return 0;\n}\n//...'"
('Prompt: You are working on an ARM-NEON optimized signal processing library and need to print out the coefficients of a complex dot product structure. Write a C function that prints the coefficients of the given dot product structure in a specific format.,"//...\nint dotprod_cccf_print(dotprod_cccf _q)\n{\n    printf(""dotprod_cccf [arm-neon, %u coefficients]\\n"", _q->n);\n    unsigned int i;\n    for (i=0; i<_q->n; i++)\n        printf(""  %3u : %12.9f +j%12.9f\\n"", i, _q->hi[i], _q->hq[i]);\n    return LIQUID_OK;\n}\n//...')
"
'Please provide the code related to the handling of double buffering and flushing in an LVGL display in an embedded system.,"//...\n    if(info.res == LV_COVER_RES_MASKED) return NULL;\n    info.area = area_p;\n    for(i = child_cnt - 1; i >= 0; i--) {\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic void call_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)\n{\n    LV_PROFILER_BEGIN;\n    LV_TRACE_REFR(""Calling flush_cb on (%d;%d)(%d;%d) area with %p image pointer"",\n                  (int)area->x1, (int)area->y1, (int)area->x2, (int)area->y2, (void *)px_map);\n    lv_area_t offset_area = {\n        .x1 = area->x1 + disp->offset_x,\n        .y1 = area->y1 + disp->offset_y,\n        .x2 = area->x2 + disp->offset_x,\n        .y2 = area->y2 + disp->offset_y\n    };\n    lv_display_send_event(disp, LV_EVENT_FLUSH_START, &offset_area);\n    disp->flush_cb(disp, &offset_area, px_map);\n    lv_display_send_event(disp, LV_EVENT_FLUSH_FINISH, &offset_area);\n    LV_PROFILER_END;\n}\nstatic void wait_for_flushing(lv_display_t * disp)\n{\n    LV_PROFILER_BEGIN;\n    LV_LOG_TRACE(""begin"");\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_START, NULL);\n    if(disp->flush_wait_cb) {\n        disp->flush_wait_cb(disp);\n    }\n    else {\n        while(disp->flushing);\n    }\n    disp->flushing_last = 0;\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_FINISH, NULL);\n    LV_LOG_TRACE(""end"");\n    LV_PROFILER_END;\n}\nstatic void draw_buf_flush(lv_display_t * disp)\n{\n    lv_layer_t * layer = disp->layer_head;\n    while(layer->draw_task_head) {\n        lv_draw_dispatch_wait_for_request();\n        lv_draw_dispatch();\n    }\n    if(lv_display_is_double_buffered(disp)) {\n        wait_for_flushing(disp_refr);\n    }\n    disp->flushing = 1;\n    if(disp->last_area && disp->last_part) disp->flushing_last = 1;\n    else disp->flushing_last = 0;\n    bool flushing_last = disp->flushing_last;\n    if(disp->flush_cb) {\n        call_flush_cb(disp, &disp->refreshed_area, layer->draw_buf->data);\n    }\n    if(lv_display_is_double_buffered(disp) && (disp->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT || flushing_last)) {\n        if(disp->buf_act == disp->buf_1) {\n            disp->buf_act = disp->buf_2;\n        }\n        else {\n            disp->buf_act = disp->buf_1;\n        }\n    }\n}\n//...'"
"(""Please provide the prompt for a command line utility that can execute autotest scripts for the liquid-dsp library. This utility should have various options such as running specific tests, running a specific package, running all tests in random order, listing all scripts and packages, stopping on fail, verbose mode, outputting results to a file in JSON format, etc. Additionally, the prompt should request a function to calculate the execution time of a given process using the 'struct rusage' data structure.","//...\nvoid usage()\n{\n    printf(""Usage: xautotest [OPTION]\\n"");\n    printf(""Execute autotest scripts for liquid-dsp library.\\n"");\n    printf(""  -h            display this help and exit\\n"");\n    printf(""  -t <id>       run specific test\\n"");\n    printf(""  -H <id>       hammer on a specific test\\n"");\n    printf(""  -c <count>    number of time to run hammer test\\n"");\n    printf(""  -p <id>       run specific package\\n"");\n    printf(""  -r            run all tests, random order\\n"");\n    printf(""  -R <seed>     specify random seed value\\n"");\n    printf(""  -L            lists all scripts\\n"");\n    printf(""  -l            lists all packages\\n"");\n    printf(""  -x            stop on fail\\n"");\n    printf(""  -s <string>   run all tests matching search string\\n"");\n    printf(""  -v            verbose\\n"");\n    printf(""  -q            quiet\\n"");\n    printf(""  -o <filename> output file (json)\\n"");\n}\ndouble calculate_execution_time(struct rusage _tic, struct rusage _toc)\n{\n    return _toc.ru_utime.tv_sec - _tic.ru_utime.tv_sec\n        + 1e-6*(_toc.ru_utime.tv_usec - _tic.ru_utime.tv_usec)\n        + _toc.ru_stime.tv_sec - _tic.ru_stime.tv_sec\n        + 1e-6*(_toc.ru_stime.tv_usec - _tic.ru_stime.tv_usec);\n}\n//...')
"
"('Prompt: You are working on a project involving GMSK (Gaussian Minimum Shift Keying) modulation and demodulation. You need to write a program that generates a GMSK frame, modulates it, adds noise, and then demodulates it to display the received signal. You also need to store the results in a file. Can you provide a C code snippet to accomplish this task using a callback function for GMSK frame synchronization and generating an output file named ""gmskframesync_example.m""?","#define OUTPUT_FILENAME ""gmskframesync_example.m""\nint callback(unsigned char *  _header,\n             int              _header_valid,\n             unsigned char *  _payload,\n             unsigned int     _payload_len,\n             int              _payload_valid,\n             framesyncstats_s _stats,\n             void *           _userdata)\n{\n    printf(""***** gmskframesync callback invoked *****\\n"");\n    return 0;\n}\nint main(int argc, char*argv[])\n{\n    unsigned int k           = 2;       \n    unsigned int m           = 3;       \n    float        BT          = 0.5f;    \n    unsigned int payload_len = 40;      \n    crc_scheme   check       = LIQUID_CRC_32;\n    fec_scheme   fec0        = LIQUID_FEC_HAMMING128;\n    fec_scheme   fec1        = LIQUID_FEC_NONE;\n    unsigned int i;\n    unsigned char header[8] = {0,1,2,3,4,5,6,7};\n    unsigned char payload[payload_len];\n    memset(payload, 0x00, payload_len);\n    gmskframegen fg = gmskframegen_create_set(k, m, BT);\n    gmskframegen_assemble(fg, header, payload, payload_len, check, fec0, fec1);\n    gmskframesync fs = gmskframesync_create_set(k, m, BT, callback, NULL);\n    unsigned int num_samples = gmskframegen_getframelen(fg) + 800;\n    float complex buf[num_samples];\n    memset(buf, 0x00, num_samples*sizeof(float complex));\n    gmskframegen_write(fg, buf+250, num_samples-250);\n    for (i=0; i<num_samples; i++)\n        buf[i] = 0.3*buf[i] + 0.01f*(randnf() + randnf()*_Complex_I)*M_SQRT1_2;\n    gmskframesync_execute(fs, buf, num_samples);\n    gmskframesync_print(fs);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    if (fid == NULL) {\n        fprintf(stderr,""error: %s, could not open \'%s\' for writing\\n"", argv[0], OUTPUT_FILENAME);\n        exit(1);\n    }\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""\\n"");\n    fprintf(fid,""clear all\\n"");\n    fprintf(fid,""close all\\n"");\n    fprintf(fid,""\\n"");\n    fprintf(fid,""num_samples = %u;\\n"", num_samples);\n    fprintf(fid,""y = zeros(1,num_samples);\\n"");\n    fprintf(fid,""\\n"");\n    for (i=0; i<num_samples; i++)\n        fprintf(fid,""y(%6u) = %12.4e + j*%12.4e;\\n"", i+1, crealf(buf[i]), cimagf(buf[i]));\n    fprintf(fid,""\\n"");\n    fprintf(fid,""t = 0:(num_samples-1);\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""plot(t, real(y), t,imag(y));\\n"");\n    fprintf(fid,""xlabel(\'time\');\\n"");\n    fprintf(fid,""ylabel(\'received signal\');\\n"");\n    fprintf(fid,""legend(\'real\',\'imag\',0);\\n"");\n    fclose(fid);\n    printf(""results written to \'%s\'\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
'Please provide a technical scenario where you need a function to break down a command line into individual arguments for a Windows application.,"#define _UTF8_LIB_SOURCE\n#define _CRT_SECURE_NO_WARNINGS \n#ifdef _WIN32\nint BreakArgLine(LPSTR pszCmdLine, char ***pppszArg) {\n  int i, j;\n  int argc = 0;\n  char c, c0;\n  char *pszCopy;\n  int iString = FALSE;\t\n  int nBackslash = 0;\n  char **ppszArg;\n  int iArg = FALSE;\t\n  ppszArg = (char **)malloc((argc+1)*sizeof(char *));\n  if (!ppszArg) return -1;\n  pszCopy = malloc(lstrlen(pszCmdLine) + 1);\n  if (!pszCopy) return -1;\n  for (i=0, j=0, c0=\'\\0\'; ; i++) {\n    c = pszCmdLine[i];\n    if (!c) {\t\t    \n      for ( ; nBackslash; nBackslash--) pszCopy[j++] = \'\\\\\'; \n      pszCopy[j++] = c;\n      break;\n    }\n    if ((!iArg) && (c != \' \') && (c != \'\\t\')) { \n      iArg = TRUE;\n      ppszArg[argc++] = pszCopy+j;\n      ppszArg = (char **)realloc(ppszArg, (argc+1)*sizeof(char *));\n      if (!ppszArg) return -1;\n      pszCopy[j] = c0 = \'\\0\';\n    }\n    if (c == \'\\\\\') {\t    \n      nBackslash += 1; \n      continue;\n    }\n    if (c == \'""\') {\n      if (nBackslash && iString && !pszCmdLine[i+1]) continue; \n      if (nBackslash & 1) { \n      \tfor (nBackslash >>= 1; nBackslash; nBackslash--) pszCopy[j++] = \'\\\\\';\n\tpszCopy[j++] = c0 = c;\n\tcontinue;\n      }\n      if (nBackslash) {\t    \n      \tfor (nBackslash >>= 1; nBackslash; nBackslash--) pszCopy[j++] = \'\\\\\';\n      }\n      iString = !iString;\n      continue;\n    }\n    for ( ; nBackslash; nBackslash--) pszCopy[j++] = \'\\\\\'; \n    if ((!iString) && ((c == \' \') || (c == \'\\t\'))) { \n      iArg = FALSE;\n      c = \'\\0\';\n    }\n    pszCopy[j++] = c0 = c;\n  }\n  ppszArg[argc] = NULL;\n  *pppszArg = ppszArg;\n  return argc;\n}\n_CRTIMP extern int __argc;\n_CRTIMP extern char **__argv;\n_CRTIMP extern char *_acmdln;\n_CRTIMP extern char *_pgmptr;\nint _initU(void); \nint _setargv(void) {\n  int err = _initU();\n  if (err) return err;\n  __argc = BreakArgLine(_acmdln, &__argv);\n  _pgmptr = __argv[0];\n  return __argc;\n}\nint _initU(void) {\n  LPWSTR lpwCommandLine;\n  int n;\n  WCHAR wc;\n  char *pNewBuf;\n  lpwCommandLine = GetCommandLineW();\n  n = lstrlenW(lpwCommandLine);\n  while (n && ((wc = lpwCommandLine[n-1]) != L\'\\0\') && ((wc == L\' \') || (wc == L\'\\t\'))) lpwCommandLine[--n] = L\'\\0\';\n  n += 1;\t\n  _acmdln = malloc(4 * n); \n  if (!_acmdln) return -1; \n  n = WideCharToMultiByte(CP_UTF8,\t\t\n\t\t\t  0,\t\t\t\n\t\t\t  lpwCommandLine,\t\n\t\t\t  n,\t\t\t\n\t\t\t  _acmdln,\t\t\n\t\t\t  (4 * n),\t\t\n\t\t\t  NULL,\t\t\t\n\t\t\t  NULL\t\t\t\n\t\t\t  );\n  if (!n) {\n#undef fprintf \n    fprintf(stderr, ""Warning: Can\'t convert the argument line to UTF-8\\n"");\n    _acmdln[0] = \'\\0\';\n  }\n  pNewBuf = realloc(_acmdln, n+1); \n  if (pNewBuf) _acmdln = pNewBuf; \n  initWideFiles();\n  return 0;\n}\n#if _MSC_VER >= 1900\n#undef main\nextern int mainU(int argc, char *argv[], char *envp[]);\n#pragma warning(disable:4100) \nint main(int argc, char *argv[], char *envp[]) {\n  argc = _setargv();\n  if (argc < 0) return argc; \n  return mainU(argc, __argv, envp); \n}\n#pragma warning(default:4100) \n#endif \n#endif '"
"('Prompt: In a DSSS frame synchronization system, implement a function that checks if the frame is currently open. The system has multiple states such as detecting the frame, receiving preamble, receiving header, and receiving payload. The function should return 0 if the frame is in the ""detect frame"" state, and 1 otherwise.","//...\nenum state {\n    DSSSFRAMESYNC_STATE_DETECTFRAME = 0,\n    DSSSFRAMESYNC_STATE_RXPREAMBLE,\n    DSSSFRAMESYNC_STATE_RXHEADER,\n    DSSSFRAMESYNC_STATE_RXPAYLOAD,\n};\nint dsssframesync_is_frame_open(dsssframesync _q)\n{\n    return (_q->state == DSSSFRAMESYNC_STATE_DETECTFRAME) ? 0 : 1;\n}\n//...')
"
"'Please provide the code for initializing the interface clock for a smartcard using the EMVSIM driver. The code should include functions for interface clock initialization, default configuration setup, initialization, activation, deactivation, and control of the smartcard interface.","#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.smartcard_phy_emvsim""\n#endif\nstatic uint32_t smartcard_phy_emvsim_InterfaceClockInit(EMVSIM_Type *base,\n                                                        const smartcard_interface_config_t *config,\n                                                        uint32_t srcClock_Hz);\nstatic uint32_t smartcard_phy_emvsim_InterfaceClockInit(EMVSIM_Type *base,\n                                                        const smartcard_interface_config_t *config,\n                                                        uint32_t srcClock_Hz)\n{\n    assert((NULL != config) && (0u != srcClock_Hz));\n    uint32_t emvsimClkMhz = 0u;\n    uint8_t emvsimPRSCValue;\n    emvsimClkMhz = srcClock_Hz / 1000000u;\n    emvsimPRSCValue = (uint8_t)((emvsimClkMhz * 1000u) / (config->smartCardClock / 1000u));\n    base->CLKCFG = (base->CLKCFG & ~EMVSIM_CLKCFG_CLK_PRSC_MASK) | EMVSIM_CLKCFG_CLK_PRSC(emvsimPRSCValue);\n    return config->smartCardClock;\n}\nvoid SMARTCARD_PHY_GetDefaultConfig(smartcard_interface_config_t *config)\n{\n    assert((NULL != config));\n    (void)memset(config, 0, sizeof(*config));\n    config->clockToResetDelay = SMARTCARD_INIT_DELAY_CLOCK_CYCLES;\n    config->vcc               = kSMARTCARD_VoltageClassB3_3V;\n}\nstatus_t SMARTCARD_PHY_Init(void *base, smartcard_interface_config_t const *config, uint32_t srcClock_Hz)\n{\n    if ((NULL == config) || (0u == srcClock_Hz))\n    {\n        return kStatus_SMARTCARD_InvalidInput;\n    }\n    EMVSIM_Type *emvsimBase = (EMVSIM_Type *)base;\n    (void)smartcard_phy_emvsim_InterfaceClockInit(emvsimBase, config, srcClock_Hz);\n    if ((emvsimBase->PCSR & EMVSIM_PCSR_SPDP_MASK) != 0u)\n    {\n        emvsimBase->PCSR &= ~EMVSIM_PCSR_SPDES_MASK;\n    }\n    else\n    {\n        emvsimBase->PCSR |= EMVSIM_PCSR_SPDES_MASK;\n    }\n    emvsimBase->PCSR &= ~EMVSIM_PCSR_SPDIM_MASK;\n    return kStatus_SMARTCARD_Success;\n}\nvoid SMARTCARD_PHY_Deinit(void *base, smartcard_interface_config_t const *config)\n{\n    assert((NULL != config));\n    ((EMVSIM_Type *)base)->PCSR &= ~(EMVSIM_PCSR_SCEN_MASK | EMVSIM_PCSR_SVCC_EN_MASK);\n}\nstatus_t SMARTCARD_PHY_Activate(void *base, smartcard_context_t *context, smartcard_reset_type_t resetType)\n{\n    if ((NULL == context) || (NULL == context->timeDelay))\n    {\n        return kStatus_SMARTCARD_InvalidInput;\n    }\n    assert(context->interfaceConfig.vcc == kSMARTCARD_VoltageClassB3_3V);\n    EMVSIM_Type *emvsimBase = (EMVSIM_Type *)base;\n    context->timersState.initCharTimerExpired = false;\n    context->resetType                        = resetType;\n    emvsimBase->CTRL &= ~EMVSIM_CTRL_RCV_EN_MASK;\n    if (resetType == kSMARTCARD_ColdReset)\n    { \n        emvsimBase->PCSR =\n            (emvsimBase->PCSR & ~EMVSIM_PCSR_VCCENP_MASK) | (EMVSIM_PCSR_SVCC_EN_MASK | EMVSIM_PCSR_SCEN_MASK);\n        emvsimBase->CTRL &= ~EMVSIM_CTRL_IC_MASK;\n    }\n    else if (resetType == kSMARTCARD_WarmReset)\n    { \n        if (!context->cardParams.active)\n        { \n            return kStatus_SMARTCARD_CardNotActivated;\n        }\n    }\n    else\n    {\n        return kStatus_SMARTCARD_InvalidInput;\n    }\n    emvsimBase->PCSR &= ~EMVSIM_PCSR_SRST_MASK;\n    uint32_t temp =\n        ((((uint32_t)10000u * context->interfaceConfig.clockToResetDelay) / context->interfaceConfig.smartCardClock) *\n         100u) +\n        1u;\n    context->timeDelay(temp);\n    emvsimBase->PCSR |= EMVSIM_PCSR_SRST_MASK;\n    emvsimBase->CLKCFG &= ~(EMVSIM_CLKCFG_GPCNT0_CLK_SEL_MASK | EMVSIM_CLKCFG_GPCNT1_CLK_SEL_MASK);\n    emvsimBase->TX_STATUS = EMVSIM_TX_STATUS_GPCNT1_TO_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK;\n    emvsimBase->GPCNT0_VAL = (SMARTCARD_INIT_DELAY_CLOCK_CYCLES + SMARTCARD_INIT_DELAY_CLOCK_CYCLES_ADJUSTMENT);\n    emvsimBase->GPCNT1_VAL = (SMARTCARD_EMV_ATR_DURATION_ETU + SMARTCARD_ATR_DURATION_ADJUSTMENT);\n    emvsimBase->CLKCFG |=\n        (EMVSIM_CLKCFG_GPCNT0_CLK_SEL(kEMVSIM_GPCCardClock) | EMVSIM_CLKCFG_GPCNT1_CLK_SEL(kEMVSIM_GPCTxClock));\n    emvsimBase->CTRL |= (EMVSIM_CTRL_ICM_MASK | EMVSIM_CTRL_FLSH_RX_MASK);\n    emvsimBase->INT_MASK &= ~EMVSIM_INT_MASK_GPCNT0_IM_MASK;\n    emvsimBase->RX_STATUS = 0xFFFFFFFFu;\n    emvsimBase->CTRL |= EMVSIM_CTRL_RCV_EN_MASK;\n    context->cardParams.active = true;\n    return kStatus_SMARTCARD_Success;\n}\nstatus_t SMARTCARD_PHY_Deactivate(void *base, smartcard_context_t *context)\n{\n    if ((NULL == context))\n    {\n        return kStatus_SMARTCARD_InvalidInput;\n    }\n    EMVSIM_Type *emvsimBase = (EMVSIM_Type *)base;\n    emvsimBase->PCSR &= ~EMVSIM_PCSR_SRST_MASK;\n    emvsimBase->PCSR &= ~EMVSIM_PCSR_SCEN_MASK;\n    emvsimBase->PCSR &= ~EMVSIM_PCSR_SVCC_EN_MASK;\n    context->timeDelay(100 * 1000);\n    context->cardParams.active = false;\n    return kStatus_SMARTCARD_Success;\n}\nstatus_t SMARTCARD_PHY_Control(void *base,\n                               smartcard_context_t *context,\n                               smartcard_interface_control_t control,\n                               uint32_t param)\n{\n    if ((NULL == context))\n    {\n        return kStatus_SMARTCARD_InvalidInput;\n    }\n    status_t status = kStatus_SMARTCARD_Success;\n    switch (control)\n    {\n        case kSMARTCARD_InterfaceSetVcc:\n            assert((smartcard_card_voltage_class_t)param == kSMARTCARD_VoltageClassB3_3V);\n            context->interfaceConfig.vcc = (smartcard_card_voltage_class_t)param;\n            break;\n        case kSMARTCARD_InterfaceSetClockToResetDelay:\n            context->interfaceConfig.clockToResetDelay = param;\n            break;\n        case kSMARTCARD_InterfaceReadStatus:\n            context->cardParams.present = (bool)((emvsim_presence_detect_status_t)(uint32_t)(\n                                                     (((EMVSIM_Type *)base)->PCSR & EMVSIM_PCSR_SPDP_MASK) >>\n                                                     EMVSIM_PCSR_SPDP_SHIFT) == kEMVSIM_DetectPinIsLow);\n            break;\n        default:\n            status = kStatus_SMARTCARD_InvalidInput;\n            break;\n    }\n    return status;\n}'"
"'Prompt: You are working on a program that generates QR codes. Your task is to implement a function that sets a specific module within the QR code grid to either black or white. Additionally, you need to create a function that fills a rectangular area within the QR code with black modules. Your functions should handle edge cases, such as ensuring the input coordinates are within the valid range for the QR code size. Provide code for the setModule and fillRectangle functions in C++ that achieve this functionality.","//...\ntestable void setModule(uint8_t qrcode[], int x, int y, bool isBlack)\n{\n    int qrsize = qrcode[0];\n    LV_ASSERT(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n    int index = y * qrsize + x;\n    int bitIndex = index & 7;\n    int byteIndex = (index >> 3) + 1;\n    if(isBlack)\n        qrcode[byteIndex] |= 1 << bitIndex;\n    else\n        qrcode[byteIndex] &= (1 << bitIndex) ^ 0xFF;\n}\nstatic void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[])\n{\n    for(int dy = 0; dy < height; dy++) {\n        for(int dx = 0; dx < width; dx++)\n            setModule(qrcode, left + dx, top + dy, true);\n    }\n}\n//...'"
"('Prompt: To verify the delay performance of the symmetrical root-raised cosine filter in a digital communication system, write a testbench function that creates a linear symmetrical root-raised cosine filter for a given bandwidth and delay factor. The function should perform a series of operations including writing samples, setting gain, and calculating delay measurements. Additionally, implement an autotest function that calls the testbench function with a bandwidth of 0.5 and a delay factor of 14.","//...\nvoid testbench_symstreamrcf_delay(float        _bw,\n                                  unsigned int _m)\n{\n    int          ftype  = LIQUID_FIRFILT_ARKAISER;\n    float        beta   = 0.30f;\n    int          ms     = LIQUID_MODEM_QPSK;\n    symstreamrcf gen    = symstreamrcf_create_linear(ftype,_bw,_m,beta,ms);\n    float        delay  = symstreamrcf_get_delay(gen);\n    float        tol    = 0.05; \n    unsigned int  nfft = 2*(120 + (unsigned int)(delay/sqrtf(_bw)));\n    float complex buf_time[nfft];\n    float complex buf_freq[nfft];\n    symstreamrcf_write_samples(gen, buf_time, 1);\n    symstreamrcf_set_gain(gen, 0.0f);\n    symstreamrcf_write_samples(gen, buf_time+1, nfft-1);\n    symstreamrcf_destroy(gen);\n    fft_run(nfft, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);\n    unsigned int m = 0.4 * _bw * nfft; \n    float complex p = 0.0f;\n    int i;\n    for (i=-(int)m; i<(int)m; i++)\n        p += buf_freq[(nfft+i)%nfft] * conjf(buf_freq[(nfft+i+1)%nfft]);\n    float delay_meas = cargf(p) * nfft / (2*M_PI);\n    if (liquid_autotest_verbose) {\n        printf(""expected delay: %.6f, measured: %.6f, err: %.6f (tol= %.3f)\\n"",\n                delay, delay_meas, delay-delay_meas,tol);\n    }\n    CONTEND_DELTA(delay, delay_meas, tol);\n}\nvoid autotest_symstreamrcf_delay_07() { testbench_symstreamrcf_delay(0.500f,14); }\n//...')
"
"('Prompt: In a software development scenario where you are testing the configuration of an OFDM frame synchronization algorithm, write a code snippet that includes error handling for potential invalid configurations. Your code should include tests for creating OFDM frame synchronization objects with different parameters, printing the object if creation is successful, and destroying the object after testing.","//...\nvoid autotest_ofdmflexframesync_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping ofdmflexframesync config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    CONTEND_ISNULL(ofdmflexframesync_create( 0, 16, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmflexframesync_create( 7, 16, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmflexframesync_create(65, 16, 4, NULL, NULL, NULL)) \n    CONTEND_ISNULL(ofdmflexframesync_create(64, 66, 4, NULL, NULL, NULL)) \n    ofdmflexframesync q = ofdmflexframesync_create(64, 16, 4, NULL, NULL, NULL);\n    CONTEND_EQUALITY(LIQUID_OK, ofdmflexframesync_print(q))\n    ofdmflexframesync_destroy(q);\n}\n//...')
"
"'Prompt: In an embedded systems project, you are working on an RTEMS BSP implementation and need a function that will return the memory address of the Umon monitor pointer. Can you write a function that returns the memory address 0x10000020 as a void pointer?",void *rtems_bsp_get_umon_monptr(void)\n{\n  return (void *)0x10000020;\n}'
'Please provide me with a prompt that involves updating and refreshing a display with multiple layers and objects.,"//...\n    if(_lv_area_is_in(area_p, &obj->coords, 0) == false) return NULL;\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic void draw_buf_flush(lv_display_t * disp)\n{\n    lv_layer_t * layer = disp->layer_head;\n    while(layer->draw_task_head) {\n        lv_draw_dispatch_wait_for_request();\n        lv_draw_dispatch();\n    }\n    if(lv_display_is_double_buffered(disp)) {\n        wait_for_flushing(disp_refr);\n    }\n    disp->flushing = 1;\n    if(disp->last_area && disp->last_part) disp->flushing_last = 1;\n    else disp->flushing_last = 0;\n    bool flushing_last = disp->flushing_last;\n    if(disp->flush_cb) {\n        call_flush_cb(disp, &disp->refreshed_area, layer->draw_buf->data);\n    }\n    if(lv_display_is_double_buffered(disp) && (disp->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT || flushing_last)) {\n        if(disp->buf_act == disp->buf_1) {\n            disp->buf_act = disp->buf_2;\n        }\n        else {\n            disp->buf_act = disp->buf_1;\n        }\n    }\n}\nstatic void layer_reshape_draw_buf(lv_layer_t * layer)\n{\n    LV_ASSERT(lv_draw_buf_reshape(\n                  layer->draw_buf,\n                  layer->color_format,\n                  lv_area_get_width(&layer->buf_area),\n                  lv_area_get_height(&layer->buf_area),\n                  0)\n              != NULL);\n}\nstatic void call_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)\n{\n    LV_PROFILER_BEGIN;\n    LV_TRACE_REFR(""Calling flush_cb on (%d;%d)(%d;%d) area with %p image pointer"",\n                  (int)area->x1, (int)area->y1, (int)area->x2, (int)area->y2, (void *)px_map);\n    lv_area_t offset_area = {\n        .x1 = area->x1 + disp->offset_x,\n        .y1 = area->y1 + disp->offset_y,\n        .x2 = area->x2 + disp->offset_x,\n        .y2 = area->y2 + disp->offset_y\n    };\n    lv_display_send_event(disp, LV_EVENT_FLUSH_START, &offset_area);\n    disp->flush_cb(disp, &offset_area, px_map);\n    lv_display_send_event(disp, LV_EVENT_FLUSH_FINISH, &offset_area);\n    LV_PROFILER_END;\n}\nstatic bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)\n{\n    if(!_lv_area_is_on(area, &obj->coords)) return true;\n    lv_cover_check_info_t info;\n    info.res = LV_COVER_RES_COVER;\n    info.area = area;\n    lv_obj_send_event(obj, LV_EVENT_COVER_CHECK, &info);\n    if(info.res == LV_COVER_RES_COVER) return false;\n    else return true;\n}\nstatic void lv_refr_join_area(void)\n{\n    LV_PROFILER_BEGIN;\n    uint32_t join_from;\n    uint32_t join_in;\n    lv_area_t joined_area;\n    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {\n        if(disp_refr->inv_area_joined[join_in] != 0) continue;\n        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {\n            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {\n                continue;\n            }\n            if(_lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {\n                continue;\n            }\n            _lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);\n            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +\n                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {\n                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);\n                disp_refr->inv_area_joined[join_from] = 1;\n            }\n        }\n    }\n    LV_PROFILER_END;\n}\nstatic void refr_area(const lv_area_t * area_p)\n{\n    LV_PROFILER_BEGIN;\n    lv_layer_t * layer = disp_refr->layer_head;\n    layer->draw_buf = disp_refr->buf_act;\n    if(disp_refr->render_mode != LV_DISPLAY_RENDER_MODE_PARTIAL) {\n        layer->buf_area.x1 = 0;\n        layer->buf_area.y1 = 0;\n        layer->buf_area.x2 = lv_display_get_horizontal_resolution(disp_refr) - 1;\n        layer->buf_area.y2 = lv_display_get_vertical_resolution(disp_refr) - 1;\n        layer_reshape_draw_buf(layer);\n        lv_area_t disp_area;\n        lv_area_set(&disp_area, 0, 0, lv_display_get_horizontal_resolution(disp_refr) - 1,\n                    lv_display_get_vertical_resolution(disp_refr) - 1);\n        if(disp_refr->render_mode == LV_DISPLAY_RENDER_MODE_FULL) {\n            disp_refr->last_part = 1;\n            layer->_clip_area = disp_area;\n            refr_area_part(layer);\n        }\n        else if(disp_refr->render_mode == LV_DISPLAY_RENDER_MODE_DIRECT) {\n            disp_refr->last_part = disp_refr->last_area;\n            layer->_clip_area = *area_p;\n            refr_area_part(layer);\n        }\n        LV_PROFILER_END;\n        return;\n    }\n    int32_t w = lv_area_get_width(area_p);\n    int32_t h = lv_area_get_height(area_p);\n    int32_t y2 = area_p->y2 >= lv_display_get_vertical_resolution(disp_refr) ?\n                 lv_display_get_vertical_resolution(disp_refr) - 1 : area_p->y2;\n    int32_t max_row = get_max_row(disp_refr, w, h);\n    int32_t row;\n    int32_t row_last = 0;\n    lv_area_t sub_area;\n    for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {\n        sub_area.x1 = area_p->x1;\n        sub_area.x2 = area_p->x2;\n        sub_area.y1 = row;\n        sub_area.y2 = row + max_row - 1;\n        layer->draw_buf = disp_refr->buf_act;\n        layer->buf_area = sub_area;\n        layer->_clip_area = sub_area;\n        layer_reshape_draw_buf(layer);\n        if(sub_area.y2 > y2) sub_area.y2 = y2;\n        row_last = sub_area.y2;\n        if(y2 == row_last) disp_refr->last_part = 1;\n        refr_area_part(layer);\n    }\n    if(y2 != row_last) {\n        sub_area.x1 = area_p->x1;\n        sub_area.x2 = area_p->x2;\n        sub_area.y1 = row;\n        sub_area.y2 = y2;\n        layer->draw_buf = disp_refr->buf_act;\n        layer->buf_area = sub_area;\n        layer->_clip_area = sub_area;\n        layer_reshape_draw_buf(layer);\n        disp_refr->last_part = 1;\n        refr_area_part(layer);\n    }\n    LV_PROFILER_END;\n}\nstatic lv_result_t layer_get_area(lv_layer_t * layer, lv_obj_t * obj, lv_layer_type_t layer_type,\n                                  lv_area_t * layer_area_out, lv_area_t * obj_draw_size_out)\n{\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_obj_get_coords(obj, obj_draw_size_out);\n    lv_area_increase(obj_draw_size_out, ext_draw_size, ext_draw_size);\n    if(layer_type == LV_LAYER_TYPE_TRANSFORM) {\n        lv_area_t clip_coords_for_obj;\n        lv_area_t tranf_coords = *obj_draw_size_out;\n        lv_obj_get_transformed_area(obj, &tranf_coords, false, false);\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, &tranf_coords)) {\n            return LV_RESULT_INVALID;\n        }\n        lv_area_t inverse_clip_coords_for_obj = clip_coords_for_obj;\n        lv_obj_get_transformed_area(obj, &inverse_clip_coords_for_obj, false, true);\n        if(!_lv_area_intersect(&inverse_clip_coords_for_obj, &inverse_clip_coords_for_obj, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = inverse_clip_coords_for_obj;\n        lv_area_increase(layer_area_out, 5, 5); \n    }\n    else if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n        lv_area_t clip_coords_for_obj;\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = clip_coords_for_obj;\n    }\n    else {\n        LV_LOG_WARN(""Unhandled layer type"");\n        return LV_RESULT_INVALID;\n    }\n    return LV_RESULT_OK;\n}\nvoid refr_obj(lv_layer_t * layer, lv_obj_t * obj)\n{\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;\n    lv_layer_type_t layer_type = _lv_obj_get_layer_type(obj);\n    if(layer_type == LV_LAYER_TYPE_NONE) {\n        lv_obj_redraw(layer, obj);\n    }\n    else {\n        lv_opa_t opa = lv_obj_get_style_opa_layered(obj, 0);\n        if(opa < LV_OPA_MIN) return;\n        lv_area_t layer_area_full;\n        lv_area_t obj_draw_size;\n        lv_result_t res = layer_get_area(layer, obj, layer_type, &layer_area_full, &obj_draw_size);\n        if(res != LV_RESULT_OK) return;\n        uint32_t max_rgb_row_height = lv_area_get_height(&layer_area_full);\n        uint32_t max_argb_row_height = lv_area_get_height(&layer_area_full);\n        if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n            int32_t w = lv_area_get_width(&layer_area_full);\n            uint8_t px_size = lv_color_format_get_size(disp_refr->color_format);\n            max_rgb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / px_size;\n            max_argb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / sizeof(lv_color32_t);\n        }\n        lv_area_t layer_area_act;\n        layer_area_act.x1 = layer_area_full.x1;\n        layer_area_act.x2 = layer_area_full.x2;\n        layer_area_act.y1 = layer_area_full.y1;\n        layer_area_act.y2 = layer_area_full.y1;\n        while(layer_area_act.y2 < layer_area_full.y2) {\n            layer_area_act.y2 = layer_area_act.y1 + max_rgb_row_height - 1;\n            if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            bool area_need_alpha = alpha_test_area_on_obj(obj, &layer_area_act);\n            if(area_need_alpha) {\n                layer_area_act.y2 = layer_area_act.y1 + max_argb_row_height - 1;\n                if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            }\n            lv_layer_t * new_layer = lv_draw_layer_create(layer,\n                                                          area_need_alpha ? LV_COLOR_FORMAT_ARGB8888 : LV_COLOR_FORMAT_NATIVE, &layer_area_act);\n            lv_obj_redraw(new_layer, obj);\n            lv_draw_image_dsc_t layer_draw_dsc;\n            lv_draw_image_dsc_init(&layer_draw_dsc);\n            layer_draw_dsc.pivot.x = obj->coords.x1 + lv_obj_get_style_transform_pivot_x(obj, 0) - new_layer->buf_area.x1;\n            layer_draw_dsc.pivot.y = obj->coords.y1 + lv_obj_get_style_transform_pivot_y(obj, 0) - new_layer->buf_area.y1;\n            layer_draw_dsc.opa = opa;\n            layer_draw_dsc.rotation = lv_obj_get_style_transform_rotation(obj, 0);\n            while(layer_draw_dsc.rotation > 3600) layer_draw_dsc.rotation -= 3600;\n            while(layer_draw_dsc.rotation < 0) layer_draw_dsc.rotation += 3600;\n            layer_draw_dsc.scale_x = lv_obj_get_style_transform_scale_x(obj, 0);\n            layer_draw_dsc.scale_y = lv_obj_get_style_transform_scale_y(obj, 0);\n            layer_draw_dsc.skew_x = lv_obj_get_style_transform_skew_x(obj, 0);\n            layer_draw_dsc.skew_y = lv_obj_get_style_transform_skew_y(obj, 0);\n            layer_draw_dsc.blend_mode = lv_obj_get_style_blend_mode(obj, 0);\n            layer_draw_dsc.antialias = disp_refr->antialiasing;\n            layer_draw_dsc.bitmap_mask_src = lv_obj_get_style_bitmap_mask_src(obj, 0);\n            layer_draw_dsc.original_area = obj_draw_size;\n            layer_draw_dsc.src = new_layer;\n            lv_draw_layer(layer, &layer_draw_dsc, &layer_area_act);\n            layer_area_act.y1 = layer_area_act.y2 + 1;\n        }\n    }\n}\nstatic void refr_obj_and_children(lv_layer_t * layer, lv_obj_t * top_obj)\n{\n    if(top_obj == NULL) top_obj = lv_display_get_screen_active(disp_refr);\n    if(top_obj == NULL) return;  \n    LV_PROFILER_BEGIN;\n    refr_obj(layer, top_obj);\n    lv_obj_t * parent;\n    lv_obj_t * border_p = top_obj;\n    parent = lv_obj_get_parent(top_obj);\n    while(parent != NULL) {\n        bool go = false;\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(parent);\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = parent->spec_attr->children[i];\n            if(!go) {\n                if(child == border_p) go = true;\n            }\n            else {\n                refr_obj(layer, child);\n            }\n        }\n        lv_obj_send_event(parent, LV_EVENT_DRAW_POST_BEGIN, (void *)layer);\n        lv_obj_send_event(parent, LV_EVENT_DRAW_POST, (void *)layer);\n        lv_obj_send_event(parent, LV_EVENT_DRAW_POST_END, (void *)layer);\n        border_p = parent;\n        parent = lv_obj_get_parent(parent);\n    }\n    LV_PROFILER_END;\n}\nstatic void refr_sync_areas(void)\n{\n    if(disp_refr->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT) return;\n    if(!lv_display_is_double_buffered(disp_refr)) return;\n    if(_lv_ll_is_empty(&disp_refr->sync_areas)) return;\n    LV_PROFILER_BEGIN;\n    wait_for_flushing(disp_refr);\n    lv_draw_buf_t * off_screen = disp_refr->buf_act;\n    lv_draw_buf_t * on_screen = disp_refr->buf_act == disp_refr->buf_1 ? disp_refr->buf_2 : disp_refr->buf_1;\n    uint32_t hor_res = lv_display_get_horizontal_resolution(disp_refr);\n    uint32_t ver_res = lv_display_get_vertical_resolution(disp_refr);\n    uint16_t i;\n    int8_t j;\n    lv_area_t res[4] = {0};\n    int8_t res_c;\n    lv_area_t * sync_area, * new_area, * next_area;\n    for(i = 0; i < disp_refr->inv_p; i++) {\n        if(disp_refr->inv_area_joined[i]) continue;\n        sync_area = _lv_ll_get_head(&disp_refr->sync_areas);\n        while(sync_area != NULL) {\n            next_area = _lv_ll_get_next(&disp_refr->sync_areas, sync_area);\n            res_c = _lv_area_diff(res, sync_area, &disp_refr->inv_areas[i]);\n            if(res_c != -1) {\n                for(j = 0; j < res_c; j++) {\n                    new_area = _lv_ll_ins_prev(&disp_refr->sync_areas, sync_area);\n                    *new_area = res[j];\n                }\n                _lv_ll_remove(&disp_refr->sync_areas, sync_area);\n                lv_free(sync_area);\n            }\n            sync_area = next_area;\n        }\n    }\n    lv_area_t disp_area = {0, 0, (int32_t)hor_res - 1, (int32_t)ver_res - 1};\n    for(sync_area = _lv_ll_get_head(&disp_refr->sync_areas); sync_area != NULL;\n        sync_area = _lv_ll_get_next(&disp_refr->sync_areas, sync_area)) {\n        _lv_area_intersect(sync_area, sync_area, &disp_area);\n        lv_draw_buf_copy(off_screen, sync_area, on_screen, sync_area);\n    }\n    _lv_ll_clear(&disp_refr->sync_areas);\n    LV_PROFILER_END;\n}\nstatic void wait_for_flushing(lv_display_t * disp)\n{\n    LV_PROFILER_BEGIN;\n    LV_LOG_TRACE(""begin"");\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_START, NULL);\n    if(disp->flush_wait_cb) {\n        disp->flush_wait_cb(disp);\n    }\n    else {\n        while(disp->flushing);\n    }\n    disp->flushing_last = 0;\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_FINISH, NULL);\n    LV_LOG_TRACE(""end"");\n    LV_PROFILER_END;\n}\nstatic uint32_t get_max_row(lv_display_t * disp, int32_t area_w, int32_t area_h)\n{\n    bool has_alpha = lv_color_format_has_alpha(disp->color_format);\n    lv_color_format_t cf = has_alpha ? LV_COLOR_FORMAT_ARGB8888 : disp->color_format;\n    uint32_t stride = lv_draw_buf_width_to_stride(area_w, cf);\n    int32_t max_row = (uint32_t)disp->buf_act->data_size / stride;\n    if(max_row > area_h) max_row = area_h;\n    lv_area_t tmp;\n    tmp.x1 = 0;\n    tmp.x2 = 0;\n    tmp.y1 = 0;\n    int32_t h_tmp = max_row;\n    do {\n        tmp.y2 = h_tmp - 1;\n        lv_display_send_event(disp_refr, LV_EVENT_INVALIDATE_AREA, &tmp);\n        if(lv_area_get_height(&tmp) <= max_row) break;\n        h_tmp--;\n    } while(h_tmp > 0);\n    if(h_tmp <= 0) {\n        LV_LOG_WARN(""Can\'t set draw_buf height using the round function. (Wrong round_cb or too ""\n                    ""small draw_buf)"");\n        return 0;\n    }\n    else {\n        max_row = tmp.y2 + 1;\n    }\n    return max_row;\n}\nvoid lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)\n{\n    lv_area_t clip_area_ori = layer->_clip_area;\n    lv_area_t clip_coords_for_obj;\n    lv_area_t obj_coords_ext;\n    lv_obj_get_coords(obj, &obj_coords_ext);\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_increase(&obj_coords_ext, ext_draw_size, ext_draw_size);\n    if(!_lv_area_intersect(&clip_coords_for_obj, &clip_area_ori, &obj_coords_ext)) return;\n    layer->_clip_area = clip_coords_for_obj;\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_BEGIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_END, layer);\n#if LV_USE_REFR_DEBUG\n    lv_color_t debug_color = lv_color_make(lv_rand(0, 0xFF), lv_rand(0, 0xFF), lv_rand(0, 0xFF));\n    lv_draw_rect_dsc_t draw_dsc;\n    lv_draw_rect_dsc_init(&draw_dsc);\n    draw_dsc.bg_color = debug_color;\n    draw_dsc.bg_opa = LV_OPA_20;\n    draw_dsc.border_width = 1;\n    draw_dsc.border_opa = LV_OPA_30;\n    draw_dsc.border_color = debug_color;\n    lv_draw_rect(layer, &draw_dsc, &obj_coords_ext);\n#endif\n    const lv_area_t * obj_coords;\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_OVERFLOW_VISIBLE)) {\n        obj_coords = &obj_coords_ext;\n    }\n    else {\n        obj_coords = &obj->coords;\n    }\n    lv_area_t clip_coords_for_children;\n    bool refr_children = true;\n    if(!_lv_area_intersect(&clip_coords_for_children, &clip_area_ori, obj_coords)) {\n        refr_children = false;\n    }\n    if(refr_children) {\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(obj);\n        if(child_cnt == 0) {\n            layer->_clip_area = clip_coords_for_obj;\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n        }\n        else {\n            layer->_clip_area = clip_coords_for_children;\n            bool clip_corner = lv_obj_get_style_clip_corner(obj, LV_PART_MAIN);\n            int32_t radius = 0;\n            if(clip_corner) {\n                radius = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n                if(radius == 0) clip_corner = false;\n            }\n            if(clip_corner == false) {\n                for(i = 0; i < child_cnt; i++) {\n                    lv_obj_t * child = obj->spec_attr->children[i];\n                    refr_obj(layer, child);\n                }\n                layer->_clip_area = clip_coords_for_obj;\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n            }\n            else {\n                lv_layer_t * layer_children;\n                lv_draw_mask_rect_dsc_t mask_draw_dsc;\n                lv_draw_mask_rect_dsc_init(&mask_draw_dsc);\n                mask_draw_dsc.radius = radius;\n                mask_draw_dsc.area = obj->coords;\n                lv_draw_image_dsc_t img_draw_dsc;\n                lv_draw_image_dsc_init(&img_draw_dsc);\n                int32_t short_side = LV_MIN(lv_area_get_width(&obj->coords), lv_area_get_height(&obj->coords));\n                int32_t rout = LV_MIN(radius, short_side >> 1);\n                lv_area_t bottom = obj->coords;\n                bottom.y1 = bottom.y2 - rout + 1;\n                if(_lv_area_intersect(&bottom, &bottom, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &bottom);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &bottom);\n                }\n                lv_area_t top = obj->coords;\n                top.y2 = top.y1 + rout - 1;\n                if(_lv_area_intersect(&top, &top, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &top);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &top);\n                }\n                lv_area_t mid = obj->coords;\n                mid.y1 += rout;\n                mid.y2 -= rout;\n                if(_lv_area_intersect(&mid, &mid, &clip_area_ori)) {\n                    layer->_clip_area = mid;\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n                }\n            }\n        }\n    }\n    layer->_clip_area = clip_area_ori;\n}\nstatic void refr_invalid_areas(void)\n{\n    if(disp_refr->inv_p == 0) return;\n    LV_PROFILER_BEGIN;\n    int32_t i;\n    int32_t last_i = 0;\n    for(i = disp_refr->inv_p - 1; i >= 0; i--) {\n        if(disp_refr->inv_area_joined[i] == 0) {\n            last_i = i;\n            break;\n        }\n    }\n    lv_display_send_event(disp_refr, LV_EVENT_RENDER_START, NULL);\n    disp_refr->last_area = 0;\n    disp_refr->last_part = 0;\n    disp_refr->rendering_in_progress = true;\n    for(i = 0; i < (int32_t)disp_refr->inv_p; i++) {\n        if(disp_refr->inv_area_joined[i] == 0) {\n            if(i == last_i) disp_refr->last_area = 1;\n            disp_refr->last_part = 0;\n            refr_area(&disp_refr->inv_areas[i]);\n        }\n    }\n    disp_refr->rendering_in_progress = false;\n    LV_PROFILER_END;\n}\nvoid _lv_display_refr_timer(lv_timer_t * tmr)\n{\n    LV_PROFILER_BEGIN;\n    LV_TRACE_REFR(""begin"");\n    if(tmr) {\n        disp_refr = tmr->user_data;\n#if !(defined(LV_USE_PERF_MONITOR) && LV_USE_PERF_MONITOR)\n        lv_timer_pause(tmr);\n#endif\n    }\n    else {\n        disp_refr = lv_display_get_default();\n    }\n    if(disp_refr == NULL) {\n        LV_LOG_WARN(""No display registered"");\n        return;\n    }\n    lv_draw_buf_t * buf_act = disp_refr->buf_act;\n    if(!(buf_act && buf_act->data && buf_act->data_size)) {\n        LV_LOG_WARN(""No draw buffer"");\n        return;\n    }\n    lv_display_send_event(disp_refr, LV_EVENT_REFR_START, NULL);\n    LV_PROFILER_BEGIN_TAG(""layout"");\n    lv_obj_update_layout(disp_refr->act_scr);\n    if(disp_refr->prev_scr) lv_obj_update_layout(disp_refr->prev_scr);\n    lv_obj_update_layout(disp_refr->bottom_layer);\n    lv_obj_update_layout(disp_refr->top_layer);\n    lv_obj_update_layout(disp_refr->sys_layer);\n    LV_PROFILER_END_TAG(""layout"");\n    if(disp_refr->act_scr == NULL) {\n        disp_refr->inv_p = 0;\n        LV_LOG_WARN(""there is no active screen"");\n        goto refr_finish;\n    }\n    lv_refr_join_area();\n    refr_sync_areas();\n    refr_invalid_areas();\n    if(disp_refr->inv_p == 0) goto refr_finish;\n    lv_display_send_event(disp_refr, LV_EVENT_RENDER_READY, NULL);\n    if(!lv_display_is_double_buffered(disp_refr) ||\n       disp_refr->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT) goto refr_clean_up;\n    wait_for_flushing(disp_refr);\n    uint32_t i;\n    for(i = 0; i < disp_refr->inv_p; i++) {\n        if(disp_refr->inv_area_joined[i])\n            continue;\n        lv_area_t * sync_area = _lv_ll_ins_tail(&disp_refr->sync_areas);\n        *sync_area = disp_refr->inv_areas[i];\n    }\nrefr_clean_up:\n    lv_memzero(disp_refr->inv_areas, sizeof(disp_refr->inv_areas));\n    lv_memzero(disp_refr->inv_area_joined, sizeof(disp_refr->inv_area_joined));\n    disp_refr->inv_p = 0;\nrefr_finish:\n#if LV_DRAW_SW_COMPLEX == 1\n    _lv_draw_sw_mask_cleanup();\n#endif\n    lv_display_send_event(disp_refr, LV_EVENT_REFR_READY, NULL);\n    LV_TRACE_REFR(""finished"");\n    LV_PROFILER_END;\n}\nstatic void refr_area_part(lv_layer_t * layer)\n{\n    LV_PROFILER_BEGIN;\n    disp_refr->refreshed_area = layer->_clip_area;\n    if(!lv_display_is_double_buffered(disp_refr)) {\n        wait_for_flushing(disp_refr);\n    }\n    if(lv_color_format_has_alpha(disp_refr->color_format)) {\n        lv_draw_buf_clear(layer->draw_buf, &disp_refr->refreshed_area);\n    }\n    lv_obj_t * top_act_scr = NULL;\n    lv_obj_t * top_prev_scr = NULL;\n    top_act_scr = lv_refr_get_top_obj(&layer->_clip_area, lv_display_get_screen_active(disp_refr));\n    if(disp_refr->prev_scr) {\n        top_prev_scr = lv_refr_get_top_obj(&layer->_clip_area, disp_refr->prev_scr);\n    }\n    if(top_act_scr == NULL && top_prev_scr == NULL) {\n        refr_obj_and_children(layer, lv_display_get_layer_bottom(disp_refr));\n    }\n    if(disp_refr->draw_prev_over_act) {\n        if(top_act_scr == NULL) top_act_scr = disp_refr->act_scr;\n        refr_obj_and_children(layer, top_act_scr);\n        if(disp_refr->prev_scr) {\n            if(top_prev_scr == NULL) top_prev_scr = disp_refr->prev_scr;\n            refr_obj_and_children(layer, top_prev_scr);\n        }\n    }\n    else {\n        if(disp_refr->prev_scr) {\n            if(top_prev_scr == NULL) top_prev_scr = disp_refr->prev_scr;\n            refr_obj_and_children(layer, top_prev_scr);\n        }\n        if(top_act_scr == NULL) top_act_scr = disp_refr->act_scr;\n        refr_obj_and_children(layer, top_act_scr);\n    }\n    refr_obj_and_children(layer, lv_display_get_layer_top(disp_refr));\n    refr_obj_and_children(layer, lv_display_get_layer_sys(disp_refr));\n    draw_buf_flush(disp_refr);\n    LV_PROFILER_END;\n}\nvoid lv_refr_now(lv_display_t * disp)\n{\n    lv_anim_refr_now();\n    if(disp) {\n        if(disp->refr_timer) _lv_display_refr_timer(disp->refr_timer);\n    }\n    else {\n        lv_display_t * d;\n        d = lv_display_get_next(NULL);\n        while(d) {\n            if(d->refr_timer) _lv_display_refr_timer(d->refr_timer);\n            d = lv_display_get_next(d);\n        }\n    }\n}\n//...'"
"('Create a C program that implements a fractional delay filter using the `fdelay_rrrf` library. The program should set up the necessary parameters such as `nmax`, `m`, `npfb`, `num_samples`, and `delay`. It should create an instance of the filter, set the delay, and print the parameters. Then, generate input samples `x` and apply the filter to obtain output samples `y`. Estimate the delay by performing a frequency domain analysis. Finally, write the input and output samples to a MATLAB-compatible file named `fdelay_rrrf_example.m` for further analysis. Provide visualizations of the input and output signals with the correct scaling and labeling. Make sure to include appropriate comments and organize the code efficiently.","#define OUTPUT_FILENAME ""fdelay_rrrf_example.m""\nint main() {\n    unsigned int nmax       = 200;  \n    unsigned int m          =  12;  \n    unsigned int npfb       =  10;  \n    unsigned int num_samples= 240;  \n    float        delay      =27.8;  \n    fdelay_rrrf q = fdelay_rrrf_create(nmax, m, npfb);\n    fdelay_rrrf_set_delay(q, delay);\n    fdelay_rrrf_print(q);\n    float x[num_samples];\n    float y[num_samples];\n    unsigned int i;\n    for (i=0; i<num_samples; i++) {\n        x[i] = i==0 ? 1.0f : 0.0f;\n        fdelay_rrrf_push(q, x[i]);\n        fdelay_rrrf_execute(q, &y[i]);\n    }\n    fdelay_rrrf_destroy(q);\n    float fc = 0.1f / (float)num_samples; \n    float complex v = 0.0f;\n    for (i=0; i<num_samples; i++)\n        v += y[i] * cexpf(_Complex_I*2*M_PI*fc*i);\n    float delay_est = cargf(v) / (2*M_PI*fc) - (float)m;\n    printf(""fdelay = %g (%g)\\n"", delay_est, delay);\n    FILE * fid = fopen(OUTPUT_FILENAME,""w"");\n    fprintf(fid,""%% %s : auto-generated file\\n"", OUTPUT_FILENAME);\n    fprintf(fid,""clear all; close all;\\n"");\n    fprintf(fid,""delay=%f; m=%u; n=%u;\\n"",delay,m,num_samples);\n    fprintf(fid,""x=zeros(1,n);\\n"");\n    fprintf(fid,""y=zeros(1,n);\\n"");\n    for (i=0; i<num_samples; i++) {\n        fprintf(fid,""x(%4u) = %12.4e;\\n"", i+1, x[i]);\n        fprintf(fid,""y(%4u) = %12.4e;\\n"", i+1, y[i]);\n    }\n    fprintf(fid,""t=0:(n-1);\\n"");\n    fprintf(fid,""figure;\\n"");\n    fprintf(fid,""subplot(2,1,1);\\n"");\n    fprintf(fid,""  plot(t,x,\'-x\',\'Color\',[0 0.3 0.5],\'LineWidth\',1);\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'input\');\\n"");\n    fprintf(fid,""  xlim([-10 10]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fprintf(fid,""subplot(2,1,2);\\n"");\n    fprintf(fid,""  plot(t-m,y,\'-x\',\'Color\',[0 0.3 0.5],\'LineWidth\',1,...\\n"");\n    fprintf(fid,""       [delay delay],[-0.1 1.1],\'-r\');\\n"");\n    fprintf(fid,""  xlabel(\'time\');\\n"");\n    fprintf(fid,""  ylabel(\'output\');\\n"");\n    fprintf(fid,""  xlim([-3 3]+delay); ylim([-0.2 1.2]);\\n"");\n    fprintf(fid,""  grid on;\\n"");\n    fclose(fid);\n    printf(""results written to %s.\\n"", OUTPUT_FILENAME);\n    return 0;\n}')
"
"('Prompt: You are working on optimizing a function that generates random complex numbers by calling the `crandnf` function multiple times in a loop. The function `benchmark_random_complex_normal` takes in pointers to `struct rusage` for start and finish times, as well as a pointer to an unsigned long integer for the number of iterations. Can you write a function that will take care of performing the random number generation process, measuring the resource usage using `getrusage`, and adjusting the number of iterations based on the calculations done inside the function?","//...\nvoid benchmark_random_complex_normal(struct rusage *_start,\n                                     struct rusage *_finish,\n                                     unsigned long int *_num_iterations)\n{\n    *_num_iterations /= 2;\n    float complex x = 0.0f;\n    unsigned long int i;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        crandnf(&x);\n        crandnf(&x);\n        crandnf(&x);\n        crandnf(&x);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    *_num_iterations += crealf(x) > 0; \n}\n//...')
"
'Prompt: You are designing a multithreaded application where you need to implement a function that signals a condition variable. The function should unblock one waiting thread on the condition variable. Can you provide me with the code for a function that accomplishes this task and handles different scenarios such as unblocking all waiting threads or unblocking just one thread based on a flag?,"//...\nstatic INLINE int\n__ptw32_cond_unblock (pthread_cond_t * cond, int unblockAll)\n{\n  int result;\n  pthread_cond_t cv;\n  int nSignalsToIssue;\n  if (cond == NULL || *cond == NULL)\n    {\n      return EINVAL;\n    }\n  cv = *cond;\n  if (cv == PTHREAD_COND_INITIALIZER)\n    {\n      return 0;\n    }\n  if ((result = pthread_mutex_lock (&(cv->mtxUnblockLock))) != 0)\n    {\n      return result;\n    }\n  if (0 != cv->nWaitersToUnblock)\n    {\n      if (0 == cv->nWaitersBlocked)\n\t{\n\t  return pthread_mutex_unlock (&(cv->mtxUnblockLock));\n\t}\n      if (unblockAll)\n\t{\n\t  cv->nWaitersToUnblock += (nSignalsToIssue = cv->nWaitersBlocked);\n\t  cv->nWaitersBlocked = 0;\n\t}\n      else\n\t{\n\t  nSignalsToIssue = 1;\n\t  cv->nWaitersToUnblock++;\n\t  cv->nWaitersBlocked--;\n\t}\n    }\n  else if (cv->nWaitersBlocked > cv->nWaitersGone)\n    {\n      if (__ptw32_semwait (&(cv->semBlockLock)) != 0)\n\t{\n\t  result =  __PTW32_GET_ERRNO();\n\t  (void) pthread_mutex_unlock (&(cv->mtxUnblockLock));\n\t  return result;\n\t}\n      if (0 != cv->nWaitersGone)\n\t{\n\t  cv->nWaitersBlocked -= cv->nWaitersGone;\n\t  cv->nWaitersGone = 0;\n\t}\n      if (unblockAll)\n\t{\n\t  nSignalsToIssue = cv->nWaitersToUnblock = cv->nWaitersBlocked;\n\t  cv->nWaitersBlocked = 0;\n\t}\n      else\n\t{\n\t  nSignalsToIssue = cv->nWaitersToUnblock = 1;\n\t  cv->nWaitersBlocked--;\n\t}\n    }\n  else\n    {\n      return pthread_mutex_unlock (&(cv->mtxUnblockLock));\n    }\n  if ((result = pthread_mutex_unlock (&(cv->mtxUnblockLock))) == 0)\n    {\n      if (sem_post_multiple (&(cv->semBlockQueue), nSignalsToIssue) != 0)\n\t{\n\t  result =  __PTW32_GET_ERRNO();\n\t}\n    }\n  return result;\n}\nint\npthread_cond_signal (pthread_cond_t * cond)\n{\n  return (__ptw32_cond_unblock (cond, 0));\n}\n//...'"
('Prompt: Write a code snippet that tests the function `spgramcf_estimate_psd` with a null input pointer. The scenario is to check that the function properly handles the case when the input vector pointer is NULL. The test should assert that the output PSD values are equal to a calculated minimum value after taking the logarithm.,"//...\nvoid autotest_spgramcf_null()\n{\n    unsigned int nfft = 1200;   \n    float psd[nfft];\n    spgramcf_estimate_psd(nfft, NULL, 0, psd);\n    float psd_val = 10*log10f(LIQUID_SPGRAM_PSD_MIN);\n    unsigned int i;\n    for (i=0; i<nfft; i++)\n        CONTEND_EQUALITY(psd[i], psd_val);\n}\n//...')
"
"'Please provide a prompt that requires a detailed explanation and implementation of USART Direct Memory Access (DMA) configuration in an embedded system using the XDMAC peripheral. The prompt should include setting up DMA channels for both receiving and transmitting data over USART, configuring DMA transfer parameters, handling callback functions for DMA completion, and enabling/disabling DMA channels as needed.","static void USARTD_Rx_Cb(uint32_t channel, UsartDma *pArg)\n{\n\tUsartChannel *pUsartdCh = pArg->pRxChannel;\n\tif (channel != pUsartdCh->ChNum)\n\t\treturn;\n\tXDMAD_FreeChannel(pArg->pXdmad, pUsartdCh->ChNum);\n\tpUsartdCh->dmaProgress = 1;\n\tSCB_InvalidateDCache_by_Addr((uint32_t *)pUsartdCh->pBuff, pUsartdCh->BuffSize);\n}\nstatic void USARTD_Tx_Cb(uint32_t channel, UsartDma *pArg)\n{\n\tUsartChannel *pUsartdCh = pArg->pTxChannel;\n\tif (channel != pUsartdCh->ChNum)\n\t\treturn;\n\tXDMAD_FreeChannel(pArg->pXdmad, pUsartdCh->ChNum);\n\tpUsartdCh->dmaProgress = 1;\n}\nstatic uint8_t _configureRxDma(UsartDma *pUsart, UsartChannel *pUsartRx)\n{\n\tsXdmadCfg xdmadRxCfg;\n\tuint32_t xdmaCndc, xdmaInt;\n\tuint32_t i, LLI_Size;\n\tUsart *pUsartHwRx = pUsart->pUsartHw;\n\tsXdmad *pXdmadRx = pUsart->pXdmad;\n\tuint8_t *pBuff = 0;\n\tif (pUsartRx->dmaProgrammingMode < XDMAD_LLI) {\n\t\txdmadRxCfg.mbr_ubc = pUsartRx->BuffSize;\n\t\txdmadRxCfg.mbr_da = (uint32_t)pUsartRx->pBuff;\n\t\txdmadRxCfg.mbr_sa = (uint32_t)&pUsartHwRx->US_RHR;\n\t\txdmadRxCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |\n\t\t\t\t\t\t\t XDMAC_CC_MBSIZE_SIXTEEN |\n\t\t\t\t\t\t\t XDMAC_CC_DSYNC_PER2MEM |\n\t\t\t\t\t\t\t XDMAC_CC_CSIZE_CHK_1 |\n\t\t\t\t\t\t\t XDMAC_CC_DWIDTH_BYTE |\n\t\t\t\t\t\t\t XDMAC_CC_SIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_DIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_SAM_FIXED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_DAM_INCREMENTED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber\n\t\t\t\t\t\t\t\t\t\t\t(pUsart->usartId, XDMAD_TRANSFER_RX));\n\t\txdmadRxCfg.mbr_bc = 0;\n\t\tif (pUsartRx->dmaProgrammingMode == XDMAD_MULTI)\n\t\t\txdmadRxCfg.mbr_bc = pUsartRx->dmaBlockSize;\n\t\txdmadRxCfg.mbr_sus = 0;\n\t\txdmadRxCfg.mbr_dus = 0;\n\t\txdmaCndc = 0;\n\t\txdmaInt =  (XDMAC_CIE_BIE   |\n\t\t\t\t\tXDMAC_CIE_DIE   |\n\t\t\t\t\tXDMAC_CIE_FIE   |\n\t\t\t\t\tXDMAC_CIE_RBIE  |\n\t\t\t\t\tXDMAC_CIE_WBIE  |\n\t\t\t\t\tXDMAC_CIE_ROIE);\n\t} else if (pUsartRx->dmaProgrammingMode == XDMAD_LLI) {\n\t\tLLI_Size = pUsartRx->dmaBlockSize;\n\t\tpBuff = pUsartRx->pBuff;\n\t\tif (pUsartRx->pLLIview != NULL) {\n\t\t\tfree(pUsartRx->pLLIview);\n\t\t\tpUsartRx->pLLIview = NULL;\n\t\t}\n\t\tpUsartRx->pLLIview = malloc(sizeof(LinkedListDescriporView1) * LLI_Size);\n\t\tif (pUsartRx->pLLIview == NULL) {\n\t\t\tTRACE_ERROR("" Can not allocate memory to Rx LLI"");\n\t\t\treturn USARTD_ERROR;\n\t\t}\n\t\txdmadRxCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |\n\t\t\t\t\t\t\t XDMAC_CC_MBSIZE_SIXTEEN |\n\t\t\t\t\t\t\t XDMAC_CC_DSYNC_PER2MEM |\n\t\t\t\t\t\t\t XDMAC_CC_MEMSET_NORMAL_MODE |\n\t\t\t\t\t\t\t XDMAC_CC_CSIZE_CHK_1 |\n\t\t\t\t\t\t\t XDMAC_CC_DWIDTH_BYTE |\n\t\t\t\t\t\t\t XDMAC_CC_SIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_DIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_SAM_FIXED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_DAM_INCREMENTED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber\n\t\t\t\t\t\t\t\t\t\t\t(pUsart->usartId, XDMAD_TRANSFER_RX));\n\t\txdmadRxCfg.mbr_bc = 0;\n\t\tfor (i = 0; i < LLI_Size; i++) {\n\t\t\tpUsartRx->pLLIview[i].mbr_ubc = XDMA_UBC_NVIEW_NDV1 |\n\t\t\t\t\t\t\t\t\t\t\tXDMA_UBC_NSEN_UNCHANGED |\n\t\t\t\t\t\t\t\t\t\t\tXDMA_UBC_NDEN_UPDATED |\n\t\t\t\t\t\t\t\t\t\t\t((i == LLI_Size - 1) ? (\n\t\t\t\t\t\t\t\t\t\t\t\t (pUsartRx->dmaRingBuffer) ?\n\t\t\t\t\t\t\t\t\t\t\t\t XDMA_UBC_NDE_FETCH_EN : 0) :\n\t\t\t\t\t\t\t\t\t\t\t XDMA_UBC_NDE_FETCH_EN) |\n\t\t\t\t\t\t\t\t\t\t\tpUsartRx->BuffSize;\n\t\t\tpUsartRx->pLLIview[i].mbr_sa = (uint32_t)&pUsartHwRx->US_RHR;\n\t\t\tpUsartRx->pLLIview[i].mbr_da = (uint32_t)pBuff;\n\t\t\tpUsartRx->pLLIview[i].mbr_nda = (i == (LLI_Size - 1)) ?\n\t\t\t\t\t\t\t\t\t\t\t((pUsartRx->dmaRingBuffer) ? (uint32_t)pUsartRx->pLLIview : 0)\n\t\t\t\t\t\t\t\t\t\t\t: (uint32_t)&pUsartRx->pLLIview[ i + 1 ];\n\t\t\tpBuff += pUsartRx->BuffSize;\n\t\t}\n\t\tSCB_CleanDCache_by_Addr((uint32_t *)(pUsartRx->pLLIview),\n\t\t\t\t\t\t\t\tsizeof(LinkedListDescriporView1)*LLI_Size);\n\t\txdmaCndc = XDMAC_CNDC_NDVIEW_NDV1 |\n\t\t\t\t   XDMAC_CNDC_NDE_DSCR_FETCH_EN |\n\t\t\t\t   XDMAC_CNDC_NDSUP_SRC_PARAMS_UPDATED |\n\t\t\t\t   XDMAC_CNDC_NDDUP_DST_PARAMS_UPDATED;\n\t\txdmaInt = ((pUsartRx->dmaRingBuffer) ? XDMAC_CIE_BIE : XDMAC_CIE_LIE);\n\t} else\n\t\treturn 1;\n\tif (XDMAD_ConfigureTransfer(\n\t\t\tpXdmadRx, pUsartRx->ChNum, &xdmadRxCfg, xdmaCndc,\n\t\t\t(uint32_t)pUsartRx->pLLIview, xdmaInt))\n\t\treturn USARTD_ERROR;\n\treturn 0;\n}\nstatic uint8_t _configureTxDma(UsartDma *pUsart, UsartChannel *pUsartTx)\n{\n\tsXdmadCfg xdmadTxCfg;\n\tuint32_t xdmaCndc, xdmaInt, LLI_Size, i;\n\tuint8_t *pBuff = 0;\n\tUsart *pUsartHwTx = pUsart->pUsartHw;\n\tsXdmad *pXdmadTx = pUsart->pXdmad;\n\tif (pUsartTx->dmaProgrammingMode < XDMAD_LLI) {\n\t\txdmadTxCfg.mbr_ubc =   pUsartTx->BuffSize;\n\t\txdmadTxCfg.mbr_sa = (uint32_t)pUsartTx->pBuff;\n\t\txdmadTxCfg.mbr_da = (uint32_t)&pUsartHwTx->US_THR;\n\t\txdmadTxCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |\n\t\t\t\t\t\t\t XDMAC_CC_MBSIZE_SIXTEEN |\n\t\t\t\t\t\t\t XDMAC_CC_DSYNC_MEM2PER |\n\t\t\t\t\t\t\t XDMAC_CC_CSIZE_CHK_1 |\n\t\t\t\t\t\t\t XDMAC_CC_DWIDTH_BYTE |\n\t\t\t\t\t\t\t XDMAC_CC_SIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_DIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_SAM_INCREMENTED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_DAM_FIXED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber\n\t\t\t\t\t\t\t\t\t\t\t(pUsart->usartId, XDMAD_TRANSFER_TX));\n\t\txdmadTxCfg.mbr_bc = 0;\n\t\tif (pUsartTx->dmaProgrammingMode == XDMAD_MULTI)\n\t\t\txdmadTxCfg.mbr_bc = pUsartTx->dmaBlockSize;\n\t\txdmadTxCfg.mbr_sus = 0;\n\t\txdmadTxCfg.mbr_dus = 0;\n\t\txdmadTxCfg.mbr_ds = 0;\n\t\txdmaCndc = 0;\n\t\txdmaInt =  (XDMAC_CIE_BIE    |\n\t\t\t\t\tXDMAC_CIE_RBIE  |\n\t\t\t\t\tXDMAC_CIE_WBIE  |\n\t\t\t\t\tXDMAC_CIE_ROIE);\n\t} else if (pUsartTx->dmaProgrammingMode == XDMAD_LLI) {\n\t\tLLI_Size = pUsartTx->dmaBlockSize;\n\t\tpBuff = pUsartTx->pBuff;\n\t\tif (pUsartTx->pLLIview != NULL) {\n\t\t\tfree(pUsartTx->pLLIview);\n\t\t\tpUsartTx->pLLIview = NULL;\n\t\t}\n\t\tpUsartTx->pLLIview = malloc(sizeof(LinkedListDescriporView1) * LLI_Size);\n\t\tif (pUsartTx->pLLIview == NULL) {\n\t\t\tTRACE_ERROR("" Can not allocate memory to Tx LLI"");\n\t\t\treturn USARTD_ERROR;\n\t\t}\n\t\txdmadTxCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |\n\t\t\t\t\t\t\t XDMAC_CC_MBSIZE_SIXTEEN |\n\t\t\t\t\t\t\t XDMAC_CC_DSYNC_MEM2PER |\n\t\t\t\t\t\t\t XDMAC_CC_MEMSET_NORMAL_MODE |\n\t\t\t\t\t\t\t XDMAC_CC_CSIZE_CHK_1 |\n\t\t\t\t\t\t\t XDMAC_CC_DWIDTH_BYTE |\n\t\t\t\t\t\t\t XDMAC_CC_SIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_DIF_AHB_IF1 |\n\t\t\t\t\t\t\t XDMAC_CC_SAM_INCREMENTED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_DAM_FIXED_AM |\n\t\t\t\t\t\t\t XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber\n\t\t\t\t\t\t\t\t\t\t\t(pUsart->usartId, XDMAD_TRANSFER_TX));\n\t\txdmadTxCfg.mbr_bc = 0;\n\t\tfor (i = 0; i < LLI_Size; i++) {\n\t\t\tpUsartTx->pLLIview[i].mbr_ubc = XDMA_UBC_NVIEW_NDV1 |\n\t\t\t\t\t\t\t\t\t\t\tXDMA_UBC_NSEN_UPDATED |\n\t\t\t\t\t\t\t\t\t\t\tXDMA_UBC_NDEN_UNCHANGED |\n\t\t\t\t\t\t\t\t\t\t\t((i == LLI_Size - 1) ? ((pUsartTx->dmaRingBuffer)\n\t\t\t\t\t\t\t\t\t\t\t\t\t? XDMA_UBC_NDE_FETCH_EN : 0) :\n\t\t\t\t\t\t\t\t\t\t\t XDMA_UBC_NDE_FETCH_EN) | pUsartTx->BuffSize;\n\t\t\tpUsartTx->pLLIview[i].mbr_sa = (uint32_t)pBuff;\n\t\t\tpUsartTx->pLLIview[i].mbr_da = (uint32_t)&pUsartHwTx->US_THR;\n\t\t\tpUsartTx->pLLIview[i].mbr_nda = (i == (LLI_Size - 1)) ?\n\t\t\t\t\t\t\t\t\t\t\t((pUsartTx->dmaRingBuffer) ? (uint32_t)pUsartTx->pLLIview : 0)\n\t\t\t\t\t\t\t\t\t\t\t: (uint32_t)&pUsartTx->pLLIview[ i + 1 ];\n\t\t\tpBuff += pUsartTx->BuffSize;\n\t\t}\n\t\tSCB_CleanDCache_by_Addr((uint32_t *)(pUsartTx->pLLIview),\n\t\t\t\t\t\t\t\tsizeof(LinkedListDescriporView1)*LLI_Size);\n\t\txdmaCndc = XDMAC_CNDC_NDVIEW_NDV1 |\n\t\t\t\t   XDMAC_CNDC_NDE_DSCR_FETCH_EN |\n\t\t\t\t   XDMAC_CNDC_NDSUP_SRC_PARAMS_UPDATED |\n\t\t\t\t   XDMAC_CNDC_NDDUP_DST_PARAMS_UPDATED;\n\t\txdmaInt = ((pUsartTx->dmaRingBuffer) ? XDMAC_CIE_BIE : XDMAC_CIE_LIE);\n\t} else {\n\t\tTRACE_ERROR(""DmaProgState is incorrect \\n\\r"");\n\t\treturn 1;\n\t}\n\tif (XDMAD_ConfigureTransfer(pXdmadTx, pUsartTx->ChNum,\n\t\t\t\t\t\t\t\t &xdmadTxCfg, xdmaCndc, (uint32_t)pUsartTx->pLLIview, xdmaInt))\n\t\treturn USARTD_ERROR;\n\treturn 0;\n}\nuint32_t USARTD_Configure(UsartDma *pUsartd ,\n\t\t\t\t\t\t   uint8_t usartId,\n\t\t\t\t\t\t   uint32_t UsartMode,\n\t\t\t\t\t\t   uint32_t BaudRate,\n\t\t\t\t\t\t   uint32_t UsartClk)\n{\n\tPMC_EnablePeripheral(usartId);\n\tpUsartd->usartId  = usartId;\n\tif (usartId == ID_USART0)\n\t\tpUsartd->pUsartHw = USART0;\n\tif (usartId == ID_USART1)\n\t\tpUsartd->pUsartHw = USART1;\n\tif (usartId == ID_USART2)\n\t\tpUsartd->pUsartHw = USART2;\n\tUSART_Configure (pUsartd->pUsartHw, UsartMode, BaudRate, UsartClk);\n\tif (!(NVIC_GetActive(XDMAC_IRQn)))\n\t\tNVIC_ClearPendingIRQ(XDMAC_IRQn);\n\treturn 0;\n}\nuint32_t USARTD_EnableRxChannels(UsartDma *pUsartd, UsartChannel *pRxCh)\n{\n\tuint32_t Channel;\n\tassert(pRxCh);\n\tpUsartd->pRxChannel = pRxCh;\n\tUSART_SetReceiverEnabled (pUsartd->pUsartHw , ENABLE);\n\tChannel =  XDMAD_AllocateChannel(pUsartd->pXdmad, pUsartd->usartId,\n\t\t\t\t\t\t\t\t\t  XDMAD_TRANSFER_MEMORY);\n\tif (Channel == XDMAD_ALLOC_FAILED)\n\t\treturn USARTD_ERROR;\n\tpRxCh->ChNum = Channel;\n\tif (pUsartd->pRxChannel->callback) {\n\t\tXDMAD_SetCallback(pUsartd->pXdmad, pRxCh->ChNum,\n\t\t\t\t\t\t  (XdmadTransferCallback)pRxCh->callback, pRxCh->pArgument);\n\t} else {\n\t\tXDMAD_SetCallback(pUsartd->pXdmad, pRxCh->ChNum,\n\t\t\t\t\t\t  (XdmadTransferCallback)USARTD_Rx_Cb, pUsartd);\n\t}\n\tif (XDMAD_PrepareChannel(pUsartd->pXdmad, pRxCh->ChNum))\n\t\treturn USARTD_ERROR;\n\tif (_configureRxDma(pUsartd , pUsartd->pRxChannel))\n\t\treturn USARTD_ERROR_LOCK;\n\tif (!(NVIC_GetActive(XDMAC_IRQn))) {\n\t\tNVIC_EnableIRQ(XDMAC_IRQn);\n\t}\n\treturn 0;\n}\nuint32_t USARTD_EnableTxChannels(UsartDma *pUsartd, UsartChannel *pTxCh)\n{\n\tuint32_t Channel;\n\tassert(pTxCh);\n\tpUsartd->pTxChannel = pTxCh;\n\tUSART_SetTransmitterEnabled (pUsartd->pUsartHw , ENABLE);\n\tChannel =  XDMAD_AllocateChannel(pUsartd->pXdmad, XDMAD_TRANSFER_MEMORY,\n\t\t\t\t\t\t\t\t\t  pUsartd->usartId);\n\tif (Channel == XDMAD_ALLOC_FAILED)\n\t\treturn USARTD_ERROR;\n\tpTxCh->ChNum = Channel;\n\tif (pUsartd->pTxChannel->callback) {\n\t\tXDMAD_SetCallback(pUsartd->pXdmad, pTxCh->ChNum,\n\t\t\t\t\t\t  (XdmadTransferCallback)pTxCh->callback, pTxCh->pArgument);\n\t} else\n\t\tXDMAD_SetCallback(pUsartd->pXdmad, pTxCh->ChNum,\n\t\t\t\t\t\t  (XdmadTransferCallback)USARTD_Tx_Cb, pUsartd);\n\tif (XDMAD_PrepareChannel(pUsartd->pXdmad, pTxCh->ChNum))\n\t\treturn USARTD_ERROR;\n\tif (_configureTxDma(pUsartd , pUsartd->pTxChannel))\n\t\treturn USARTD_ERROR_LOCK;\n\tif (!(NVIC_GetActive(XDMAC_IRQn))) {\n\t\tNVIC_EnableIRQ(XDMAC_IRQn);\n\t}\n\treturn 0;\n}\nuint32_t USARTD_DisableRxChannels(UsartDma *pUsartd, UsartChannel *pRxCh)\n{\n\tassert(pRxCh);\n\tUSART_SetReceiverEnabled (pUsartd->pUsartHw , DISABLE);\n\tXDMAD_StopTransfer(pUsartd->pXdmad, pRxCh->ChNum);\n\tXDMAD_SetCallback(pUsartd->pXdmad, pRxCh->ChNum, NULL, NULL);\n\tif (XDMAD_FreeChannel(pUsartd->pXdmad, pRxCh->ChNum) != XDMAD_OK)\n\t\treturn USARTD_ERROR;\n\tif (pRxCh->dmaProgrammingMode == XDMAD_LLI) {\n\t\tfree(pRxCh->pLLIview);\n\t\tpRxCh->pLLIview = NULL;\n\t}\n\tpRxCh->dmaProgress = 1;\n\treturn 0;\n}\nuint32_t USARTD_DisableTxChannels(UsartDma *pUsartd, UsartChannel *pTxCh)\n{\n\tassert(pTxCh);\n\tUSART_SetTransmitterEnabled (pUsartd->pUsartHw , DISABLE);\n\tXDMAD_StopTransfer(pUsartd->pXdmad, pTxCh->ChNum);\n\tXDMAD_SetCallback(pUsartd->pXdmad, pTxCh->ChNum, NULL, NULL);\n\tif (XDMAD_FreeChannel(pUsartd->pXdmad, pTxCh->ChNum) != XDMAD_OK)\n\t\treturn USARTD_ERROR;\n\tif (pTxCh->dmaProgrammingMode == XDMAD_LLI) {\n\t\tfree(pTxCh->pLLIview);\n\t\tpTxCh->pLLIview = NULL;\n\t}\n\tpTxCh->dmaProgress = 1;\n\treturn 0;\n}\nuint32_t USARTD_SendData(UsartDma *pUsartd)\n{\n\tpUsartd->pTxChannel->dmaProgress = 0;\n\tSCB_CleanDCache_by_Addr((uint32_t *)pUsartd->pTxChannel->pBuff,\n\t\t\t\t\t\t\tpUsartd->pTxChannel->BuffSize);\n\tif (XDMAD_StartTransfer(pUsartd->pXdmad, pUsartd->pTxChannel->ChNum))\n\t\treturn USARTD_ERROR_LOCK;\n\treturn 0;\n}\nuint32_t USARTD_RcvData(UsartDma *pUsartd)\n{\n\tpUsartd->pRxChannel->dmaProgress = 0;\n\tif (XDMAD_StartTransfer(pUsartd->pXdmad, pUsartd->pRxChannel->ChNum))\n\t\treturn USARTD_ERROR_LOCK;\n\treturn 0;\n}'"
"'Please provide a prompt that describes a scenario where you need to implement functions for creating and formatting TLV (Type-Length-Value) data structures in C. The functions should allow adding different types of values (bytes, strings, nested TLV structures) to the TLV collection and formatting them into a buffer. You should also include memory management for dynamic data allocation.","//...\n    tlv_t *t = tlv_get_value(values, type);\n\n    return NULL;\n    return value;\n    int r = tlv_parse(t->value, t->size, value);\ntlv_values_t *tlv_new() {\n    tlv_values_t *values = malloc(sizeof(tlv_values_t));\n    values->head = NULL;\n    return values;\n}\nint tlv_format(const tlv_values_t *values, byte *buffer, size_t *size) {\n    size_t required_size = 0;\n    tlv_t *t = values->head;\n    while (t) {\n        required_size += t->size + 2 * ((t->size + 254) / 255);\n        t = t->next;\n    }\n    if (*size < required_size) {\n        *size = required_size;\n        return -1;\n    }\n    *size = required_size;\n    t = values->head;\n    while (t) {\n        byte *data = t->value;\n        if (!t->size) {\n            buffer[0] = t->type;\n            buffer[1] = 0;\n            buffer += 2;\n            t = t->next;\n            continue;\n        }\n        size_t remaining = t->size;\n        while (remaining) {\n            buffer[0] = t->type;\n            size_t chunk_size = (remaining > 255) ? 255 : remaining;\n            buffer[1] = chunk_size;\n            memcpy(&buffer[2], data, chunk_size);\n            remaining -= chunk_size;\n            buffer += chunk_size + 2;\n            data += chunk_size;\n        }\n        t = t->next;\n    }\n    return 0;\n}\nint tlv_add_value_(tlv_values_t *values, byte type, byte *value, size_t size) {\n    tlv_t *tlv = malloc(sizeof(tlv_t));\n    tlv->type = type;\n    tlv->size = size;\n    tlv->value = value;\n    tlv->next = NULL;\n    if (!values->head) {\n        values->head = tlv;\n    } else {\n        tlv_t *t = values->head;\n        while (t->next) {\n            t = t->next;\n        }\n        t->next = tlv;\n    }\n    return 0;\n}\nint tlv_add_value(tlv_values_t *values, byte type, const byte *value, size_t size) {\n    byte *data = NULL;\n    if (size) {\n        data = malloc(size);\n        memcpy(data, value, size);\n    }\n    return tlv_add_value_(values, type, data, size);\n}\nint tlv_add_tlv_value(tlv_values_t *values, byte type, tlv_values_t *value) {\n    size_t tlv_size = 0;\n    tlv_format(value, NULL, &tlv_size);\n    byte *tlv_data = malloc(tlv_size);\n    int r = tlv_format(value, tlv_data, &tlv_size);\n    if (r) {\n        free(tlv_data);\n        return r;\n    }\n    r = tlv_add_value_(values, type, tlv_data, tlv_size);\n    return r;\n}\n//...'"
"('Prompt: Create a function called ""autotest_firinterp_rrrf_common"" that tests the functionality of a finite impulse response (FIR) interpolator with a Kaiser window function. The interpolator should have an interpolation rate of 17 and a decimation rate of 4. The Kaiser window parameter should be set to 60.0f. The function should check if the interpolation rate is set correctly, and then destroy the interpolator.","//...\nvoid autotest_firinterp_rrrf_common()\n{\n    firinterp_rrrf interp = firinterp_rrrf_create_kaiser(17, 4, 60.0f);\n    CONTEND_EQUALITY(firinterp_rrrf_get_interp_rate(interp), 17);\n    firinterp_rrrf_destroy(interp);\n}\n//...')
"
"('Prompt: Design a testbench function for evaluating the frequency response of an elliptic lowpass IIR filter implemented using the CRCF data type. The function should take the filter order (_n), cutoff frequency (_fc), sampling frequency (_fs), passband ripple (_ap), and stopband attenuation (_as) as input parameters. The function should generate the filter prototype, calculate the power spectral density (PSD), and validate the filter response against specified frequency regions. Additionally, provide a flag to enable/disable verbose output for debugging purposes.","//...\nvoid testbench_iirdes_ellip_lowpass(unsigned int _n,    \n                                    float        _fc,   \n                                    float        _fs,   \n                                    float        _ap,   \n                                    float        _as)   \n{\n    float        tol  = 1e-3f;  \n    unsigned int nfft = 800;    \n    iirfilt_crcf q = iirfilt_crcf_create_prototype(\n        LIQUID_IIRDES_ELLIP, LIQUID_IIRDES_LOWPASS, LIQUID_IIRDES_SOS,\n        _n,_fc,0.0f,_ap,_as);\n    if (liquid_autotest_verbose)\n        iirfilt_crcf_print(q);\n    float H0 = 0.0f, H1 = -_ap, H2 = -_as;\n    unsigned int i;\n    float H[nfft]; \n    for (i=0; i<nfft; i++)\n        H[i] = iirfilt_crcf_get_psd(q, (float)i/(float)nfft-0.5f);\n    autotest_psd_s regions[] = {\n      {.fmin=0.0f, .fmax=_fc,   .pmin=H1-tol, .pmax=H0+tol, .test_lo=1, .test_hi=1},\n      {.fmin=_fs,  .fmax=+0.5f, .pmin=0,      .pmax=H2+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(H, nfft, regions, 2,\n        liquid_autotest_verbose ? ""autotest/logs/iirdes_ellip_lowpass.m"" : NULL);\n    iirfilt_crcf_destroy(q);\n}\n//...')
"
"('Prompt: ""Please write a function in C that performs a test using a finite impulse response decimator on a complex float data set. The decimator should have a filter length of 5, operate on input data set \'firdecim_cccf_data_M5h23x50_x\' with 50 elements, and produce an output data set \'firdecim_cccf_data_M5h23x50_y\' with a decimation rate of 10. The filter coefficients are stored in \'firdecim_cccf_data_M5h23x50_h\' with a length of 23. The function should be named \'autotest_firdecim_cccf_data_M5h23x50\'.""","//...\nvoid autotest_firdecim_cccf_data_M5h23x50()\n{\n    firdecim_cccf_test(5,\n                       firdecim_cccf_data_M5h23x50_h, 23,\n                       firdecim_cccf_data_M5h23x50_x, 50,\n                       firdecim_cccf_data_M5h23x50_y, 10);\n}\n//...')
"
"'Prompt: You are developing a user interface for an embedded system using LittlevGL library. You need to create a Pinyin input method editor (IME) with a keyboard and a candidate panel. The IME should work with a textarea for user input. When the textarea is focused, the keyboard should be displayed, and when the input is cancelled, the keyboard should be hidden. The candidate panel should be positioned above the keyboard. Finally, you need to display a label with Chinese text below the textarea. Can you provide a code snippet for this scenario? . . Code:. ```c. #if LV_USE_LABEL && LV_USE_TEXTAREA && LV_FONT_SIMSUN_16_CJK && LV_USE_IME_PINYIN && LV_BUILD_EXAMPLES. static void ta_event_cb(lv_event_t * e). {.     lv_event_code_t code = lv_event_get_code(e);.     lv_obj_t * ta = lv_event_get_target(e);.     lv_obj_t * kb = lv_event_get","#if LV_USE_LABEL && LV_USE_TEXTAREA && LV_FONT_SIMSUN_16_CJK && LV_USE_IME_PINYIN && LV_BUILD_EXAMPLES\nstatic void ta_event_cb(lv_event_t * e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * ta = lv_event_get_target(e);\n    lv_obj_t * kb = lv_event_get_user_data(e);\n    if(code == LV_EVENT_FOCUSED) {\n        if(lv_indev_get_type(lv_indev_active()) != LV_INDEV_TYPE_KEYPAD) {\n            lv_keyboard_set_textarea(kb, ta);\n            lv_obj_remove_flag(kb, LV_OBJ_FLAG_HIDDEN);\n        }\n    }\n    else if(code == LV_EVENT_CANCEL) {\n        lv_obj_add_flag(kb, LV_OBJ_FLAG_HIDDEN);\n        lv_obj_remove_state(ta, LV_STATE_FOCUSED);\n        lv_indev_reset(NULL, ta);   \n    }\n}\nvoid lv_example_ime_pinyin_1(void)\n{\n    lv_obj_t * pinyin_ime = lv_ime_pinyin_create(lv_screen_active());\n    lv_obj_set_style_text_font(pinyin_ime, &lv_font_simsun_16_cjk, 0);\n    lv_obj_t * ta1 = lv_textarea_create(lv_screen_active());\n    lv_textarea_set_one_line(ta1, true);\n    lv_obj_set_style_text_font(ta1, &lv_font_simsun_16_cjk, 0);\n    lv_obj_align(ta1, LV_ALIGN_TOP_LEFT, 0, 0);\n    lv_obj_t * kb = lv_keyboard_create(lv_screen_active());\n    lv_ime_pinyin_set_keyboard(pinyin_ime, kb);\n    lv_keyboard_set_textarea(kb, ta1);\n    lv_obj_add_event_cb(ta1, ta_event_cb, LV_EVENT_ALL, kb);\n    lv_obj_t * cand_panel = lv_ime_pinyin_get_cand_panel(pinyin_ime);\n    lv_obj_set_size(cand_panel, LV_PCT(100), LV_PCT(10));\n    lv_obj_align_to(cand_panel, kb, LV_ALIGN_OUT_TOP_MID, 0, 0);\n    lv_obj_t * cz_label = lv_label_create(lv_screen_active());\n    lv_label_set_text(cz_label,\n                      ""Embedded System\\n"");\n    lv_obj_set_style_text_font(cz_label, &lv_font_simsun_16_cjk, 0);\n    lv_obj_set_width(cz_label, 310);\n    lv_obj_align_to(cz_label, ta1, LV_ALIGN_OUT_BOTTOM_LEFT, 0, 0);\n}\n#endif'"
'Please provide the prompt or technical scenario in which you would like to use the code provided for response.,"//...\n    if(_lv_area_is_in(area_p, &obj->coords, 0) == false) return NULL;\n    info.area = area_p;\n    for(i = child_cnt - 1; i >= 0; i--) {\n    for(i = child_cnt - 1; i >= 0; i--) {\nlv_display_t * _lv_refr_get_disp_refreshing(void)\n{\n    return disp_refr;\n}\nstatic void draw_buf_flush(lv_display_t * disp)\n{\n    lv_layer_t * layer = disp->layer_head;\n    while(layer->draw_task_head) {\n        lv_draw_dispatch_wait_for_request();\n        lv_draw_dispatch();\n    }\n    if(lv_display_is_double_buffered(disp)) {\n        wait_for_flushing(disp_refr);\n    }\n    disp->flushing = 1;\n    if(disp->last_area && disp->last_part) disp->flushing_last = 1;\n    else disp->flushing_last = 0;\n    bool flushing_last = disp->flushing_last;\n    if(disp->flush_cb) {\n        call_flush_cb(disp, &disp->refreshed_area, layer->draw_buf->data);\n    }\n    if(lv_display_is_double_buffered(disp) && (disp->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT || flushing_last)) {\n        if(disp->buf_act == disp->buf_1) {\n            disp->buf_act = disp->buf_2;\n        }\n        else {\n            disp->buf_act = disp->buf_1;\n        }\n    }\n}\nstatic void layer_reshape_draw_buf(lv_layer_t * layer)\n{\n    LV_ASSERT(lv_draw_buf_reshape(\n                  layer->draw_buf,\n                  layer->color_format,\n                  lv_area_get_width(&layer->buf_area),\n                  lv_area_get_height(&layer->buf_area),\n                  0)\n              != NULL);\n}\nstatic void call_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)\n{\n    LV_PROFILER_BEGIN;\n    LV_TRACE_REFR(""Calling flush_cb on (%d;%d)(%d;%d) area with %p image pointer"",\n                  (int)area->x1, (int)area->y1, (int)area->x2, (int)area->y2, (void *)px_map);\n    lv_area_t offset_area = {\n        .x1 = area->x1 + disp->offset_x,\n        .y1 = area->y1 + disp->offset_y,\n        .x2 = area->x2 + disp->offset_x,\n        .y2 = area->y2 + disp->offset_y\n    };\n    lv_display_send_event(disp, LV_EVENT_FLUSH_START, &offset_area);\n    disp->flush_cb(disp, &offset_area, px_map);\n    lv_display_send_event(disp, LV_EVENT_FLUSH_FINISH, &offset_area);\n    LV_PROFILER_END;\n}\nstatic bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)\n{\n    if(!_lv_area_is_on(area, &obj->coords)) return true;\n    lv_cover_check_info_t info;\n    info.res = LV_COVER_RES_COVER;\n    info.area = area;\n    lv_obj_send_event(obj, LV_EVENT_COVER_CHECK, &info);\n    if(info.res == LV_COVER_RES_COVER) return false;\n    else return true;\n}\nstatic void lv_refr_join_area(void)\n{\n    LV_PROFILER_BEGIN;\n    uint32_t join_from;\n    uint32_t join_in;\n    lv_area_t joined_area;\n    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {\n        if(disp_refr->inv_area_joined[join_in] != 0) continue;\n        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {\n            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {\n                continue;\n            }\n            if(_lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {\n                continue;\n            }\n            _lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);\n            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +\n                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {\n                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);\n                disp_refr->inv_area_joined[join_from] = 1;\n            }\n        }\n    }\n    LV_PROFILER_END;\n}\nstatic void refr_area(const lv_area_t * area_p)\n{\n    LV_PROFILER_BEGIN;\n    lv_layer_t * layer = disp_refr->layer_head;\n    layer->draw_buf = disp_refr->buf_act;\n    if(disp_refr->render_mode != LV_DISPLAY_RENDER_MODE_PARTIAL) {\n        layer->buf_area.x1 = 0;\n        layer->buf_area.y1 = 0;\n        layer->buf_area.x2 = lv_display_get_horizontal_resolution(disp_refr) - 1;\n        layer->buf_area.y2 = lv_display_get_vertical_resolution(disp_refr) - 1;\n        layer_reshape_draw_buf(layer);\n        lv_area_t disp_area;\n        lv_area_set(&disp_area, 0, 0, lv_display_get_horizontal_resolution(disp_refr) - 1,\n                    lv_display_get_vertical_resolution(disp_refr) - 1);\n        if(disp_refr->render_mode == LV_DISPLAY_RENDER_MODE_FULL) {\n            disp_refr->last_part = 1;\n            layer->_clip_area = disp_area;\n            refr_area_part(layer);\n        }\n        else if(disp_refr->render_mode == LV_DISPLAY_RENDER_MODE_DIRECT) {\n            disp_refr->last_part = disp_refr->last_area;\n            layer->_clip_area = *area_p;\n            refr_area_part(layer);\n        }\n        LV_PROFILER_END;\n        return;\n    }\n    int32_t w = lv_area_get_width(area_p);\n    int32_t h = lv_area_get_height(area_p);\n    int32_t y2 = area_p->y2 >= lv_display_get_vertical_resolution(disp_refr) ?\n                 lv_display_get_vertical_resolution(disp_refr) - 1 : area_p->y2;\n    int32_t max_row = get_max_row(disp_refr, w, h);\n    int32_t row;\n    int32_t row_last = 0;\n    lv_area_t sub_area;\n    for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {\n        sub_area.x1 = area_p->x1;\n        sub_area.x2 = area_p->x2;\n        sub_area.y1 = row;\n        sub_area.y2 = row + max_row - 1;\n        layer->draw_buf = disp_refr->buf_act;\n        layer->buf_area = sub_area;\n        layer->_clip_area = sub_area;\n        layer_reshape_draw_buf(layer);\n        if(sub_area.y2 > y2) sub_area.y2 = y2;\n        row_last = sub_area.y2;\n        if(y2 == row_last) disp_refr->last_part = 1;\n        refr_area_part(layer);\n    }\n    if(y2 != row_last) {\n        sub_area.x1 = area_p->x1;\n        sub_area.x2 = area_p->x2;\n        sub_area.y1 = row;\n        sub_area.y2 = y2;\n        layer->draw_buf = disp_refr->buf_act;\n        layer->buf_area = sub_area;\n        layer->_clip_area = sub_area;\n        layer_reshape_draw_buf(layer);\n        disp_refr->last_part = 1;\n        refr_area_part(layer);\n    }\n    LV_PROFILER_END;\n}\nstatic lv_result_t layer_get_area(lv_layer_t * layer, lv_obj_t * obj, lv_layer_type_t layer_type,\n                                  lv_area_t * layer_area_out, lv_area_t * obj_draw_size_out)\n{\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_obj_get_coords(obj, obj_draw_size_out);\n    lv_area_increase(obj_draw_size_out, ext_draw_size, ext_draw_size);\n    if(layer_type == LV_LAYER_TYPE_TRANSFORM) {\n        lv_area_t clip_coords_for_obj;\n        lv_area_t tranf_coords = *obj_draw_size_out;\n        lv_obj_get_transformed_area(obj, &tranf_coords, false, false);\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, &tranf_coords)) {\n            return LV_RESULT_INVALID;\n        }\n        lv_area_t inverse_clip_coords_for_obj = clip_coords_for_obj;\n        lv_obj_get_transformed_area(obj, &inverse_clip_coords_for_obj, false, true);\n        if(!_lv_area_intersect(&inverse_clip_coords_for_obj, &inverse_clip_coords_for_obj, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = inverse_clip_coords_for_obj;\n        lv_area_increase(layer_area_out, 5, 5); \n    }\n    else if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n        lv_area_t clip_coords_for_obj;\n        if(!_lv_area_intersect(&clip_coords_for_obj, &layer->_clip_area, obj_draw_size_out)) {\n            return LV_RESULT_INVALID;\n        }\n        *layer_area_out = clip_coords_for_obj;\n    }\n    else {\n        LV_LOG_WARN(""Unhandled layer type"");\n        return LV_RESULT_INVALID;\n    }\n    return LV_RESULT_OK;\n}\nvoid refr_obj(lv_layer_t * layer, lv_obj_t * obj)\n{\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;\n    lv_layer_type_t layer_type = _lv_obj_get_layer_type(obj);\n    if(layer_type == LV_LAYER_TYPE_NONE) {\n        lv_obj_redraw(layer, obj);\n    }\n    else {\n        lv_opa_t opa = lv_obj_get_style_opa_layered(obj, 0);\n        if(opa < LV_OPA_MIN) return;\n        lv_area_t layer_area_full;\n        lv_area_t obj_draw_size;\n        lv_result_t res = layer_get_area(layer, obj, layer_type, &layer_area_full, &obj_draw_size);\n        if(res != LV_RESULT_OK) return;\n        uint32_t max_rgb_row_height = lv_area_get_height(&layer_area_full);\n        uint32_t max_argb_row_height = lv_area_get_height(&layer_area_full);\n        if(layer_type == LV_LAYER_TYPE_SIMPLE) {\n            int32_t w = lv_area_get_width(&layer_area_full);\n            uint8_t px_size = lv_color_format_get_size(disp_refr->color_format);\n            max_rgb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / px_size;\n            max_argb_row_height = LV_DRAW_SW_LAYER_SIMPLE_BUF_SIZE / w / sizeof(lv_color32_t);\n        }\n        lv_area_t layer_area_act;\n        layer_area_act.x1 = layer_area_full.x1;\n        layer_area_act.x2 = layer_area_full.x2;\n        layer_area_act.y1 = layer_area_full.y1;\n        layer_area_act.y2 = layer_area_full.y1;\n        while(layer_area_act.y2 < layer_area_full.y2) {\n            layer_area_act.y2 = layer_area_act.y1 + max_rgb_row_height - 1;\n            if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            bool area_need_alpha = alpha_test_area_on_obj(obj, &layer_area_act);\n            if(area_need_alpha) {\n                layer_area_act.y2 = layer_area_act.y1 + max_argb_row_height - 1;\n                if(layer_area_act.y2 > layer_area_full.y2) layer_area_act.y2 = layer_area_full.y2;\n            }\n            lv_layer_t * new_layer = lv_draw_layer_create(layer,\n                                                          area_need_alpha ? LV_COLOR_FORMAT_ARGB8888 : LV_COLOR_FORMAT_NATIVE, &layer_area_act);\n            lv_obj_redraw(new_layer, obj);\n            lv_draw_image_dsc_t layer_draw_dsc;\n            lv_draw_image_dsc_init(&layer_draw_dsc);\n            layer_draw_dsc.pivot.x = obj->coords.x1 + lv_obj_get_style_transform_pivot_x(obj, 0) - new_layer->buf_area.x1;\n            layer_draw_dsc.pivot.y = obj->coords.y1 + lv_obj_get_style_transform_pivot_y(obj, 0) - new_layer->buf_area.y1;\n            layer_draw_dsc.opa = opa;\n            layer_draw_dsc.rotation = lv_obj_get_style_transform_rotation(obj, 0);\n            while(layer_draw_dsc.rotation > 3600) layer_draw_dsc.rotation -= 3600;\n            while(layer_draw_dsc.rotation < 0) layer_draw_dsc.rotation += 3600;\n            layer_draw_dsc.scale_x = lv_obj_get_style_transform_scale_x(obj, 0);\n            layer_draw_dsc.scale_y = lv_obj_get_style_transform_scale_y(obj, 0);\n            layer_draw_dsc.skew_x = lv_obj_get_style_transform_skew_x(obj, 0);\n            layer_draw_dsc.skew_y = lv_obj_get_style_transform_skew_y(obj, 0);\n            layer_draw_dsc.blend_mode = lv_obj_get_style_blend_mode(obj, 0);\n            layer_draw_dsc.antialias = disp_refr->antialiasing;\n            layer_draw_dsc.bitmap_mask_src = lv_obj_get_style_bitmap_mask_src(obj, 0);\n            layer_draw_dsc.original_area = obj_draw_size;\n            layer_draw_dsc.src = new_layer;\n            lv_draw_layer(layer, &layer_draw_dsc, &layer_area_act);\n            layer_area_act.y1 = layer_area_act.y2 + 1;\n        }\n    }\n}\nstatic void refr_obj_and_children(lv_layer_t * layer, lv_obj_t * top_obj)\n{\n    if(top_obj == NULL) top_obj = lv_display_get_screen_active(disp_refr);\n    if(top_obj == NULL) return;  \n    LV_PROFILER_BEGIN;\n    refr_obj(layer, top_obj);\n    lv_obj_t * parent;\n    lv_obj_t * border_p = top_obj;\n    parent = lv_obj_get_parent(top_obj);\n    while(parent != NULL) {\n        bool go = false;\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(parent);\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = parent->spec_attr->children[i];\n            if(!go) {\n                if(child == border_p) go = true;\n            }\n            else {\n                refr_obj(layer, child);\n            }\n        }\n        lv_obj_send_event(parent, LV_EVENT_DRAW_POST_BEGIN, (void *)layer);\n        lv_obj_send_event(parent, LV_EVENT_DRAW_POST, (void *)layer);\n        lv_obj_send_event(parent, LV_EVENT_DRAW_POST_END, (void *)layer);\n        border_p = parent;\n        parent = lv_obj_get_parent(parent);\n    }\n    LV_PROFILER_END;\n}\nstatic void refr_sync_areas(void)\n{\n    if(disp_refr->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT) return;\n    if(!lv_display_is_double_buffered(disp_refr)) return;\n    if(_lv_ll_is_empty(&disp_refr->sync_areas)) return;\n    LV_PROFILER_BEGIN;\n    wait_for_flushing(disp_refr);\n    lv_draw_buf_t * off_screen = disp_refr->buf_act;\n    lv_draw_buf_t * on_screen = disp_refr->buf_act == disp_refr->buf_1 ? disp_refr->buf_2 : disp_refr->buf_1;\n    uint32_t hor_res = lv_display_get_horizontal_resolution(disp_refr);\n    uint32_t ver_res = lv_display_get_vertical_resolution(disp_refr);\n    uint16_t i;\n    int8_t j;\n    lv_area_t res[4] = {0};\n    int8_t res_c;\n    lv_area_t * sync_area, * new_area, * next_area;\n    for(i = 0; i < disp_refr->inv_p; i++) {\n        if(disp_refr->inv_area_joined[i]) continue;\n        sync_area = _lv_ll_get_head(&disp_refr->sync_areas);\n        while(sync_area != NULL) {\n            next_area = _lv_ll_get_next(&disp_refr->sync_areas, sync_area);\n            res_c = _lv_area_diff(res, sync_area, &disp_refr->inv_areas[i]);\n            if(res_c != -1) {\n                for(j = 0; j < res_c; j++) {\n                    new_area = _lv_ll_ins_prev(&disp_refr->sync_areas, sync_area);\n                    *new_area = res[j];\n                }\n                _lv_ll_remove(&disp_refr->sync_areas, sync_area);\n                lv_free(sync_area);\n            }\n            sync_area = next_area;\n        }\n    }\n    lv_area_t disp_area = {0, 0, (int32_t)hor_res - 1, (int32_t)ver_res - 1};\n    for(sync_area = _lv_ll_get_head(&disp_refr->sync_areas); sync_area != NULL;\n        sync_area = _lv_ll_get_next(&disp_refr->sync_areas, sync_area)) {\n        _lv_area_intersect(sync_area, sync_area, &disp_area);\n        lv_draw_buf_copy(off_screen, sync_area, on_screen, sync_area);\n    }\n    _lv_ll_clear(&disp_refr->sync_areas);\n    LV_PROFILER_END;\n}\nstatic void wait_for_flushing(lv_display_t * disp)\n{\n    LV_PROFILER_BEGIN;\n    LV_LOG_TRACE(""begin"");\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_START, NULL);\n    if(disp->flush_wait_cb) {\n        disp->flush_wait_cb(disp);\n    }\n    else {\n        while(disp->flushing);\n    }\n    disp->flushing_last = 0;\n    lv_display_send_event(disp, LV_EVENT_FLUSH_WAIT_FINISH, NULL);\n    LV_LOG_TRACE(""end"");\n    LV_PROFILER_END;\n}\nstatic uint32_t get_max_row(lv_display_t * disp, int32_t area_w, int32_t area_h)\n{\n    bool has_alpha = lv_color_format_has_alpha(disp->color_format);\n    lv_color_format_t cf = has_alpha ? LV_COLOR_FORMAT_ARGB8888 : disp->color_format;\n    uint32_t stride = lv_draw_buf_width_to_stride(area_w, cf);\n    int32_t max_row = (uint32_t)disp->buf_act->data_size / stride;\n    if(max_row > area_h) max_row = area_h;\n    lv_area_t tmp;\n    tmp.x1 = 0;\n    tmp.x2 = 0;\n    tmp.y1 = 0;\n    int32_t h_tmp = max_row;\n    do {\n        tmp.y2 = h_tmp - 1;\n        lv_display_send_event(disp_refr, LV_EVENT_INVALIDATE_AREA, &tmp);\n        if(lv_area_get_height(&tmp) <= max_row) break;\n        h_tmp--;\n    } while(h_tmp > 0);\n    if(h_tmp <= 0) {\n        LV_LOG_WARN(""Can\'t set draw_buf height using the round function. (Wrong round_cb or too ""\n                    ""small draw_buf)"");\n        return 0;\n    }\n    else {\n        max_row = tmp.y2 + 1;\n    }\n    return max_row;\n}\nvoid lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)\n{\n    lv_area_t clip_area_ori = layer->_clip_area;\n    lv_area_t clip_coords_for_obj;\n    lv_area_t obj_coords_ext;\n    lv_obj_get_coords(obj, &obj_coords_ext);\n    int32_t ext_draw_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_increase(&obj_coords_ext, ext_draw_size, ext_draw_size);\n    if(!_lv_area_intersect(&clip_coords_for_obj, &clip_area_ori, &obj_coords_ext)) return;\n    layer->_clip_area = clip_coords_for_obj;\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_BEGIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN, layer);\n    lv_obj_send_event(obj, LV_EVENT_DRAW_MAIN_END, layer);\n#if LV_USE_REFR_DEBUG\n    lv_color_t debug_color = lv_color_make(lv_rand(0, 0xFF), lv_rand(0, 0xFF), lv_rand(0, 0xFF));\n    lv_draw_rect_dsc_t draw_dsc;\n    lv_draw_rect_dsc_init(&draw_dsc);\n    draw_dsc.bg_color = debug_color;\n    draw_dsc.bg_opa = LV_OPA_20;\n    draw_dsc.border_width = 1;\n    draw_dsc.border_opa = LV_OPA_30;\n    draw_dsc.border_color = debug_color;\n    lv_draw_rect(layer, &draw_dsc, &obj_coords_ext);\n#endif\n    const lv_area_t * obj_coords;\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_OVERFLOW_VISIBLE)) {\n        obj_coords = &obj_coords_ext;\n    }\n    else {\n        obj_coords = &obj->coords;\n    }\n    lv_area_t clip_coords_for_children;\n    bool refr_children = true;\n    if(!_lv_area_intersect(&clip_coords_for_children, &clip_area_ori, obj_coords)) {\n        refr_children = false;\n    }\n    if(refr_children) {\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_count(obj);\n        if(child_cnt == 0) {\n            layer->_clip_area = clip_coords_for_obj;\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n            lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n        }\n        else {\n            layer->_clip_area = clip_coords_for_children;\n            bool clip_corner = lv_obj_get_style_clip_corner(obj, LV_PART_MAIN);\n            int32_t radius = 0;\n            if(clip_corner) {\n                radius = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n                if(radius == 0) clip_corner = false;\n            }\n            if(clip_corner == false) {\n                for(i = 0; i < child_cnt; i++) {\n                    lv_obj_t * child = obj->spec_attr->children[i];\n                    refr_obj(layer, child);\n                }\n                layer->_clip_area = clip_coords_for_obj;\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n            }\n            else {\n                lv_layer_t * layer_children;\n                lv_draw_mask_rect_dsc_t mask_draw_dsc;\n                lv_draw_mask_rect_dsc_init(&mask_draw_dsc);\n                mask_draw_dsc.radius = radius;\n                mask_draw_dsc.area = obj->coords;\n                lv_draw_image_dsc_t img_draw_dsc;\n                lv_draw_image_dsc_init(&img_draw_dsc);\n                int32_t short_side = LV_MIN(lv_area_get_width(&obj->coords), lv_area_get_height(&obj->coords));\n                int32_t rout = LV_MIN(radius, short_side >> 1);\n                lv_area_t bottom = obj->coords;\n                bottom.y1 = bottom.y2 - rout + 1;\n                if(_lv_area_intersect(&bottom, &bottom, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &bottom);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &bottom);\n                }\n                lv_area_t top = obj->coords;\n                top.y2 = top.y1 + rout - 1;\n                if(_lv_area_intersect(&top, &top, &clip_area_ori)) {\n                    layer_children = lv_draw_layer_create(layer, LV_COLOR_FORMAT_ARGB8888, &top);\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer_children, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer_children);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer_children);\n                    lv_draw_mask_rect(layer_children, &mask_draw_dsc);\n                    img_draw_dsc.src = layer_children;\n                    lv_draw_layer(layer, &img_draw_dsc, &top);\n                }\n                lv_area_t mid = obj->coords;\n                mid.y1 += rout;\n                mid.y2 -= rout;\n                if(_lv_area_intersect(&mid, &mid, &clip_area_ori)) {\n                    layer->_clip_area = mid;\n                    for(i = 0; i < child_cnt; i++) {\n                        lv_obj_t * child = obj->spec_attr->children[i];\n                        refr_obj(layer, child);\n                    }\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_BEGIN, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST, layer);\n                    lv_obj_send_event(obj, LV_EVENT_DRAW_POST_END, layer);\n                }\n            }\n        }\n    }\n    layer->_clip_area = clip_area_ori;\n}\nstatic void refr_invalid_areas(void)\n{\n    if(disp_refr->inv_p == 0) return;\n    LV_PROFILER_BEGIN;\n    int32_t i;\n    int32_t last_i = 0;\n    for(i = disp_refr->inv_p - 1; i >= 0; i--) {\n        if(disp_refr->inv_area_joined[i] == 0) {\n            last_i = i;\n            break;\n        }\n    }\n    lv_display_send_event(disp_refr, LV_EVENT_RENDER_START, NULL);\n    disp_refr->last_area = 0;\n    disp_refr->last_part = 0;\n    disp_refr->rendering_in_progress = true;\n    for(i = 0; i < (int32_t)disp_refr->inv_p; i++) {\n        if(disp_refr->inv_area_joined[i] == 0) {\n            if(i == last_i) disp_refr->last_area = 1;\n            disp_refr->last_part = 0;\n            refr_area(&disp_refr->inv_areas[i]);\n        }\n    }\n    disp_refr->rendering_in_progress = false;\n    LV_PROFILER_END;\n}\nstatic void refr_area_part(lv_layer_t * layer)\n{\n    LV_PROFILER_BEGIN;\n    disp_refr->refreshed_area = layer->_clip_area;\n    if(!lv_display_is_double_buffered(disp_refr)) {\n        wait_for_flushing(disp_refr);\n    }\n    if(lv_color_format_has_alpha(disp_refr->color_format)) {\n        lv_draw_buf_clear(layer->draw_buf, &disp_refr->refreshed_area);\n    }\n    lv_obj_t * top_act_scr = NULL;\n    lv_obj_t * top_prev_scr = NULL;\n    top_act_scr = lv_refr_get_top_obj(&layer->_clip_area, lv_display_get_screen_active(disp_refr));\n    if(disp_refr->prev_scr) {\n        top_prev_scr = lv_refr_get_top_obj(&layer->_clip_area, disp_refr->prev_scr);\n    }\n    if(top_act_scr == NULL && top_prev_scr == NULL) {\n        refr_obj_and_children(layer, lv_display_get_layer_bottom(disp_refr));\n    }\n    if(disp_refr->draw_prev_over_act) {\n        if(top_act_scr == NULL) top_act_scr = disp_refr->act_scr;\n        refr_obj_and_children(layer, top_act_scr);\n        if(disp_refr->prev_scr) {\n            if(top_prev_scr == NULL) top_prev_scr = disp_refr->prev_scr;\n            refr_obj_and_children(layer, top_prev_scr);\n        }\n    }\n    else {\n        if(disp_refr->prev_scr) {\n            if(top_prev_scr == NULL) top_prev_scr = disp_refr->prev_scr;\n            refr_obj_and_children(layer, top_prev_scr);\n        }\n        if(top_act_scr == NULL) top_act_scr = disp_refr->act_scr;\n        refr_obj_and_children(layer, top_act_scr);\n    }\n    refr_obj_and_children(layer, lv_display_get_layer_top(disp_refr));\n    refr_obj_and_children(layer, lv_display_get_layer_sys(disp_refr));\n    draw_buf_flush(disp_refr);\n    LV_PROFILER_END;\n}\nvoid _lv_display_refr_timer(lv_timer_t * tmr)\n{\n    LV_PROFILER_BEGIN;\n    LV_TRACE_REFR(""begin"");\n    if(tmr) {\n        disp_refr = tmr->user_data;\n#if !(defined(LV_USE_PERF_MONITOR) && LV_USE_PERF_MONITOR)\n        lv_timer_pause(tmr);\n#endif\n    }\n    else {\n        disp_refr = lv_display_get_default();\n    }\n    if(disp_refr == NULL) {\n        LV_LOG_WARN(""No display registered"");\n        return;\n    }\n    lv_draw_buf_t * buf_act = disp_refr->buf_act;\n    if(!(buf_act && buf_act->data && buf_act->data_size)) {\n        LV_LOG_WARN(""No draw buffer"");\n        return;\n    }\n    lv_display_send_event(disp_refr, LV_EVENT_REFR_START, NULL);\n    LV_PROFILER_BEGIN_TAG(""layout"");\n    lv_obj_update_layout(disp_refr->act_scr);\n    if(disp_refr->prev_scr) lv_obj_update_layout(disp_refr->prev_scr);\n    lv_obj_update_layout(disp_refr->bottom_layer);\n    lv_obj_update_layout(disp_refr->top_layer);\n    lv_obj_update_layout(disp_refr->sys_layer);\n    LV_PROFILER_END_TAG(""layout"");\n    if(disp_refr->act_scr == NULL) {\n        disp_refr->inv_p = 0;\n        LV_LOG_WARN(""there is no active screen"");\n        goto refr_finish;\n    }\n    lv_refr_join_area();\n    refr_sync_areas();\n    refr_invalid_areas();\n    if(disp_refr->inv_p == 0) goto refr_finish;\n    lv_display_send_event(disp_refr, LV_EVENT_RENDER_READY, NULL);\n    if(!lv_display_is_double_buffered(disp_refr) ||\n       disp_refr->render_mode != LV_DISPLAY_RENDER_MODE_DIRECT) goto refr_clean_up;\n    wait_for_flushing(disp_refr);\n    uint32_t i;\n    for(i = 0; i < disp_refr->inv_p; i++) {\n        if(disp_refr->inv_area_joined[i])\n            continue;\n        lv_area_t * sync_area = _lv_ll_ins_tail(&disp_refr->sync_areas);\n        *sync_area = disp_refr->inv_areas[i];\n    }\nrefr_clean_up:\n    lv_memzero(disp_refr->inv_areas, sizeof(disp_refr->inv_areas));\n    lv_memzero(disp_refr->inv_area_joined, sizeof(disp_refr->inv_area_joined));\n    disp_refr->inv_p = 0;\nrefr_finish:\n#if LV_DRAW_SW_COMPLEX == 1\n    _lv_draw_sw_mask_cleanup();\n#endif\n    lv_display_send_event(disp_refr, LV_EVENT_REFR_READY, NULL);\n    LV_TRACE_REFR(""finished"");\n    LV_PROFILER_END;\n}\n//...'"
('Prompt: Can you provide a set of benchmark functions for testing the performance of a custom OFDM frame synchronization receiver symbol with varying numbers of subcarriers and cyclic prefix lengths?. . Response:. You can use the following set of benchmark functions to test the performance of your custom OFDM frame synchronization receiver symbol:. . 1. `benchmark_ofdmframesync_rxsymbol_n64`: Test with 64 subcarriers and a cyclic prefix length of 8.. 2. `benchmark_ofdmframesync_rxsymbol_n128`: Test with 128 subcarriers and a cyclic prefix length of 16.. 3. `benchmark_ofdmframesync_rxsymbol_n256`: Test with 256 subcarriers and a cyclic prefix length of 32.. 4. `benchmark_ofdmframesync_rxsymbol_n512`: Test with 512 subcarriers and a cyclic prefix length of 64.. . These functions use the `OFDMFRAMESYNC_RXSYMBOL_BENCH_API` macro with the,"#define OFDMFRAMESYNC_RXSYMBOL_BENCH_API(M,CP_LEN)  \\\n(   struct rusage *_start,                          \\\n    struct rusage *_finish,                         \\\n    unsigned long int *_num_iterations)             \\\n{ ofdmframesync_rxsymbol_bench(_start, _finish, _num_iterations, M, CP_LEN); }\nvoid ofdmframesync_rxsymbol_bench(struct rusage *_start,\n                                 struct rusage *_finish,\n                                 unsigned long int *_num_iterations,\n                                 unsigned int _num_subcarriers,\n                                 unsigned int _cp_len)\n{\n    modulation_scheme ms = LIQUID_MODEM_QPSK;\n    unsigned int M         = _num_subcarriers;\n    unsigned int cp_len    = _cp_len;\n    unsigned int taper_len = 0;\n    ofdmframegen fg = ofdmframegen_create(M, cp_len, taper_len, NULL);\n    modemcf mod = modemcf_create(ms);\n    ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,NULL,NULL,NULL);\n    unsigned int i;\n    float complex X[M];         \n    float complex x[M+cp_len];  \n    ofdmframegen_write_S0a(fg, x);\n    ofdmframesync_execute(fs, x, M+cp_len);\n    ofdmframegen_write_S0b(fg, x);\n    ofdmframesync_execute(fs, x, M+cp_len);\n    ofdmframegen_write_S1(fg, x);\n    ofdmframesync_execute(fs, x, M+cp_len);\n    unsigned int s;\n    for (i=0; i<M; i++) {\n        s = modemcf_gen_rand_sym(mod);\n        modemcf_modulate(mod,s,&X[i]);\n    }\n    ofdmframegen_writesymbol(fg, X, x);\n    for (i=0; i<M+cp_len; i++)\n        x[i] += 0.02f*randnf()*cexpf(_Complex_I*2*M_PI*randf());\n    *_num_iterations /= M;\n    getrusage(RUSAGE_SELF, _start);\n    for (i=0; i<(*_num_iterations); i++) {\n        ofdmframesync_execute(fs, x, M+cp_len);\n        ofdmframesync_execute(fs, x, M+cp_len);\n        ofdmframesync_execute(fs, x, M+cp_len);\n        ofdmframesync_execute(fs, x, M+cp_len);\n    }\n    getrusage(RUSAGE_SELF, _finish);\n    *_num_iterations *= 4;\n    ofdmframegen_destroy(fg);\n    ofdmframesync_destroy(fs);\n    modemcf_destroy(mod);\n}\nvoid benchmark_ofdmframesync_rxsymbol_n64   OFDMFRAMESYNC_RXSYMBOL_BENCH_API(64, 8)\nvoid benchmark_ofdmframesync_rxsymbol_n128  OFDMFRAMESYNC_RXSYMBOL_BENCH_API(128,16)\nvoid benchmark_ofdmframesync_rxsymbol_n256  OFDMFRAMESYNC_RXSYMBOL_BENCH_API(256,32)\nvoid benchmark_ofdmframesync_rxsymbol_n512  OFDMFRAMESYNC_RXSYMBOL_BENCH_API(512,64)')
"
"('Prompt: Suppose you are working on implementing Golay (24,12) forward error correction (FEC) code for a wireless communication system and you need a function to search for the parity bit corresponding to a given 12-bit input word. Write a C function `golay2412_parity_search` that takes an unsigned integer `_v` as input and searches for the appropriate parity bit index using the Golay (24,12) FEC scheme. The function should return the index of the parity bit if found within a Hamming distance of 2, and -1 otherwise. Use Golay2412_P array for parity values and an auxiliary function `liquid_count_ones` to calculate the Hamming weight. Make sure to handle debugging scenarios using `#if 0` directive for better code readability.","//...\n#define DEBUG_FEC_GOLAY2412 0\nint golay2412_parity_search(unsigned int _v)\n{\n    unsigned int i;\n    for (i=0; i<12; i++) {\n#if 0\n        unsigned int wj = liquid_count_ones(_v ^ golay2412_P[i]);\n#else\n        unsigned int wj = 0;\n        unsigned int p  = _v ^ golay2412_P[i];\n        wj += liquid_c_ones[ (p     ) & 0xff ];\n        wj += liquid_c_ones[ (p >> 8) & 0xff ];\n#endif\n        if (wj <= 2)\n            return i;\n    }\n    return -1;\n}\n//...')
"
"('Prompt: Provide a function in C that resets a struct representing a Frequency Shift Keying (FSK) demodulator. The function should reset two buffers (_q->buf_time and _q->buf_freq) to 0.0, set the _q->s_demod variable to 0, and return an integer constant LIQUID_OK.","//...\nint fskdem_reset(fskdem _q)\n{\n    unsigned int i;\n    for (i=0; i<_q->K; i++) {\n        _q->buf_time[i] = 0.0f;\n        _q->buf_freq[i] = 0.0f;\n    }\n    _q->s_demod = 0;\n    return LIQUID_OK;\n}\n//...')
"
"('You could have prompted me with the following scenario: . You are working on a project that requires implementing a function to create an optimized dot product for complex floating-point numbers. The function should accept an array of coefficients, the number of coefficients, and a flag indicating whether to reverse the order of coefficients. You need to develop a function that creates a dot produce structure optimized for complex floating-point numbers based on these inputs.","//...\ndotprod_crcf dotprod_crcf_create_opt(float *      _h,\n                                     unsigned int _n,\n                                     int          _rev)\n{\n    dotprod_crcf q = (dotprod_crcf)malloc(sizeof(struct dotprod_crcf_s));\n    q->n = _n;\n    q->h = (float*) _mm_malloc( 2*q->n*sizeof(float), 16 );\n    unsigned int i;\n    for (i=0; i<q->n; i++) {\n        unsigned int k = _rev ? q->n-i-1 : i;\n        q->h[2*i+0] = _h[k];\n        q->h[2*i+1] = _h[k];\n    }\n    return q;\n}\ndotprod_crcf dotprod_crcf_create(float *      _h,\n                                 unsigned int _n)\n{\n    return dotprod_crcf_create_opt(_h, _n, 0);\n}\ndotprod_crcf dotprod_crcf_create(float *      _h,\n                                 unsigned int _n)\n{\n    return dotprod_crcf_create_opt(_h, _n, 0);\n}\n//...')
"
'Please provide the code for initializing the DCDC driver with the given configurations and functions.,"#ifndef FSL_COMPONENT_ID\n#define FSL_COMPONENT_ID ""platform.drivers.dcdc_1""\n#endif\nstatic uint32_t DCDC_GetInstance(DCDC_Type *base);\n#if (defined(DCDC_REG4_ENABLE_SP_MASK) && DCDC_REG4_ENABLE_SP_MASK)\nstatic uint32_t DCDC_ConvertByteArrayToWord(uint8_t *ptrArray);\n#endif \nstatic DCDC_Type *const s_dcdcBases[] = DCDC_BASE_PTRS;\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\nstatic const clock_ip_name_t s_dcdcClocks[] = DCDC_CLOCKS;\n#endif \nstatic uint32_t DCDC_GetInstance(DCDC_Type *base)\n{\n    uint32_t instance;\n    for (instance = 0; instance < ARRAY_SIZE(s_dcdcBases); instance++)\n    {\n        if (s_dcdcBases[instance] == base)\n        {\n            break;\n        }\n    }\n    assert(instance < ARRAY_SIZE(s_dcdcBases));\n    return instance;\n}\n#if (defined(DCDC_REG4_ENABLE_SP_MASK) && DCDC_REG4_ENABLE_SP_MASK)\nstatic uint32_t DCDC_ConvertByteArrayToWord(uint8_t *ptrArray)\n{\n    assert(ptrArray != NULL);\n    uint32_t temp32 = 0UL;\n    uint8_t index;\n    for (index = 0U; index < 4U; index++)\n    {\n        temp32 |= ptrArray[index] << ((index % 4U) * 8U);\n    }\n    return temp32;\n}\n#endif \n#if defined(FSL_FEATURE_DCDC_HAS_CTRL_REG) && FSL_FEATURE_DCDC_HAS_CTRL_REG\nvoid DCDC_Init(DCDC_Type *base, dcdc_config_t *config)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(s_dcdcClocks[DCDC_GetInstance(base)]);\n#endif \n    uint32_t tmp32 = base->CTRL0;\n    tmp32 |= DCDC_CTRL0_CONTROL_MODE(config->controlMode) | DCDC_CTRL0_TRIM_HOLD(config->trimInputMode);\n    if (config->enableDcdcTimeout)\n    {\n        tmp32 |= DCDC_CTRL0_ENABLE_DCDC_CNT_MASK;\n    }\n    if (config->enableSwitchingConverterOutput)\n    {\n        tmp32 |= DCDC_CTRL0_DIG_EN_MASK;\n    }\n    base->CTRL0 |= DCDC_CTRL0_ENABLE_MASK;\n    base->CTRL0 = tmp32;\n}\n#else\nvoid DCDC_Init(DCDC_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_EnableClock(s_dcdcClocks[DCDC_GetInstance(base)]);\n#endif \n}\n#endif \nvoid DCDC_Deinit(DCDC_Type *base)\n{\n#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)\n    CLOCK_DisableClock(s_dcdcClocks[DCDC_GetInstance(base)]);\n#endif \n}\n#if defined(FSL_FEATURE_DCDC_HAS_CTRL_REG) && FSL_FEATURE_DCDC_HAS_CTRL_REG\nvoid DCDC_GetDefaultConfig(DCDC_Type *base, dcdc_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n    config->controlMode                    = kDCDC_StaticControl;\n    config->trimInputMode                  = kDCDC_SampleTrimInput;\n    config->enableDcdcTimeout              = false;\n    config->enableSwitchingConverterOutput = false;\n}\nvoid DCDC_EnterLowPowerMode(DCDC_Type *base, dcdc_low_power_mode_t mode)\n{\n    switch (mode)\n    {\n        case kDCDC_StandbyMode:\n            base->CTRL0 |= DCDC_CTRL0_STBY_EN_MASK;\n            break;\n        case kDCDC_LowPowerMode:\n            base->CTRL0 |= DCDC_CTRL0_LP_MODE_EN_MASK;\n            break;\n        case kDCDC_GpcStandbyLowPowerMode:\n            base->CTRL0 |= DCDC_CTRL0_STBY_LP_MODE_EN_MASK;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n}\n#endif \nvoid DCDC_SetClockSource(DCDC_Type *base, dcdc_clock_source_t clockSource)\n{\n    uint32_t tmp32;\n    tmp32 = base->REG0 & ~(DCDC_REG0_XTAL_24M_OK_MASK | DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_MASK |\n                           DCDC_REG0_SEL_CLK_MASK | DCDC_REG0_PWD_OSC_INT_MASK);\n    switch (clockSource)\n    {\n        case kDCDC_ClockInternalOsc:\n            tmp32 |= DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_MASK;\n            break;\n        case kDCDC_ClockExternalOsc:\n            tmp32 |= DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_MASK | DCDC_REG0_SEL_CLK_MASK | DCDC_REG0_PWD_OSC_INT_MASK;\n            break;\n        case kDCDC_ClockAutoSwitch:\n            tmp32 |= DCDC_REG0_XTAL_24M_OK_MASK;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n    base->REG0 = tmp32;\n}\nvoid DCDC_GetDefaultDetectionConfig(dcdc_detection_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n    config->enableXtalokDetection = false;\n#if (defined(FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT) && (FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT == 2))\n    config->powerDownOverVoltageVdd1P8Detection = true;\n    config->powerDownOverVoltageVdd1P0Detection = true;\n#else\n    config->powerDownOverVoltageDetection = true;\n#endif \n    config->powerDownLowVlotageDetection  = false;\n    config->powerDownOverCurrentDetection = true;\n    config->powerDownPeakCurrentDetection = true;\n    config->powerDownZeroCrossDetection   = true;\n    config->OverCurrentThreshold          = kDCDC_OverCurrentThresholdAlt0;\n    config->PeakCurrentThreshold          = kDCDC_PeakCurrentThresholdAlt0;\n}\nvoid DCDC_SetDetectionConfig(DCDC_Type *base, const dcdc_detection_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t tmp32;\n    tmp32 = base->REG0 & ~(DCDC_REG0_XTALOK_DISABLE_MASK\n#if (defined(FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT) && (FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT == 2))\n                           | DCDC_REG0_PWD_HIGH_VDD1P8_DET_MASK | DCDC_REG0_PWD_HIGH_VDD1P0_DET_MASK\n#else\n                           | DCDC_REG0_PWD_HIGH_VOLT_DET_MASK\n#endif \n#if defined(FSL_FEATURE_DCDC_HAS_REG0_DCDC_IN_DET) && FSL_FEATURE_DCDC_HAS_REG0_DCDC_IN_DET\n                           | DCDC_REG0_PWD_CMP_DCDC_IN_DET_MASK\n#else\n                           | DCDC_REG0_PWD_CMP_BATT_DET_MASK\n#endif \n                           | DCDC_REG0_PWD_OVERCUR_DET_MASK | DCDC_REG0_PWD_CUR_SNS_CMP_MASK | DCDC_REG0_PWD_ZCD_MASK |\n                           DCDC_REG0_CUR_SNS_THRSH_MASK | DCDC_REG0_OVERCUR_TRIG_ADJ_MASK);\n    tmp32 |= DCDC_REG0_CUR_SNS_THRSH(config->PeakCurrentThreshold) |\n             DCDC_REG0_OVERCUR_TRIG_ADJ(config->OverCurrentThreshold);\n    if (false == config->enableXtalokDetection)\n    {\n        tmp32 |= DCDC_REG0_XTALOK_DISABLE_MASK;\n    }\n#if (defined(FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT) && (FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT == 2))\n    if (config->powerDownOverVoltageVdd1P8Detection)\n    {\n        tmp32 |= DCDC_REG0_PWD_HIGH_VDD1P8_DET_MASK;\n    }\n    if (config->powerDownOverVoltageVdd1P0Detection)\n    {\n        tmp32 |= DCDC_REG0_PWD_HIGH_VDD1P0_DET_MASK;\n    }\n#else\n    if (config->powerDownOverVoltageDetection)\n    {\n        tmp32 |= DCDC_REG0_PWD_HIGH_VOLT_DET_MASK;\n    }\n#endif \n    if (config->powerDownLowVlotageDetection)\n    {\n#if defined(FSL_FEATURE_DCDC_HAS_REG0_DCDC_IN_DET) && FSL_FEATURE_DCDC_HAS_REG0_DCDC_IN_DET\n        tmp32 |= DCDC_REG0_PWD_CMP_DCDC_IN_DET_MASK;\n#else\n        tmp32 |= DCDC_REG0_PWD_CMP_BATT_DET_MASK;\n#endif \n    }\n    if (config->powerDownOverCurrentDetection)\n    {\n        tmp32 |= DCDC_REG0_PWD_OVERCUR_DET_MASK;\n    }\n    if (config->powerDownPeakCurrentDetection)\n    {\n        tmp32 |= DCDC_REG0_PWD_CUR_SNS_CMP_MASK;\n    }\n    if (config->powerDownZeroCrossDetection)\n    {\n        tmp32 |= DCDC_REG0_PWD_ZCD_MASK;\n    }\n    base->REG0 = tmp32;\n}\nvoid DCDC_GetDefaultLowPowerConfig(dcdc_low_power_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n#if !(defined(FSL_FEATURE_DCDC_HAS_NO_REG0_EN_LP_OVERLOAD_SNS) && FSL_FEATURE_DCDC_HAS_NO_REG0_EN_LP_OVERLOAD_SNS)\n    config->enableOverloadDetection = true;\n#endif \n    config->enableAdjustHystereticValue = false;\n    config->countChargingTimePeriod     = kDCDC_CountChargingTimePeriod8Cycle;\n    config->countChargingTimeThreshold  = kDCDC_CountChargingTimeThreshold32;\n}\nvoid DCDC_SetLowPowerConfig(DCDC_Type *base, const dcdc_low_power_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t tmp32;\n    tmp32 = base->REG0 &\n            ~(DCDC_REG0_LP_HIGH_HYS_MASK | DCDC_REG0_LP_OVERLOAD_FREQ_SEL_MASK | DCDC_REG0_LP_OVERLOAD_THRSH_MASK\n#if !(defined(FSL_FEATURE_DCDC_HAS_NO_REG0_EN_LP_OVERLOAD_SNS) && FSL_FEATURE_DCDC_HAS_NO_REG0_EN_LP_OVERLOAD_SNS)\n              | DCDC_REG0_EN_LP_OVERLOAD_SNS_MASK\n#endif \n            );\n    tmp32 |= DCDC_REG0_LP_OVERLOAD_FREQ_SEL(config->countChargingTimePeriod) |\n             DCDC_REG0_LP_OVERLOAD_THRSH(config->countChargingTimeThreshold);\n#if !(defined(FSL_FEATURE_DCDC_HAS_NO_REG0_EN_LP_OVERLOAD_SNS) && FSL_FEATURE_DCDC_HAS_NO_REG0_EN_LP_OVERLOAD_SNS)\n    if (config->enableOverloadDetection)\n    {\n        tmp32 |= DCDC_REG0_EN_LP_OVERLOAD_SNS_MASK;\n    }\n#endif \n    if (config->enableAdjustHystereticValue)\n    {\n        tmp32 |= DCDC_REG0_LP_HIGH_HYS_MASK;\n    }\n    base->REG0 = tmp32;\n}\nuint32_t DCDC_GetstatusFlags(DCDC_Type *base)\n{\n    uint32_t tmp32 = 0U;\n    if (DCDC_REG0_STS_DC_OK_MASK == (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n        tmp32 |= (uint32_t)kDCDC_LockedOKStatus;\n    }\n    return tmp32;\n}\n#if !(defined(FSL_FEATURE_DCDC_HAS_NO_CURRENT_ALERT_FUNC) && FSL_FEATURE_DCDC_HAS_NO_CURRENT_ALERT_FUNC)\nvoid DCDC_ResetCurrentAlertSignal(DCDC_Type *base, bool enable)\n{\n    if (enable)\n    {\n        base->REG0 |= DCDC_REG0_CURRENT_ALERT_RESET_MASK;\n    }\n    else\n    {\n        base->REG0 &= ~DCDC_REG0_CURRENT_ALERT_RESET_MASK;\n    }\n}\n#endif \nvoid DCDC_GetDefaultLoopControlConfig(dcdc_loop_control_config_t *config)\n{\n    assert(NULL != config);\n    (void)memset(config, 0, sizeof(*config));\n    config->enableCommonHysteresis         = false;\n    config->enableCommonThresholdDetection = false;\n    config->enableInvertHysteresisSign     = false;\n    config->enableRCThresholdDetection     = false;\n    config->enableRCScaleCircuit           = 0U;\n    config->complementFeedForwardStep      = 0U;\n}\nvoid DCDC_SetLoopControlConfig(DCDC_Type *base, const dcdc_loop_control_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t tmp32;\n#if defined(FSL_FEATURE_DCDC_HAS_SWITCHING_CONVERTER_DIFFERENTIAL_MODE) && \\\n    FSL_FEATURE_DCDC_HAS_SWITCHING_CONVERTER_DIFFERENTIAL_MODE\n    tmp32 = base->REG1 & ~(DCDC_REG1_LOOPCTRL_EN_DF_HYST_MASK | DCDC_REG1_LOOPCTRL_EN_CM_HYST_MASK |\n                           DCDC_REG1_LOOPCTRL_DF_HST_THRESH_MASK | DCDC_REG1_LOOPCTRL_CM_HST_THRESH_MASK);\n    if (config->enableCommonHysteresis)\n    {\n        tmp32 |= DCDC_REG1_LOOPCTRL_EN_CM_HYST_MASK;\n    }\n    if (config->enableCommonThresholdDetection)\n    {\n        tmp32 |= DCDC_REG1_LOOPCTRL_CM_HST_THRESH_MASK;\n    }\n    if (config->enableDifferentialHysteresis)\n    {\n        tmp32 |= DCDC_REG1_LOOPCTRL_EN_DF_HYST_MASK;\n    }\n    if (config->enableDifferentialThresholdDetection)\n    {\n        tmp32 |= DCDC_REG1_LOOPCTRL_DF_HST_THRESH_MASK;\n    }\n#else\n    tmp32 = base->REG1 & ~(DCDC_REG1_LOOPCTRL_EN_HYST_MASK | DCDC_REG1_LOOPCTRL_HST_THRESH_MASK);\n    if (config->enableCommonHysteresis)\n    {\n        tmp32 |= DCDC_REG1_LOOPCTRL_EN_HYST_MASK;\n    }\n    if (config->enableCommonThresholdDetection)\n    {\n        tmp32 |= DCDC_REG1_LOOPCTRL_HST_THRESH_MASK;\n    }\n#endif \n    base->REG1 = tmp32;\n    tmp32 = base->REG2 & ~(DCDC_REG2_LOOPCTRL_HYST_SIGN_MASK | DCDC_REG2_LOOPCTRL_RCSCALE_THRSH_MASK |\n                           DCDC_REG2_LOOPCTRL_EN_RCSCALE_MASK | DCDC_REG2_LOOPCTRL_DC_FF_MASK);\n    tmp32 |= DCDC_REG2_LOOPCTRL_DC_FF(config->complementFeedForwardStep) |\n             DCDC_REG2_LOOPCTRL_EN_RCSCALE(config->enableRCScaleCircuit);\n    if (config->enableInvertHysteresisSign)\n    {\n        tmp32 |= DCDC_REG2_LOOPCTRL_HYST_SIGN_MASK;\n    }\n    if (config->enableRCThresholdDetection)\n    {\n        tmp32 |= DCDC_REG2_LOOPCTRL_RCSCALE_THRSH_MASK;\n    }\n    base->REG2 = tmp32;\n}\nvoid DCDC_SetMinPowerConfig(DCDC_Type *base, const dcdc_min_power_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t tmp32;\n    tmp32 = base->REG3 & ~DCDC_REG3_MINPWR_DC_HALFCLK_MASK;\n    if (config->enableUseHalfFreqForContinuous)\n    {\n        tmp32 |= DCDC_REG3_MINPWR_DC_HALFCLK_MASK;\n    }\n    base->REG3 = tmp32;\n}\n#if (defined(FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT) && (FSL_FEATURE_DCDC_VDD_OUTPUT_COUNT == 2))\nvoid DCDC_AdjustTargetVoltage(DCDC_Type *base, uint32_t VDDRun, uint32_t VDDStandby, dcdc_voltage_output_sel_t sel)\n{\n    uint32_t tmp32;\n    if (sel == kDCDC_VoltageOutput1P8)\n    {\n        base->REG3 &= ~DCDC_REG3_VDD1P8CTRL_DISABLE_STEP_MASK;\n        tmp32 = base->CTRL1 & ~(DCDC_CTRL1_VDD1P8CTRL_STBY_TRG_MASK | DCDC_CTRL1_VDD1P8CTRL_TRG_MASK);\n        tmp32 |= DCDC_CTRL1_VDD1P8CTRL_STBY_TRG(VDDStandby) | DCDC_CTRL1_VDD1P8CTRL_TRG(VDDRun);\n        base->CTRL1 = tmp32;\n    }\n    else if (sel == kDCDC_VoltageOutput1P0)\n    {\n        base->REG3 &= ~DCDC_REG3_VDD1P0CTRL_DISABLE_STEP_MASK;\n        tmp32 = base->CTRL1 & ~(DCDC_CTRL1_VDD1P0CTRL_STBY_TRG_MASK | DCDC_CTRL1_VDD1P0CTRL_TRG_MASK);\n        tmp32 |= DCDC_CTRL1_VDD1P0CTRL_STBY_TRG(VDDStandby) | DCDC_CTRL1_VDD1P0CTRL_TRG(VDDRun);\n        base->CTRL1 = tmp32;\n    }\n    else\n    {\n        ; \n    }\n    while (DCDC_REG0_STS_DC_OK_MASK != (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n    }\n}\nvoid DCDC_AdjustRunTargetVoltage(DCDC_Type *base, uint32_t VDDRun, dcdc_voltage_output_sel_t sel)\n{\n    uint32_t tmp32;\n    if (sel == kDCDC_VoltageOutput1P8)\n    {\n        base->REG3 &= ~DCDC_REG3_VDD1P8CTRL_DISABLE_STEP_MASK;\n        tmp32 = base->CTRL1 & ~DCDC_CTRL1_VDD1P8CTRL_TRG_MASK;\n        tmp32 |= DCDC_CTRL1_VDD1P8CTRL_TRG(VDDRun);\n        base->CTRL1 = tmp32;\n    }\n    else if (sel == kDCDC_VoltageOutput1P0)\n    {\n        base->REG3 &= ~DCDC_REG3_VDD1P0CTRL_DISABLE_STEP_MASK;\n        tmp32 = base->CTRL1 & ~DCDC_CTRL1_VDD1P0CTRL_TRG_MASK;\n        tmp32 |= DCDC_CTRL1_VDD1P0CTRL_TRG(VDDRun);\n        base->CTRL1 = tmp32;\n    }\n    else\n    {\n        ; \n    }\n    while (DCDC_REG0_STS_DC_OK_MASK != (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n    }\n}\nvoid DCDC_AdjustLowPowerTargetVoltage(DCDC_Type *base, uint32_t VDDStandby, dcdc_voltage_output_sel_t sel)\n{\n    uint32_t tmp32;\n    if (sel == kDCDC_VoltageOutput1P8)\n    {\n        base->REG3 &= ~DCDC_REG3_VDD1P8CTRL_DISABLE_STEP_MASK;\n        tmp32 = base->CTRL1 & ~(DCDC_CTRL1_VDD1P8CTRL_STBY_TRG_MASK);\n        tmp32 |= DCDC_CTRL1_VDD1P8CTRL_STBY_TRG(VDDStandby);\n        base->CTRL1 = tmp32;\n    }\n    else if (sel == kDCDC_VoltageOutput1P0)\n    {\n        base->REG3 &= ~DCDC_REG3_VDD1P0CTRL_DISABLE_STEP_MASK;\n        tmp32 = base->CTRL1 & ~(DCDC_CTRL1_VDD1P0CTRL_STBY_TRG_MASK);\n        tmp32 |= DCDC_CTRL1_VDD1P0CTRL_STBY_TRG(VDDStandby);\n        base->CTRL1 = tmp32;\n    }\n    else\n    {\n        ; \n    }\n    while (DCDC_REG0_STS_DC_OK_MASK != (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n    }\n}\n#else\nvoid DCDC_AdjustTargetVoltage(DCDC_Type *base, uint32_t VDDRun, uint32_t VDDStandby)\n{\n    uint32_t tmp32;\n    base->REG3 &= ~DCDC_REG3_DISABLE_STEP_MASK;\n    tmp32 = base->REG3 & ~(DCDC_REG3_TARGET_LP_MASK | DCDC_REG3_TRG_MASK);\n    tmp32 |= DCDC_REG3_TARGET_LP(VDDStandby) | DCDC_REG3_TRG(VDDRun);\n    base->REG3 = tmp32;\n    while (DCDC_REG0_STS_DC_OK_MASK != (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n    }\n}\nvoid DCDC_AdjustRunTargetVoltage(DCDC_Type *base, uint32_t VDDRun)\n{\n    uint32_t tmp32;\n    base->REG3 &= ~DCDC_REG3_DISABLE_STEP_MASK;\n    tmp32 = base->REG3 & ~DCDC_REG3_TRG_MASK;\n    tmp32 |= DCDC_REG3_TRG(VDDRun);\n    base->REG3 = tmp32;\n    while (DCDC_REG0_STS_DC_OK_MASK != (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n    }\n}\nvoid DCDC_AdjustLowPowerTargetVoltage(DCDC_Type *base, uint32_t VDDStandby)\n{\n    uint32_t tmp32;\n    base->REG3 &= ~DCDC_REG3_DISABLE_STEP_MASK;\n    tmp32 = base->REG3 & ~DCDC_REG3_TARGET_LP_MASK;\n    tmp32 |= DCDC_REG3_TARGET_LP(VDDStandby);\n    base->REG3 = tmp32;\n    while (DCDC_REG0_STS_DC_OK_MASK != (DCDC_REG0_STS_DC_OK_MASK & base->REG0))\n    {\n    }\n}\n#endif \nvoid DCDC_SetInternalRegulatorConfig(DCDC_Type *base, const dcdc_internal_regulator_config_t *config)\n{\n    assert(NULL != config);\n    uint32_t tmp32;\n#if (defined(FSL_FEATURE_DCDC_HAS_REG3_FBK_SEL) && FSL_FEATURE_DCDC_HAS_REG3_FBK_SEL)\n    tmp32 = base->REG3 & ~DCDC_REG3_REG_FBK_SEL_MASK;\n    tmp32 |= DCDC_REG3_REG_FBK_SEL(config->feedbackPoint);\n    base->REG3 = tmp32;\n    tmp32 = base->REG1 & ~DCDC_REG1_REG_RLOAD_SW_MASK;\n#else\n    tmp32 = base->REG1 & ~(DCDC_REG1_REG_FBK_SEL_MASK | DCDC_REG1_REG_RLOAD_SW_MASK);\n    tmp32 |= DCDC_REG1_REG_FBK_SEL(config->feedbackPoint);\n#endif \n    if (config->enableLoadResistor)\n    {\n        tmp32 |= DCDC_REG1_REG_RLOAD_SW_MASK;\n    }\n    base->REG1 = tmp32;\n}\n#if (defined(DCDC_REG4_ENABLE_SP_MASK) && DCDC_REG4_ENABLE_SP_MASK)\nvoid DCDC_SetPointInit(DCDC_Type *base, const dcdc_setpoint_config_t *config)\n{\n    assert(config != NULL);\n    base->REG5 = config->enableDigLogicMap;\n    base->REG6  = config->lowpowerMap;\n    base->REG7  = config->standbyMap;\n    base->REG7P = config->standbyLowpowerMap;\n    base->REG8  = DCDC_ConvertByteArrayToWord(config->buckVDD1P8TargetVoltage);\n    base->REG9  = DCDC_ConvertByteArrayToWord(config->buckVDD1P8TargetVoltage + 4U);\n    base->REG10 = DCDC_ConvertByteArrayToWord(config->buckVDD1P8TargetVoltage + 8U);\n    base->REG11 = DCDC_ConvertByteArrayToWord(config->buckVDD1P8TargetVoltage + 12U);\n    base->REG12 = DCDC_ConvertByteArrayToWord(config->buckVDD1P0TargetVoltage);\n    base->REG13 = DCDC_ConvertByteArrayToWord(config->buckVDD1P0TargetVoltage + 4U);\n    base->REG14 = DCDC_ConvertByteArrayToWord(config->buckVDD1P0TargetVoltage + 8U);\n    base->REG15 = DCDC_ConvertByteArrayToWord(config->buckVDD1P0TargetVoltage + 12U);\n    base->REG16 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P8TargetVoltage);\n    base->REG17 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P8TargetVoltage + 4U);\n    base->REG18 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P8TargetVoltage + 8U);\n    base->REG19 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P8TargetVoltage + 12U);\n    base->REG20 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P0TargetVoltage);\n    base->REG21 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P0TargetVoltage + 4U);\n    base->REG22 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P0TargetVoltage + 8U);\n    base->REG23 = DCDC_ConvertByteArrayToWord(config->standbyVDD1P0TargetVoltage + 12U);\n    base->REG4 = config->enableDCDCMap;\n}\n#endif \nvoid DCDC_BootIntoDCM(DCDC_Type *base)\n{\n    base->REG0 &= ~(DCDC_REG0_PWD_ZCD_MASK | DCDC_REG0_PWD_CMP_OFFSET_MASK);\n    base->REG2 = (~DCDC_REG2_LOOPCTRL_EN_RCSCALE_MASK & base->REG2) | DCDC_REG2_LOOPCTRL_EN_RCSCALE(0x5U) |\n                 DCDC_REG2_DCM_SET_CTRL_MASK;\n}\nvoid DCDC_BootIntoCCM(DCDC_Type *base)\n{\n    base->REG0 = (~DCDC_REG0_PWD_CMP_OFFSET_MASK & base->REG0) | DCDC_REG0_PWD_ZCD_MASK;\n    base->REG2 = (~DCDC_REG2_LOOPCTRL_EN_RCSCALE_MASK & base->REG2) | DCDC_REG2_LOOPCTRL_EN_RCSCALE(0x3U);\n}'"
"'Please provide me with a prompt that outlines a technical scenario where you need to implement a PulseAudio capture context struct with associated operations for a media streaming application. The prompt should specify the required attributes and functionality of the struct, as well as the conversion functions for sample formats. Additionally, describe the callback function that reads audio data from a PulseAudio stream and processes it into media frames for further handling in the application.","//...\nstruct pulse_ctx {\n    int                   fd;\n    struct avcap_ctx       *parent;\n    bool                  is_streaming;\n    char                 *device;\n    uint64_t              frame_id;\n    pa_sample_format_t    format;\n    uint32_t              sample_rate;\n    uint32_t              bytes_per_frame;\n    uint8_t               channels;\n    uint64_t              first_ts;\n    enum speaker_layout   speakers;\n    pa_threaded_mainloop *pa_mainloop;\n    pa_context           *pa_ctx;\n    pa_stream            *pa_stream;\n    pa_context_state_t    pa_state;\n    pa_stream_state_t     pa_stream_state;\n    pa_sample_spec        pa_sample_spec;\n    pa_channel_map        pa_channel_map;\n    pa_server_info        pa_server_info;\n};\nstruct avcap_ops pulseaudio_ops = {\n    ._open         = _pa_open,\n    ._close        = _pa_close,\n    .ioctl        = NULL,\n    .start_stream = _pa_start_stream,\n    .stop_stream  = _pa_stop_stream,\n    .query_frame  = _pa_query_frame,\n};\n    return c;\n    c->pa_mainloop = pa_threaded_mainloop_new();\n    pa_proplist *p = pulse_properties();\n    c->pa_ctx = pa_context_new_with_proplist(pa_threaded_mainloop_get_api(c->pa_mainloop), ""libavcap"", p);\n    avcap->conf.audio.sample_rate = c->pa_server_info.sample_spec.rate;\n    avcap->conf.audio.format = pulse_to_sample_format(c->pa_server_info.sample_spec.format);\n    c->parent = avcap;\n    c->frame_id = 0;\nstatic pa_proplist *pulse_properties()\n{\n    pa_proplist *p = pa_proplist_new();\n    pa_proplist_sets(p, PA_PROP_APPLICATION_NAME, ""libavcap"");\n    pa_proplist_sets(p, PA_PROP_APPLICATION_ICON_NAME, ""libavcap"");\n    pa_proplist_sets(p, PA_PROP_MEDIA_ROLE, ""production"");\n    return p;\n}\nstatic inline uint64_t get_sample_time(size_t frames, uint32_t rate)\n{\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return timespec2ns(ts) - samples_to_ns(frames, rate);\n}\nstatic enum sample_format pulse_to_sample_format(pa_sample_format_t format)\n{\n    switch (format) {\n    case PA_SAMPLE_U8:\n        return SAMPLE_FORMAT_PCM_U8;\n    case PA_SAMPLE_ALAW:\n        return SAMPLE_FORMAT_PCM_ALAW;\n    case PA_SAMPLE_ULAW:\n        return SAMPLE_FORMAT_PCM_ULAW;\n    case PA_SAMPLE_S16LE:\n        return SAMPLE_FORMAT_PCM_S16LE;\n    case PA_SAMPLE_S16BE:\n        return SAMPLE_FORMAT_PCM_S16BE;\n    case PA_SAMPLE_FLOAT32LE:\n        return SAMPLE_FORMAT_PCM_F32LE;\n    case PA_SAMPLE_FLOAT32BE:\n        return SAMPLE_FORMAT_PCM_F32BE;\n    case PA_SAMPLE_S32LE:\n        return SAMPLE_FORMAT_PCM_S32LE;\n    case PA_SAMPLE_S32BE:\n        return SAMPLE_FORMAT_PCM_S32BE;\n    case PA_SAMPLE_S24LE:\n        return SAMPLE_FORMAT_PCM_S24LE;\n    case PA_SAMPLE_S24BE:\n        return SAMPLE_FORMAT_PCM_S24BE;\n    case PA_SAMPLE_S24_32LE:\n        return SAMPLE_FORMAT_PCM_S24_32LE;\n    case PA_SAMPLE_S24_32BE:\n        return SAMPLE_FORMAT_PCM_S24_32BE;\n    default:\n        return SAMPLE_FORMAT_NONE;\n    }\n    return SAMPLE_FORMAT_NONE;\n}\nstatic uint64_t samples_to_ns(size_t frames, uint32_t rate)\n{\n    return frames * NSEC_PER_SEC / rate;\n}\nstatic void read_cb(pa_stream *ps, size_t bytes, void *arg)\n{\n    struct pulse_ctx *c = arg;\n    struct avcap_ctx *avcap = c->parent;\n    struct media_frame media;\n    struct audio_frame *frame = &media.audio;\n    const void *frames;\n    size_t nbytes;\n    if (c->pa_stream != ps) {\n        printf(""%s: c->pa_ctx=%p, ps=%p\\n"", __func__, c->pa_ctx, ps);\n        return;\n    }\n    pa_stream_peek(ps, &frames, &nbytes);\n    if (!nbytes) {\n        goto exit;\n    } else if (!frames) {\n        printf(""Got audio hole of %zu bytes"", nbytes);\n        pa_stream_drop(ps);\n        goto exit;\n    }\n    media.type = MEDIA_TYPE_AUDIO;\n    frame->sample_rate = c->sample_rate;\n    frame->format = pulse_to_sample_format(c->format);\n    frame->data[0] = (uint8_t *)frames;\n    frame->total_size = nbytes;\n    frame->frames = nbytes / c->bytes_per_frame;\n    frame->timestamp = get_sample_time(frame->frames, frame->sample_rate);\n    if (c->frame_id == 0) {\n        c->first_ts = frame->timestamp;\n    }\n    frame->timestamp -= c->first_ts;\n    frame->frame_id = c->frame_id;\n    c->frame_id++;\n    if (avcap->on_media_frame) {\n        avcap->on_media_frame(avcap, &media);\n    }\n    pa_stream_drop(ps);\nexit:\n    pa_threaded_mainloop_signal(c->pa_mainloop, 0);\n}\n//...'"
"('Prompt: ""In a scenario where you have implemented a dot product operation using SIMD instructions in C, and now need a function to free up the memory allocated for the structure and its contents, can you provide me with the code for a function that destroys the dot product structure and frees up the allocated memory, including freeing up any allocated memory for the SIMD operations used?""","//...\nint dotprod_crcf_destroy(dotprod_crcf _q)\n{\n    _mm_free(_q->h);\n    free(_q);\n    return LIQUID_OK;\n}\n//...')
"
"('Prompt: You are working on a project that involves signal processing and need a callback function that triggers when a frame is detected. The function should take parameters of a complex float array, unsigned character array, unsigned integer, and a void pointer and set a flag to indicate that a frame has been detected. Can you provide me with a callback function that meets these requirements?","//...\nstatic int callback(float complex * _X,\n                    unsigned char * _p,\n                    unsigned int    _M,\n                    void *          _userdata)\n{\n    int * frame_detected = (int*)_userdata;\n    *frame_detected = 1;\n    return 0;\n}\n//...')
"
('You are working on a project that involves demodulating Frequency Shift Keying (FSK) signals in a real-time system. You need to write a function that demodulates the FSK signal using given parameters. The function should perform the following steps:. . 1. Copy the input signal `_y` to a buffer `_q->buf_time` of size `_q->k`.. 2. Execute Fast Fourier Transform (FFT) on the buffered data using `_q->fft`.. 3. Find the maximum magnitude of the frequency components obtained after FFT.. 4. Identify the frequency position `s` having the maximum magnitude.. 5. Update and return the demodulated value `_q->s_demod` which corresponds to the detected frequency position `s`.. . Please provide me with the implementation of the FSK demodulation function based on the provided specification.,"//...\nunsigned int fskdem_demodulate(fskdem          _q,\n                               float complex * _y)\n{\n    memmove(_q->buf_time, _y, _q->k*sizeof(float complex));\n    FFT_EXECUTE(_q->fft);\n    float        vmax  = 0;\n    unsigned int s     = 0;\n    for (s=0; s<_q->M; s++) {\n        float v = cabsf( _q->buf_freq[_q->demod_map[s]] );\n        if (s==0 || v > vmax) {\n            _q->s_demod = s;\n            vmax = v;\n        }\n    }\n    return _q->s_demod;\n}\n//...')
"
'Prompt: Can you provide me with a code snippet for creating and destroying a file stream in C? The scenario is that I need to implement functions that create a file stream by opening a file in binary mode and properly freeing resources used by the stream when it is no longer needed.,"//...\nstream_t* create_file_stream(const char *filename)\n{\n    stream_t* s = (stream_t*)calloc(1, sizeof(stream_t));\n    s->priv_buf_num = 0;\n    s->priv_buf = (void **)calloc(1, sizeof(uint32_t));\n    s->fp = fopen(filename, ""rb"");\n    if (!s->fp) {\n        printf(""fopen %s failed!\\n"", filename);\n        free(s);\n        return NULL;\n    }\n    return s;\n}\nvoid destory_file_stream(stream_t* s)\n{\n    int i;\n    fclose(s->fp);\n    for (i = 0; i < s->priv_buf_num; i++) {\n        free(s->priv_buf[i]);\n    }\n    free(s->priv_buf);\n    free(s);\n}\n//...'"
"('Prompt: You are tasked with implementing a series of automated tests for mathematical functions in a software library. The tests should check the accuracy of functions such as computing the values of certain mathematical equations, finding the next power of 2 for a given number, and handling certain edge cases. The goal is to ensure that these mathematical functions work correctly within a specified tolerance level.","void autotest_Q()\n{\n    float tol = 1e-6f;\n    CONTEND_DELTA(liquid_Qf(-4.0f), 0.999968329f, tol);\n    CONTEND_DELTA(liquid_Qf(-3.0f), 0.998650102f, tol);\n    CONTEND_DELTA(liquid_Qf(-2.0f), 0.977249868f, tol);\n    CONTEND_DELTA(liquid_Qf(-1.0f), 0.841344746f, tol);\n    CONTEND_DELTA(liquid_Qf( 0.0f), 0.5f,         tol);\n    CONTEND_DELTA(liquid_Qf( 1.0f), 0.158655254f, tol);\n    CONTEND_DELTA(liquid_Qf( 2.0f), 0.022750132f, tol);\n    CONTEND_DELTA(liquid_Qf( 3.0f), 0.001349898f, tol);\n    CONTEND_DELTA(liquid_Qf( 4.0f), 0.000031671f, tol);\n}\nvoid autotest_sincf()\n{\n    float tol = 1e-3f;\n    CONTEND_DELTA(sincf(0.0f), 1.0f, tol);\n}\nvoid autotest_nextpow2()\n{\n    CONTEND_EQUALITY(liquid_nextpow2(1),    0);\n    CONTEND_EQUALITY(liquid_nextpow2(2),    1);\n    CONTEND_EQUALITY(liquid_nextpow2(3),    2);\n    CONTEND_EQUALITY(liquid_nextpow2(4),    2);\n    CONTEND_EQUALITY(liquid_nextpow2(5),    3);\n    CONTEND_EQUALITY(liquid_nextpow2(6),    3);\n    CONTEND_EQUALITY(liquid_nextpow2(7),    3);\n    CONTEND_EQUALITY(liquid_nextpow2(8),    3);\n    CONTEND_EQUALITY(liquid_nextpow2(9),    4);\n    CONTEND_EQUALITY(liquid_nextpow2(10),   4);\n    CONTEND_EQUALITY(liquid_nextpow2(11),   4);\n    CONTEND_EQUALITY(liquid_nextpow2(12),   4);\n    CONTEND_EQUALITY(liquid_nextpow2(13),   4);\n    CONTEND_EQUALITY(liquid_nextpow2(14),   4);\n    CONTEND_EQUALITY(liquid_nextpow2(15),   4);\n    CONTEND_EQUALITY(liquid_nextpow2(67),   7);\n    CONTEND_EQUALITY(liquid_nextpow2(179),  8);\n    CONTEND_EQUALITY(liquid_nextpow2(888),  10);\n}\nvoid autotest_math_config()\n{\n    CONTEND_EQUALITY(liquid_nextpow2(0), 0);\n    CONTEND_EQUALITY(liquid_nchoosek(4, 5), 0.0f);\n    CONTEND_EQUALITY(liquid_lngammaf(-1), 0.0f);\n    CONTEND_EQUALITY(liquid_gcd(12, 0), 0);\n    CONTEND_EQUALITY(liquid_gcd( 0,12), 0);\n    CONTEND_EQUALITY(liquid_gcd( 0, 0), 0);\n}')
"
"('Write a C function `liquid_pack_array` that takes in parameters `_src` as a pointer to unsigned char, `_n` as an unsigned int, `_k` as an unsigned int, `_b` as an unsigned int, and `_sym_in` as an unsigned char. The function should pack symbols into an array based on the given parameters. It should handle cases where the symbol spans multiple bytes. . . Similarly, write a C function `liquid_unpack_array` that takes in parameters `_src` as a pointer to unsigned char, `_n` as an unsigned int, `_k` as an unsigned int, `_b` as an unsigned int, and `_sym_out` as a pointer to unsigned char. The function should unpack symbols from an array based on the given parameters. It should handle cases where the symbol spans multiple bytes.. . Additionally, write a C function `liquid_pack_bytes` that takes in parameters `_sym_in` as a pointer to unsigned char, `_sym_in_len`","int liquid_pack_array(unsigned char * _src,\n                      unsigned int    _n,\n                      unsigned int    _k,\n                      unsigned int    _b,\n                      unsigned char   _sym_in)\n{\n    if (_k >= 8*_n)\n        return liquid_error(LIQUID_EIRANGE,""liquid_pack_array(), bit index exceeds array length"");\n    if (_b > 8)\n        return liquid_error(LIQUID_EIRANGE,""liquid_pack_array(), symbol size cannot exceed 8 bits"");\n    unsigned int i0 = _k / 8;       \n    unsigned int b0 = _k - 8*i0;    \n    if (b0 + _b > 8) {\n        unsigned int n0 = 8 - b0;\n        unsigned int n1 = _b - n0;\n        unsigned char mask_0 =  0xff >> (8-n0);\n        unsigned char mask_1 = (0xff >> (8-n1)) << (8-n1);\n        unsigned char sym_0 = (_sym_in >>    n1 ) & mask_0;\n        unsigned char sym_1 = (_sym_in << (8-n1)) & mask_1;\n        _src[i0] &= ~mask_0;        \n        _src[i0] |= sym_0;          \n        if (i0 < _n-1) {\n            _src[i0+1] &= ~mask_1;  \n            _src[i0+1] |= sym_1;    \n        }\n#if 0\n        printf(""  output symbol spans multiple bytes\\n"");\n        printf(""  n0    : %u\\n"", n0);\n        printf(""  n1    : %u\\n"", n1);\n        printf(""  mask0 : 0x%.2x\\n"", mask_0);\n        printf(""  mask1 : 0x%.2x\\n"", mask_1);\n        printf(""  sym 0 : 0x%.2x\\n"", sym_0);\n        printf(""  sym 1 : 0x%.2x\\n"", sym_1);\n#endif\n    } else {\n        unsigned char mask_0 = (0xff >> (8-_b)) << (8-_b-b0);\n        unsigned char sym_0  = (_sym_in << (8-_b-b0)) & mask_0;\n        _src[i0] &= ~mask_0;    \n        _src[i0] |= sym_0;      \n#if 0\n        printf(""  _b   : %u\\n"", _b);\n        printf(""  b0   : %u\\n"", b0);\n        printf(""  mask : 0x%.2x\\n"", mask_0);\n#endif\n    }\n    return LIQUID_OK;\n}\nint liquid_unpack_array(unsigned char * _src,\n                        unsigned int    _n,\n                        unsigned int    _k,\n                        unsigned int    _b,\n                        unsigned char * _sym_out)\n{\n    if (_k >= 8*_n)\n        return liquid_error(LIQUID_EIRANGE,""liquid_unpack_array(), bit index exceeds array length"");\n    if (_b > 8)\n        return liquid_error(LIQUID_EIRANGE,""liquid_unpack_array(), symbol size cannot exceed 8 bits"");\n    unsigned int i0 = _k / 8;       \n    unsigned int b0 = _k - 8*i0;    \n    if (b0 + _b > 8) {\n        unsigned int n0 = 8 - b0;\n        unsigned int n1 = _b - n0;\n        unsigned char mask_0 = 0xff >> (8-n0);\n        unsigned char mask_1 = 0xff >> (8-n1);\n        unsigned char sym_0 = _src[i0] & mask_0;\n        unsigned char sym_1 = (i0==_n-1) ? 0x00 : (_src[i0+1] >> (8-n1)) & mask_1;\n        *_sym_out = (sym_0 << n1) | sym_1;\n#if 0\n        printf(""  output symbol spans multiple bytes\\n"");\n        printf(""  n0    : %u\\n"", n0);\n        printf(""  n1    : %u\\n"", n1);\n        printf(""  mask0 : 0x%.2x\\n"", mask_0);\n        printf(""  mask1 : 0x%.2x\\n"", mask_1);\n        printf(""  sym 0 : 0x%.2x\\n"", sym_0);\n        printf(""  sym 1 : 0x%.2x\\n"", sym_1);\n#endif\n    } else {\n        unsigned char mask_0 = ((1 << _b) - 1);\n        *_sym_out = (_src[i0] >> (8-_b-b0)) & mask_0;\n#if 0\n        printf(""  _b   : %u\\n"", _b);\n        printf(""  b0   : %u\\n"", b0);\n        printf(""  mask : 0x%.2x\\n"", mask_0);\n#endif\n    }\n    return LIQUID_OK;\n}\nint liquid_pack_bytes(unsigned char * _sym_in,\n                      unsigned int    _sym_in_len,\n                      unsigned char * _sym_out,\n                      unsigned int    _sym_out_len,\n                      unsigned int *  _num_written)\n{\n    div_t d = div(_sym_in_len,8);\n    unsigned int req__sym_out_len = d.quot;\n    req__sym_out_len += ( d.rem > 0 ) ? 1 : 0;\n    if ( _sym_out_len < req__sym_out_len )\n        return liquid_error(LIQUID_EIMEM,""pack_bytes(), output too short"");\n    unsigned int i;\n    unsigned int N = 0;         \n    unsigned char byte = 0;\n    for (i=0; i<_sym_in_len; i++) {\n        byte |= _sym_in[i] & 0x01;\n        if ( (i+1)%8 == 0 ) {\n            _sym_out[N++] = byte;\n            byte = 0;\n        } else {\n            byte <<= 1;\n        }\n    }\n    if ( i%8 != 0 )\n        _sym_out[N++] = byte >> 1;\n    *_num_written = N;\n    return LIQUID_OK;\n}\nint liquid_unpack_bytes(unsigned char * _sym_in,\n                        unsigned int    _sym_in_len,\n                        unsigned char * _sym_out,\n                        unsigned int    _sym_out_len,\n                        unsigned int *  _num_written)\n{\n    if ( _sym_out_len < 8*_sym_in_len )\n        return liquid_error(LIQUID_EIMEM,""unpack_bytes(), output too short"");\n    unsigned int i;\n    unsigned int n = 0;\n    unsigned char byte;\n    for (i=0; i<_sym_in_len; i++) {\n        byte = _sym_in[i];\n        _sym_out[n++] = (byte >> 7) & 0x01;\n        _sym_out[n++] = (byte >> 6) & 0x01;\n        _sym_out[n++] = (byte >> 5) & 0x01;\n        _sym_out[n++] = (byte >> 4) & 0x01;\n        _sym_out[n++] = (byte >> 3) & 0x01;\n        _sym_out[n++] = (byte >> 2) & 0x01;\n        _sym_out[n++] = (byte >> 1) & 0x01;\n        _sym_out[n++] =  byte       & 0x01;\n    }\n    *_num_written = n;\n    return LIQUID_OK;\n}\nint liquid_repack_bytes(unsigned char * _sym_in,\n                        unsigned int    _sym_in_bps,\n                        unsigned int    _sym_in_len,\n                        unsigned char * _sym_out,\n                        unsigned int    _sym_out_bps,\n                        unsigned int    _sym_out_len,\n                        unsigned int *  _num_written)\n{\n    div_t d = div(_sym_in_len*_sym_in_bps,_sym_out_bps);\n    unsigned int req__sym_out_len = d.quot;\n    req__sym_out_len += ( d.rem > 0 ) ? 1 : 0;\n    if ( _sym_out_len < req__sym_out_len ) {\n        return liquid_error(LIQUID_EIMEM,\n                ""repack_bytes(), output too short; %u %u-bit symbols cannot be packed into %u %u-bit elements"",\n                _sym_in_len, _sym_in_bps,\n                _sym_out_len, _sym_out_bps);\n    }\n    unsigned int i;\n    unsigned char s_in = 0;     \n    unsigned char s_out = 0;    \n    unsigned int total_bits = _sym_in_len*_sym_in_bps;\n    unsigned int i_in = 0;  \n    unsigned int i_out = 0; \n    unsigned int k=0;       \n    unsigned int n=0;       \n    unsigned int v;         \n    for (i=0; i<total_bits; i++) {\n        s_out <<= 1;\n        if ( k == 0 ) {\n            s_in = _sym_in[i_in++];\n        }\n        v = _sym_in_bps - k - 1;\n        s_out |= (s_in >> v) & 0x01;\n        if ( n == _sym_out_bps-1 ) {\n            _sym_out[i_out++] = s_out;\n            s_out = 0;\n        }\n        k = (k+1) % _sym_in_bps;\n        n = (n+1) % _sym_out_bps;\n    }\n    if (i_out != req__sym_out_len) {\n        for (i=n; i<_sym_out_bps; i++)\n            s_out <<= 1;\n        _sym_out[i_out++] = s_out;\n    }\n    *_num_written = i_out;\n    return LIQUID_OK;\n}')
"
"('Design a test prompt for evaluating the stand-alone functionality of a specific C function `spgramcf_estimate_psd` that estimates power spectral density based on input samples. In the test scenario, generate a noise signal with a specified noise floor level and standard deviation, then calculate the PSD using the function. Verify that the calculated PSD values fall within expected ranges defined by lower and upper masks. Finally, provide a sequence of assertions to compare the calculated PSD values with the expected masks.","//...\nvoid autotest_spgramcf_standalone()\n{\n    unsigned int nfft        = 1200;\n    unsigned int num_samples = 20*nfft;  \n    float        noise_floor = -20.0f;\n    float        nstd        = powf(10.0f,noise_floor/20.0f); \n    float complex * buf = (float complex*)malloc(num_samples*sizeof(float complex));\n    unsigned int i;\n    for (i=0; i<num_samples; i++)\n        buf[i] = 0.1f + nstd*(randnf()+_Complex_I*randnf())*M_SQRT1_2;\n    float psd[nfft];\n    spgramcf_estimate_psd(nfft, buf, num_samples, psd);\n    for (i=0; i<nfft; i++) {\n        float mask_lo = i ==nfft/2                     ? 2.0f : noise_floor - 3.0f;\n        float mask_hi = i > nfft/2-10 && i < nfft/2+10 ? 8.0f : noise_floor + 3.0f;\n        if (liquid_autotest_verbose)\n            printf(""%6u : %8.2f < %8.2f < %8.2f\\n"", i, mask_lo, psd[i], mask_hi);\n        CONTEND_GREATER_THAN( psd[i], mask_lo );\n        CONTEND_LESS_THAN   ( psd[i], mask_hi );\n    }\n    free(buf);\n}\n//...')
"
"(""Prompt: You are working on a software defined radio (SDR) application that involves decoding message symbols. Design a function that decodes symbols using 15/11 Hamming encoding. The function should take an input symbol, check if it's within the valid range, calculate syndromes using bit-dot product operations, and correct the symbol if needed based on specific syndrome index mappings. Additionally, the function should handle debug output if a certain macro is set.","//...\nunsigned int fec_hamming1511_decode_symbol(unsigned int _sym_enc)\n{\n    if (_sym_enc >= (1<<15)) {\n        liquid_error(LIQUID_EICONFIG,""fec_hamming_decode(), input symbol too large"");\n        return 0;\n    }\n    unsigned int s1 = liquid_bdotprod_uint16(_sym_enc, HAMMING_S1);\n    unsigned int s2 = liquid_bdotprod_uint16(_sym_enc, HAMMING_S2);\n    unsigned int s4 = liquid_bdotprod_uint16(_sym_enc, HAMMING_S4);\n    unsigned int s8 = liquid_bdotprod_uint16(_sym_enc, HAMMING_S8);\n    unsigned int z = (s8<<3) | (s4<<2) | (s2<<1) | s1;\n#if DEBUG_FEC_HAMMING1511\n    printf(""syndrome bits (s1,s2,s4,s8) : (%1u,%1u,%1u,%1u)\\n"", s1, s2, s4, s8);\n    printf(""syndrome z : %u\\n"", z);\n#endif\n    if (z) {\n        if (z > 15) {\n            fprintf(stderr,""warning, fec_hamming1511_decode_symbol(), syndrome index exceeds maximum\\n"");\n        } else {\n            _sym_enc ^= 1 << (15-z);\n        }\n    }\n    unsigned int sym_dec = ((_sym_enc & 0x007f)     )   |\n                           ((_sym_enc & 0x0700) >> 1)   |\n                           ((_sym_enc & 0x1000) >> 2);\n    return sym_dec;\n}\n//...')
"
('Prompt: You are designing a digital signal processing application and need functions to quantize analog signals for both Analog-to-Digital Conversion (ADC) and Digital-to-Analog Conversion (DAC). The quantization process involves rounding the input value to the nearest discretized value based on the specified number of bits. Your prompt should include the requirement for input validation to ensure the number of bits does not exceed a maximum value. Please provide C code for `quantize_adc()` and `quantize_dac()` functions that implement the quantization process with input validation.,"#define LIQUID_VALIDATE_INPUT\n#define QUANTIZER_MAX_BITS      32\nunsigned int quantize_adc(float _x, unsigned int _num_bits)\n{\n#ifdef LIQUID_VALIDATE_INPUT\n    if (_num_bits > QUANTIZER_MAX_BITS) {\n        liquid_error(LIQUID_EIRANGE,""quantize_adc(), maximum bits exceeded"");\n        return 0;\n    }\n#endif\n    if (_num_bits == 0)\n        return 0;\n    unsigned int n = _num_bits-1;   \n    unsigned int N = 1<<n;          \n    int neg = (_x < 0);\n    unsigned int r = floorf(fabsf(_x)*N);\n    if (r >= N)\n        r = N-1;\n    if (neg)\n        r |= N;\n    return r;\n}\nfloat quantize_dac(unsigned int _s, unsigned int _num_bits)\n{\n#ifdef LIQUID_VALIDATE_INPUT\n    if (_num_bits > QUANTIZER_MAX_BITS) {\n        liquid_error(LIQUID_EIRANGE,""quantize_dac(), maximum bits exceeded"");\n        return 0.0f;\n    }\n#endif\n    if (_num_bits == 0)\n        return 0.0f;\n    unsigned int n = _num_bits-1;   \n    unsigned int N = 1<<n;          \n    float r = ((float)(_s & (N-1))+0.5f) / (float) (N);\n    return (_s & N) ? -r : r;\n}')
"
"'Prompt: You are working on a multi-threaded application and need to write a function in C that retrieves the stack size attribute from a pthread attribute object. Please provide code for a function called `pthread_attr_getstacksize` that takes a `pthread_attr_t` pointer and a `size_t` pointer as arguments and returns an integer. The function should handle scenarios where `_POSIX_THREAD_ATTR_STACKSIZE` is defined and where it is not, returning `EINVAL` if the attribute is invalid and setting the stack size in the `size_t` pointer if the attribute is valid, otherwise returning `ENOSYS`.","//...\nint\npthread_attr_getstacksize (const pthread_attr_t * attr, size_t * stacksize)\n{\n#if defined(_POSIX_THREAD_ATTR_STACKSIZE) && _POSIX_THREAD_ATTR_STACKSIZE != -1\n  if (__ptw32_is_attr (attr) != 0)\n    {\n      return EINVAL;\n    }\n  *stacksize = (*attr)->stacksize;\n  return 0;\n#else\n  return ENOSYS;\n#endif \n}\n//...'"
"'Prompt: Assume you are working on a project that involves multi-threading and you need to implement a function that sets the scope of a pthread attribute. However, you want to handle different scenarios based on the platform and compiler being used. Can you provide a code snippet that includes handling the configuration, compiler-specific directives, and platform-specific checks for setting the contention scope of a pthread attribute?","#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n#if defined(_MSC_VER)\n#pragma warning( disable : 4100 )\n#endif\nint\npthread_attr_setscope (pthread_attr_t * attr, int contentionscope)\n{\n#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)\n  switch (contentionscope)\n    {\n    case PTHREAD_SCOPE_SYSTEM:\n      (*attr)->contentionscope = contentionscope;\n      return 0;\n    case PTHREAD_SCOPE_PROCESS:\n      return ENOTSUP;\n    default:\n      return EINVAL;\n    }\n#else\n  return ENOSYS;\n#endif\n}'"
"('Prompt: You are working on testing the demodulation software for different modulation schemes in a modem communication framework. Write a function that takes a modulation scheme as input, creates modulators and demodulators for that scheme, tests the demodulation process for all possible symbols, and verifies the correctness of the demodulation. Implement test functions for PSK2 and PSK256 modulation schemes in the modem communication framework.","//...\nvoid modemcf_test_demodsoft(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int bps = modemcf_get_bps(demod);\n    unsigned int i, s, M=1<<bps;\n    unsigned int sym_soft;\n    unsigned char soft_bits[bps];\n    float complex x;\n    for (i=0; i<M; i++) {\n        modemcf_modulate(mod, i, &x);\n        modemcf_demodulate_soft(demod, x, &s, soft_bits);\n        CONTEND_EQUALITY(s, i);\n        liquid_pack_soft_bits(soft_bits, bps, &sym_soft);\n        CONTEND_EQUALITY(sym_soft, i);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodsoft_psk2()      { modemcf_test_demodsoft(LIQUID_MODEM_PSK2);      }\nvoid autotest_demodsoft_psk256()    { modemcf_test_demodsoft(LIQUID_MODEM_PSK256);    }\n//...')
"
"('""I need you to create a function that tests the copy functionality for forward error correction schemes. In this function, if the LIBFEC library is not enabled, it should display a warning message. Then, it should create two FEC instances based on the provided scheme, encode random data using one instance, copy that instance to another, encode data with both instances, compare the encoded data, decode data with both instances, and compare the decoded data. Finally, it should destroy both FEC instances. Can you provide me with the code for this scenario?""","void fec_test_copy(fec_scheme _fs)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    unsigned int n_dec = 64;\n    void *       opts  = NULL;\n    fec q0 = fec_create(_fs,opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,n_dec);\n    unsigned char msg_org[n_dec];   \n    unsigned char msg_enc_0[n_enc]; \n    unsigned char msg_enc_1[n_enc]; \n    unsigned char msg_dec_0[n_dec]; \n    unsigned char msg_dec_1[n_dec]; \n    unsigned int i;\n    for (i=0; i<n_dec; i++)\n        msg_org[i] = rand() & 0xff;\n    fec_encode(q0,n_dec,msg_org,msg_enc_0);\n    fec q1 = fec_copy(q0);\n    fec_encode(q1,n_dec,msg_org,msg_enc_1);\n    CONTEND_SAME_DATA(msg_enc_0,msg_enc_1,n_enc);\n    for (i=0; i<n_enc; i++) {\n        msg_enc_0[i] = rand() & 0xff;\n        msg_enc_1[i] = msg_enc_0[i];\n    }\n    fec_decode(q0,n_dec,msg_enc_0,msg_dec_0);\n    fec_decode(q1,n_dec,msg_enc_1,msg_dec_1);\n    CONTEND_SAME_DATA(msg_dec_0,msg_dec_1,n_dec);\n    fec_destroy(q0);\n    fec_destroy(q1);\n}\nvoid autotest_fec_copy_r3()      { fec_test_copy(LIQUID_FEC_REP3          ); }\nvoid autotest_fec_copy_r5()      { fec_test_copy(LIQUID_FEC_REP5          ); }\nvoid autotest_fec_copy_h74()     { fec_test_copy(LIQUID_FEC_HAMMING74     ); }\nvoid autotest_fec_copy_h84()     { fec_test_copy(LIQUID_FEC_HAMMING84     ); }\nvoid autotest_fec_copy_h128()    { fec_test_copy(LIQUID_FEC_HAMMING128    ); }\nvoid autotest_fec_copy_g2412()   { fec_test_copy(LIQUID_FEC_GOLAY2412     ); }\nvoid autotest_fec_copy_secded2216() { fec_test_copy(LIQUID_FEC_SECDED2216 ); }\nvoid autotest_fec_copy_secded3932() { fec_test_copy(LIQUID_FEC_SECDED3932 ); }\nvoid autotest_fec_copy_secded7264() { fec_test_copy(LIQUID_FEC_SECDED7264 ); }\nvoid autotest_fec_copy_v27()     { fec_test_copy(LIQUID_FEC_CONV_V27      ); }\nvoid autotest_fec_copy_v29()     { fec_test_copy(LIQUID_FEC_CONV_V29      ); }\nvoid autotest_fec_copy_v39()     { fec_test_copy(LIQUID_FEC_CONV_V39      ); }\nvoid autotest_fec_copy_v615()    { fec_test_copy(LIQUID_FEC_CONV_V615     ); }\nvoid autotest_fec_copy_v27p23()  { fec_test_copy(LIQUID_FEC_CONV_V27P23   ); }\nvoid autotest_fec_copy_v27p34()  { fec_test_copy(LIQUID_FEC_CONV_V27P34   ); }\nvoid autotest_fec_copy_v27p45()  { fec_test_copy(LIQUID_FEC_CONV_V27P45   ); }\nvoid autotest_fec_copy_v27p56()  { fec_test_copy(LIQUID_FEC_CONV_V27P56   ); }\nvoid autotest_fec_copy_v27p67()  { fec_test_copy(LIQUID_FEC_CONV_V27P67   ); }\nvoid autotest_fec_copy_v27p78()  { fec_test_copy(LIQUID_FEC_CONV_V27P78   ); }\nvoid autotest_fec_copy_v29p23()  { fec_test_copy(LIQUID_FEC_CONV_V29P23   ); }\nvoid autotest_fec_copy_v29p34()  { fec_test_copy(LIQUID_FEC_CONV_V29P34   ); }\nvoid autotest_fec_copy_v29p45()  { fec_test_copy(LIQUID_FEC_CONV_V29P45   ); }\nvoid autotest_fec_copy_v29p56()  { fec_test_copy(LIQUID_FEC_CONV_V29P56   ); }\nvoid autotest_fec_copy_v29p67()  { fec_test_copy(LIQUID_FEC_CONV_V29P67   ); }\nvoid autotest_fec_copy_v29p78()  { fec_test_copy(LIQUID_FEC_CONV_V29P78   ); }\nvoid autotest_fec_copy_rs8()     { fec_test_copy(LIQUID_FEC_RS_M8         ); }')
"
'Could you provide me with the code implementation for parsing and manipulating SDP (Session Description Protocol) information in a file located at `../gear-lib/librtsp/sdp.c`?,../gear-lib/librtsp/sdp.c'
"('You are building an application that involves signal processing with a multi-channel filter bank to perform various operations like FFT, windowing, and dot product calculations. In this scenario, you need to debug and print out intermediate results during the execution of the program. The code snippet you provided initializes necessary parameters, creates filter banks, processes input signals, and calculates the Root Mean Square Error (RMSE) between traditional and filter bank outputs. You are interested in viewing the prototype and sub-filter bank details, as well as the final output comparison between the traditional and filter bank processing.","#define DEBUG 1\nint main() {\n    unsigned int num_channels=4;    \n    unsigned int m=3;               \n    unsigned int num_symbols=5;     \n    unsigned int num_samples = num_channels * num_symbols;\n    unsigned int i;\n    unsigned int j;\n    unsigned int h_len = 2*m*num_channels;\n    float h[h_len];\n    for (i=0; i<h_len; i++) h[i] = randnf();\n    dotprod_crcf dp[num_channels];  \n    windowcf w[num_channels];       \n#if DEBUG\n    printf(""h_prototype:\\n"");\n    for (i=0; i<h_len; i++)\n        printf(""  h[%3u] = %12.8f\\n"", i, h[i]);\n#endif\n    unsigned int h_sub_len = 2*m;\n    float h_sub[h_sub_len];\n    for (i=0; i<num_channels; i++) {\n#if 0\n        for (j=0; j<h_sub_len; j++)\n            h_sub[j] = h[j*num_channels+i];\n#else\n        for (j=0; j<h_sub_len; j++)\n            h_sub[h_sub_len-j-1] = h[j*num_channels+i];\n#endif\n        dp[i] = dotprod_crcf_create(h_sub, h_sub_len);\n        w[i]  = windowcf_create(h_sub_len);\n#if DEBUG\n        printf(""h_sub[%u] : \\n"", i);\n        for (j=0; j<h_sub_len; j++)\n            printf(""  h[%3u] = %12.8f\\n"", j, h_sub[j]);\n#endif\n    }\n    float complex x[num_channels];  \n    float complex X[num_channels];  \n#if 1\n    fftplan ifft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);\n#else\n    fftplan ifft = fft_create_plan(num_channels, X, x, LIQUID_FFT_FORWARD, 0);\n#endif\n    firfilt_crcf f = firfilt_crcf_create(h, h_len);\n    float complex Y[num_symbols][num_channels];     \n    float complex y0[num_samples];                  \n    float complex y1[num_samples];                  \n    for (i=0; i<num_symbols; i++) {\n        for (j=0; j<num_channels; j++)\n            Y[i][j] = randnf() * cexpf(_Complex_I*randf()*2*M_PI);\n#if 0\n        for (j=0; j<num_channels; j++)\n            Y[i][j] = i==0 ? randnf() * cexpf(_Complex_I*randf()*2*M_PI) : 0.0f;\n#endif\n    }\n    float complex * r;      \n    for (i=0; i<num_symbols; i++) {\n        for (j=0; j<num_channels; j++) {\n            X[j] = Y[i][j];\n        }\n        fft_execute(ifft);\n        for (j=0; j<num_channels; j++) {\n            windowcf_push(w[j], x[j]);\n            windowcf_read(w[j], &r);\n            dotprod_crcf_execute(dp[j], r, &y0[i*num_channels+j]);\n        }\n    }\n    for (i=0; i<num_samples; i++)\n        y1[i] = 0.0f;\n    unsigned int n;\n    float dphi; \n    float complex y_hat;\n    for (i=0; i<num_channels; i++) {\n        firfilt_crcf_reset(f);\n        dphi = 2.0f * M_PI * (float)i / (float)num_channels;\n        n=0;\n        for (j=0; j<num_samples; j++) {\n            if ( (j%num_channels)==0 ) {\n                assert(n<num_symbols);\n                firfilt_crcf_push(f, Y[n][i]);\n                n++;\n            } else {\n                firfilt_crcf_push(f, 0);\n            }\n            firfilt_crcf_execute(f, &y_hat);\n            y1[j] += y_hat * cexpf(_Complex_I*j*dphi);\n        }\n        assert(n==num_symbols);\n    }\n    for (i=0; i<num_channels; i++) {\n        dotprod_crcf_destroy(dp[i]);\n        windowcf_destroy(w[i]);\n    }\n    fft_destroy_plan(ifft);\n    firfilt_crcf_destroy(f);\n    printf(""\\n"");\n    printf(""output: filterbank:             traditional:\\n"");\n    for (i=0; i<num_samples; i++) {\n        printf(""%3u: %10.5f+%10.5fj  %10.5f+%10.5fj\\n"",\n            i,\n            crealf(y0[i]), cimagf(y0[i]),\n            crealf(y1[i]), cimagf(y1[i]));\n    }\n    float mse = 0.0f;\n    float complex d;\n    for (i=0; i<num_samples; i++) {\n        d = y0[i] - y1[i];\n        mse += crealf(d*conjf(d));\n    }\n    mse /= num_samples;\n    printf(""\\n"");\n    printf(""rmse: %12.4e\\n"", sqrtf(mse));\n    printf(""done.\\n"");\n    return 0;\n}')
"
"('Prompt: You are working on a C program that deals with matrix operations using float data type. Create a macro that generates the name of the matrix using a given identifier, defines the data type to be used for the matrix elements as float, sets the complex number type to 0, and defines functions for finding the absolute value of elements. Additionally, define a macro for printing elements of the matrix with specific formatting.","#define MATRIX(name)    LIQUID_CONCAT(matrixf, name)\n#define MATRIX_NAME     ""matrixf""\n#define T               float           \n#define TP              float           \n#define T_COMPLEX       0               \n#define T_ABS(X)        fabsf(X)\n#define TP_ABS(X)       fabsf(X)\n#define MATRIX_PRINT_ELEMENT(X,R,C,r,c) \\\n    printf(""%12.7f"", matrix_access(X,R,C,r,c));')
"
"('""I need a prompt for you to provide a code snippet that creates a flexframe generator object in C. The flexframe generator includes functions to set header properties, configure the generator, reset it, and reconfigure it. It also includes various properties such as preamble, header, payload, and encoder settings. Can you provide me with the code for this scenario?""","//...\n    unsigned int    k;                  \n    unsigned int    m;                  \n    float           beta;               \n    firinterp_crcf  interp;             \n    flexframegenprops_s props;          \n    flexframegenprops_s header_props;   \n    float complex * preamble_pn;        \n    unsigned char * header;             \n    unsigned int    header_user_len;    \n    qpacketmodem    header_encoder;     \n    float complex * header_mod;         \n    qpilotgen       header_pilotgen;    \n    float complex * header_sym;         \n    unsigned int    payload_dec_len;    \n    qpacketmodem    payload_encoder;    \n    unsigned int    payload_sym_len;    \n    float complex * payload_sym;        \nint flexframegen_set_header_len(flexframegen   _q,\n                                 unsigned int   _len)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), frame is already assembled; must reset() first"");\n    _q->header_user_len = _len;\n    _q->header_dec_len = FLEXFRAME_H_DEC + _q->header_user_len;\n    _q->header     = (unsigned char *) realloc(_q->header, _q->header_dec_len*sizeof(unsigned char));\n    if (_q->header_encoder) {\n        qpacketmodem_destroy(_q->header_encoder);\n    }\n    _q->header_encoder = qpacketmodem_create();\n    qpacketmodem_configure(_q->header_encoder,\n                           _q->header_dec_len,\n                           _q->header_props.check,\n                           _q->header_props.fec0,\n                           _q->header_props.fec1,\n                           _q->header_props.mod_scheme);\n    _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_encoder);\n    _q->header_mod     = (float complex *) realloc(_q->header_mod, _q->header_mod_len*sizeof(float complex));\n    if (_q->header_pilotgen) {\n        qpilotgen_destroy(_q->header_pilotgen);\n    }\n    _q->header_pilotgen = qpilotgen_create(_q->header_mod_len, 16);\n    _q->header_sym_len  = qpilotgen_get_frame_len(_q->header_pilotgen);\n    _q->header_sym      = (float complex *) realloc(_q->header_sym, _q->header_sym_len*sizeof(float complex));\n    return LIQUID_OK;\n}\nint flexframegen_set_header_props(flexframegen          _q,\n                                  flexframegenprops_s * _props)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_set_header_props(), frame is already assembled; must reset() first"");\n    if (_props == NULL)\n        _props = &flexframegenprops_header_default;\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EIMODE,""flexframegen_set_header_props(), invalid/unsupported CRC scheme\\n"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EIMODE,""flexframegen_set_header_props(), invalid/unsupported FEC scheme\\n"");\n    if (_props->mod_scheme == LIQUID_MODEM_UNKNOWN )\n        return liquid_error(LIQUID_EIMODE,""flexframegen_set_header_props(), invalid/unsupported modulation scheme\\n"");\n    memmove(&_q->header_props, _props, sizeof(flexframegenprops_s));\n    return flexframegen_set_header_len(_q, _q->header_user_len);\n}\nint flexframegen_setprops(flexframegen          _q,\n                          flexframegenprops_s * _props)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), frame is already assembled; must reset() first"");\n    if (_props == NULL)\n        return flexframegen_setprops(_q, &flexframegenprops_default);\n    if (_props->check == LIQUID_CRC_UNKNOWN || _props->check >= LIQUID_CRC_NUM_SCHEMES)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), invalid/unsupported CRC scheme"");\n    if (_props->fec0 == LIQUID_FEC_UNKNOWN || _props->fec1 == LIQUID_FEC_UNKNOWN)\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), invalid/unsupported FEC scheme"");\n    if (_props->mod_scheme == LIQUID_MODEM_UNKNOWN )\n        return liquid_error(LIQUID_EICONFIG,""flexframegen_setprops(), invalid/unsupported modulation scheme"");\n    memmove(&_q->props, _props, sizeof(flexframegenprops_s));\n    return flexframegen_reconfigure(_q);\n}\nint flexframegen_reset(flexframegen _q)\n{\n    _q->symbol_counter  = 0;\n    _q->sample_counter  = 0;\n    _q->frame_assembled = 0;\n    _q->frame_complete  = 0;\n    _q->state           = STATE_PREAMBLE;\n    return LIQUID_OK;\n}\nint flexframegen_reconfigure(flexframegen _q)\n{\n    qpacketmodem_configure(_q->payload_encoder,\n                           _q->payload_dec_len,\n                           _q->props.check,\n                           _q->props.fec0,\n                           _q->props.fec1,\n                           _q->props.mod_scheme);\n    _q->payload_sym_len = qpacketmodem_get_frame_len(_q->payload_encoder);\n    _q->payload_sym = (float complex*) realloc(_q->payload_sym,\n                                               _q->payload_sym_len*sizeof(float complex));\n    if (_q->payload_sym == NULL)\n        return liquid_error(LIQUID_EIMEM,""flexframegen_reconfigure(), could not re-allocate payload array"");\n    return LIQUID_OK;\n}\nflexframegen flexframegen_create(flexframegenprops_s * _fgprops)\n{\n    flexframegen q = (flexframegen) malloc(sizeof(struct flexframegen_s));\n    unsigned int i;\n    q->k      = 2;\n    q->m      = 7;\n    q->beta   = 0.25f;\n    q->interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,q->k,q->m,q->beta,0);\n    q->preamble_pn = (float complex *) malloc(64*sizeof(float complex));\n    msequence ms = msequence_create(7, 0x0089, 1);\n    for (i=0; i<64; i++) {\n        q->preamble_pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        q->preamble_pn[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;\n    }\n    msequence_destroy(ms);\n    flexframegen_reset(q);\n    q->header = NULL;\n    q->header_mod = NULL;\n    q->header_sym = NULL;\n    q->header_encoder = NULL;\n    q->header_pilotgen = NULL;\n    q->header_user_len = FLEXFRAME_H_USER_DEFAULT;\n    q->payload_encoder = qpacketmodem_create();\n    q->payload_dec_len = 64;\n    q->payload_sym_len = qpacketmodem_get_frame_len(q->payload_encoder);\n    q->payload_sym     = (float complex *) malloc( q->payload_sym_len*sizeof(float complex));\n    flexframegen_setprops(q, _fgprops);\n    flexframegen_set_header_props(q, NULL);\n    return q;\n}\n//...')
"
"('Prompt: You are tasked with writing a function that factors a given unsigned integer into its prime factors. The function should take in the integer to factor, an array to store the factors, and a pointer to store the number of factors found. The function should continue factoring until it reaches the maximum number of factors allowed or until it has completely factored the number. If the maximum number of factors is reached without fully factoring the number, an error should be returned.","//...\nint liquid_factor(unsigned int   _n,\n                  unsigned int * _factors,\n                  unsigned int * _num_factors)\n{\n    unsigned int k;\n    unsigned int n = _n;\n    unsigned int num_factors = 0;\n    do {\n        for (k=2; k<=n; k++) {\n            if ( (n % k) == 0) {\n                _factors[num_factors++] = k;\n                n /= k;\n                break;\n            }\n        }\n    } while (n > 1 && num_factors < LIQUID_MAX_FACTORS);\n    if (n > 1 && num_factors == LIQUID_MAX_FACTORS)\n        return liquid_error(LIQUID_EICONFIG,""liquid_factor(), could not factor %u in %u numbers"", _n, LIQUID_MAX_FACTORS);\n    *_num_factors = num_factors;\n    return LIQUID_OK;\n}\n//...')
"
"'Please provide a code snippet that initializes a plugin manager, loads multiple plugins specified in an array of plugin information, performs a specific operation on one of the loaded plugins (specified by name), and then unloads and destroys all loaded plugins before exiting. The plugin information includes the path and name of each plugin to load.","struct plugin_info {\n    char *path;\n    char *name;\n};\nstruct plugin_info p_info[] = {\n    {""./modules/plugin_log.so"", ""plugin_log""},\n    {""./modules/plugin_ipc.so"", ""plugin_ipc""},\n    {""./modules/plugin_skt.so"", ""plugin_skt""},\n};\n#define SIZEOF(array)       (sizeof(array)/sizeof(array[0]))\nstatic struct plugin_manager *pm = NULL;\nvoid init()\n{\n    int i = 0;\n    struct plugin *p = NULL;\n    pm = plugin_manager_create();\n    if (!pm) {\n        printf(""plugin_manager_create failed!\\n"");\n        return;\n    }\n    for (i = 0; i < SIZEOF(p_info); i++) {\n        p = plugin_load(pm, p_info[i].path, p_info[i].name);\n        if (!p) {\n            printf(""plugin_load failed!\\n"");\n            return;\n        }\n    }\n}\nvoid deinit()\n{\n    int i = 0;\n    for (i = 0; i < SIZEOF(p_info); i++) {\n        plugin_unload(pm, p_info[i].name);\n    }\n    plugin_manager_destroy(pm);\n}\nvoid foo()\n{\n    char *name = ""plugin_ipc"";\n    struct plugin *p = plugin_lookup(pm, name);\n    if (!p) {\n        printf(""plugin_lookup %s failed!\\n"", name);\n        return;\n    }\n    p->open(NULL);\n    printf(""name=%s, version=%d,%d,%d\\n"", p->name, p->version.major, p->version.minor, p->version.patch);\n}\nint main(int argc, char **argv)\n{\n    init();\n    foo();\n    deinit();\n    return 0;\n}'"
"('Prompt: ""Please provide a function that performs an automated test for an IIR filter with a numerator coefficient array of size 7 and a denominator coefficient array of size 7. The function should filter input data array of size 64 using the provided coefficients and store the output in a separate data array of size 64.""","//...\nvoid autotest_iirfilt_rrrf_h7x64()\n{\n    iirfilt_rrrf_test(iirfilt_rrrf_data_h7x64_b,\n                      iirfilt_rrrf_data_h7x64_a, 7,\n                      iirfilt_rrrf_data_h7x64_x, 64,\n                      iirfilt_rrrf_data_h7x64_y, 64);\n}\n//...')
"
"('Prompt: You are working on a project involving symbol tracking and you need to test a function that simulates symbol tracking and demodulation using complex floating-point numbers. The function takes parameters such as the filter type, number of symbols, noise floor, SNR, bandwidth, and phase parameters. Additionally, it uses automatic gain control (AGC) and carrier frequency offset correction. The function also computes the error vector magnitude (EVM) of the demodulated symbols. Could you provide me with a test bench code for this scenario?","//...\nvoid testbench_symtrack_cccf(unsigned int _k, unsigned int _m, float _beta, int _ms)\n{\n    int          ftype       = LIQUID_FIRFILT_ARKAISER;\n    unsigned int num_symbols = 6000;    \n    float        noise_floor = -30.0f;  \n    float        SNRdB       = 30.0f;   \n    float        bandwidth   =  0.15f;  \n    float        dphi        =  0.02f;  \n    float        phi         =  2.1f;   \n    unsigned int    buf_len = 800;  \n    float complex   buf_0[buf_len]; \n    float complex   buf_1[buf_len]; \n    symstreamcf gen = symstreamcf_create_linear(ftype,_k,2*_m,_beta,_ms);\n    channel_cccf channel = channel_cccf_create();\n    channel_cccf_add_awgn          (channel, noise_floor, SNRdB);\n    channel_cccf_add_carrier_offset(channel, dphi, phi);\n    symtrack_cccf symtrack = symtrack_cccf_create(ftype,_k,_m,_beta,_ms);\n    symtrack_cccf_set_bandwidth(symtrack,bandwidth);\n    if (liquid_autotest_verbose)\n        symtrack_cccf_print(symtrack);\n    unsigned int total_samples = 0;\n    unsigned int num_symbols_evm = 0;\n    float        evm = 0.0f;\n    modemcf demod = modemcf_create(_ms); \n    while (total_samples < num_symbols * _k)\n    {\n        symstreamcf_write_samples(gen, buf_0, buf_len);\n        channel_cccf_execute_block(channel, buf_0, buf_len, buf_0);\n        unsigned int num_symbols_sync;\n        symtrack_cccf_execute_block(symtrack, buf_0, buf_len, buf_1, &num_symbols_sync);\n        total_samples += buf_len;\n        if (total_samples > 0.80 * num_symbols * _k) {\n            unsigned int i, sym;\n            for (i=0; i<num_symbols_sync; i++) {\n                modemcf_demodulate(demod, buf_1[i], &sym);\n                float err = modemcf_get_demodulator_evm(demod);\n                evm += err*err;\n            }\n            num_symbols_evm += num_symbols_sync;\n        }\n    }\n    symstreamcf_destroy  (gen);\n    channel_cccf_destroy (channel);\n    symtrack_cccf_destroy(symtrack);\n    modemcf_destroy(demod);\n    evm = 10*log10f(evm / (float)num_symbols_evm);\n    printf(""EVM: %12.8f, %u\\n"", evm, num_symbols_evm);\n    CONTEND_LESS_THAN(evm, -15.0f);\n}\n//...')
"
"(""Prompt: You are designing a testbench for the synchronization of GMSK frames in a communication system. The system uses a GMSK frame generator and a GMSK frame synchronizer with parameters _k, _m, and _bt. The testbench should assemble a default frame of length 80 and continuously write frames to the synchronizer until a complete frame is received. Upon completion, the testbench should print the frame synchronization details and validate the received frame data statistics to ensure correct synchronization. Finally, the frame generator and synchronizer should be destroyed. Implement the testbench function 'testbench_gmskframesync' with these requirements.. . Response: You can use the provided testbench_gmskframesync code as a response to the prompt to implement the testbench function for GMSK frame synchronization in the given technical scenario.","//...\nvoid testbench_gmskframesync(unsigned int _k, unsigned int _m, float _bt)\n{\n    gmskframegen  fg = gmskframegen_create_set (_k,_m,_bt);\n    gmskframesync fs = gmskframesync_create_set(_k,_m,_bt,NULL,NULL);\n    gmskframegen_assemble_default(fg, 80);\n    unsigned int  buf_len = 200;\n    float complex buf[buf_len];\n    int frame_complete = 0;\n    while (!frame_complete) {\n        frame_complete = gmskframegen_write(fg, buf, buf_len);\n        gmskframesync_execute(fs, buf, buf_len);\n    }\n    if (liquid_autotest_verbose)\n        gmskframesync_print(fs);\n    framedatastats_s stats = gmskframesync_get_framedatastats(fs);\n    CONTEND_EQUALITY(stats.num_frames_detected, 1);\n    CONTEND_EQUALITY(stats.num_headers_valid,   1);\n    CONTEND_EQUALITY(stats.num_payloads_valid,  1);\n    CONTEND_EQUALITY(stats.num_bytes_received,  80);\n    gmskframegen_destroy(fg);\n    gmskframesync_destroy(fs);\n}\nvoid autotest_gmskframesync_k03_m07_bt20() { testbench_gmskframesync( 3, 7, 0.20f); }\n//...')
"
"('Prompt: Design a function to determine the number of pilots needed for a communication system. The function should take into account the payload length and the spacing between pilots. Additionally, create a function to calculate the total frame length including the pilots. The pilot spacing should be at least 2 and if the payload length is 0, no pilots should be included. Output the total number of pilots required and the frame length in bytes.","//...\nunsigned int qpilot_num_pilots(unsigned int _payload_len,\n                               unsigned int _pilot_spacing)\n{\n    if (_payload_len == 0 || _pilot_spacing < 2)\n        return 0;\n    div_t d = div(_payload_len,(_pilot_spacing - 1));\n    return d.quot + (d.rem ? 1 : 0);\n}\nunsigned int qpilot_frame_len(unsigned int _payload_len,\n                              unsigned int _pilot_spacing)\n{\n    return _payload_len + qpilot_num_pilots(_payload_len, _pilot_spacing);\n}\n//...')
"
'Prompt: You are working on a project that involves capturing video and audio frames using the V4L2 backend on a Linux operating system. Can you provide a code snippet that shows how to handle and process video and audio frames within the context of the AV capture library?,"//...\nstruct avcap_config conf = {\n            .type = AVCAP_TYPE_VIDEO,\n            .backend = AVCAP_BACKEND_XCB,\n    };\nstatic struct file *fp;\nstatic int on_frame(struct avcap_ctx *c, struct media_frame *frm)\n{\n    int ret;\n    if (!c || !frm) {\n        printf(""on_frame invalid!\\n"");\n        return -1;\n    }\n    switch (frm->type) {\n    case MEDIA_TYPE_VIDEO:\n        ret = on_video(c, &frm->video);\n        break;\n    case MEDIA_TYPE_AUDIO:\n        ret = on_audio(c, &frm->audio);\n        break;\n    default:\n        printf(""unsupport frame format"");\n        ret = -1;\n        break;\n    }\n    return ret;\n}\nstatic int on_video(struct avcap_ctx *c, struct video_frame *video)\n{\n    static uint64_t last_ms = 0;\n    static int luma = 0;\n    static int i = 0;\n    printf(""video_frame[%"" PRIu64 ""] size=%"" PRIu64 "", ts=%"" PRIu64 "" ms, gap=%"" PRIu64 "" ms\\n"",\n          video->frame_id, video->total_size, video->timestamp/1000000, video->timestamp/1000000 - last_ms);\n    last_ms = video->timestamp/1000000;\n    luma = 2 * i++;\n    luma *= i%2 ? 1: -1;\n    avcap_ioctl(c, VIDCAP_SET_LUMA, luma);\n    file_write(fp, video->data[0], video->total_size);\n    return 0;\n}\nstatic int on_audio(struct avcap_ctx *c, struct audio_frame *audio)\n{\n    printf(""audio_frame[%"" PRIu64 ""] cnt=%d size=%"" PRIu64 "", ts=%"" PRIu64 "" ms\\n"",\n           audio->frame_id, audio->frames, audio->total_size, audio->timestamp/1000000);\n    file_write(fp, audio->data[0], audio->total_size);\n    return 0;\n}\nint v4l2_test()\n{\n#if defined (OS_LINUX)\n    struct avcap_ctx *avcap;\n    struct video_frame *frm;\n    struct avcap_config conf = {\n            .type = AVCAP_TYPE_VIDEO,\n            .backend = AVCAP_BACKEND_V4L2,\n            .video = {\n                PIXEL_FORMAT_YUY2,\n                VIDEO_WIDTH,\n                VIDEO_HEIGHT,\n                .fps = {30, 1},\n            },\n    };\n    printf(""======== v4l2_test enter\\n"");\n    avcap = avcap_open(VIDEO_DEV, &conf);\n    if (!avcap) {\n        printf(""avcap_open v4l2 failed!\\n"");\n        return -1;\n    }\n    avcap_ioctl(avcap, VIDCAP_GET_CAP, NULL);\n    frm = video_frame_create(avcap->conf.video.format, avcap->conf.video.width, avcap->conf.video.height, MEDIA_MEM_SHALLOW);\n    if (!frm) {\n        printf(""video_frame_create failed!\\n"");\n        avcap_close(avcap);\n        return -1;\n    }\n    printf(""avcap info: %s %dx%d@%d/%d fps format:%s\\n"", VIDEO_DEV, avcap->conf.video.width, avcap->conf.video.height,\n        avcap->conf.video.fps.num, avcap->conf.video.fps.den, pixel_format_to_string(avcap->conf.video.format));\n    fp = file_open(OUTPUT_V4L2, F_CREATE);\n    avcap_start_stream(avcap, on_frame);\n    sleep(5);\n    avcap_stop_stream(avcap);\n    file_close(fp);\n    video_frame_destroy(frm);\n    avcap_close(avcap);\n    printf(""write %s fininshed!\\n"", OUTPUT_V4L2);\n    printf(""======== v4l2_test leave\\n"");\n#endif\n    return 0;\n}\n//...'"
"('Please write a prompt asking for a code snippet that compares the power spectral density (PSD) values generated with a waterfall object in C language. The scenario involves a function that compares two values for sorting purposes, another function that generates noise with specified parameters, creates a waterfall object, pushes samples into it, and then calculates the median PSD value after sorting the PSD values. The code snippet should also include error checking and verbose output for testing purposes.","//...\nint testbench_spwaterfallcf_compare(const void * _v0, const void * _v1)\n    { return *(float*)_v0 > *(float*)_v1 ? 1 : -1; }\nvoid testbench_spwaterfallcf_noise(unsigned int _nfft,\n                                   unsigned int _window_len,\n                                   unsigned int _delay,\n                                   unsigned int _time,\n                                   float        _noise_floor)\n{\n    unsigned int num_samples = 4*_nfft*_time;  \n    float        nstd        = powf(10.0f,_noise_floor/20.0f); \n    float        tol         = 4.0f; \n    int _wtype = LIQUID_WINDOW_HAMMING;\n    spwaterfallcf q = spwaterfallcf_create(_nfft, _wtype, _window_len, _delay, _time);\n    unsigned int i;\n    for (i=0; i<num_samples; i++)\n        spwaterfallcf_push(q, nstd*( randnf() + _Complex_I*randnf() ) * M_SQRT1_2);\n    CONTEND_EQUALITY(spwaterfallcf_get_num_samples_total(q), num_samples);\n    const float * psd = spwaterfallcf_get_psd(q);\n    unsigned int time = spwaterfallcf_get_num_time(q);\n#if 0\n    FILE * fid = fopen(""spwaterfallcf_testbench.m"", ""w"");\n    fprintf(fid,""clear all; close all; psd=zeros(%u,%u);\\n"", _nfft, time);\n    for (i=0; i<_nfft*time; i++)\n        fprintf(fid,""psd(%u) = %g;\\n"", i+1, psd[i]);\n    fclose(fid);\n#endif\n    float * v = (float*) malloc(_nfft*time*sizeof(float));\n    memmove(v, psd, _nfft*time*sizeof(float));\n    qsort(v, _nfft*time, sizeof(float), &testbench_spwaterfallcf_compare);\n    float median = v[_nfft*time/2];\n    if (liquid_autotest_verbose) {\n        printf(""  spwaterfallcf_test(noise): nfft:%4u, wtype:%s, n0:%6.1f, est:%6.1f, tol:%5.2f\\n"",\n                _nfft, liquid_window_str[_wtype][1], _noise_floor, median, tol);\n    }\n    CONTEND_DELTA(median, _noise_floor, tol)\n    free(v);\n    spwaterfallcf_destroy(q);\n}\n//...')
"
"'Prompt: You are working on a project where you need to ensure consistent file size handling across different platforms. Additionally, you need to ensure that the time_t data type is consistent across your codebase. Please provide a code snippet that includes the following directives:. . ```. #undef _USE_32BIT_TIME_T. #define _FILE_OFFSET_BITS 32. ```",#undef _USE_32BIT_TIME_T\n#define _FILE_OFFSET_BITS 32'
"('Please provide the prompt for which you would like the following C code as a response:. . This code includes functions related to a genetic algorithm search for optimizing a peak. The `gasearch_autotest_peak_callback` function calculates the utility of a chromosome based on its traits and is used as the fitness function for the genetic algorithm. The `autotest_gasearch_peak` function sets up and runs the genetic algorithm search to find the optimal solution. The `autotest_chromosome_config` and `autotest_gasearch_config` functions test various configurations and functionalities of the chromosome and genetic algorithm search. . . ```C. float gasearch_autotest_peak_callback(void * _userdata, chromosome _c). {.     // Function code. }. . void autotest_gasearch_peak(). {.     // Function code. }. . void autotest_chromosome_config(). {.     // Function code. }. . void autotest_gasearch_config(). {.     // Function code. }. ","float gasearch_autotest_peak_callback(void * _userdata, chromosome _c)\n{\n    unsigned int i, n = chromosome_get_num_traits(_c);\n    float u     = 1.0f;\n    float sig   = 0.2f;\n    float p     = M_SQRT1_2;\n    for (i=0; i<n; i++) {\n        float v = chromosome_valuef(_c,i);\n        float e = v - p;\n        u *= exp(-e*e/(2*sig*sig));\n    }\n    return u;\n}\nvoid autotest_gasearch_peak()\n{\n    unsigned int num_parameters     = 16;   \n    unsigned int bits_per_parameter =  6;   \n    unsigned int num_iterations     = 8000; \n    unsigned int population_size    = 16;   \n    float        mutation_rate      = 0.2f; \n    float        tol                = 0.1f; \n    unsigned int i;\n    float optimum_utility;\n    chromosome prototype = chromosome_create_basic(num_parameters, bits_per_parameter);\n    gasearch ga = gasearch_create_advanced(gasearch_autotest_peak_callback, NULL, prototype,\n                    LIQUID_OPTIM_MAXIMIZE, population_size, mutation_rate);\n    optimum_utility = gasearch_run(ga, num_iterations, 1e6f);\n    gasearch_getopt(ga, prototype, &optimum_utility);\n    float v_opt[num_parameters];\n    for (i=0; i<num_parameters; i++)\n        v_opt[i] = chromosome_valuef(prototype, i);\n    if (liquid_autotest_verbose) {\n        gasearch_print(ga);\n        printf("" opt: [  %6.4f] "", optimum_utility);\n        chromosome_printf(prototype);\n    }\n    chromosome_destroy(prototype);\n    gasearch_destroy(ga);\n    for (i=0; i<num_parameters; i++)\n        CONTEND_DELTA(v_opt[i], M_SQRT1_2, tol)\n    CONTEND_GREATER_THAN( optimum_utility, 0.70f )\n}\nvoid autotest_chromosome_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping chromosome config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    unsigned int bits_per_trait_invalid[8] = {6,6,6,6,6,6,6,1000};\n    unsigned int bits_per_trait_valid  [8] = {6,6,6,6,6,6,6,  32};\n    CONTEND_ISNULL(chromosome_create(bits_per_trait_invalid, 8))\n    CONTEND_ISNULL(chromosome_create(bits_per_trait_valid,   0))\n    CONTEND_ISNULL(chromosome_create_basic(0, 12)) \n    CONTEND_ISNULL(chromosome_create_basic(8,  0)) \n    CONTEND_ISNULL(chromosome_create_basic(8, 99)) \n    chromosome prototype = chromosome_create_basic(20, 5);\n    CONTEND_EQUALITY(LIQUID_OK, chromosome_print(prototype))\n    chromosome_destroy(prototype);\n    prototype = chromosome_create(bits_per_trait_valid, 8);\n    CONTEND_EQUALITY  (LIQUID_OK, chromosome_print    (prototype))\n    CONTEND_EQUALITY  (LIQUID_OK, chromosome_reset    (prototype))\n    unsigned int values_invalid[] = {999,12,11,13,63,17, 3,123456789}; \n    unsigned int values_valid  [] = {  0,12,11,13,63,17, 3,123456789};\n    CONTEND_INEQUALITY(LIQUID_OK, chromosome_init (prototype, values_invalid))\n    CONTEND_EQUALITY  (LIQUID_OK, chromosome_init (prototype, values_valid  ))\n    CONTEND_EQUALITY  (        0, chromosome_value    (prototype,999))\n    CONTEND_EQUALITY  (     0.0f, chromosome_valuef   (prototype,999))\n    CONTEND_INEQUALITY(LIQUID_OK, chromosome_mutate   (prototype,999))\n    CONTEND_INEQUALITY(LIQUID_OK, chromosome_crossover(prototype,prototype,prototype,999))\n    CONTEND_EQUALITY( chromosome_value(prototype, 0),         0)\n    CONTEND_EQUALITY( chromosome_value(prototype, 1),        12)\n    CONTEND_EQUALITY( chromosome_value(prototype, 2),        11)\n    CONTEND_EQUALITY( chromosome_value(prototype, 3),        13)\n    CONTEND_EQUALITY( chromosome_value(prototype, 4),        63)\n    CONTEND_EQUALITY( chromosome_value(prototype, 5),        17)\n    CONTEND_EQUALITY( chromosome_value(prototype, 6),         3)\n    CONTEND_EQUALITY( chromosome_value(prototype, 7), 123456789)\n    float valuesf_invalid[] = {0.0,0.1,0.2,0.3,0.4,0.5,0.6,999,};\n    float valuesf_valid  [] = {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,};\n    CONTEND_INEQUALITY(LIQUID_OK, chromosome_initf(prototype, valuesf_invalid))\n    CONTEND_EQUALITY  (LIQUID_OK, chromosome_initf(prototype, valuesf_valid  ))\n    CONTEND_DELTA( chromosome_valuef(prototype, 0), 0.0f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 1), 0.1f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 2), 0.2f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 3), 0.3f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 4), 0.4f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 5), 0.5f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 6), 0.6f, 0.02f )\n    CONTEND_DELTA( chromosome_valuef(prototype, 7), 0.7f, 0.02f )\n    chromosome_destroy(prototype);\n}\nvoid autotest_gasearch_config()\n{\n#if LIQUID_STRICT_EXIT\n    AUTOTEST_WARN(""skipping gasearch config test with strict exit enabled\\n"");\n    return;\n#endif\n#if !LIQUID_SUPPRESS_ERROR_OUTPUT\n    fprintf(stderr,""warning: ignore potential errors here; checking for invalid configurations\\n"");\n#endif\n    chromosome prototype = chromosome_create_basic(8, 12);\n    CONTEND_ISNULL(gasearch_create_advanced(                           NULL, NULL, prototype, LIQUID_OPTIM_MAXIMIZE, 16, 0.1f)) \n    CONTEND_ISNULL(gasearch_create_advanced(gasearch_autotest_peak_callback, NULL,      NULL, LIQUID_OPTIM_MAXIMIZE,  0, 0.1f)) \n    CONTEND_ISNULL(gasearch_create_advanced(gasearch_autotest_peak_callback, NULL, prototype, LIQUID_OPTIM_MAXIMIZE,  0, 0.1f)) \n    CONTEND_ISNULL(gasearch_create_advanced(gasearch_autotest_peak_callback, NULL, prototype, LIQUID_OPTIM_MAXIMIZE, -1, 0.1f)) \n    CONTEND_ISNULL(gasearch_create_advanced(gasearch_autotest_peak_callback, NULL, prototype, LIQUID_OPTIM_MAXIMIZE, 16,-1.0f)) \n    gasearch ga = gasearch_create(gasearch_autotest_peak_callback, NULL, prototype, LIQUID_OPTIM_MAXIMIZE);\n    CONTEND_EQUALITY(LIQUID_OK, gasearch_print(ga))\n    CONTEND_INEQUALITY(LIQUID_OK, gasearch_set_population_size(ga, 0, 8)) \n    CONTEND_INEQUALITY(LIQUID_OK, gasearch_set_population_size(ga,-1, 8)) \n    CONTEND_INEQUALITY(LIQUID_OK, gasearch_set_population_size(ga,24, 0)) \n    CONTEND_INEQUALITY(LIQUID_OK, gasearch_set_population_size(ga,24,24)) \n    CONTEND_EQUALITY  (LIQUID_OK, gasearch_set_population_size(ga,24,12)) \n    CONTEND_INEQUALITY(LIQUID_OK, gasearch_set_mutation_rate  (ga,-1.0f)) \n    CONTEND_INEQUALITY(LIQUID_OK, gasearch_set_mutation_rate  (ga, 2.0f)) \n    CONTEND_EQUALITY  (LIQUID_OK, gasearch_set_mutation_rate  (ga, 0.1f)) \n    chromosome_destroy(prototype);\n    gasearch_destroy(ga);\n}')
"
"('Prompt: Develop a function `sumsqcf_runtest` that runs a test on a custom function `liquid_sumsqcf` which takes in an array of complex numbers `_x`, length `_n`, and a float `_y`. The `sumsqcf_runtest` function should calculate the sum of squares of the complex numbers in the array using `liquid_sumsqcf` and compare the result with the given `_y` value with a tolerance of 1e-6 using the `CONTEND_DELTA` macro.","//...\nvoid sumsqcf_runtest(float complex * _x,\n                     unsigned int    _n,\n                     float           _y)\n{\n    float tol = 1e-6;   \n    float y = liquid_sumsqcf(_x, _n);\n    CONTEND_DELTA( y, _y, tol );\n}\n//...')
"
"('Prompt: . You want to verify the functionality of a frequency mixer block in a software-defined radio application. To achieve this, you need to write a testbench function that generates random complex data, mixes it using the frequency mixer block, and compares the output with the expected signal after phase adjustment. Additionally, you want to ensure that the mixer works correctly for a specific VCO type with a given phase and frequency. Write a testbench function using Liquid DSP library functions to perform these validations.","//...\nvoid testbench_nco_crcf_mix(int   _type,\n                            float _phase,\n                            float _frequency)\n{\n    unsigned int buf_len = 1200;\n    float        tol     = 1e-2f;\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase    (nco, _phase);\n    nco_crcf_set_frequency(nco, _frequency);\n    float complex buf_0[buf_len];\n    float complex buf_1[buf_len];\n    unsigned int i;\n    for (i=0; i<buf_len; i++)\n        buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());\n    nco_crcf_mix_block_up(nco, buf_0, buf_1, buf_len);\n    float theta = _phase;\n    for (i=0; i<buf_len; i++) {\n        float complex v = buf_0[i] * cexpf(_Complex_I*theta);\n        CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);\n        CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);\n        theta += _frequency;\n        while (theta >  M_PI) { theta -= 2*M_PI; }\n        while (theta < -M_PI) { theta += 2*M_PI; }\n    }\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_mix_vco_6() { testbench_nco_crcf_mix(LIQUID_VCO,  0.000f,   -M_PI); }\n//...')
"
"('Prompt: Create a frame generator for a digital communication system that uses 64 chips per frame. Include features such as error correction coding, modulation scheme, and pilot generation. Ensure to initialize all necessary parameters and structures for the frame generator to function properly.","//...\nstruct framegen64_s {\n    qpacketmodem    enc;                \n    qpilotgen       pilotgen;           \n    float complex   pn_sequence[64];    \n    unsigned char   payload_dec[150];   \n    float complex   payload_sym[600];   \n    float complex   payload_tx[630];    \n    unsigned int    m;                  \n    float           beta;               \n    firinterp_crcf  interp;             \n};\nframegen64 framegen64_create()\n{\n    framegen64 q = (framegen64) malloc(sizeof(struct framegen64_s));\n    q->m    = 7;\n    q->beta = 0.3f;\n    unsigned int i;\n    msequence ms = msequence_create(7, 0x0089, 1);\n    for (i=0; i<64; i++) {\n        q->pn_sequence[i]  = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);\n        q->pn_sequence[i] += (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2)*_Complex_I;\n    }\n    msequence_destroy(ms);\n    int check      = LIQUID_CRC_24;\n    int fec0       = LIQUID_FEC_NONE;\n    int fec1       = LIQUID_FEC_GOLAY2412;\n    int mod_scheme = LIQUID_MODEM_QPSK;\n    q->enc         = qpacketmodem_create();\n    qpacketmodem_configure(q->enc, 72, check, fec0, fec1, mod_scheme);\n    assert( qpacketmodem_get_frame_len(q->enc)==600 );\n    q->pilotgen = qpilotgen_create(600, 21);\n    assert( qpilotgen_get_frame_len(q->pilotgen)==630 );\n    q->interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,2,q->m,q->beta,0);\n    return q;\n}\n//...')
"
"('Prompt: You are testing a numerical-controlled oscillator (NCO) phase in a software framework. Write a code snippet that creates an NCO oscillator, sets its phase, calculates the cosine and sine values, and performs assertions based on expected values with a given tolerance during an auto test run.. . Code Response:. ```c. void nco_crcf_phase_test(float _theta,.                          float _cos,.                          float _sin,.                          int   _type,.                          float _tol). {.     nco_crcf nco = nco_crcf_create(_type);.     nco_crcf_set_phase(nco, _theta);.     float c = nco_crcf_cos(nco);.     float s = nco_crcf_sin(nco);.     if (liquid_autotest_verbose) {.         printf(""cos(%8.5f) = %8.5f (%8.5f) e:%8.5f, sin(%8.5f) = %8.","//...\nvoid nco_crcf_phase_test(float _theta,\n                         float _cos,\n                         float _sin,\n                         int   _type,\n                         float _tol)\n{\n    nco_crcf nco = nco_crcf_create(_type);\n    nco_crcf_set_phase(nco, _theta);\n    float c = nco_crcf_cos(nco);\n    float s = nco_crcf_sin(nco);\n    if (liquid_autotest_verbose) {\n        printf(""cos(%8.5f) = %8.5f (%8.5f) e:%8.5f, sin(%8.5f) = %8.5f (%8.5f) e:%8.5f\\n"",\n                _theta, _cos, c, _cos-c, _theta, _sin, s, _sin-s);\n    }\n    CONTEND_DELTA( c, _cos, _tol );\n    CONTEND_DELTA( s, _sin, _tol );\n    nco_crcf_destroy(nco);\n}\nvoid autotest_nco_crcf_phase()\n{\n    float tol = 0.02f;\n    nco_crcf_phase_test(-6.283185307f,  1.000000000f,  0.000000000f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-6.195739393f,  0.996179042f,  0.087334510f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-5.951041106f,  0.945345356f,  0.326070787f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-5.131745978f,  0.407173250f,  0.913350943f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-4.748043551f,  0.035647016f,  0.999364443f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-3.041191113f, -0.994963998f, -0.100232943f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-1.947799864f, -0.368136099f, -0.929771914f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-1.143752030f,  0.414182352f, -0.910193924f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-1.029377689f,  0.515352252f, -0.856978446f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-0.174356887f,  0.984838307f, -0.173474811f, LIQUID_NCO, tol);\n    nco_crcf_phase_test(-0.114520496f,  0.993449692f, -0.114270338f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 0.000000000f,  1.000000000f,  0.000000000f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 1.436080000f,  0.134309213f,  0.990939471f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 2.016119855f, -0.430749878f,  0.902471353f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 2.996498473f, -0.989492293f,  0.144585621f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 3.403689755f, -0.965848729f, -0.259106603f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 3.591162483f, -0.900634128f, -0.434578148f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 5.111428476f,  0.388533479f, -0.921434607f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 5.727585681f,  0.849584319f, -0.527452828f, LIQUID_NCO, tol);\n    nco_crcf_phase_test( 6.283185307f,  1.000000000f, -0.000000000f, LIQUID_NCO, tol);\n}\n//...')
"
"('Prompt: You are conducting testing for an FSK modem system that involves modulation and demodulation processes. The function you need to implement should take in the modulation index `_m`, the symbol expansion factor `_k`, and the bandwidth. The function should set up the FSK modem, modulate and demodulate signals, and test for equality between the input and output symbols. Additionally, there is an existing autotest function `autotest_fskmodem_norm_M8` that tests the FSK modem with specific parameters. Your task is to write the code for the `fskmodem_test_mod_demod` function to handle these testing scenarios.","//...\nvoid fskmodem_test_mod_demod(unsigned int _m,\n                             unsigned int _k,\n                             float        _bandwidth)\n{\n    if (liquid_autotest_verbose)\n        printf(""fskmodem_test_mod_demod(m=%u, k=%u, bandwidth=%g)\\n"", _m, _k, _bandwidth);\n    fskmod mod = fskmod_create(_m,_k,_bandwidth);\n    fskdem dem = fskdem_create(_m,_k,_bandwidth);\n    unsigned int M = 1 << _m;   \n    float complex buf[_k];      \n    unsigned int i;\n    for (i=0; i<M; i++) {\n        unsigned int sym_in = i;\n        fskmod_modulate(mod, sym_in, buf);\n        unsigned int sym_out = fskdem_demodulate(dem, buf);\n        CONTEND_EQUALITY(sym_in, sym_out);\n    }\n    fskmod_destroy(mod);\n    fskdem_destroy(dem);\n}\nvoid autotest_fskmodem_norm_M8()    { fskmodem_test_mod_demod( 3,   16, 0.25f    ); }\n//...')
"
"('Prompt: Calculate the output of the FFT-filter using the provided data. The input data consists of arrays for impulse response (h) and data to be filtered (x), and the output data array (y). The arrays are in complex form. . . Response:. float complex fftfilt_cccf_data_h4x256_h[] = { -0.135231339931 +   0.062977480888*_Complex_I, -0.157240438461 + 0.037726294994*_Complex_I, 0.169742667675 + -0.043306457996*_Complex_I, -0.001679791883 + -0.031882059574*_Complex_I};. . float complex fftfilt_cccf_data_h4x256_x[] = { -0.145331311226 + 0.109500586987*_Complex_I, 0.008576134592 + -0.169542956352*_Complex_I, ...}; . . ","float complex fftfilt_cccf_data_h4x256_h[] = {\n   -0.135231339931 +   0.062977480888*_Complex_I,\n   -0.157240438461 +   0.037726294994*_Complex_I,\n    0.169742667675 +  -0.043306457996*_Complex_I,\n   -0.001679791883 +  -0.031882059574*_Complex_I};\nfloat complex fftfilt_cccf_data_h4x256_x[] = {\n   -0.145331311226 +   0.109500586987*_Complex_I,\n    0.008576134592 +  -0.169542956352*_Complex_I,\n    0.047844916582 +   0.149058306217*_Complex_I,\n    0.177120888233 +   0.170329642296*_Complex_I,\n   -0.004175573960 +   0.072688925266*_Complex_I,\n   -0.027152365446 +   0.035960051417*_Complex_I,\n    0.094344460964 +  -0.033645594120*_Complex_I,\n   -0.010391099006 +  -0.035192406178*_Complex_I,\n   -0.180138766766 +  -0.031795871258*_Complex_I,\n   -0.203700375557 +  -0.138529646397*_Complex_I,\n   -0.019561575353 +  -0.144657015800*_Complex_I,\n   -0.118808639050 +  -0.027752715349*_Complex_I,\n    0.056749093533 +  -0.025054290891*_Complex_I,\n    0.116542947292 +  -0.007720955461*_Complex_I,\n   -0.074969446659 +   0.100591087341*_Complex_I,\n    0.001408090629 +  -0.042336615920*_Complex_I,\n    0.240100383759 +  -0.161245095730*_Complex_I,\n   -0.085952699184 +   0.084794622660*_Complex_I,\n   -0.015006904304 +   0.035609281063*_Complex_I,\n    0.000034478516 +  -0.187320244312*_Complex_I,\n    0.052339464426 +  -0.004798505455*_Complex_I,\n    0.093824869394 +  -0.070545089245*_Complex_I,\n    0.149086785316 +   0.108725130558*_Complex_I,\n   -0.156761336327 +   0.005509132892*_Complex_I,\n   -0.125493848324 +  -0.043598395586*_Complex_I,\n   -0.121326863766 +   0.007096276432*_Complex_I,\n    0.003544984013 +   0.166835379601*_Complex_I,\n   -0.037431293726 +  -0.020329789817*_Complex_I,\n   -0.085911118984 +  -0.079901820421*_Complex_I,\n    0.122742509842 +   0.014822798967*_Complex_I,\n    0.110778486729 +  -0.071227872372*_Complex_I,\n   -0.007605559379 +  -0.128052246571*_Complex_I,\n   -0.066244971752 +  -0.047825807333*_Complex_I,\n   -0.030502566695 +  -0.254250669479*_Complex_I,\n    0.157666409016 +  -0.093531721830*_Complex_I,\n    0.043991112709 +   0.067102664709*_Complex_I,\n   -0.063667005301 +   0.055537760258*_Complex_I,\n    0.035860368609 +  -0.217314362526*_Complex_I,\n   -0.154697167873 +  -0.051928877831*_Complex_I,\n   -0.154008638859 +   0.137628376484*_Complex_I,\n   -0.021988071501 +  -0.136372375488*_Complex_I,\n    0.118345403671 +  -0.299838876724*_Complex_I,\n    0.066200459003 +   0.107628118992*_Complex_I,\n   -0.022814218700 +   0.042800396681*_Complex_I,\n    0.039931696653 +   0.066364485025*_Complex_I,\n   -0.038531854749 +  -0.120103299618*_Complex_I,\n    0.017913374305 +   0.016456928849*_Complex_I,\n    0.001270754635 +   0.030759117007*_Complex_I,\n    0.235941290855 +   0.024339741468*_Complex_I,\n    0.074259299040 +   0.054985857010*_Complex_I,\n   -0.117393791676 +  -0.024225908518*_Complex_I,\n    0.195164024830 +  -0.100901556015*_Complex_I,\n   -0.074234390259 +  -0.041768211126*_Complex_I,\n    0.042385265231 +  -0.228795623779*_Complex_I,\n   -0.089356112480 +   0.027445358038*_Complex_I,\n   -0.273647761345 +  -0.094072991610*_Complex_I,\n    0.067754048109 +  -0.066324621439*_Complex_I,\n   -0.071163922548 +   0.011088901013*_Complex_I,\n    0.002260415070 +  -0.033153522015*_Complex_I,\n   -0.163043868542 +   0.147372353077*_Complex_I,\n    0.130338788033 +   0.113823711872*_Complex_I,\n   -0.018929108977 +  -0.134858226776*_Complex_I,\n    0.005879180133 +   0.110552978516*_Complex_I,\n   -0.177987158298 +  -0.145397603512*_Complex_I,\n    0.112013733387 +  -0.243533611298*_Complex_I,\n   -0.065134996176 +  -0.161895787716*_Complex_I,\n   -0.100013601780 +  -0.185575771332*_Complex_I,\n   -0.039732664824 +  -0.033335423470*_Complex_I,\n   -0.004159386829 +  -0.118040883541*_Complex_I,\n    0.101805281639 +   0.084620487690*_Complex_I,\n   -0.150429344177 +  -0.084105199575*_Complex_I,\n    0.062221693993 +   0.047454631329*_Complex_I,\n    0.138085842133 +  -0.076058888435*_Complex_I,\n    0.254889655113 +  -0.163386595249*_Complex_I,\n   -0.025463542342 +  -0.060935062170*_Complex_I,\n    0.061728596687 +  -0.006239769980*_Complex_I,\n   -0.083425503969 +   0.069602411985*_Complex_I,\n    0.039149901271 +  -0.118299651146*_Complex_I,\n    0.103384292126 +  -0.022438082099*_Complex_I,\n   -0.008195941895 +   0.049835348129*_Complex_I,\n   -0.049642279744 +  -0.038572207093*_Complex_I,\n    0.112285923958 +   0.046880367398*_Complex_I,\n   -0.052668154240 +   0.054064834118*_Complex_I,\n   -0.009626910090 +  -0.040556022525*_Complex_I,\n    0.002097596042 +  -0.216656374931*_Complex_I,\n    0.057758331299 +  -0.002327759005*_Complex_I,\n   -0.008833542466 +  -0.014824745059*_Complex_I,\n    0.040581482649 +   0.045436677337*_Complex_I,\n    0.194773435593 +   0.044354414940*_Complex_I,\n   -0.028676524758 +  -0.018726617098*_Complex_I,\n   -0.019215075672 +  -0.038972333074*_Complex_I,\n    0.200048685074 +   0.008784489334*_Complex_I,\n   -0.116677081585 +  -0.295071172714*_Complex_I,\n   -0.077746075392 +  -0.031134122610*_Complex_I,\n    0.078498488665 +   0.007961921394*_Complex_I,\n   -0.081279265881 +   0.114860057831*_Complex_I,\n   -0.014656324685 +  -0.145551848412*_Complex_I,\n    0.129554140568 +   0.086291736364*_Complex_I,\n    0.123636543751 +  -0.061629927158*_Complex_I,\n    0.040432214737 +   0.095078992844*_Complex_I,\n    0.021615064144 +   0.087291020155*_Complex_I,\n   -0.036054989696 +   0.058331966400*_Complex_I,\n    0.031770968437 +   0.150715994835*_Complex_I,\n    0.036789077520 +   0.006291696429*_Complex_I,\n    0.207829833031 +  -0.195549118519*_Complex_I,\n   -0.069425356388 +   0.034547394514*_Complex_I,\n    0.121964550018 +  -0.175282227993*_Complex_I,\n   -0.076088452339 +   0.189335298538*_Complex_I,\n   -0.238275814056 +   0.164852106571*_Complex_I,\n   -0.105275332928 +   0.048049694300*_Complex_I,\n    0.025219294429 +   0.148977017403*_Complex_I,\n   -0.116340065002 +   0.047728052735*_Complex_I,\n   -0.001223530248 +   0.002220938914*_Complex_I,\n   -0.095514726639 +   0.177518546581*_Complex_I,\n   -0.024929241836 +   0.051844847202*_Complex_I,\n    0.003478102759 +  -0.047746166587*_Complex_I,\n   -0.179150342941 +  -0.217488384247*_Complex_I,\n   -0.004914051294 +  -0.154762375355*_Complex_I,\n    0.097842323780 +  -0.024203261733*_Complex_I,\n   -0.103857576847 +  -0.032823368907*_Complex_I,\n   -0.092790353298 +   0.061397796869*_Complex_I,\n    0.047670701146 +   0.110239303112*_Complex_I,\n    0.073129659891 +   0.008005330712*_Complex_I,\n    0.215736103058 +  -0.160301959515*_Complex_I,\n    0.012318083644 +   0.165701925755*_Complex_I,\n   -0.092335480452 +   0.060041588545*_Complex_I,\n    0.057762295008 +   0.212985706329*_Complex_I,\n   -0.116756439209 +   0.080165004730*_Complex_I,\n   -0.016070105135 +   0.102566015720*_Complex_I,\n   -0.031425985694 +   0.048826861382*_Complex_I,\n   -0.138180553913 +  -0.015630686283*_Complex_I,\n   -0.040541607141 +   0.086674833298*_Complex_I,\n   -0.017452953756 +  -0.181320679188*_Complex_I,\n    0.011673089117 +   0.072657525539*_Complex_I,\n   -0.015449254215 +   0.112104630470*_Complex_I,\n    0.071193879843 +  -0.032887244225*_Complex_I,\n    0.016030588746 +  -0.007359164953*_Complex_I,\n    0.007357457280 +   0.054825830460*_Complex_I,\n   -0.068202400208 +  -0.091296017170*_Complex_I,\n    0.030967503786 +  -0.193203377724*_Complex_I,\n    0.036832565069 +  -0.081849122047*_Complex_I,\n   -0.046027070284 +  -0.027470356226*_Complex_I,\n   -0.125437974930 +   0.032441046834*_Complex_I,\n    0.011070625484 +  -0.092022657394*_Complex_I,\n    0.137458860874 +   0.151134181023*_Complex_I,\n   -0.117661428452 +  -0.008656930178*_Complex_I,\n    0.163053572178 +  -0.070776551962*_Complex_I,\n   -0.119681096077 +  -0.012249100208*_Complex_I,\n    0.127253675461 +   0.107909095287*_Complex_I,\n   -0.051333457232 +  -0.116273534298*_Complex_I,\n   -0.071138489246 +   0.072735458612*_Complex_I,\n    0.037040272355 +  -0.050955241919*_Complex_I,\n   -0.200804090500 +  -0.217231678963*_Complex_I,\n   -0.109212982655 +   0.012372082472*_Complex_I,\n   -0.029450660944 +   0.118574059010*_Complex_I,\n    0.099285334349 +  -0.000237483322*_Complex_I,\n    0.276025676727 +  -0.017251548171*_Complex_I,\n    0.088983309269 +   0.013136875629*_Complex_I,\n    0.163659727573 +  -0.066418147087*_Complex_I,\n    0.104050731659 +   0.028489127755*_Complex_I,\n    0.016449892521 +  -0.020746667683*_Complex_I,\n   -0.126559376717 +  -0.070659190416*_Complex_I,\n   -0.237141442299 +   0.089611142874*_Complex_I,\n    0.068004012108 +   0.173722803593*_Complex_I,\n   -0.047145104408 +  -0.175941777229*_Complex_I,\n   -0.123525714874 +  -0.166570901871*_Complex_I,\n    0.001423638687 +   0.157464015484*_Complex_I,\n    0.079405152798 +  -0.025422385335*_Complex_I,\n    0.081756842136 +   0.121069538593*_Complex_I,\n   -0.128136157990 +   0.139459896088*_Complex_I,\n    0.007735489309 +  -0.027935725451*_Complex_I,\n   -0.092589050531 +  -0.109762561321*_Complex_I,\n   -0.016260780394 +  -0.015316626430*_Complex_I,\n   -0.158776199818 +   0.127178168297*_Complex_I,\n   -0.026575049758 +   0.238629913330*_Complex_I,\n    0.152634930611 +  -0.165786969662*_Complex_I,\n    0.108250701427 +  -0.051711326838*_Complex_I,\n    0.076149952412 +  -0.090032291412*_Complex_I,\n    0.074367189407 +  -0.029565215111*_Complex_I,\n    0.061409753561 +  -0.112582445145*_Complex_I,\n   -0.097367572784 +  -0.113927245140*_Complex_I,\n    0.026321750879 +   0.138302946091*_Complex_I,\n   -0.001476241183 +  -0.069936299324*_Complex_I,\n   -0.114703190327 +   0.070511698723*_Complex_I,\n   -0.006401912868 +  -0.010170778632*_Complex_I,\n    0.082021260262 +  -0.036617666483*_Complex_I,\n    0.381905221939 +   0.054933649302*_Complex_I,\n   -0.047172623873 +  -0.016221418977*_Complex_I,\n    0.075080448389 +   0.044649630785*_Complex_I,\n    0.006743746251 +  -0.057219368219*_Complex_I,\n    0.072658914328 +  -0.113842511177*_Complex_I,\n    0.063461345434 +   0.108319532871*_Complex_I,\n   -0.085157209635 +   0.127499580383*_Complex_I,\n   -0.110658645630 +   0.026664611697*_Complex_I,\n    0.087542557716 +  -0.198326361179*_Complex_I,\n   -0.187630629539 +  -0.076032394171*_Complex_I,\n    0.158300364017 +  -0.183700358868*_Complex_I,\n   -0.117931878567 +  -0.157972729206*_Complex_I,\n    0.048598474264 +  -0.121435344219*_Complex_I,\n    0.090523117781 +  -0.092027544975*_Complex_I,\n   -0.126598548889 +  -0.115896356106*_Complex_I,\n   -0.050347799063 +   0.063965880871*_Complex_I,\n    0.009061803669 +  -0.003273813799*_Complex_I,\n   -0.138404893875 +  -0.058004939556*_Complex_I,\n   -0.027039816976 +   0.123541855812*_Complex_I,\n   -0.260724592209 +   0.070059484243*_Complex_I,\n   -0.071726894379 +   0.118393385410*_Complex_I,\n   -0.103354132175 +  -0.048656904697*_Complex_I,\n   -0.079942697287 +  -0.007439111173*_Complex_I,\n    0.010002358258 +   0.217011165619*_Complex_I,\n   -0.107096755505 +  -0.032441377640*_Complex_I,\n   -0.038857096434 +  -0.075556772947*_Complex_I,\n    0.103407859802 +  -0.010233432055*_Complex_I,\n   -0.017742788792 +  -0.016240037978*_Complex_I,\n   -0.061273831129 +   0.003164015338*_Complex_I,\n   -0.120957195759 +   0.053525984287*_Complex_I,\n   -0.102713096142 +  -0.067174482346*_Complex_I,\n    0.033584815264 +   0.006909974664*_Complex_I,\n   -0.067435938120 +  -0.001113843173*_Complex_I,\n    0.151518130302 +  -0.022716298699*_Complex_I,\n   -0.092082822323 +  -0.080135297775*_Complex_I,\n    0.027139824629 +   0.071895372868*_Complex_I,\n   -0.115053045750 +   0.071924138069*_Complex_I,\n    0.011123746634 +  -0.015718665719*_Complex_I,\n    0.101550316811 +   0.003213942051*_Complex_I,\n    0.087435191870 +  -0.074827837944*_Complex_I,\n    0.098427033424 +   0.153796470165*_Complex_I,\n   -0.030665528774 +   0.086529731750*_Complex_I,\n   -0.015693670511 +  -0.002731614932*_Complex_I,\n    0.133912920952 +   0.264183211327*_Complex_I,\n   -0.000968740415 +   0.156215214729*_Complex_I,\n   -0.018345800042 +  -0.029062193632*_Complex_I,\n   -0.049218568206 +  -0.058449655771*_Complex_I,\n    0.045136275887 +   0.035753569007*_Complex_I,\n    0.011435703933 +   0.002002427541*_Complex_I,\n    0.021104848385 +  -0.311103820801*_Complex_I,\n    0.005841723830 +  -0.030350989103*_Complex_I,\n   -0.064211606979 +   0.203191661835*_Complex_I,\n   -0.071606880426 +   0.014993095398*_Complex_I,\n    0.072429609299 +   0.168000137806*_Complex_I,\n   -0.038637900352 +  -0.050586193800*_Complex_I,\n    0.168560516834 +   0.112749493122*_Complex_I,\n    0.140708494186 +  -0.139942800999*_Complex_I,\n    0.044472098351 +   0.057332044840*_Complex_I,\n   -0.113584566116 +   0.036734291911*_Complex_I,\n   -0.115594518185 +   0.096241426468*_Complex_I,\n   -0.132571578026 +   0.076662874222*_Complex_I,\n   -0.088810175657 +   0.180961203575*_Complex_I,\n   -0.134494102001 +   0.108674275875*_Complex_I,\n   -0.066532063484 +   0.080732357502*_Complex_I,\n   -0.001597549021 +   0.199119567871*_Complex_I,\n   -0.171998977661 +   0.006639727950*_Complex_I,\n    0.157607150078 +  -0.054489070177*_Complex_I,\n   -0.109499049187 +  -0.023027896881*_Complex_I,\n   -0.172086226940 +   0.121059966087*_Complex_I,\n    0.119662201405 +  -0.004805976152*_Complex_I};\nfloat complex fftfilt_cccf_data_h4x256_y[] = {\n    0.012757276827 +  -0.023960510977*_Complex_I,\n    0.028238533774 +   0.000766892287*_Complex_I,\n   -0.030736578281 +   0.034719058493*_Complex_I,\n   -0.049977138490 +  -0.058212812777*_Complex_I,\n   -0.029132843102 +  -0.006952447936*_Complex_I,\n    0.041434724419 +   0.001305867219*_Complex_I,\n   -0.000154542372 +   0.010398927205*_Complex_I,\n   -0.010671035217 +   0.020245277403*_Complex_I,\n    0.045073710539 +  -0.010894785162*_Complex_I,\n    0.061276520757 +  -0.004366387666*_Complex_I,\n    0.015952866275 +   0.035222286704*_Complex_I,\n   -0.014939304199 +   0.009382470283*_Complex_I,\n   -0.000027323374 +  -0.010136557087*_Complex_I,\n   -0.049199930734 +   0.015765195506*_Complex_I,\n   -0.006368245652 +  -0.015589575903*_Complex_I,\n    0.029022969544 +  -0.020956220654*_Complex_I,\n   -0.029749689836 +   0.060255058887*_Complex_I,\n   -0.023648414328 +   0.012506271275*_Complex_I,\n    0.042523255991 +  -0.060078254361*_Complex_I,\n   -0.003653249612 +   0.029899901014*_Complex_I,\n    0.002128348980 +   0.042692956028*_Complex_I,\n   -0.023239979421 +  -0.013201242246*_Complex_I,\n   -0.036395878395 +   0.006550682393*_Complex_I,\n    0.005937946446 +  -0.039787300481*_Complex_I,\n    0.071765960434 +   0.000338344221*_Complex_I,\n    0.014183242345 +  -0.003691402540*_Complex_I,\n   -0.014927275586 +  -0.025008346274*_Complex_I,\n   -0.021975526648 +  -0.015174616793*_Complex_I,\n    0.031559403980 +   0.039201077146*_Complex_I,\n   -0.002930033110 +   0.012825110045*_Complex_I,\n   -0.048982592713 +   0.010293962046*_Complex_I,\n    0.013434665977 +   0.032290621601*_Complex_I,\n    0.033982791965 +   0.001317652206*_Complex_I,\n    0.023064195315 +   0.012663899061*_Complex_I,\n   -0.018428432947 +   0.056613928236*_Complex_I,\n   -0.049039654309 +  -0.025292660627*_Complex_I,\n    0.010320821686 +  -0.041716388907*_Complex_I,\n    0.023878576192 +   0.025126876135*_Complex_I,\n    0.020413632469 +   0.043472532575*_Complex_I,\n    0.036996565632 +  -0.062485539135*_Complex_I,\n   -0.004910190919 +  -0.013287275246*_Complex_I,\n   -0.010096052144 +   0.103664702556*_Complex_I,\n   -0.028018937736 +   0.023708913702*_Complex_I,\n   -0.011287655176 +  -0.076741200437*_Complex_I,\n   -0.001467109023 +  -0.001917661318*_Complex_I,\n    0.005293144320 +   0.010848041931*_Complex_I,\n    0.018185964149 +   0.026525130926*_Complex_I,\n   -0.015239532128 +  -0.026094016726*_Complex_I,\n   -0.034810813866 +   0.010226757752*_Complex_I,\n   -0.049480455827 +   0.006882194797*_Complex_I,\n    0.045731930549 +  -0.016140007390*_Complex_I,\n    0.014701121326 +   0.023870809774*_Complex_I,\n   -0.033559313643 +   0.022713731523*_Complex_I,\n    0.050108362232 +   0.015581007741*_Complex_I,\n   -0.005632120264 +   0.018308311284*_Complex_I,\n    0.052024517749 +  -0.050433653230*_Complex_I,\n    0.020247348485 +   0.025265853477*_Complex_I,\n   -0.048724807310 +   0.005688999390*_Complex_I,\n    0.018642648578 +  -0.005112453077*_Complex_I,\n   -0.000164879106 +  -0.021983711442*_Complex_I,\n   -0.005295938220 +  -0.039983291504*_Complex_I,\n   -0.036089961107 +   0.036124313440*_Complex_I,\n    0.032332494429 +   0.024537918792*_Complex_I,\n    0.022487700299 +  -0.035126580906*_Complex_I,\n    0.035179302371 +   0.075476289976*_Complex_I,\n   -0.022415275427 +   0.042965211229*_Complex_I,\n    0.045691989716 +   0.001526190095*_Complex_I,\n    0.004179917382 +  -0.000409395803*_Complex_I,\n   -0.014563762228 +  -0.005376713067*_Complex_I,\n   -0.027925684190 +   0.012934585830*_Complex_I,\n   -0.000374846557 +  -0.026098719210*_Complex_I,\n    0.032612571524 +   0.015336583912*_Complex_I,\n   -0.052107302856 +   0.002717865097*_Complex_I,\n   -0.032834640384 +   0.065614047849*_Complex_I,\n   -0.005080334534 +   0.020989805546*_Complex_I,\n    0.031881162655 +  -0.029694607868*_Complex_I,\n   -0.015170864143 +  -0.028448915975*_Complex_I,\n    0.020955734615 +   0.001553519861*_Complex_I,\n   -0.025709904149 +   0.043093492818*_Complex_I,\n   -0.013558366662 +  -0.019060063112*_Complex_I,\n    0.021290614364 +  -0.015390877095*_Complex_I,\n   -0.008998068093 +   0.010479790493*_Complex_I,\n   -0.024201210119 +  -0.017983452805*_Complex_I,\n    0.030041436100 +  -0.000867601449*_Complex_I,\n    0.011111929170 +   0.043244016918*_Complex_I,\n   -0.001398590030 +   0.033219709577*_Complex_I,\n   -0.017169337706 +  -0.032498137528*_Complex_I,\n   -0.003608831698 +  -0.004190317460*_Complex_I,\n   -0.039540681605 +  -0.003316647474*_Complex_I,\n   -0.018843962328 +   0.007361859229*_Complex_I,\n    0.046631096565 +   0.003646629910*_Complex_I,\n   -0.027706090091 +   0.008592625414*_Complex_I,\n   -0.002924156406 +   0.033883252714*_Complex_I,\n    0.075079733805 +   0.034815167989*_Complex_I,\n   -0.030357014457 +  -0.045596609600*_Complex_I,\n   -0.032642221938 +  -0.016644239862*_Complex_I,\n    0.032402948921 +  -0.001883868205*_Complex_I,\n   -0.023858913130 +   0.039323855789*_Complex_I,\n   -0.041457486487 +  -0.014233573157*_Complex_I,\n   -0.007459151809 +   0.013792354132*_Complex_I,\n    0.002485997247 +  -0.043959018212*_Complex_I,\n    0.003318269056 +  -0.012519460724*_Complex_I,\n    0.000093169055 +  -0.016480871965*_Complex_I,\n   -0.016900119114 +  -0.010406925321*_Complex_I,\n   -0.007971836056 +   0.065190143824*_Complex_I,\n   -0.006820219290 +   0.027753423502*_Complex_I,\n    0.031106376763 +  -0.020043621536*_Complex_I,\n   -0.031071266484 +   0.004339971697*_Complex_I,\n    0.040991447377 +  -0.102820217268*_Complex_I,\n    0.031948560681 +  -0.016199124342*_Complex_I,\n   -0.025194033136 +   0.010324013232*_Complex_I,\n   -0.006991588793 +  -0.016219922197*_Complex_I,\n    0.028959571857 +   0.015200024042*_Complex_I,\n   -0.011128094874 +  -0.018331258759*_Complex_I,\n    0.010033408771 +  -0.036038577315*_Complex_I,\n   -0.003951805923 +   0.031887379901*_Complex_I,\n    0.043011761476 +   0.038394544247*_Complex_I,\n    0.047003249222 +   0.040511060053*_Complex_I,\n   -0.046451986806 +   0.004395040215*_Complex_I,\n   -0.012529114947 +  -0.014584931709*_Complex_I,\n    0.036884371074 +  -0.020832501744*_Complex_I,\n   -0.021101612528 +  -0.029213061508*_Complex_I,\n   -0.036011838357 +   0.005793889985*_Complex_I,\n   -0.015900637518 +   0.056267590724*_Complex_I,\n   -0.023781635996 +   0.008199383119*_Complex_I,\n    0.030327057536 +  -0.078422708418*_Complex_I,\n   -0.005177131563 +  -0.017104662921*_Complex_I,\n   -0.014188045903 +  -0.035985384502*_Complex_I,\n    0.032146074117 +   0.004602106645*_Complex_I,\n   -0.009821272669 +  -0.008851465116*_Complex_I,\n    0.027236042210 +   0.006241896038*_Complex_I,\n    0.022418389996 +  -0.007040618186*_Complex_I,\n   -0.005638389798 +   0.012513644070*_Complex_I,\n    0.000036227705 +   0.039661942810*_Complex_I,\n   -0.017530818413 +  -0.055992409201*_Complex_I,\n   -0.009980130825 +   0.003409352124*_Complex_I,\n   -0.007128899287 +   0.029065621717*_Complex_I,\n    0.007569712793 +  -0.013550165086*_Complex_I,\n    0.012981701430 +  -0.004450356742*_Complex_I,\n    0.025509754347 +   0.048348739912*_Complex_I,\n   -0.011201724949 +   0.032065969619*_Complex_I,\n   -0.000655974814 +  -0.016732426150*_Complex_I,\n    0.019689483222 +  -0.025854936465*_Complex_I,\n    0.011124510152 +  -0.000398237810*_Complex_I,\n   -0.047061637319 +   0.015558558157*_Complex_I,\n   -0.011720140733 +  -0.036972797597*_Complex_I,\n    0.028160356014 +   0.036264888172*_Complex_I,\n   -0.021771924689 +   0.010389295245*_Complex_I,\n    0.019810005650 +  -0.024476888982*_Complex_I,\n   -0.033191779573 +  -0.001651714148*_Complex_I,\n    0.043581774082 +   0.018672171512*_Complex_I,\n   -0.003880433403 +  -0.026649182116*_Complex_I,\n    0.024387701876 +   0.043399010529*_Complex_I,\n    0.060278802711 +   0.009923457700*_Complex_I,\n   -0.031958233338 +  -0.053227946939*_Complex_I,\n   -0.037844853987 +   0.000125803799*_Complex_I,\n   -0.051129681909 +   0.048362994750*_Complex_I,\n   -0.034939691771 +   0.013353255240*_Complex_I,\n    0.013495424238 +   0.002533014678*_Complex_I,\n   -0.024433814805 +   0.008923172086*_Complex_I,\n    0.006819321217 +  -0.017933176852*_Complex_I,\n    0.036263988877 +   0.000691266276*_Complex_I,\n    0.051618724746 +  -0.028316128600*_Complex_I,\n   -0.011460974644 +  -0.049249657052*_Complex_I,\n   -0.038203479805 +   0.025707308664*_Complex_I,\n    0.063567349796 +   0.074586008729*_Complex_I,\n    0.005400590167 +  -0.029955963800*_Complex_I,\n   -0.049012787288 +  -0.037393461959*_Complex_I,\n   -0.028249615420 +   0.026654301221*_Complex_I,\n    0.008517579272 +  -0.050945600372*_Complex_I,\n    0.033776936755 +  -0.007976718780*_Complex_I,\n    0.007283043274 +   0.040108239951*_Complex_I,\n    0.026628003403 +   0.013587396181*_Complex_I,\n   -0.004776533268 +  -0.040224248409*_Complex_I,\n    0.001966163699 +  -0.058690841656*_Complex_I,\n   -0.036928601088 +   0.022515059406*_Complex_I,\n   -0.018983384206 +   0.092142143476*_Complex_I,\n    0.006683303356 +  -0.005118852801*_Complex_I,\n   -0.006178795549 +   0.007657773084*_Complex_I,\n   -0.004596093747 +   0.004602055322*_Complex_I,\n    0.023277809619 +   0.018778205222*_Complex_I,\n    0.011819463018 +  -0.026895362189*_Complex_I,\n   -0.029906188199 +  -0.028279608383*_Complex_I,\n    0.020930036213 +   0.019813673820*_Complex_I,\n    0.017967997243 +  -0.027321140175*_Complex_I,\n   -0.026039058237 +   0.028575862467*_Complex_I,\n   -0.065707150276 +   0.027564172049*_Complex_I,\n   -0.042699371771 +  -0.004553530531*_Complex_I,\n    0.060963634866 +  -0.010306512109*_Complex_I,\n   -0.018398404569 +  -0.009004454205*_Complex_I,\n    0.012682078281 +   0.035081253992*_Complex_I,\n   -0.022569581502 +  -0.002483099277*_Complex_I,\n   -0.005011260632 +  -0.059832394695*_Complex_I,\n    0.033576764841 +  -0.020322773572*_Complex_I,\n    0.011459245426 +   0.047090396734*_Complex_I,\n    0.010458010526 +   0.044772209285*_Complex_I,\n    0.029840259776 +   0.005715793160*_Complex_I,\n   -0.033675797644 +   0.041554808951*_Complex_I,\n    0.042385066649 +   0.007945594638*_Complex_I,\n   -0.042488207826 +   0.012628049489*_Complex_I,\n    0.011808820611 +   0.006893400628*_Complex_I,\n    0.034485946031 +  -0.019260139612*_Complex_I,\n   -0.025110072757 +  -0.027865545511*_Complex_I,\n    0.011809921801 +   0.017253366676*_Complex_I,\n    0.023347768774 +  -0.013960810328*_Complex_I,\n    0.004312140053 +  -0.050475400734*_Complex_I,\n    0.039740495297 +  -0.014728639995*_Complex_I,\n   -0.013385038021 +   0.002586440528*_Complex_I,\n    0.024990035834 +   0.031120474272*_Complex_I,\n   -0.017924227058 +  -0.032258326607*_Complex_I,\n   -0.008503405616 +  -0.030526995261*_Complex_I,\n    0.039069831028 +   0.047795375707*_Complex_I,\n   -0.017060972790 +   0.016758758851*_Complex_I,\n   -0.023173891050 +  -0.001084414363*_Complex_I,\n    0.026255359508 +  -0.007252038830*_Complex_I,\n    0.018286656103 +  -0.022933031391*_Complex_I,\n    0.024368811798 +  -0.006580655348*_Complex_I,\n   -0.004301769439 +   0.024140294549*_Complex_I,\n   -0.014786161819 +  -0.007103599240*_Complex_I,\n   -0.004382808422 +   0.013351241103*_Complex_I,\n   -0.016799676739 +   0.015974782469*_Complex_I,\n    0.034117502850 +  -0.007152515247*_Complex_I,\n   -0.016030168590 +  -0.041660273222*_Complex_I,\n    0.020183324735 +   0.001275076977*_Complex_I,\n   -0.029259335107 +   0.025057117273*_Complex_I,\n   -0.019506766368 +   0.019348724623*_Complex_I,\n   -0.017064727586 +  -0.003715333530*_Complex_I,\n   -0.011048527087 +  -0.053833523722*_Complex_I,\n    0.024686830410 +   0.003799560503*_Complex_I,\n   -0.028896024708 +  -0.014835494620*_Complex_I,\n   -0.040702141102 +  -0.056626153309*_Complex_I,\n    0.032680942933 +   0.017723655112*_Complex_I,\n    0.029116465637 +   0.030527344293*_Complex_I,\n    0.002198173782 +   0.000971254919*_Complex_I,\n   -0.021900155002 +  -0.010625879853*_Complex_I,\n    0.022293892586 +   0.049298267413*_Complex_I,\n    0.012631626403 +   0.052532172470*_Complex_I,\n   -0.013732381568 +  -0.080618502666*_Complex_I,\n    0.000893373321 +  -0.046464687935*_Complex_I,\n   -0.012758518468 +   0.013919376550*_Complex_I,\n   -0.014235454439 +  -0.011924506441*_Complex_I,\n   -0.001743292107 +   0.029502693438*_Complex_I,\n   -0.044487788769 +   0.006911727783*_Complex_I,\n    0.005476613431 +   0.035516199946*_Complex_I,\n    0.025026369628 +  -0.054869348705*_Complex_I,\n    0.031378831930 +  -0.026801186271*_Complex_I,\n    0.011708942324 +  -0.028570090261*_Complex_I,\n    0.004475361885 +  -0.022218736038*_Complex_I,\n    0.002560834562 +  -0.032693273555*_Complex_I,\n    0.016389708983 +   0.001391247264*_Complex_I,\n   -0.017112703198 +  -0.015433616304*_Complex_I,\n    0.011474238974 +  -0.022409486851*_Complex_I,\n    0.019950525436 +   0.045615249829*_Complex_I,\n   -0.029025601300 +   0.019024103552*_Complex_I,\n    0.058627375247 +  -0.038320734588*_Complex_I,\n   -0.014973530138 +  -0.021441866237*_Complex_I};')
"
"('Prompt: Can you write a function that tests the functionality of copying a Forward Error-Correction (FEC) scheme object using a specific FEC scheme, but provides a warning message if the libfec library is not enabled? The function should generate random message data, encode it, make a copy of the FEC scheme object, encode the message again using the copy, compare the encoded data from the original and copied FEC schemes, then decode and compare the results.Finally, the function should destroy both FEC scheme objects.. . Response: Here is a function `fec_test_copy` that tests copying an FEC scheme object for a specific FEC scheme. It generates random message data, encodes it, makes a copy of the FEC scheme object, encodes the message again using the copy, compares the encoded data from the original and copied FEC schemes, then decodes and compares the results before destroying both FEC scheme objects. Additionally, a warning message will be displayed if the libfec library is not enabled.","//...\nvoid fec_test_copy(fec_scheme _fs)\n{\n#if !LIBFEC_ENABLED\n    switch (_fs) {\n    case LIQUID_FEC_CONV_V27:\n    case LIQUID_FEC_CONV_V29:\n    case LIQUID_FEC_CONV_V39:\n    case LIQUID_FEC_CONV_V615:\n    case LIQUID_FEC_CONV_V27P23:\n    case LIQUID_FEC_CONV_V27P34:\n    case LIQUID_FEC_CONV_V27P45:\n    case LIQUID_FEC_CONV_V27P56:\n    case LIQUID_FEC_CONV_V27P67:\n    case LIQUID_FEC_CONV_V27P78:\n    case LIQUID_FEC_CONV_V29P23:\n    case LIQUID_FEC_CONV_V29P34:\n    case LIQUID_FEC_CONV_V29P45:\n    case LIQUID_FEC_CONV_V29P56:\n    case LIQUID_FEC_CONV_V29P67:\n    case LIQUID_FEC_CONV_V29P78:\n    case LIQUID_FEC_RS_M8:\n        AUTOTEST_WARN(""convolutional, Reed-Solomon codes unavailable (install libfec)"");\n        return;\n    default:;\n    }\n#endif\n    unsigned int n_dec = 64;\n    void *       opts  = NULL;\n    fec q0 = fec_create(_fs,opts);\n    unsigned int n_enc = fec_get_enc_msg_length(_fs,n_dec);\n    unsigned char msg_org[n_dec];   \n    unsigned char msg_enc_0[n_enc]; \n    unsigned char msg_enc_1[n_enc]; \n    unsigned char msg_dec_0[n_dec]; \n    unsigned char msg_dec_1[n_dec]; \n    unsigned int i;\n    for (i=0; i<n_dec; i++)\n        msg_org[i] = rand() & 0xff;\n    fec_encode(q0,n_dec,msg_org,msg_enc_0);\n    fec q1 = fec_copy(q0);\n    fec_encode(q1,n_dec,msg_org,msg_enc_1);\n    CONTEND_SAME_DATA(msg_enc_0,msg_enc_1,n_enc);\n    for (i=0; i<n_enc; i++) {\n        msg_enc_0[i] = rand() & 0xff;\n        msg_enc_1[i] = msg_enc_0[i];\n    }\n    fec_decode(q0,n_dec,msg_enc_0,msg_dec_0);\n    fec_decode(q1,n_dec,msg_enc_1,msg_dec_1);\n    CONTEND_SAME_DATA(msg_dec_0,msg_dec_1,n_dec);\n    fec_destroy(q0);\n    fec_destroy(q1);\n}\nvoid autotest_fec_copy_g2412()   { fec_test_copy(LIQUID_FEC_GOLAY2412     ); }\n//...')
"
"('Create a program that implements an interleaver for a communication system. The program should have functions to create, copy, print, set depth, encode, decode, destroy, permute, and permute with a mask for the interleaver. The interleaver should have parameters for block size, M, N, and depth. The interleaver permutation should be done with and without mask using both soft and hard permutations. The program should use memmove and malloc functions for memory management.","//...\nint interleaver_permute_mask_soft(unsigned char * _x,\n                                  unsigned int    _n,\n                                  unsigned int    _M,\n                                  unsigned int    _N,\n                                  unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int k;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        for (k=0; k<8; k++) {\n            if ( (_mask >> (8-k-1)) & 0x01 ) {\n                tmp = _x[8*(2*j+1)+k];\n                _x[8*(2*j+1)+k] = _x[8*(2*i+0)+k];\n                _x[8*(2*i+0)+k] = tmp;\n            }\n        }\n    }\n    return LIQUID_OK;\n}\nint interleaver_encode_soft(interleaver     _q,\n                            unsigned char * _msg_dec,\n                            unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, 8*_q->n);\n    if (_q->depth > 0) interleaver_permute_soft(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\nint interleaver_permute_mask_soft(unsigned char * _x,\n                                  unsigned int    _n,\n                                  unsigned int    _M,\n                                  unsigned int    _N,\n                                  unsigned char   _mask);\nstruct interleaver_s {\n    unsigned int n;     \n    unsigned int M;     \n    unsigned int N;     \n    unsigned int depth;\n};\ninterleaver interleaver_create(unsigned int _n)\n{\n    interleaver q = (interleaver) malloc(sizeof(struct interleaver_s));\n    q->n = _n;\n    q->depth = 4;   \n    q->M = 1 + (unsigned int) floorf(sqrtf(q->n));\n    q->N = q->n / q->M;\n    while (q->n >= (q->M*q->N)) q->N++;  \n    return q;\n}\ninterleaver interleaver_copy(interleaver q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""interleaver_copy(), object cannot be NULL"");\n    return interleaver_create(q_orig->n);\n}\nint interleaver_destroy(interleaver _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\nint interleaver_print(interleaver _q)\n{\n    printf(""interleaver [block, %u bytes] :\\n"", _q->n);\n    printf(""    M       :   %u\\n"", _q->M);\n    printf(""    N       :   %u\\n"", _q->N);\n    printf(""    depth   :   %u\\n"", _q->depth);\n    return LIQUID_OK;\n}\nint interleaver_set_depth(interleaver  _q,\n                          unsigned int _depth)\n{\n    _q->depth = _depth;\n    return LIQUID_OK;\n}\nint interleaver_encode(interleaver     _q,\n                       unsigned char * _msg_dec,\n                       unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, _q->n);\n    if (_q->depth > 0) interleaver_permute(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\nint interleaver_encode_soft(interleaver     _q,\n                            unsigned char * _msg_dec,\n                            unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, 8*_q->n);\n    if (_q->depth > 0) interleaver_permute_soft(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask_soft(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\nint interleaver_decode(interleaver     _q,\n                       unsigned char * _msg_enc,\n                       unsigned char * _msg_dec)\n{\n    memmove(_msg_dec, _msg_enc, _q->n);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+8, 0x33);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 0) interleaver_permute(_msg_dec, _q->n, _q->M, _q->N);\n    return LIQUID_OK;\n}\nint interleaver_decode_soft(interleaver     _q,\n                            unsigned char * _msg_enc,\n                            unsigned char * _msg_dec)\n{\n    memmove(_msg_dec, _msg_enc, 8*_q->n);\n    if (_q->depth > 3) interleaver_permute_mask_soft(_msg_dec, _q->n, _q->M, _q->N+8, 0x33);\n    if (_q->depth > 2) interleaver_permute_mask_soft(_msg_dec, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 1) interleaver_permute_mask_soft(_msg_dec, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 0) interleaver_permute_soft(_msg_dec, _q->n, _q->M, _q->N);\n    return LIQUID_OK;\n}\nint interleaver_permute(unsigned char * _x,\n                        unsigned int    _n,\n                        unsigned int    _M,\n                        unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp = _x[2*j+1];\n        _x[2*j+1] = _x[2*i+0];\n        _x[2*i+0] = tmp;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute_soft(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp[8];\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        memmove( tmp,            &_x[8*(2*j+1)], 8);\n        memmove( &_x[8*(2*j+1)], &_x[8*(2*i+0)], 8);\n        memmove( &_x[8*(2*i+0)], tmp,            8);\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute_mask(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N,\n                             unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp0;\n    unsigned char tmp1;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp0 = (_x[2*i+0] & (~_mask)) | (_x[2*j+1] & ( _mask));\n        tmp1 = (_x[2*i+0] & ( _mask)) | (_x[2*j+1] & (~_mask));\n        _x[2*i+0] = tmp0;\n        _x[2*j+1] = tmp1;\n    }\n    return LIQUID_OK;\n}\nint interleaver_permute_mask_soft(unsigned char * _x,\n                                  unsigned int    _n,\n                                  unsigned int    _M,\n                                  unsigned int    _N,\n                                  unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int k;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        for (k=0; k<8; k++) {\n            if ( (_mask >> (8-k-1)) & 0x01 ) {\n                tmp = _x[8*(2*j+1)+k];\n                _x[8*(2*j+1)+k] = _x[8*(2*i+0)+k];\n                _x[8*(2*i+0)+k] = tmp;\n            }\n        }\n    }\n    return LIQUID_OK;\n}\ninterleaver interleaver_copy(interleaver q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""interleaver_copy(), object cannot be NULL"");\n    return interleaver_create(q_orig->n);\n}\nint interleaver_permute_mask(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N,\n                             unsigned char   _mask)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp0;\n    unsigned char tmp1;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp0 = (_x[2*i+0] & (~_mask)) | (_x[2*j+1] & ( _mask));\n        tmp1 = (_x[2*i+0] & ( _mask)) | (_x[2*j+1] & (~_mask));\n        _x[2*i+0] = tmp0;\n        _x[2*j+1] = tmp1;\n    }\n    return LIQUID_OK;\n}\nint interleaver_decode(interleaver     _q,\n                       unsigned char * _msg_enc,\n                       unsigned char * _msg_dec)\n{\n    memmove(_msg_dec, _msg_enc, _q->n);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+8, 0x33);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_dec, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 0) interleaver_permute(_msg_dec, _q->n, _q->M, _q->N);\n    return LIQUID_OK;\n}\nint interleaver_permute(unsigned char * _x,\n                        unsigned int    _n,\n                        unsigned int    _M,\n                        unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp;\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        tmp = _x[2*j+1];\n        _x[2*j+1] = _x[2*i+0];\n        _x[2*i+0] = tmp;\n    }\n    return LIQUID_OK;\n}\nint interleaver_destroy(interleaver _q)\n{\n    free(_q);\n    return LIQUID_OK;\n}\nint interleaver_decode_soft(interleaver     _q,\n                            unsigned char * _msg_enc,\n                            unsigned char * _msg_dec)\n{\n    memmove(_msg_dec, _msg_enc, 8*_q->n);\n    if (_q->depth > 3) interleaver_permute_mask_soft(_msg_dec, _q->n, _q->M, _q->N+8, 0x33);\n    if (_q->depth > 2) interleaver_permute_mask_soft(_msg_dec, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 1) interleaver_permute_mask_soft(_msg_dec, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 0) interleaver_permute_soft(_msg_dec, _q->n, _q->M, _q->N);\n    return LIQUID_OK;\n}\nint interleaver_set_depth(interleaver  _q,\n                          unsigned int _depth)\n{\n    _q->depth = _depth;\n    return LIQUID_OK;\n}\nint interleaver_encode(interleaver     _q,\n                       unsigned char * _msg_dec,\n                       unsigned char * _msg_enc)\n{\n    memmove(_msg_enc, _msg_dec, _q->n);\n    if (_q->depth > 0) interleaver_permute(_msg_enc, _q->n, _q->M, _q->N);\n    if (_q->depth > 1) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+2, 0x0f);\n    if (_q->depth > 2) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+4, 0x55);\n    if (_q->depth > 3) interleaver_permute_mask(_msg_enc, _q->n, _q->M, _q->N+8, 0x33);\n    return LIQUID_OK;\n}\nint interleaver_print(interleaver _q)\n{\n    printf(""interleaver [block, %u bytes] :\\n"", _q->n);\n    printf(""    M       :   %u\\n"", _q->M);\n    printf(""    N       :   %u\\n"", _q->N);\n    printf(""    depth   :   %u\\n"", _q->depth);\n    return LIQUID_OK;\n}\nint interleaver_permute_soft(unsigned char * _x,\n                             unsigned int    _n,\n                             unsigned int    _M,\n                             unsigned int    _N)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned int m=0;\n    unsigned int n=_n/3;\n    unsigned int n2=_n/2;\n    unsigned char tmp[8];\n    for (i=0; i<n2; i++) {\n        do {\n            j = m*_N + n; \n            m++;\n            if (m == _M) {\n                n = (n+1) % (_N);\n                m=0;\n            }\n        } while (j>=n2);\n        memmove( tmp,            &_x[8*(2*j+1)], 8);\n        memmove( &_x[8*(2*j+1)], &_x[8*(2*i+0)], 8);\n        memmove( &_x[8*(2*i+0)], tmp,            8);\n    }\n    return LIQUID_OK;\n}\ninterleaver interleaver_copy(interleaver q_orig)\n{\n    if (q_orig == NULL)\n        return liquid_error_config(""interleaver_copy(), object cannot be NULL"");\n    return interleaver_create(q_orig->n);\n}\n//...')
"
"('Please provide a prompt in which you need to reconfigure and set the length of the header for a DSSS frame generator. The prompt should include details such as the need to configure the header encoder, update the header modulation length, and set the header user length based on specific requirements.","//...\nstruct dsssframegen_s {\n    unsigned int        k;             \n    unsigned int        m;             \n    float               beta;          \n    firinterp_crcf      interp;        \n    float complex       buf_interp[2]; \n    dsssframegenprops_s props;        \n    dsssframegenprops_s header_props; \n    float complex *     preamble_pn; \n    synth_crcf          header_synth;\n    synth_crcf          payload_synth;\n    unsigned char *     header;          \n    unsigned int        header_user_len; \n    unsigned int        header_dec_len;  \n    qpacketmodem        header_encoder;  \n    unsigned int        header_mod_len;  \n    float complex *     header_mod;\n    unsigned int        payload_dec_len; \n    qpacketmodem        payload_encoder;\n    unsigned int        payload_mod_len;\n    float complex *     payload_mod;\n    unsigned int        symbol_counter; \n    unsigned int        sample_counter; \n    unsigned int        bit_counter;    \n    int                 bit_high;       \n    float complex       sym;\n    int                 frame_assembled; \n    int                 frame_complete;  \n    enum state          state;           \n};\n        return 0.f;\n        _q->frame_assembled = 0;\nint dsssframegen_reconfigure_header(dsssframegen _q)\n{\n    qpacketmodem_configure(_q->header_encoder,\n                           _q->header_dec_len,\n                           _q->header_props.check,\n                           _q->header_props.fec0,\n                           _q->header_props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_encoder);\n    _q->header_mod     = (float complex *)realloc(\n        _q->header_mod, _q->header_mod_len * sizeof(float complex));\n    return LIQUID_OK;\n}\nint dsssframegen_reconfigure(dsssframegen _q)\n{\n    qpacketmodem_configure(_q->payload_encoder,\n                           _q->payload_dec_len,\n                           _q->props.check,\n                           _q->props.fec0,\n                           _q->props.fec1,\n                           LIQUID_MODEM_BPSK);\n    _q->payload_mod_len = qpacketmodem_get_frame_len(_q->payload_encoder);\n    _q->payload_mod     = (float complex *)realloc(\n        _q->payload_mod, _q->payload_mod_len * sizeof(float complex));\n    return LIQUID_OK;\n}\nint dsssframegen_set_header_len(dsssframegen _q, unsigned int _len)\n{\n    if (_q->frame_assembled)\n        return liquid_error(LIQUID_EICONFIG,""dsssframegen_set_header_len(), frame is already assembled; must reset() first"");\n    _q->header_user_len = _len;\n    _q->header_dec_len  = DSSSFRAME_H_DEC + _q->header_user_len;\n    _q->header = (unsigned char *)realloc(_q->header, _q->header_dec_len * sizeof(unsigned char));\n    return dsssframegen_reconfigure_header(_q);\n}\n//...')
"
"('Prompt: Can you write a testbench function that calls the function `liquid_firdespm_halfband_ft` with parameters `_m` and `_ft`, estimates the required filter stop-band attenuation with the function `estimate_req_filter_As`, calculates specific frequency ranges `f0` and `f1`, defines regions based on these frequencies, and validates the power spectral density response of the filter using the `liquid_autotest_validate_psd_signalf` function? The test should focus on a half-band filter with `_m=4` and `_ft=0.400`. The results should be saved in a file for verification purposes.","//...\nvoid testbench_firdespm_halfband_ft(unsigned int _m,\n                                    float        _ft)\n{\n    unsigned int h_len = 4*_m + 1;\n    float h[h_len];\n    liquid_firdespm_halfband_ft(_m, _ft, h);\n    float As = estimate_req_filter_As(_ft, h_len);\n    float f0 = 0.25f - 0.5f*_ft;\n    float f1 = 0.25f + 0.5f*_ft;\n    autotest_psd_s regions[] = {\n      {.fmin=-0.5, .fmax= -f1, .pmin= 0,   .pmax=-As,  .test_lo=0, .test_hi=1},\n      {.fmin=-f0,  .fmax=  f0, .pmin=-0.1, .pmax= 0.1, .test_lo=1, .test_hi=1},\n      {.fmin= f1,  .fmax= 0.5, .pmin= 0,   .pmax=-As,  .test_lo=0, .test_hi=1},\n    };\n    char filename[256];\n    sprintf(filename,""autotest/logs/firdespm_halfband_m%u_ft%.3u.m"", _m, (int)(_ft*1000));\n    liquid_autotest_validate_psd_signalf(h, h_len, regions, 3,\n        liquid_autotest_verbose ? filename : NULL);\n}\nvoid autotest_firdespm_halfband_m4_ft400()  { testbench_firdespm_halfband_ft( 4, 0.400f); }\n//...')
"
"'Prompt: Create a code example that demonstrates the usage of a line chart in LittlevGL. The chart should have two series with different colors, and each series should display randomly generated values. The chart should be visually appealing and centered on the screen.. . Response:. ```c. #if LV_USE_CHART && LV_BUILD_EXAMPLES. void lv_example_chart_1(void). {.     lv_obj_t * chart;.     chart = lv_chart_create(lv_screen_active());.     lv_obj_set_size(chart, 200, 150);.     lv_obj_center(chart);.     lv_chart_set_type(chart, LV_CHART_TYPE_LINE);   .     lv_chart_series_t * ser1 = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_GREEN), LV_CHART_AXIS_PRIMARY_Y);.     lv_chart_series_t * ser2 = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_RED), LV_CHART_AXIS_SECONDARY_Y);.     uint32_t i;.     for(i =","#if LV_USE_CHART && LV_BUILD_EXAMPLES\nvoid lv_example_chart_1(void)\n{\n    lv_obj_t * chart;\n    chart = lv_chart_create(lv_screen_active());\n    lv_obj_set_size(chart, 200, 150);\n    lv_obj_center(chart);\n    lv_chart_set_type(chart, LV_CHART_TYPE_LINE);   \n    lv_chart_series_t * ser1 = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_GREEN), LV_CHART_AXIS_PRIMARY_Y);\n    lv_chart_series_t * ser2 = lv_chart_add_series(chart, lv_palette_main(LV_PALETTE_RED), LV_CHART_AXIS_SECONDARY_Y);\n    uint32_t i;\n    for(i = 0; i < 10; i++) {\n        lv_chart_set_next_value(chart, ser1, lv_rand(10, 50));\n        ser2->y_points[i] = lv_rand(50, 90);\n    }\n    lv_chart_refresh(chart); \n}\n#endif'"
"'Prompt: Can you provide a code snippet that sets the mode for an LCD display on an ARM microcontroller, taking into account possible architecture differences? . . Technical Scenario: We are working on configuring an LCD display on an ARM microcontroller. The code needs to handle different architectures and set the appropriate mode for the LCD display. The provided code includes a function `lpc24xx_lcd_set_mode` which sets the mode for the LCD display based on the given mode parameter and enables/disables the display accordingly. It also includes a function `lpc24xx_lcd_current_mode` which returns the current mode of the LCD display based on the architecture. The code includes conditional compilation directives to handle the architecture differences.","#ifdef ARM_MULTILIB_ARCH_V4\n  #define LCD_ENABLE BSP_BIT32(0)\n#endif\nrtems_status_code lpc24xx_lcd_set_mode(\n  lpc24xx_lcd_mode mode,\n  const lpc24xx_pin_range *pins\n)\n{\n  rtems_status_code sc = RTEMS_SUCCESSFUL;\n  bool enable = false;\n  switch (mode) {\n    case LCD_MODE_STN_4_BIT:\n    case LCD_MODE_STN_8_BIT:\n    case LCD_MODE_STN_DUAL_PANEL_4_BIT:\n    case LCD_MODE_STN_DUAL_PANEL_8_BIT:\n    case LCD_MODE_TFT_12_BIT_4_4_4:\n    case LCD_MODE_TFT_16_BIT_5_6_5:\n    case LCD_MODE_TFT_16_BIT_1_5_5_5:\n    case LCD_MODE_TFT_24_BIT:\n      enable = true;\n      break;\n    case LCD_MODE_DISABLED:\n      enable = false;\n      break;\n    default:\n      sc = RTEMS_IO_ERROR;\n      break;\n  }\n  if (sc == RTEMS_SUCCESSFUL) {\n    if (enable) {\n      sc = lpc24xx_module_enable(LPC24XX_MODULE_LCD, LPC24XX_MODULE_PCLK_DEFAULT);\n      assert(sc == RTEMS_SUCCESSFUL);\n      #ifdef ARM_MULTILIB_ARCH_V4\n        PINSEL11 = BSP_FLD32(mode, 1, 3) | LCD_ENABLE;\n      #endif\n      sc = lpc24xx_pin_config(pins, LPC24XX_PIN_SET_FUNCTION);\n      assert(sc == RTEMS_SUCCESSFUL);\n    } else {\n      if (lpc24xx_lcd_current_mode() != LCD_MODE_DISABLED) {\n        uint32_t lcd_ctrl = LCD_CTRL;\n        lcd_ctrl &= ~BSP_BIT32(11);\n        LCD_CTRL = lcd_ctrl;\n        lpc24xx_micro_seconds_delay(100000);\n        lcd_ctrl &= ~BSP_BIT32(0);\n        LCD_CTRL = lcd_ctrl;\n      }\n      sc = lpc24xx_pin_config(pins, LPC24XX_PIN_SET_INPUT);\n      assert(sc == RTEMS_SUCCESSFUL);\n      #ifdef ARM_MULTILIB_ARCH_V4\n        PINSEL11 = 0;\n      #endif\n      sc = lpc24xx_module_disable(LPC24XX_MODULE_LCD);\n      assert(sc == RTEMS_SUCCESSFUL);\n    }\n  }\n  return sc;\n}\nlpc24xx_lcd_mode lpc24xx_lcd_current_mode(void)\n{\n  #ifdef ARM_MULTILIB_ARCH_V4\n    uint32_t pinsel11 = PINSEL11;\n    if ((PCONP & BSP_BIT32(20)) != 0 && (pinsel11 & LCD_ENABLE) != 0) {\n      return BSP_FLD32GET(pinsel11, 1, 3);\n    } else {\n      return LCD_MODE_DISABLED;\n    }\n  #else\n    volatile lpc17xx_scb *scb = &LPC17XX_SCB;\n    if ((scb->pconp & LPC17XX_SCB_PCONP_LCD) != 0) {\n      return LCD_CTRL & 0xae;\n    } else {\n      return LCD_MODE_DISABLED;\n    }\n  #endif\n}'"
"('Prompt: You are working on a software-defined radio application and need to test the demodulator statistics for different modulation schemes. Write a function that takes a modulation scheme as input and performs demodulator error testing for that specific scheme. The function should modulate and demodulate symbols while checking for phase errors. Additionally, create helper functions to perform the demodulator error testing for PSK2 and PSK256 modulation schemes.","//...\nvoid modemcf_test_demodstats(modulation_scheme _ms)\n{\n    modemcf mod   = modemcf_create(_ms);\n    modemcf demod = modemcf_create(_ms);\n    unsigned int i, s, M = 1 << modemcf_get_bps(mod);\n    float complex x;\n    float complex x_hat;    \n    float demodstats;\n    float phi = 0.01f;\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf( phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats > 0.0f);\n    }\n    for (i=0; i<M; i++) {\n        modemcf_reset(mod);\n        modemcf_reset(demod);\n        modemcf_modulate(mod, i, &x);\n        if (cabsf(x) < 1e-3f) continue;\n        x_hat = x * cexpf(-phi*_Complex_I);\n        modemcf_demodulate(demod, x_hat, &s);\n        if (s != i)\n            AUTOTEST_WARN(""modem_test_demodstats(), output symbol does not match"");\n        demodstats = modemcf_get_demodulator_phase_error(demod);\n        CONTEND_EXPRESSION(demodstats < 0.0f);\n    }\n    modemcf_destroy(mod);\n    modemcf_destroy(demod);\n}\nvoid autotest_demodstats_psk2()     { modemcf_test_demodstats(LIQUID_MODEM_PSK2);     }\nvoid autotest_demodstats_psk256()   { modemcf_test_demodstats(LIQUID_MODEM_PSK256);   }\n//...')
"
"('Prompt: Imagine you need to test a resampler module in your software project. You want to validate the resampling operation and spectral analysis of the resampled signal. You need a test harness function that takes in resampling parameters such as P, Q, filter length, bandwidth, and attenuation, creates a resampler using these parameters, generates a modulated signal, applies resampling, computes the power spectral density (PSD) of the resampled signal, and validates the PSD against specified regions. Additionally, you want an automated test specific to P=2 and Q=5. Write a code snippet for the test harness function and the specific test for P=2, Q=5, filter length = 15, bandwidth = 0.4, and attenuation = 60.","//...\nvoid test_harness_rresamp_crcf(unsigned int _P,\n                               unsigned int _Q,\n                               unsigned int _m,\n                               float        _bw,\n                               float        _as)\n{\n    unsigned int n=800000;  \n    float bw = 0.2f; \n    unsigned int nfft = 800;\n    float tol = 0.5f;\n    rresamp_crcf resamp = rresamp_crcf_create_kaiser(_P, _Q, _m, _bw, _as);\n    float r = rresamp_crcf_get_rate(resamp);\n    spgramcf     q   = spgramcf_create(nfft, LIQUID_WINDOW_HANN, nfft/2, nfft/4);\n    symstreamrcf gen = symstreamrcf_create_linear(LIQUID_FIRFILT_KAISER,r*bw,25,0.2f,LIQUID_MODEM_QPSK);\n    symstreamrcf_set_gain(gen, sqrtf(bw*r));\n    float complex buf_0[_Q]; \n    float complex buf_1[_P]; \n    while (spgramcf_get_num_samples_total(q) < n) {\n        symstreamrcf_write_samples(gen, buf_0, _Q);\n        rresamp_crcf_execute(resamp, buf_0, buf_1);\n        spgramcf_write(q, buf_1, _P);\n    }\n    float psd[nfft];\n    spgramcf_get_psd(q, psd);\n    autotest_psd_s regions[] = {\n        {.fmin=-0.5f,    .fmax=-0.6f*bw, .pmin=0,     .pmax=-_as+tol, .test_lo=0, .test_hi=1},\n        {.fmin=-0.4f*bw, .fmax=+0.4f*bw, .pmin=0-tol, .pmax=  0 +tol, .test_lo=1, .test_hi=1},\n        {.fmin=+0.6f*bw, .fmax=+0.5f,    .pmin=0,     .pmax=-_as+tol, .test_lo=0, .test_hi=1},\n    };\n    liquid_autotest_validate_spectrum(psd, nfft, regions, 3,\n        liquid_autotest_verbose ? ""autotest/logs/rresamp_crcf.m"" : NULL);\n    rresamp_crcf_destroy(resamp);\n    spgramcf_destroy(q);\n    symstreamrcf_destroy(gen);\n}\nvoid autotest_rresamp_crcf_P2_Q5() { test_harness_rresamp_crcf( 2, 5, 15, 0.4f, 60.0f); }\n//...')
"
"('Prompt: I need you to write a code snippet that tests the functionality of a liquid scrambling algorithm. The scenario is that we have a function `liquid_scramble_test` that takes an unsigned integer `_n`, initializes three arrays `x`, `y`, and `z` of size `_n`, fills `x` with zeros, scrambles the data in `y` using a function `scramble_data`, unscrambles the data in `z` using a function `unscramble_data`, then checks if the data in `x` and `z` are the same. The function also calculates the entropy of the data in array `y` using the function `liquid_scramble_test_entropy` and asserts that the entropy is greater than `0.8f`. The function `liquid_scramble_test_entropy` calculates the entropy of the data in an array `_x` of length `_n`. The scenario requires you to implement the necessary functions and assertions.","//...\nvoid liquid_scramble_test(unsigned int _n)\n{\n    unsigned char x[_n];    \n    unsigned char y[_n];    \n    unsigned char z[_n];    \n    unsigned int i;\n    for (i=0; i<_n; i++)\n        x[i] = 0x00;\n    memmove(y,x,_n);\n    scramble_data(y,_n);\n    memmove(z,y,_n);\n    unscramble_data(z,_n);\n    CONTEND_SAME_DATA(x,z,_n*sizeof(unsigned char));\n    float H = liquid_scramble_test_entropy(y,_n);\n    CONTEND_EXPRESSION( H > 0.8f );\n}\nfloat liquid_scramble_test_entropy(unsigned char * _x,\n                                   unsigned int _n)\n{\n    unsigned int i;\n    unsigned int num_ones=0;\n    for (i=0; i<_n; i++)\n        num_ones += liquid_c_ones[_x[i]];\n    float p1 = (float)num_ones / (float)(8*_n) + 1e-12f;\n    float p0 = 1.0 - p1;\n    return -p0*log2f(p0) - p1*log2f(p1);\n}\nfloat liquid_scramble_test_entropy(unsigned char * _x,\n                                   unsigned int _n)\n{\n    unsigned int i;\n    unsigned int num_ones=0;\n    for (i=0; i<_n; i++)\n        num_ones += liquid_c_ones[_x[i]];\n    float p1 = (float)num_ones / (float)(8*_n) + 1e-12f;\n    float p0 = 1.0 - p1;\n    return -p0*log2f(p0) - p1*log2f(p1);\n}\n//...')
"
