// This program uses Clang's libraries to analyze C/C++ source code for function definitions and their comments.
// It traverses the Abstract Syntax Tree (AST) generated by Clang to find function declarations and captures comments preceding them.
// The captured data is then saved into separate files for each function and its comment in a directory named after the source file.

#include <clang/AST/RecursiveASTVisitor.h> // For AST traversal.
#include <clang/Frontend/ASTConsumers.h>    // Provides interfaces for consuming ASTs.
#include <clang/Frontend/CompilerInstance.h> // Compiler instance to setup and run the Clang frontend.
#include <clang/Frontend/FrontendActions.h> // Defines actions to be performed by the Clang frontend.
#include <clang/Lex/Preprocessor.h>          // For handling preprocessing and comments.
#include <clang/Tooling/CommonOptionsParser.h> // Parses common command-line options for Clang tools.
#include <clang/Tooling/Tooling.h>            // Provides utilities to run Clang tools.
#include <llvm/Support/CommandLine.h>         // For command-line option processing.
#include <fstream>                            // File stream for output.
#include <filesystem>                         // For directory and file operations.

#include <fstream>    // For file operations.
#include <map>        // To map function signatures to comments.
#include <string>     // For string manipulation.
#include <functional> // For std::function.
#include <filesystem> // For handling filesystem paths.
#include <iostream>   // For standard I/O.

namespace fs = std::filesystem; // Shorten namespace for filesystem.

// Global map to store the association between function signatures and their comments.
extern std::map<std::string, std::string> FunctionComments;

using namespace clang;
using namespace clang::tooling;

// Utility function to sanitize function names into valid filenames.
std::string sanitizeFilename(std::string functionName) {
    std::string sanitized;
    for (char c : functionName) {
        if (isalnum(c) || c == '_') {
            sanitized += c;
        } else if (c == ' ' || c == ',' || c == '(' || c == ')' || c == '&') {
            sanitized += '_'; // Replace problematic characters with underscores.
        }
        // Additional replacements can be added here as needed.
    }
    return sanitized;
}

// Generates a hash value for a given function signature to create unique identifiers.
std::size_t hashFunctionSignature(const std::string& functionSignature) {
    return std::hash<std::string>{}(functionSignature);
}

// Definition of the global map to store functions and their comments.
std::map<std::string, std::string> FunctionComments;

// CommentCapturer: Handles comments encountered during preprocessing.
class CommentCapturer : public CommentHandler {
    // Stores comments along with their source locations.
    std::vector<std::pair<SourceLocation, std::string>> comments;

public:
    // Override to capture comments and their locations.
    bool HandleComment(Preprocessor &PP, SourceRange CommentRange) override {
        SourceManager &SM = PP.getSourceManager();
        // Extract comment text from the source code.
        std::string commentText = std::string(Lexer::getSourceText(CharSourceRange::getTokenRange(CommentRange), SM, LangOptions(), 0));

        // Store the comment and its location.
        comments.push_back(std::make_pair(CommentRange.getBegin(), commentText));
        return false; // Return false to indicate the comment has not been "consumed."
    }

    // Accessor for the stored comments.
    const std::vector<std::pair<SourceLocation, std::string>>& getComments() const {
        return comments;
    }
};

// FunctionVisitor: Traverses the AST to visit function declarations.
class FunctionVisitor : public RecursiveASTVisitor<FunctionVisitor> {
    ASTContext *Context; // AST context provides information about the current state of the AST.
    // Reference to the vector of comments captured by CommentCapturer.
    const std::vector<std::pair<SourceLocation, std::string>>& Comments;

public:
    // Constructor initializes the context and comments.
    explicit FunctionVisitor(ASTContext *Context, const std::vector<std::pair<SourceLocation, std::string>>& Comments)
        : Context(Context), Comments(Comments) {}

    // VisitFunctionDecl is called for each FunctionDecl in the AST.
     bool VisitFunctionDecl(FunctionDecl *Function) {
         if (!Context->getSourceManager().isInMainFile(Function->getLocation()) || !Function->hasBody())
             return true; // Skip functions not in the main file or without a body.
         SourceManager &SM = Context->getSourceManager();
         const LangOptions &LangOpts = Context->getLangOpts();
         // Get the function's start location.
         SourceLocation StartLoc = SM.getExpansionLoc(Function->getBeginLoc());
         // Extract the function's text from the source.
         std::string FunctionText = Lexer::getSourceText(CharSourceRange::getTokenRange(Function->getSourceRange()), SM, LangOpts, 0).str();
         std::string AssociatedComment = "<no comment>";
         unsigned int FunctionStartLine = SM.getPresumedLineNumber(StartLoc);
         for (const auto& comment : Comments) {
             // Ensure the comment comes from the main file
             if (!SM.isInMainFile(comment.first)) continue;
             unsigned int CommentEndLine = SM.getPresumedLineNumber(comment.first);
             // Check the distance between the comment end and the function start.
             if (FunctionStartLine > CommentEndLine && (FunctionStartLine - CommentEndLine) < 5) { // Assuming a threshold of 5 lines
                 AssociatedComment = comment.second;
                 break; // Found a comment within the acceptable distance
             }
         }
         // Map the entire function text to its comment.
         FunctionComments[FunctionText] = AssociatedComment;
         return true; // Continue traversing the AST.
     }


};

// FindNamedFunctionConsumer: Consumes the AST produced by Clang.
class FindNamedFunctionConsumer : public clang::ASTConsumer {
    CommentCapturer CommentHandler; // To capture comments.
    std::unique_ptr<FunctionVisitor> Visitor; // For visiting functions.

public:
    // Constructor sets up the CommentCapturer and FunctionVisitor.
    explicit FindNamedFunctionConsumer(CompilerInstance &CI)
        : CommentHandler(), Visitor(new FunctionVisitor(&CI.getASTContext(), CommentHandler.getComments())) {
        CI.getPreprocessor().addCommentHandler(&CommentHandler); // Register the comment handler.
    }

    // Called when the AST for the entire translation unit is ready.
    virtual void HandleTranslationUnit(clang::ASTContext &Context) {
        Visitor->TraverseDecl(Context.getTranslationUnitDecl()); // Start AST traversal.
        Context.getTranslationUnitDecl()->getASTContext().getDiagnostics().getClient()->EndSourceFile(); // Cleanup after traversal.
    }
};

// FindNamedFunctionAction: Defines the frontend action to be performed by Clang.
class FindNamedFunctionAction : public clang::ASTFrontendAction {
public:
    // Creates the ASTConsumer instance for this action.
    std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
        clang::CompilerInstance &Compiler, llvm::StringRef InFile) override {
        return std::make_unique<FindNamedFunctionConsumer>(Compiler);
    }
};

static llvm::cl::OptionCategory MyToolCategory("my-tool options"); // Command-line options category.

int main(int argc, const char **argv) {
    auto ExpectedParser = clang::tooling::CommonOptionsParser::create(argc, argv, MyToolCategory);
    if (!ExpectedParser) {
        llvm::errs() << "Error creating options parser: " << ExpectedParser.takeError() << "\n";
        return 1;
    }
    clang::tooling::CommonOptionsParser& OptionsParser = ExpectedParser.get();

    clang::tooling::ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList());

    if (OptionsParser.getSourcePathList().empty()) {
        llvm::errs() << "No source file provided.\n";
        return 1;
    }

    // Set up the output directory based on the source file path.
    fs::path srcFilePath(OptionsParser.getSourcePathList().front());
    fs::path parentDir = srcFilePath.parent_path();
    fs::path baseFileName = srcFilePath.stem();

    fs::path outputDir = parentDir / (baseFileName.string() + "_ext");
    fs::create_directories(outputDir); // Ensure the output directory exists.

    int result = Tool.run(clang::tooling::newFrontendActionFactory<FindNamedFunctionAction>().get());

    // Process and save the captured function definitions and comments.
    for (const auto& pair : FunctionComments) {
        std::string functionName = pair.first;
        std::string functionComment = pair.second;

        std::size_t hashValue = hashFunctionSignature(functionName); // Create a unique filename based on the function's hash.
        std::string uniqueFilename = std::to_string(hashValue);

        // Define paths for the function code and comment files.
        fs::path codeFilePath = outputDir / (uniqueFilename + "_code.txt");
        fs::path commentFilePath = outputDir / (uniqueFilename + "_comment.txt");

        // Save the function code.
        std::ofstream codeFile(codeFilePath);
        if (codeFile.is_open()) {
            codeFile << functionName;
            codeFile.close();
        } else {
            std::cerr << "Failed to open " << codeFilePath << " for writing.\n";
        }

        // Save the function comment.
        std::ofstream commentFile(commentFilePath);
        if (commentFile.is_open()) {
            commentFile << functionComment;
            commentFile.close();
        } else {
            std::cerr << "Failed to open " << commentFilePath << " for writing.\n";
        }
    }

    return result; // Return the result of the Clang tool execution.
}
